<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>The Road To Bald Man!</title>
      <link href="/2020/04/21/The%20Road%20To%20Bald%20Man!/"/>
      <url>/2020/04/21/The%20Road%20To%20Bald%20Man!/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="The-Road-To-Bald-Man"><a href="#The-Road-To-Bald-Man" class="headerlink" title="The Road To Bald Man!"></a>The Road To Bald Man!</h1><h2 id="一、JavaSE"><a href="#一、JavaSE" class="headerlink" title="一、JavaSE"></a>一、JavaSE</h2><h3 id="1）、JavaSE基础"><a href="#1）、JavaSE基础" class="headerlink" title="1）、JavaSE基础"></a>1）、<a href="https://fangchenyong.top/2019/07/20/Java基础笔记/#Java基础笔记">JavaSE基础</a></h3><ol><li>基本语法</li><li>面向对象</li><li>异常</li></ol><h3 id="2）、JavaSE高级"><a href="#2）、JavaSE高级" class="headerlink" title="2）、JavaSE高级"></a>2）、JavaSE高级</h3><ol><li><p>多线程和并发库</p><ol><li><p>并发编程基础</p></li><li><p>线程池</p></li><li><p>锁</p></li><li><p>并发容器</p></li><li><p>原子类</p></li><li><p>JUC并发工具类</p><p> <a href="https://www.bilibili.com/video/BV14W411u7gB" target="_blank" rel="noopener">JUC视频教程</a></p></li></ol></li><li><p>常用API</p></li><li><p>枚举和注解</p></li><li><p>集合</p></li><li><p>泛型和File</p></li><li><p>IO流</p></li><li><p>网络编程</p></li><li><p>反射</p></li><li><p>动态代理</p></li><li><p>类加载器</p></li><li><p>JVM</p><ol><li><p>类加载机制</p></li><li><p>字节码执行机制</p></li><li><p>JVM内存模型</p></li><li><p>GC垃圾回收</p></li><li><p>JVM性能监控与故障定位</p></li><li><p>JVM调优</p><p> <a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">JVM视频教程（持续更新中）</a></p></li></ol></li><li><p>NIO</p><ul><li><a href="https://www.bilibili.com/video/BV14W411u7ro" target="_blank" rel="noopener">NIO视频教程</a></li></ul></li><li><p>网络编程</p><ul><li><a href="https://www.bilibili.com/video/BV1Jt411g7g4" target="_blank" rel="noopener">Java基础</a>（272/376）</li><li><a href="https://www.bilibili.com/video/BV1Kb411W75N" target="_blank" rel="noopener">java基础新版视频教程717集</a>（542/717）</li></ul></li><li><p>新特性</p><ul><li><a href="https://www.bilibili.com/video/BV14W411u7Ly" target="_blank" rel="noopener">Java8新特性视频教程</a></li><li><a href="https://www.bilibili.com/video/BV17W411g7eK" target="_blank" rel="noopener">Java9新特性视频教程</a></li><li><a href="https://www.bilibili.com/video/BV1Dt411472L" target="_blank" rel="noopener">Java11新特性视频教程</a></li><li><a href="https://www.bilibili.com/video/BV1jJ411M7kQ" target="_blank" rel="noopener">Java12&amp;13新特性视频教程</a></li></ul></li></ol><h2 id="二、数据结构和算法"><a href="#二、数据结构和算法" class="headerlink" title="二、数据结构和算法"></a>二、数据结构和算法</h2><h3 id="1）、数据结构"><a href="#1）、数据结构" class="headerlink" title="1）、数据结构"></a>1）、数据结构</h3><ol><li>字符串</li><li>数组</li><li>链表</li><li>二叉树</li><li>堆、栈、队列</li><li>哈希</li><li>……</li></ol><h3 id="2）、算法"><a href="#2）、算法" class="headerlink" title="2）、算法"></a>2）、算法</h3><ol><li>查找</li><li>排序</li><li>贪心</li><li>分治</li><li>动态规划</li><li>回溯</li><li>……</li></ol><p><a href="https://www.bilibili.com/video/BV1E4411H73v" target="_blank" rel="noopener">韩顺平图解Java数据结构和算法</a>（08/195）</p><h2 id="三、计算机网络"><a href="#三、计算机网络" class="headerlink" title="三、计算机网络"></a>三、计算机网络</h2><ol><li>ARP协议</li><li>IP/ICMP协议</li><li>TCP/UDP协议</li><li>DNS/HTTP/HTTPS协议</li><li>Session/Cookie</li></ol><h2 id="四、数据库"><a href="#四、数据库" class="headerlink" title="四、数据库"></a>四、数据库</h2><ol><li>MySql<ul><li><a href="https://www.bilibili.com/video/av21400736" target="_blank" rel="noopener">MySQL基础</a>（178/178）</li><li><a href="https://www.bilibili.com/video/av21334868" target="_blank" rel="noopener">MySQL高级</a>（06/63）</li></ul></li><li>Oracle<ul><li><a href="https://www.bilibili.com/video/BV14W411u7wT" target="_blank" rel="noopener">Oracle、SQL、PLSQL视频教程</a></li></ul></li><li>MongoDB<ul><li><a href="https://www.bilibili.com/video/BV1bJ411x7mq" target="_blank" rel="noopener">MongoDB基础入门到高级进阶</a></li></ul></li><li>JDBC<ul><li><a href="https://www.bilibili.com/video/BV1eJ411c7rf" target="_blank" rel="noopener">JDBC视频教程</a>（55/57）</li></ul></li><li>Druid</li><li>C3P0</li><li>MyCat<ul><li><a href="https://www.bilibili.com/video/BV1WJ411x7bD" target="_blank" rel="noopener">MyCat视频教程</a></li></ul></li><li>Sharding-JDBC</li><li>Sharding-Sphere</li></ol><h2 id="五、操作系统"><a href="#五、操作系统" class="headerlink" title="五、操作系统"></a>五、操作系统</h2><ol><li>进程/线程</li><li>并发/锁</li><li>内存管理和调度</li><li>I/O原理</li></ol><h2 id="六、设计模式"><a href="#六、设计模式" class="headerlink" title="六、设计模式"></a>六、设计模式</h2><ol><li>单例</li><li>工厂</li><li>代理</li><li>策略</li><li>模板方法</li><li>观察者</li><li>适配器</li><li>责任链</li><li>建造者</li></ol><p><a href="https://www.bilibili.com/video/BV1G4411c7N4" target="_blank" rel="noopener">韩顺平图解Java设计模式</a></p><h2 id="七、开发工具"><a href="#七、开发工具" class="headerlink" title="七、开发工具"></a>七、开发工具</h2><ol><li>IDEA<ul><li><a href="https://www.bilibili.com/video/BV1PW411X75p" target="_blank" rel="noopener">IDEA视频教程</a>（0/19）</li></ul></li><li>Eclipse（√）</li></ol><h2 id="八、前端技术"><a href="#八、前端技术" class="headerlink" title="八、前端技术"></a>八、前端技术</h2><ol><li>HTML5</li><li>CSS<ul><li><a href="https://www.bilibili.com/video/BV1XJ411X7Ud" target="_blank" rel="noopener">Web前端HTML5+CSS3全套基础教程完整版</a>（43/148）</li></ul></li><li>JavaScript<ul><li><a href="https://www.bilibili.com/video/BV1pJ41157z8" target="_blank" rel="noopener">JavaScript基础入门教程全集</a>（45/172）</li><li><a href="https://www.bilibili.com/video/bv18s411E7Nd" target="_blank" rel="noopener">ECMAScript教程(ecmascript详解含es5、es6)</a></li></ul></li><li>Vue<ul><li><a href="https://www.bilibili.com/video/BV1Wp411d7Ur" target="_blank" rel="noopener">超经典VUE实战教程全套完整版</a>（20/75）</li><li><a href="https://www.bilibili.com/video/BV1SJ41157Y9" target="_blank" rel="noopener">2020Vue全套教程全开源</a></li><li><a href="https://www.bilibili.com/video/BV11s411A7h6" target="_blank" rel="noopener">学 Vue.js 看这个就够了</a></li></ul></li><li>React<ul><li><a href="https://www.bilibili.com/video/BV184411x7F9" target="_blank" rel="noopener">React基础到实战</a></li></ul></li><li>WebPack<ul><li><a href="https://www.bilibili.com/video/BV1e7411j7T5" target="_blank" rel="noopener">尚硅谷2020最新版Webpack5实战教程(从入门到精通)</a></li></ul></li><li>Node.js</li><li>Thymeleaf</li><li>FreeMarker</li></ol><h2 id="九、JavaWeb"><a href="#九、JavaWeb" class="headerlink" title="九、JavaWeb"></a>九、JavaWeb</h2><ol><li><p>Servlet</p></li><li><p>Jsp</p></li><li><p>EL</p></li><li><p>JSTL</p></li><li><p>Cookie</p></li><li><p>Session</p></li><li><p>Filter</p></li><li><p>Listener</p></li></ol><p>（1-8）<a href="https://www.bilibili.com/video/BV1Y7411K7zz" target="_blank" rel="noopener">2020最新版JavaWeb全套教程</a></p><p>​            <a href="https://www.bilibili.com/video/BV12J411M7Sj?p=2" target="_blank" rel="noopener">【狂神说Java】JavaWeb入门到实战</a>（42/42）</p><h2 id="十、管理-构建工具"><a href="#十、管理-构建工具" class="headerlink" title="十、管理/构建工具"></a>十、管理/构建工具</h2><ol><li>SVN（√）<ul><li><a href="https://www.bilibili.com/video/BV1mW411M7yR" target="_blank" rel="noopener">SVN视频教程</a></li><li><a href="https://www.bilibili.com/video/BV1Us411E7HJ" target="_blank" rel="noopener">SVN高级视频教程</a></li></ul></li><li>Git<ul><li><a href="https://www.bilibili.com/video/BV1pW411A7a5" target="_blank" rel="noopener">Git&amp;GitHub视频教程</a></li></ul></li><li>Maven<ul><li><a href="https://www.bilibili.com/video/BV1TW411g7hP" target="_blank" rel="noopener">Maven视频教程</a></li></ul></li></ol><h2 id="十一、热门技术框架"><a href="#十一、热门技术框架" class="headerlink" title="十一、热门技术框架"></a>十一、热门技术框架</h2><ol><li>Spring<ul><li><a href="https://www.bilibili.com/video/BV1KW411u7An" target="_blank" rel="noopener">Spring4视频教程</a></li><li><a href="https://www.bilibili.com/video/BV1gW411W7wy" target="_blank" rel="noopener">Spring注解驱动开发视频教程</a></li><li><a href="https://www.bilibili.com/video/BV1WE411d7Dv" target="_blank" rel="noopener">【狂神说Java】Spring5最新完整教程IDEA版通俗易懂</a></li></ul></li><li>SpringMVC<ul><li><a href="https://www.bilibili.com/video/BV1mW411M7YA" target="_blank" rel="noopener">SpringMVC视频教程</a></li><li><a href="https://www.bilibili.com/video/BV1aE41167Tu" target="_blank" rel="noopener">【狂神说Java】SpringMVC最新教程IDEA版通俗易懂</a></li></ul></li><li>Mybatis<ul><li><a href="https://www.bilibili.com/video/BV1yW411M7m1" target="_blank" rel="noopener">通用Mapper视频教程</a></li><li><a href="https://www.bilibili.com/video/BV1mW411M737" target="_blank" rel="noopener">MyBatis视频教程（源码级讲授）</a></li></ul></li><li>Mybatis Plus<ul><li><a href="https://www.bilibili.com/video/BV1Ds411E76Y" target="_blank" rel="noopener">MyBatisPlus视频教程</a></li></ul></li><li>JPA<ul><li><a href="https://www.bilibili.com/video/BV1vW411M7zp" target="_blank" rel="noopener">JPA视频教程</a></li></ul></li><li>Spring Data<ul><li><a href="https://www.bilibili.com/video/BV1hW411g7jy" target="_blank" rel="noopener">Spring Data视频教程</a></li></ul></li><li>SpringBoot<ul><li><a href="https://www.bilibili.com/video/BV1gW411W76m" target="_blank" rel="noopener">好评如潮【Spring Boot】视频教程</a></li><li><a href="https://www.bilibili.com/video/BV1KW411F7oX" target="_blank" rel="noopener">Spring Boot整合篇</a></li></ul></li><li>Spring Cloud<ul><li><a href="https://www.bilibili.com/video/BV18E411x7eT" target="_blank" rel="noopener">Spring Cloud视频教程（2020新版）</a></li></ul></li><li>整合<ul><li><a href="https://www.bilibili.com/video/BV17W411g7zP" target="_blank" rel="noopener">SSM整合视频教程</a></li><li><a href="https://www.bilibili.com/video/BV18W411g7on" target="_blank" rel="noopener">Spring、SpringMVC、JPA、SpringData整合案例视频教程</a></li></ul></li></ol><h2 id="十二、Web-应用服务器"><a href="#十二、Web-应用服务器" class="headerlink" title="十二、Web/应用服务器"></a>十二、Web/应用服务器</h2><ol><li>Nginx<ul><li><a href="https://www.bilibili.com/video/BV1zJ411w7SV" target="_blank" rel="noopener">Nginx视频教程</a></li></ul></li><li>Tomcat</li><li>Jetty</li><li>UnderTow</li></ol><h2 id="十三、中间件"><a href="#十三、中间件" class="headerlink" title="十三、中间件"></a>十三、中间件</h2><ol><li>缓存<ol><li>Redis<ul><li><a href="https://www.bilibili.com/video/BV1CJ411m7Gc?from=search&seid=17587189821895008844" target="_blank" rel="noopener">Redis入门到精通</a>（112/112）</li><li><a href="https://www.bilibili.com/video/BV1oW411u75R" target="_blank" rel="noopener">Redis视频教程</a></li></ul></li><li>memcache</li></ol></li><li>消息队列<ol><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li><li>ActiveMQ<ul><li><a href="https://www.bilibili.com/video/BV164411G7aB" target="_blank" rel="noopener">消息中间件之ActiveMQ</a></li></ul></li></ol></li><li>RPC架构<ol><li>Netty<ul><li><a href="https://www.bilibili.com/video/BV1DJ411m7NR" target="_blank" rel="noopener">Netty视频教程</a></li></ul></li><li>Dubbo<ul><li><a href="https://www.bilibili.com/video/BV1ns411c7jV" target="_blank" rel="noopener">Dubbo视频教程</a></li></ul></li><li>GRPC</li><li>Thrift</li></ol></li></ol><h2 id="十四、搜索引擎"><a href="#十四、搜索引擎" class="headerlink" title="十四、搜索引擎"></a>十四、搜索引擎</h2><ol><li>Lucene</li><li>ElasticSearch</li><li>Solr</li></ol><h2 id="十五、分布式-微服务"><a href="#十五、分布式-微服务" class="headerlink" title="十五、分布式/微服务"></a>十五、分布式/微服务</h2><ol><li>服务发现/注册<ol><li>Eureka</li><li>Consul</li><li>Zookeeper<ul><li><a href="https://www.bilibili.com/video/BV1PW411r7iP" target="_blank" rel="noopener">Zookeeper教程(zookeeper框架精讲)</a></li></ul></li><li>Nacos</li></ol></li><li>网关<ol><li>Zuul</li><li>GateWay</li></ol></li><li>服务调用（负载均衡）<ol><li>Ribbon</li><li>Feign</li></ol></li><li>熔断/降级<ol><li>Hystrix</li></ol></li><li>配置中心<ol><li>Config</li><li>Apollo</li><li>Nacos</li></ol></li><li>认证和鉴权<ol><li>Shiro<ul><li><a href="https://www.bilibili.com/video/BV1YW411M7S3" target="_blank" rel="noopener">Shiro视频教程</a></li></ul></li><li>Spring Security</li><li>OAuth2.0</li><li>SSO</li></ol></li><li>分布式事务<ol><li>JTA接口<ul><li>Atomikos组件</li></ul></li><li>2PC、3PC</li><li>XA模式</li><li>TCC模式<ul><li>tcc-transaction</li><li>ByteTCC</li><li>EasyTransaction</li><li>Seata</li></ul></li><li>SAGA模式<ul><li>ServiceComb</li><li>Seata</li></ul></li><li>LCN模式<ul><li>tx-lcn</li></ul></li></ol></li><li>任务调度<ol><li>Quartz</li><li>Elastic-Job</li></ol></li><li>链路追踪与监控<ol><li>Zipkin</li><li>Sleuth</li><li>Skywalking</li></ol></li><li>日志分析与监控<ol><li>ElasticSearch</li><li>Logstash</li><li>Kibana</li></ol></li></ol><h2 id="十六、虚拟化-容器化"><a href="#十六、虚拟化-容器化" class="headerlink" title="十六、虚拟化/容器化"></a>十六、虚拟化/容器化</h2><ol><li>Docker<ul><li><a href="https://www.bilibili.com/video/BV1Ls411n7mx" target="_blank" rel="noopener">Docker视频教程</a></li></ul></li><li>Kubernetes<ul><li><a href="https://www.bilibili.com/video/BV1w4411y7Go" target="_blank" rel="noopener">Kubernetes教程</a></li></ul></li><li>Swarm</li></ol><h2 id="十七、Linux"><a href="#十七、Linux" class="headerlink" title="十七、Linux"></a>十七、Linux</h2><ol><li>常用命令</li><li>Shell脚本</li><li>Vmware</li><li>Virtualbox</li></ol><p><a href="https://www.bilibili.com/video/BV11W411T7jR" target="_blank" rel="noopener">Linux视频教程</a></p><h2 id="十八、运维知识"><a href="#十八、运维知识" class="headerlink" title="十八、运维知识"></a>十八、运维知识</h2><ol><li>Web服务器<ol><li>Nginx</li></ol></li><li>应用服务器<ol><li>Tomcat</li><li>Jetty</li><li>Undertow</li></ol></li><li>CDN加速</li><li>持续集成/持续发布<ol><li>Jenkins<ul><li><a href="https://www.bilibili.com/video/BV1GW411w7pn" target="_blank" rel="noopener">Jenkins视频教程</a></li></ul></li></ol></li><li>代码质量检查<ol><li>Sonar</li></ol></li><li>日志收集/分析<ol><li>ElasticSearch</li><li>Logstash</li><li>Kibana</li></ol></li></ol><h2 id="十九、业务解决方案"><a href="#十九、业务解决方案" class="headerlink" title="十九、业务解决方案"></a>十九、业务解决方案</h2><ol start="4"><li>Pinpoint</li><li>JMS</li><li>Neo4j</li><li>Beats</li><li>JCL</li><li>Log4J</li><li>Logback</li><li>SLF4J</li><li>D3</li><li>Echarts（√）</li><li>AntV</li><li>JasperReport</li><li>POI</li><li>Activiti</li><li>微信支付</li><li>支付宝支付</li><li>百度地图（√）</li><li>高德地图（√）</li></ol><h2 id="二十、Java项目"><a href="#二十、Java项目" class="headerlink" title="二十、Java项目"></a>二十、Java项目</h2><ul><li><input disabled type="checkbox"> </li></ul><h2 id="二十一、面试"><a href="#二十一、面试" class="headerlink" title="二十一、面试"></a>二十一、面试</h2><ul><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV1Eb411P7bP" target="_blank" rel="noopener">Java学科第一季面试题</a></li><li><input disabled type="checkbox"> <a href="https://www.bilibili.com/video/BV18b411M7xz" target="_blank" rel="noopener">互联网大厂高频重点面试题第2季</a></li></ul><h2 id="二十二、手撕源码"><a href="#二十二、手撕源码" class="headerlink" title="二十二、手撕源码"></a>二十二、手撕源码</h2>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级</title>
      <link href="/2020/04/19/MySQL%E9%AB%98%E7%BA%A7/"/>
      <url>/2020/04/19/MySQL%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL的结构介绍"><a href="#1-MySQL的结构介绍" class="headerlink" title="1.MySQL的结构介绍"></a>1.MySQL的结构介绍</h1><h1 id="1-1MySQL-Linux版安装"><a href="#1-1MySQL-Linux版安装" class="headerlink" title="1.1MySQL-Linux版安装"></a>1.1MySQL-Linux版安装</h1><p><a href="https://fangchenyong.top/2019/07/23/install_MySql5.7/">CentOS 7.2 安装MySql 5.7</a></p><h1 id="2-索引优化分析"><a href="#2-索引优化分析" class="headerlink" title="2.索引优化分析"></a>2.索引优化分析</h1><h1 id="3-查询截取分析"><a href="#3-查询截取分析" class="headerlink" title="3.查询截取分析"></a>3.查询截取分析</h1><h1 id="4-MySQL锁机制"><a href="#4-MySQL锁机制" class="headerlink" title="4.MySQL锁机制"></a>4.MySQL锁机制</h1><h1 id="5-主从复制"><a href="#5-主从复制" class="headerlink" title="5.主从复制"></a>5.主从复制</h1><div class="row">    <embed src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/pdf/%E5%B0%9A%E7%A1%85%E8%B0%B7MySQL%E9%AB%98%E7%BA%A7_JAVA%E7%89%88.pdf" width="100%" height="550" type="application/pdf"></div> ]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记</title>
      <link href="/2020/04/01/Redis/"/>
      <url>/2020/04/01/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-redis入门"><a href="#1-redis入门" class="headerlink" title="1.redis入门"></a>1.redis入门</h1><h2 id="1-1-redis简介"><a href="#1-1-redis简介" class="headerlink" title="1.1 redis简介"></a>1.1 redis简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id="1-1-1-Redis-优势"><a href="#1-1-1-Redis-优势" class="headerlink" title="1.1.1 Redis 优势"></a>1.1.1 Redis 优势</h3><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h3 id="1-1-2-Redis与其他key-value存储有什么不同？"><a href="#1-1-2-Redis与其他key-value存储有什么不同？" class="headerlink" title="1.1.2 Redis与其他key-value存储有什么不同？"></a>1.1.2 Redis与其他key-value存储有什么不同？</h3><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li></ul><h3 id="1-1-3-应用"><a href="#1-1-3-应用" class="headerlink" title="1.1.3 应用"></a>1.1.3 应用</h3><ul><li>Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 </li><li>Tips 2：redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 </li><li>Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速 </li><li>Tips 4：redis 应用于购物车数据存储设计 </li><li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 </li><li>Tips 6：redis 应用于具有操作先后顺序的数据控制 </li><li>Tips 7：redis 应用于最新消息展示 </li><li>Tips 8：redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等 </li><li>Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 </li><li>Tips 10：redis 应用于同类型不重复数据的合并、取交集操作 </li><li>Tips 11：redis 应用于同类型数据的快速去重 </li><li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制 </li><li>Tips 13：redis 应用于计数器组合排序功能对应的排名 </li><li>Tips 14：redis 应用于定时任务执行顺序管理或任务过期管理 </li><li>Tips 15：redis 应用于及时任务/消息队列执行管理 </li><li>Tips 16：redis 应用于按次结算的服务控制 </li><li>Tips 17：redis 应用于基于时间顺序的数据操作，而不关注具体时间</li></ul><h2 id="1-2-redis的下载与安装"><a href="#1-2-redis的下载与安装" class="headerlink" title="1.2 redis的下载与安装"></a>1.2 redis的下载与安装</h2><p><strong>参考链接：</strong><a href="https://fangchenyong.top/2019/07/23/install_Redis5.0.3/#9-SpringBoot连接redis">Centos 7.2 安装目前最新版Redis5.0.3</a></p><h2 id="1-3-redis配置"><a href="#1-3-redis配置" class="headerlink" title="1.3 redis配置"></a>1.3 redis配置</h2><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。</p><h3 id="1-3-1-查看配置"><a href="#1-3-1-查看配置" class="headerlink" title="1.3.1 查看配置"></a>1.3.1 查看配置</h3><p>你可以通过 <strong>CONFIG</strong> 命令查看或设置配置项。</p><p><strong>语法</strong></p><p>Redis CONFIG 命令格式如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET loglevel</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"loglevel"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"notice"</span></span><br></pre></td></tr></table></figure><p>使用 ***** 号获取所有配置项：</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET *</span><br><span class="line"> </span><br><span class="line">  <span class="number">1</span>) <span class="string">"dbfilename"</span></span><br><span class="line">  <span class="number">2</span>) <span class="string">"dump.rdb"</span></span><br><span class="line">  <span class="number">3</span>) <span class="string">"requirepass"</span></span><br><span class="line">  <span class="number">4</span>) <span class="string">""</span></span><br><span class="line">  <span class="number">5</span>) <span class="string">"masterauth"</span></span><br><span class="line">  <span class="number">6</span>) <span class="string">""</span></span><br><span class="line">  <span class="number">7</span>) <span class="string">"unixsocket"</span></span><br><span class="line">  <span class="number">8</span>) <span class="string">""</span></span><br><span class="line">  <span class="number">9</span>) <span class="string">"logfile"</span></span><br><span class="line"> <span class="number">10</span>) <span class="string">""</span></span><br><span class="line"> <span class="number">11</span>) <span class="string">"pidfile"</span></span><br><span class="line"> <span class="number">12</span>) <span class="string">"/var/run/redis.pid"</span></span><br><span class="line"> <span class="number">13</span>) <span class="string">"maxmemory"</span></span><br><span class="line"> <span class="number">14</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">15</span>) <span class="string">"maxmemory-samples"</span></span><br><span class="line"> <span class="number">16</span>) <span class="string">"3"</span></span><br><span class="line"> <span class="number">17</span>) <span class="string">"timeout"</span></span><br><span class="line"> <span class="number">18</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">19</span>) <span class="string">"tcp-keepalive"</span></span><br><span class="line"> <span class="number">20</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">21</span>) <span class="string">"auto-aof-rewrite-percentage"</span></span><br><span class="line"> <span class="number">22</span>) <span class="string">"100"</span></span><br><span class="line"> <span class="number">23</span>) <span class="string">"auto-aof-rewrite-min-size"</span></span><br><span class="line"> <span class="number">24</span>) <span class="string">"67108864"</span></span><br><span class="line"> <span class="number">25</span>) <span class="string">"hash-max-ziplist-entries"</span></span><br><span class="line"> <span class="number">26</span>) <span class="string">"512"</span></span><br><span class="line"> <span class="number">27</span>) <span class="string">"hash-max-ziplist-value"</span></span><br><span class="line"> <span class="number">28</span>) <span class="string">"64"</span></span><br><span class="line"> <span class="number">29</span>) <span class="string">"list-max-ziplist-entries"</span></span><br><span class="line"> <span class="number">30</span>) <span class="string">"512"</span></span><br><span class="line"> <span class="number">31</span>) <span class="string">"list-max-ziplist-value"</span></span><br><span class="line"> <span class="number">32</span>) <span class="string">"64"</span></span><br><span class="line"> <span class="number">33</span>) <span class="string">"set-max-intset-entries"</span></span><br><span class="line"> <span class="number">34</span>) <span class="string">"512"</span></span><br><span class="line"> <span class="number">35</span>) <span class="string">"zset-max-ziplist-entries"</span></span><br><span class="line"> <span class="number">36</span>) <span class="string">"128"</span></span><br><span class="line"> <span class="number">37</span>) <span class="string">"zset-max-ziplist-value"</span></span><br><span class="line"> <span class="number">38</span>) <span class="string">"64"</span></span><br><span class="line"> <span class="number">39</span>) <span class="string">"hll-sparse-max-bytes"</span></span><br><span class="line"> <span class="number">40</span>) <span class="string">"3000"</span></span><br><span class="line"> <span class="number">41</span>) <span class="string">"lua-time-limit"</span></span><br><span class="line"> <span class="number">42</span>) <span class="string">"5000"</span></span><br><span class="line"> <span class="number">43</span>) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line"> <span class="number">44</span>) <span class="string">"10000"</span></span><br><span class="line"> <span class="number">45</span>) <span class="string">"latency-monitor-threshold"</span></span><br><span class="line"> <span class="number">46</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">47</span>) <span class="string">"slowlog-max-len"</span></span><br><span class="line"> <span class="number">48</span>) <span class="string">"128"</span></span><br><span class="line"> <span class="number">49</span>) <span class="string">"port"</span></span><br><span class="line"> <span class="number">50</span>) <span class="string">"6379"</span></span><br><span class="line"> <span class="number">51</span>) <span class="string">"tcp-backlog"</span></span><br><span class="line"> <span class="number">52</span>) <span class="string">"511"</span></span><br><span class="line"> <span class="number">53</span>) <span class="string">"databases"</span></span><br><span class="line"> <span class="number">54</span>) <span class="string">"16"</span></span><br><span class="line"> <span class="number">55</span>) <span class="string">"repl-ping-slave-period"</span></span><br><span class="line"> <span class="number">56</span>) <span class="string">"10"</span></span><br><span class="line"> <span class="number">57</span>) <span class="string">"repl-timeout"</span></span><br><span class="line"> <span class="number">58</span>) <span class="string">"60"</span></span><br><span class="line"> <span class="number">59</span>) <span class="string">"repl-backlog-size"</span></span><br><span class="line"> <span class="number">60</span>) <span class="string">"1048576"</span></span><br><span class="line"> <span class="number">61</span>) <span class="string">"repl-backlog-ttl"</span></span><br><span class="line"> <span class="number">62</span>) <span class="string">"3600"</span></span><br><span class="line"> <span class="number">63</span>) <span class="string">"maxclients"</span></span><br><span class="line"> <span class="number">64</span>) <span class="string">"4064"</span></span><br><span class="line"> <span class="number">65</span>) <span class="string">"watchdog-period"</span></span><br><span class="line"> <span class="number">66</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">67</span>) <span class="string">"slave-priority"</span></span><br><span class="line"> <span class="number">68</span>) <span class="string">"100"</span></span><br><span class="line"> <span class="number">69</span>) <span class="string">"min-slaves-to-write"</span></span><br><span class="line"> <span class="number">70</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">71</span>) <span class="string">"min-slaves-max-lag"</span></span><br><span class="line"> <span class="number">72</span>) <span class="string">"10"</span></span><br><span class="line"> <span class="number">73</span>) <span class="string">"hz"</span></span><br><span class="line"> <span class="number">74</span>) <span class="string">"10"</span></span><br><span class="line"> <span class="number">75</span>) <span class="string">"no-appendfsync-on-rewrite"</span></span><br><span class="line"> <span class="number">76</span>) <span class="string">"no"</span></span><br><span class="line"> <span class="number">77</span>) <span class="string">"slave-serve-stale-data"</span></span><br><span class="line"> <span class="number">78</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">79</span>) <span class="string">"slave-read-only"</span></span><br><span class="line"> <span class="number">80</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">81</span>) <span class="string">"stop-writes-on-bgsave-error"</span></span><br><span class="line"> <span class="number">82</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">83</span>) <span class="string">"daemonize"</span></span><br><span class="line"> <span class="number">84</span>) <span class="string">"no"</span></span><br><span class="line"> <span class="number">85</span>) <span class="string">"rdbcompression"</span></span><br><span class="line"> <span class="number">86</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">87</span>) <span class="string">"rdbchecksum"</span></span><br><span class="line"> <span class="number">88</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">89</span>) <span class="string">"activerehashing"</span></span><br><span class="line"> <span class="number">90</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">91</span>) <span class="string">"repl-disable-tcp-nodelay"</span></span><br><span class="line"> <span class="number">92</span>) <span class="string">"no"</span></span><br><span class="line"> <span class="number">93</span>) <span class="string">"aof-rewrite-incremental-fsync"</span></span><br><span class="line"> <span class="number">94</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">95</span>) <span class="string">"appendonly"</span></span><br><span class="line"> <span class="number">96</span>) <span class="string">"no"</span></span><br><span class="line"> <span class="number">97</span>) <span class="string">"dir"</span></span><br><span class="line"> <span class="number">98</span>) <span class="string">"/home/deepak/Downloads/redis-2.8.13/src"</span></span><br><span class="line"> <span class="number">99</span>) <span class="string">"maxmemory-policy"</span></span><br><span class="line"><span class="number">100</span>) <span class="string">"volatile-lru"</span></span><br><span class="line"><span class="number">101</span>) <span class="string">"appendfsync"</span></span><br><span class="line"><span class="number">102</span>) <span class="string">"everysec"</span></span><br><span class="line"><span class="number">103</span>) <span class="string">"save"</span></span><br><span class="line"><span class="number">104</span>) <span class="string">"3600 1 300 100 60 10000"</span></span><br><span class="line"><span class="number">105</span>) <span class="string">"loglevel"</span></span><br><span class="line"><span class="number">106</span>) <span class="string">"notice"</span></span><br><span class="line"><span class="number">107</span>) <span class="string">"client-output-buffer-limit"</span></span><br><span class="line"><span class="number">108</span>) <span class="string">"normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60"</span></span><br><span class="line"><span class="number">109</span>) <span class="string">"unixsocketperm"</span></span><br><span class="line"><span class="number">110</span>) <span class="string">"0"</span></span><br><span class="line"><span class="number">111</span>) <span class="string">"slaveof"</span></span><br><span class="line"><span class="number">112</span>) <span class="string">""</span></span><br><span class="line"><span class="number">113</span>) <span class="string">"notify-keyspace-events"</span></span><br><span class="line"><span class="number">114</span>) <span class="string">""</span></span><br><span class="line"><span class="number">115</span>) <span class="string">"bind"</span></span><br><span class="line"><span class="number">116</span>) <span class="string">""</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-编辑配置"><a href="#1-3-2-编辑配置" class="headerlink" title="1.3.2 编辑配置"></a>1.3.2 编辑配置</h3><p>你可以通过修改 redis.conf 文件或使用 <strong>CONFIG set</strong> 命令来修改配置。</p><p><strong>语法</strong></p><p><strong>CONFIG SET</strong> 命令基本语法：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG SET loglevel <span class="string">"notice"</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET loglevel</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"loglevel"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"notice"</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3-参数说明"><a href="#1-3-3-参数说明" class="headerlink" title="1.3.3 参数说明"></a>1.3.3 参数说明</h3><p>redis.conf 配置项说明如下：</p><ol><li><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize no</span><br></pre></td></tr></table></figure></li><li><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pidfile /var/run/redis.pid</span><br></pre></td></tr></table></figure></li><li><p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure></li><li><p>绑定的主机地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure></li><li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loglevel verbose</span><br></pre></td></tr></table></figure></li><li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logfile stdout</span><br></pre></td></tr></table></figure></li><li><p>设置数据库的数量，默认数据库为0，可以使用SELECT <code>&lt;dbid&gt;</code>命令在连接上指定数据库id</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure></li><li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br></pre></td></tr></table></figure><p>Redis默认配置文件中提供了三个条件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1  #900秒（15分钟）内有1个更改</span><br><span class="line">save 300 10     #300秒（5分钟）内有10个更改</span><br><span class="line">save 60 10000#60秒内有10000个更改</span><br></pre></td></tr></table></figure></li><li><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure></li><li><p>指定本地数据库文件名，默认值为dump.rdb</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure></li><li><p>指定本地数据库存放目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir ./</span><br></pre></td></tr></table></figure></li><li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li><li><p>当master服务设置了密码保护时，slav服务连接master的密码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure></li><li><p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <code>&lt;password&gt;</code>命令提供密码，默认关闭</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requirepass foobared</span><br></pre></td></tr></table></figure></li><li><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxclients 128</span><br></pre></td></tr></table></figure></li><li><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br></pre></td></tr></table></figure></li><li><p>指定更新日志文件名，默认为appendonly.aof</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure></li><li><p>指定更新日志条件，共有3个可选值：     <strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）     <strong>always</strong>：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）     <strong>everysec</strong>：表示每秒同步一次（折衷，默认值）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure></li><li><p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-enabled no</span><br></pre></td></tr></table></figure></li><li><p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-swap-file /tmp/redis.swap</span><br></pre></td></tr></table></figure></li><li><p>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-max-memory 0</span><br></pre></td></tr></table></figure></li><li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-page-size 32</span><br></pre></td></tr></table></figure></li><li><p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-pages 134217728</span><br></pre></td></tr></table></figure></li><li><p>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-max-threads 4</span><br></pre></td></tr></table></figure></li><li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glueoutputbuf yes</span><br></pre></td></tr></table></figure></li><li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash-max-zipmap-entries 64</span><br><span class="line">hash-max-zipmap-value 512</span><br></pre></td></tr></table></figure></li><li><p>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure></li><li><p>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include /path/to/local.conf</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-4-redis数据类型"><a href="#1-4-redis数据类型" class="headerlink" title="1.4 redis数据类型"></a>1.4 redis数据类型</h2><h3 id="1-4-1-String（字符串）"><a href="#1-4-1-String（字符串）" class="headerlink" title="1.4.1 String（字符串）"></a>1.4.1 String（字符串）</h3><p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p><p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p><p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SET name <span class="string">"redis.net.cn"</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET name</span><br><span class="line"><span class="string">"redis.net.cn"</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们使用了 Redis 的 <strong>SET</strong> 和 <strong>GET</strong> 命令。键为 name，对应的值为redis.net.cn。</p><p><strong>注意：</strong>一个键最大能存储512MB。</p><h3 id="1-4-2-Hash（哈希）"><a href="#1-4-2-Hash（哈希）" class="headerlink" title="1.4.2 Hash（哈希）"></a>1.4.2 Hash（哈希）</h3><p>Redis hash 是一个键值对集合。</p><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HMSET user:<span class="number">1</span> username redis.net.cn password redis.net.cn points <span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGETALL user:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"username"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redis.net.cn"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"password"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"redis.net.cn"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"points"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"200"</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><p>以上实例中 hash 数据类型存储了包含用户脚本信息的用户对象。 实例中我们使用了 Redis <strong>HMSET, HEGTALL</strong> 命令，<strong>user:1</strong> 为键值。</p><p>每个 hash 可以存储 2^(32 - 1)键值对（40多亿）。</p><h3 id="1-4-3-List（列表）"><a href="#1-4-3-List（列表）" class="headerlink" title="1.4.3 List（列表）"></a>1.4.3 List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush redis.net.cn redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush redis.net.cn mongodb</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush redis.net.cn rabitmq</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange redis.net.cn <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"rabitmq"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h3 id="1-4-4-Set（集合）"><a href="#1-4-4-Set（集合）" class="headerlink" title="1.4.4 Set（集合）"></a>1.4.4 Set（集合）</h3><p>Redis的Set是string类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p><strong>sadd 命令</strong></p><p>添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0,key对应的set不存在返回错误。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sadd key member</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn rabitmq</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn rabitmq</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers redis.net.cn</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"rabitmq"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure><h3 id="1-4-5-zset-sorted-set：有序集合"><a href="#1-4-5-zset-sorted-set：有序集合" class="headerlink" title="1.4.5 zset(sorted set：有序集合)"></a>1.4.5 zset(sorted set：有序集合)</h3><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><p><strong>zadd 命令</strong></p><p>添加元素到集合，元素在集合中存在则更新对应score</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">zadd key score member</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> rabitmq</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> rabitmq</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGEBYSCORE redis.net.cn <span class="number">0</span> <span class="number">1000</span></span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"redis"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"rabitmq"</span></span><br></pre></td></tr></table></figure><h1 id="2-redis命令"><a href="#2-redis命令" class="headerlink" title="2.redis命令"></a>2.<a href="http://doc.redisfans.com" target="_blank" rel="noopener">redis命令</a></h1><h2 id="2-1-如何执行命令"><a href="#2-1-如何执行命令" class="headerlink" title="2.1 如何执行命令"></a>2.1 如何执行命令</h2><h3 id="2-1-1-在本地连接执行命令"><a href="#2-1-1-在本地连接执行命令" class="headerlink" title="2.1.1 在本地连接执行命令"></a>2.1.1 在本地连接执行命令</h3><p>Redis 命令用于在 redis 服务上执行操作。</p><p>要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</p><p><strong>语法</strong></p><p>Redis 客户端的基本语法为：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>以下实例讲解了如何启动 redis 客户端：</p><p>启动 redis 客户端，打开终端并输入命令 <strong>redis-cli</strong>。该命令会连接本地的 redis 服务。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$redis</span>-cliredis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PING PONG</span><br></pre></td></tr></table></figure><p>在以上实例中我们连接到本地的 redis 服务并执行 <strong>PING</strong> 命令，该命令用于检测 redis 服务是否启动。</p><hr><h3 id="2-2-2-在远程服务上执行命令"><a href="#2-2-2-在远程服务上执行命令" class="headerlink" title="2.2.2 在远程服务上执行命令"></a>2.2.2 在远程服务上执行命令</h3><p>如果需要在远程 redis 服务上执行命令，同样我们使用的也是 <strong>redis-cli</strong> 命令。</p><p><strong>语法</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$redis</span>-cli -h <span class="number">127.0</span>.<span class="number">0.1</span> -p <span class="number">6379</span> -a <span class="string">"mypass"</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PING</span><br><span class="line"> </span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h2 id="2-2-key（键）"><a href="#2-2-key（键）" class="headerlink" title="2.2 key（键）"></a>2.2 key（键）</h2><p>Redis 键命令用于管理 redis 的键。</p><p><strong>语法</strong></p><p>Redis 键命令的基本语法如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SET mykey redis</span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; DEL mykey</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在以上实例中 <strong>DEL</strong> 是一个命令， <strong>mykey</strong> 是一个键。 如果键被删除成功，命令执行后输出 <strong>(integer) 1</strong>，否则将输出 <strong>(integer) 0</strong></p><p><strong>下表给出了与 Redis 键相关常用的基本命令：</strong></p><table><thead><tr><th><strong>命令</strong></th><th><strong>语法(可用版本)</strong></th><th><strong>返回值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>DEL</strong></td><td><strong><font size="2" color="red">DEL KEY_NAME（&gt;= 1.0.0）</font></strong></td><td><strong><font size="2">被删除 <code>key</code> 的数量。</font></strong></td><td><strong><font size="2">删除存在的<code>key</code>，不存在就忽略。</font></strong></td></tr><tr><td><strong>DUMP</strong></td><td><font size="2" color="red"><strong>DUMP KEY_NAME（&gt;= 2.6.0）</strong></font></td><td><strong><font size="2"><code>key</code>不存在，返回 <code>nil</code> 。否则，返回序列化之后的值。</font></strong></td><td><strong><font size="2">序列化给定 <code>key</code> 并返回值</font></strong></td></tr><tr><td><strong>EXISTS</strong></td><td><font size="2" color="red"><strong>EXISTS KEY_NAME（&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">存在返回 <code>1</code>，否则返回 <code>0</code>。</font></strong></td><td><strong><font size="2">检查给定<code>key</code>是否存在。</font></strong></td></tr><tr><td><strong>EXPIRE</strong></td><td><font size="2" color="red"><strong>EXPIRE KEY_NAME         TIME_IN_SECONDS         （&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">设置成功返回 <code>1</code> 。 不存在或者不能设置过期时间时(低于 2.1.3 版本)返回 <code>0</code>。</font></strong></td><td><strong><font size="2">设置<code>key</code>的过期时间，<code>key</code> 过期后将不再可用。</font></strong></td></tr><tr><td><strong>EXPIREAT</strong></td><td><font size="2" color="red"><strong>EXPIREAT KEY_NAME TIME_IN_UNIX_TIMESTAMP（&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">设置成功返回<code>1</code>。 不存在或者不能设置过期时间时(低于 2.1.3 版本)返回<code>0</code>。</font></strong></td><td><strong><font size="2">以 UNIX 时间戳(unix timestamp)格式设置<code>key</code>的过期时间。过期后将不再可用。</font></strong></td></tr><tr><td><strong>KEYS</strong></td><td><font size="2" color="red"><strong>KEYS PATTERN（&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">符合给定模式的 <code>key</code>列表 (Array)。</font></strong></td><td><strong><font size="2">用于查找所有符合给定模式 <code>pattern</code> 的 <code>key</code></font></strong></td></tr><tr><td><strong>MIGRATE</strong></td><td><font size="2" color="red"><strong>MIGRATE HOST PORT KEY_NAME DESTINATION-DB TIMEOUT [COPY] [REPLACE]（&gt;= 2.6.0）</strong></font></td><td><strong><font size="2">迁移成功时返回 <code>OK</code>，否则返回相应的错误。</font></strong></td><td><strong><font size="2">将 <code>key</code>原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， <code>key</code> 保证会出现在目标实例上，而当前实例上的 <code>key</code>会被删除。</font></strong></td></tr><tr><td><strong>MOVE</strong></td><td><font size="2" color="red"><strong>MOVE KEY_NAME DESTINATION_DATABASE （&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">移动成功返回 <code>1</code>，失败则返回<code>0</code>。</font></strong></td><td><strong><font size="2">将当前数据库的<code>key</code> 移动到给定的数据库<code>db</code>当中。</font></strong></td></tr><tr><td><strong>PERSIST</strong></td><td><font size="2" color="red"><strong>PERSIST KEY_NAME（&gt;= 2.2.0）</strong></font></td><td><strong><font size="2">当过期时间移除成功时，返回 <code>1</code>。 如果<code>key</code>不存在或 <code>key</code> 没有设置过期时间，返回<code>0</code>。</font></strong></td><td><strong><font size="2">移除给定 <code>key</code> 的过期时间，使得 key 永不过期。</font></strong></td></tr><tr><td><strong>PEXPIRE</strong></td><td><font size="2" color="red"><strong>PEXPIREAT KEY_NAME TIME_IN_MILLISECONDS_IN_UNIX_TIMESTAMP （&gt;= 2.6.0）</strong></font></td><td><strong><font size="2">设置成功返回<code>1</code>。 当<code>key</code>不存在或者不能为 <code>key</code>设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 <code>key</code> 的过期时间)返回 <code>0</code> 。</font></strong></td><td><strong><font size="2">用于设置 <code>key</code> 的过期时间，以毫秒记。<code>key</code>过期后将不再可用。</font></strong></td></tr><tr><td><strong>PEXPIREAT</strong></td><td><font size="2" color="red"><strong>PEXPIREAT KEY_NAME TIME_IN_MILLISECONDS_IN_UNIX_TIMESTAMP （&gt;= 2.6.0）</strong></font></td><td><strong><font size="2">设置成功返回 <code>1</code> 。 当 <code>key</code> 不存在或者不能为<code>key</code> 设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 <code>key</code>的过期时间)返回 <code>0</code>。</font></strong></td><td><strong><font size="2">用于设置<code>key</code> 的过期时间，以毫秒记。<code>key</code>过期后将不再可用。</font></strong></td></tr><tr><td><strong>PTTL</strong></td><td><font size="2" color="red"><strong>PTTL KEY_NAME（&gt;= 2.6.0）</strong></font></td><td><strong><font size="2">当 <code>key</code>不存在时，返回 <code>-2</code>。 当 <code>key</code>存在但没有设置剩余生存时间时，返回 <code>-1</code>。 否则，以毫秒为单位，返回的剩余生存时间。</font></strong></td><td><strong><font size="2">以毫秒为单位返回 <code>key</code> 的剩余过期时间。<br>注意：在 Redis 2.8 以前，当 <code>key</code> 不存在，或者 <code>key</code> 没有设置剩余生存时间时，命令都返回<code>-1</code>。</font></strong></td></tr><tr><td><strong>RANDOMKEY</strong></td><td><font size="2" color="red"><strong>RANDOMKEY（&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">当数据库不为空时，返回一个<code>key</code> 。 当数据库为空时，返回<code>nil</code>。</font></strong></td><td><strong><font size="2">从当前数据库中随机返回一个 <code>key</code>。</font></strong></td></tr><tr><td><strong>RENAME</strong></td><td><font size="2" color="red"><strong>RENAME OLD_KEY_NAME NEW_KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">改名成功时返回<code>OK</code>，失败时候返回一个错误。当 <code>OLD_KEY_NAME</code>和 <code>NEW_KEY_NAME</code> 相同，或者 <code>OLD_KEY_NAME</code>不存在时，返回一个错误。 当 <code>NEW_KEY_NAME</code> 已经存在时， <code>RENAME</code> 命令将覆盖旧值。</font></strong></td><td><strong><font size="2">用于修改<code>key</code>的名称 </font></strong></td></tr><tr><td><strong>RENAMENX</strong></td><td><font size="2" color="red"><strong>RENAMENX OLD_KEY_NAME NEW_KEY_NAME（&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">修改成功时，返回 <code>1</code> 。 如果 <code>NEW_KEY_NAME</code>已经存在，返回<code>0</code>。</font></strong></td><td><strong><font size="2">用于在新的 <code>key</code>不存在时修改<code>key</code>的名称 。</font></strong></td></tr><tr><td><strong>SORT</strong></td><td><font size="2" color="red"><strong>SORT KEY [BY PATTERN] [LIMIT OFFSET COUNT] [GET PATTERN [GET PATTERN …]] [ASC|DESC] [ALPHA] [STORE DESTINATION]</strong></font></td><td><strong><a href="http://doc.redisfans.com/key/sort.html" target="_blank" rel="noopener">较为复杂见文档</a></strong></td><td><strong><a href="http://doc.redisfans.com/key/sort.html" target="_blank" rel="noopener">较为复杂见文档</a></strong></td></tr><tr><td><strong>TTL</strong></td><td><font size="2" color="red"><strong>TTL KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">当 <code>key</code>不存在时，返回<code>-2</code> 。 当 <code>key</code>存在但没有设置剩余生存时间时，返回 <code>-1</code>。 否则，以秒为单位，返回剩余生存时间。</font></strong></td><td><strong><font size="2">以秒为单位返回 <code>key</code>的剩余过期时间。<br>注意：在 Redis 2.8 以前，当 <code>key</code>不存在，或者<code>key</code>没有设置剩余生存时间时，命令都返回 <code>-1</code>。</font></strong></td></tr><tr><td><strong>TYPE</strong></td><td><font size="2" color="red"><strong>TYPE KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><strong><font size="2">返回数据类型有：<code>none</code> (key不存在) <code>string</code>(字符串)       <code>list</code>(列表)                 <code>set</code>(集合)             <code>zset</code> (有序集)          <code>hash</code>(哈希表)</font></strong></td><td><font size="2"><strong>返回<code>key</code>所储存的值的类型</strong>。</font></td></tr></tbody></table><h2 id="2-3-String（字符串）"><a href="#2-3-String（字符串）" class="headerlink" title="2.3 String（字符串）"></a>2.3 String（字符串）</h2><p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：</p><p><strong>语法</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SET mykey redis </span><br><span class="line">OK </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET mykey </span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们使用了 <strong>SET</strong> 和 <strong>GET</strong> 命令，键为 mykey。</p><p><strong>下表给出了与 Redis字符串相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>APPEND</strong></td><td><font size="2" color="red"><strong>APPEND KEY_NAME NEW_VALUE（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>追加指定值之后，<code>key</code> 中字符串的长度。</strong></font></td><td><font size="2"><strong>如果 <code>key</code>已经存在并且是一个字符串， <code>APPEND</code>命令将<code>value</code>追加到 <code>key</code>原来的值的末尾。                                        如果 <code>key</code>不存在， <code>APPEND</code> 就简单地将给定 <code>key</code> 设为 <code>value</code>，就像执行 <code>SET key value</code>一样。</strong></font></td></tr><tr><td><strong>BITCOUNT</strong></td><td><font size="2" color="red"><strong>BITCOUNT key [start] [end]（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>被设置为 <code>1</code> 的位的数量。</strong></font></td><td><font size="2"><strong>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行。不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 <code>0</code> 。</strong></font></td></tr><tr><td><strong>BITOP</strong></td><td><font size="2" color="red"><strong>BITOP operation destkey key [key …]（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>保存到 <code>destkey</code> 的字符串的长度，和输入 <code>key</code> 中最长的字符串长度相等。</strong></font></td><td><font size="2"><strong>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。</strong></font></td></tr><tr><td><strong>DECR</strong></td><td><font size="2" color="red"><strong>DECR KEY_NAME（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>执行命令之后 <code>key</code> 的值。</strong></font></td><td><font size="2"><strong>将 <code>key</code>中储存的数字值减一。             如果 <code>key</code> 不存在，<code>key</code> 的值会先被初始化为<code>0</code> ，然后再执行 <code>DECR</code>操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>DECRBY</strong></td><td><font size="2" color="red"><strong>DECRBY KEY_NAME DECREMENT_AMOUNT （&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>减去指定减量值之后，<code>key</code>的值。</strong></font></td><td><font size="2"><strong>将 <code>key</code>所储存的值减去指定的减量值。如果 <code>key</code>不存在，<code>key</code>的值会先被初始化为 <code>0</code> ，然后再执行 <code>DECRBY</code> 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>GET</strong></td><td><font size="2" color="red"><strong>GET KEY_NAME（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>返回<code>key</code> 的值，如果 <code>key</code> 不存在时，返回 <code>nil</code>。 如果 <code>key</code> 不是字符串类型，那么返回一个错误。</strong></font></td><td><font size="2"><strong>获取指定 <code>key</code> 的值。 如果 <code>key</code> 不存在，返回 <code>nil</code>。 如果<code>key</code>储存的值不是字符串类型，返回一个错误。</strong></font></td></tr><tr><td><strong>GETBIT</strong></td><td><font size="2" color="red"><strong>GETBIT KEY_NAME OFFSET（&gt;=2.4.0）</strong></font></td><td><font size="2"><strong>字符串值指定偏移量上的位(bit)。当偏移量 <code>OFFSET</code> 比字符串值的长度大，或者 <code>key</code>不存在时，返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>对 <code>key</code>所储存的字符串值，获取指定偏移量上的位(bit)。</strong></font></td></tr><tr><td><strong>GETRANGE</strong></td><td><font size="2" color="red"><strong>GETRANGE KEY_NAME START END（&gt;=2.4.0）</strong></font></td><td><font size="2"><strong>截取得到的子字符串。</strong></font></td><td><font size="2"><strong>获取存储在指定 <code>key</code>中字符串的子字符串。字符串的截取范围由 <code>start</code>和<code>end</code>两个偏移量决定(包括 <code>start</code>和 <code>end</code> 在内)。</strong></font></td></tr><tr><td><strong>GETSET</strong></td><td><font size="2" color="red"><strong>GETSET KEY_NAME VALUE（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>返回给定 <code>key</code>的旧值。 当 <code>key</code> 没有旧值时，即<code>key</code>不存在时，返回 <code>nil</code> 。当 <code>key</code>存在但不是字符串类型时，返回一个错误。</strong></font></td><td><font size="2"><strong>设置指定<code>key</code> 的值，并返回 <code>key</code>旧的值。</strong></font></td></tr><tr><td><strong>INCR</strong></td><td><font size="2" color="red"><strong>INCR KEY_NAME（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>执行 <code>INCR</code> 命令之后 <code>key</code>的值。</strong></font></td><td><font size="2"><strong>将 <code>key</code>中储存的数字值增一。如果 <code>key</code> 不存在，那么 <code>key</code>的值会先被初始化为 <code>0</code> ，然后再执行 <code>INCR</code> 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>INCRBY</strong></td><td><font size="2" color="red"><strong>INCRBY KEY_NAME INCR_AMOUNT（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>加上指定的增量值之后，<code>key</code>的值。</strong></font></td><td><font size="2"><strong>将 <code>key</code>中储存的数字加上指定的增量值。如果 <code>key</code> 不存在，那么 <code>key</code> 的值会先被初始化为 <code>0</code>，然后再执行 <code>INCRBY</code> 命令。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>INCRBYFLOAT</strong></td><td><font size="2" color="red"><strong>INCRBYFLOAT KEY_NAME INCR_AMOUNT（&gt;=2.6.0）</strong></font></td><td><font size="2"><strong>执行命令之后 <code>key</code>的值。</strong></font></td><td><font size="2"><strong>为 <code>key</code> 中所储存的值加上指定的浮点数增量值。如果 <code>key</code>不存在，那么 <code>INCRBYFLOAT</code> 会先将 <code>key</code> 的值设为 <code>0</code>，再执行加法操作。</strong></font></td></tr><tr><td><strong>MGET</strong></td><td><font size="2" color="red"><strong>MGET KEY1 KEY2 .. KEYN（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>一个包含所有给定 <code>key</code> 的值的列表。</strong></font></td><td><font size="2"><strong>如果给定的 <code>key</code>里面，有某个<code>key</code> 不存在，那么这个<code>key</code> 返回特殊值 <code>nil</code> 。</strong></font></td></tr><tr><td><strong>MSET</strong></td><td><font size="2" color="red"><strong>MSET key1 value1 key2 value2 .. keyN valueN（&gt;=1.0.1）</strong></font></td><td><font size="2"><strong>总是返回 <code>OK</code> 。</strong></font></td><td><font size="2"><strong>同时设置一个或多个 <code>key</code>-<code>value</code> 对。</strong></font></td></tr><tr><td><strong>MSETNX</strong></td><td><font size="2" color="red"><strong>MSETNX key1 value1 key2 value2 .. keyN valueN（&gt;=1.0.1）</strong></font></td><td><font size="2"><strong>当所有<code>key</code>都成功设置，返回 <code>1</code> 。 如果所有给定 <code>key</code>都设置失败(至少有一个<code>key</code> 已经存在)，那么返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>所有给定 <code>key</code>都不存在时，同时设置一个或多个 <code>key</code>-<code>value</code> 对。</strong></font></td></tr><tr><td><strong>PSETEX</strong></td><td><font size="2" color="red"><strong>PSETEX key1 EXPIRY_IN_MILLISECONDS value1 （&gt;=2.6.0）</strong></font></td><td><font size="2"><strong>总是返回 <code>OK</code> 。</strong></font></td><td><font size="2"><strong>以毫秒为单位设置<code>key</code> 的生存时间。</strong></font></td></tr><tr><td><strong>SET</strong></td><td><font size="2" color="red"><strong>SET KEY_NAME VALUE（&gt;=1.0.0）</strong></font></td><td><strong><font size="2">在 2.6.12 以前版本， <code>SET</code>命令总是返回 <code>OK</code> 。从 Redis 2.6.12 版本开始， <code>SET</code> 在设置操作成功完成时，才返回 <code>OK</code> </font></strong></td><td><font size="2"><strong>用于设置给定<code>key</code> 的值。如果 <code>key</code>已经存储其他值， <code>SET</code>就覆写旧值，且无视类型。</strong></font></td></tr><tr><td><strong>SETBIT</strong></td><td><font size="2" color="red"><strong>Setbit KEY_NAME OFFSET（&gt;=2.2.0）</strong></font></td><td><font size="2"><strong>指定偏移量原来储存的位。</strong></font></td><td><font size="2"><strong>对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</strong></font></td></tr><tr><td><strong>SETEX</strong></td><td><font size="2" color="red"><strong>SETEX KEY_NAME TIMEOUT VALUE（&gt;=2.0.0）</strong></font></td><td><font size="2"><strong>成功返回 <code>OK</code> 。</strong></font></td><td><font size="2"><strong>为指定的 <code>key</code>设置值及其过期时间。如果 <code>key</code> 已经存在， <code>SETEX</code> 命令将会替换旧的值。</strong></font></td></tr><tr><td><strong>SETNX</strong></td><td><font size="2" color="red"><strong>SETNX KEY_NAME VALUE（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>成功返回 <code>1</code> 。  失败返回<code>0</code> 。</strong></font></td><td><font size="2"><strong><code>Setnx</code>（SET if Not eXists） 命令在指定的<code>key</code>不存在时，为 <code>key</code> 设置指定的值。</strong></font></td></tr><tr><td><strong>SETRANGE</strong></td><td><font size="2" color="red"><strong>SETRANGE KEY_NAME OFFSET VALUE（&gt;=2.2.0）</strong></font></td><td><font size="2"><strong>被修改后的字符串长度。</strong></font></td><td><font size="2"><strong>用指定的字符串覆盖给定 <code>key</code> 所储存的字符串值，覆盖的位置从偏移量 <code>offset</code> 开始。</strong></font></td></tr><tr><td><strong>STRLEN</strong></td><td><font size="2" color="red"><strong>STRLEN KEY_NAME（&gt;=2.2.0）</strong></font></td><td><font size="2"><strong>字符串值的长度。 当<code>key</code> 不存在时，返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>用于获取指定 <code>key</code> 所储存的字符串值的长度。当 <code>key</code> 储存的不是字符串值时，返回一个错误。</strong></font></td></tr></tbody></table><h2 id="2-4-Hash（哈希）"><a href="#2-4-Hash（哈希）" class="headerlink" title="2.4 Hash（哈希）"></a>2.4 Hash（哈希）</h2><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>Redis 中每个 hash 可以存储 2^(32 - 1 )键值对（40多亿）。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HMSET mykey name <span class="string">"redis tutorial"</span> description <span class="string">"redis basic commands for caching"</span> likes <span class="number">20</span> visitors <span class="number">23000</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGETALL mykey</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"name"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redis tutorial"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"description"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"redis basic commands for caching"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"likes"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"20"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"visitors"</span></span><br><span class="line"><span class="number">8</span>) <span class="string">"23000"</span></span><br></pre></td></tr></table></figure><p>在以上实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 mykey 中。</p><p><strong>下表给出了与 Redis哈希相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>HDEL</strong></td><td><font size="2" color="red"><strong>HDEL KEY_NAME FIELD1.. FIELDN      （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>被成功删除字段的数量，不包括被忽略的字段。</strong></font></td><td><font size="2"><strong>用于删除哈希表<code>key</code>中的一个或多个指定字段，不存在的字段将被忽略。</strong></font></td></tr><tr><td><strong>HEXISTS</strong></td><td><font size="2" color="red"><strong>HEXISTS KEY_NAME FIELD_NAME   （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>如果哈希表含有给定字段，返回 <code>1</code>。 如果哈希表不含有给定字段，或 key 不存在，返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>查看哈希表的指定字段是否存在。</strong></font></td></tr><tr><td><strong>HGET</strong></td><td><font size="2" color="red"><strong>HGET KEY_NAME FIELD_NAME    （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>返回给定字段的值。如果给定的字段或 <code>key</code>不存在时，返回 <code>nil</code> 。</strong></font></td><td><font size="2"><strong>返回哈希表中指定字段的值。</strong></font></td></tr><tr><td><strong>HGETALL</strong></td><td><font size="2" color="red"><strong>HGETALL KEY_NAME        （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>以列表形式返回哈希表的字段及字段值。 若 <code>key</code>不存在，返回空列表。</strong></font></td><td><font size="2"><strong>返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。</strong></font></td></tr><tr><td><strong>HINCRBY</strong></td><td><font size="2" color="red"><strong>HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER  （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>执行 <code>HINCRBY</code> 命令之后，哈希表中字段的值。</strong></font></td><td><font size="2"><strong>用于为哈希表中的字段值加上指定增量值。增量也可以为负数，相当于对指定字段进行减法操作。如果哈希表的 <code>key</code> 不存在，一个新的哈希表被创建并执行 <code>HINCRBY</code> 命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 <code>0</code>。对一个储存字符串值的字段执行 <code>HINCRBY</code> 命令将造成一个错误。本操作的值被限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>HINCRBYFLOAT</strong></td><td><font size="2" color="red"><strong>HINCRBYFLOAT KEY_NAME FIELD_NAME INCR_BY_NUMBER （&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>执行 <code>Hincrbyfloat</code>命令之后，哈希表中字段的值。</strong></font></td><td><font size="2"><strong>为哈希表中的字段值加上指定浮点数增量值。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 <code>0</code> 。</strong></font></td></tr><tr><td><strong>HKEYS</strong></td><td><font size="2" color="red"><strong>HKEYS KEY_NAME FIELD_NAME INCR_BY_NUMBER （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>包含哈希表中所有字段的列表。  <code>key</code> 不存在时，返回空列表。</strong></font></td><td><font size="2"><strong>获取哈希表中的所有字段名。</strong></font></td></tr><tr><td><strong>HLEN</strong></td><td><font size="2" color="red"><strong>HLEN KEY_NAME （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>哈希表中字段的数量。 <code>key</code>不存在时，返回 0 。</strong></font></td><td><font size="2"><strong>获取哈希表中字段的数量。</strong></font></td></tr><tr><td><strong>HMGET</strong></td><td><font size="2" color="red"><strong>HMGET KEY_NAME FIELD1…FIELDN （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。</strong></font></td><td><font size="2"><strong>返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 <code>nil</code>值。</strong></font></td></tr><tr><td><strong>HMSET</strong></td><td><font size="2" color="red"><strong>HMSET KEY_NAME FIELD1 VALUE1 …FIELDN VALUEN （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>如果命令执行成功，返回 <code>OK</code> 。</strong></font></td><td><font size="2"><strong>同时将多个 <code>field</code>-<code>value</code> (字段-值)对设置到哈希表中。此命令会覆盖哈希表中已存在的字段。如果哈希表不存在，会创建一个空哈希表，并执行 <code>HMSET</code> 操作。</strong></font></td></tr><tr><td><strong>HSET</strong></td><td><font size="2" color="red"><strong>HSET KEY_NAME FIELD VALUE     （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>如果字段是哈希表中的一个新建字段，并且值设置成功，返回 <code>1</code> 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 <code>0</code> 。</strong></font></td><td><font size="2"><strong>为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 <code>HSET</code>操作。如果字段已经存在于哈希表中，旧值将被覆盖。</strong></font></td></tr><tr><td><strong>HSETNX</strong></td><td><font size="2" color="red"><strong>HSETNX KEY_NAME FIELD VALUE                  （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>设置成功返回 <code>1</code> 。 如果给定字段已经存在且没有操作被执行，返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>为哈希表中不存在的的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 <code>HSET</code>操作。如果字段已经存在于哈希表中，操作无效。如果 <code>key</code> 不存在，一个新哈希表被创建并执行 <code>HSETNX</code> 命令。</strong></font></td></tr><tr><td><strong>HVALS</strong></td><td><font size="2" color="red"><strong>HVALS KEY_NAME FIELD VALUE      （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>一个包含哈希表中所有值的表。 当 <code>key</code> 不存在时，返回一个空表。</strong></font></td><td><font size="2"><strong>返回哈希表所有字段的值。</strong></font></td></tr></tbody></table><h2 id="2-5-List（列表）"><a href="#2-5-List（列表）" class="headerlink" title="2.5 List（列表）"></a>2.5 List（列表）</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 2^(32 - 1) 个元素 (4294967295, 每个列表超过40亿个元素)。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH mykey redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH mykey mongodb</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH mykey mysql</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE mykey <span class="number">0</span> <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"mysql"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们使用了 <strong>LPUSH</strong> 将三个值插入了名为 mykey 的列表当中。</p><p><strong>下表给出了与 Redis列表相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>BLPOP</strong></td><td><font size="2" color="red"><strong>BLPOP LIST1 LIST2 .. LISTN TIMEOUT（&gt;=2.0.0）</strong></font></td><td><font size="2"><strong>假如在指定时间内没有任何元素被弹出，则返回一个 <code>nil</code> 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <code>key</code> ，第二个元素是被弹出元素的值。</strong></font></td><td><font size="2"><strong>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></font></td></tr><tr><td><strong>BRPOP</strong></td><td><font size="2" color="red"><strong>BRPOP LIST1 LIST2 .. LISTN TIMEOUT（&gt;=2.0.0）</strong></font></td><td><font size="2"><strong>假如在指定时间内没有任何元素被弹出，则返回一个 <code>nil</code> 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <code>key</code> ，第二个元素是被弹出元素的值。</strong></font></td><td><font size="2"><strong>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></font></td></tr><tr><td><strong>BRPOPLPUSH</strong></td><td><font size="2" color="red"><strong>BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT（&gt;=2.0.0）</strong></font></td><td><font size="2"><strong>假如在指定时间内没有任何元素被弹出，则返回一个<code>nil</code>和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</strong></font></td><td><font size="2"><strong>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></font></td></tr><tr><td><strong>LINDEX</strong></td><td><font size="2" color="red"><strong>LINDEX KEY_NAME INDEX_POSITION         （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>列表中下标为指定索引值的元素。 如果指定索引值不在列表的区间范围内，返回<code>nil</code>。</strong></font></td><td><font size="2"><strong>通过索引获取列表中的元素。你也可以使用负数下标，以 <code>-1</code> 表示列表的最后一个元素，<code>-2</code> 表示列表的倒数第二个元素，以此类推。</strong></font></td></tr><tr><td><strong>LINSERT</strong></td><td><font size="2" color="red"><strong>LINSERT KEY_NAME BEFORE EXISTING_VALUE NEW_VALUE                 （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 <code>-1</code>。 如果 key 不存在或为空列表，返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>在列表的元素前或者后插入元素。 当指定元素不存在于列表中时，不执行任何操作。 当列表不存在时，被视为空列表，不执行任何操作。 如果<code>key</code> 不是列表类型，返回一个错误。</strong></font></td></tr><tr><td><strong>LLEN</strong></td><td><font size="2" color="red"><strong>LLEN KEY_NAME           （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>列表的长度。</strong></font></td><td><font size="2"><strong>返回列表的长度。 如果列表 <code>key</code>不存在，则<code>key</code>被解释为一个空列表，返回 <code>0</code> 。 如果 <code>key</code> 不是列表类型，返回一个错误。</strong></font></td></tr><tr><td><strong>LPOP</strong></td><td><font size="2" color="red"><strong>LLEN KEY_NAME             （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>列表的第一个元素。 当列表 <code>key</code> 不存在时，返回<code>nil</code>。</strong></font></td><td><font size="2"><strong>移除并返回列表的第一个元素。</strong></font></td></tr><tr><td><strong>LPUSH</strong></td><td><font size="2" color="red"><strong>LPUSH KEY_NAME VALUE1.. VALUEN              （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>执行 <code>LPUSH</code> 命令后，列表的长度。</strong></font></td><td><font size="2"><strong>将一个或多个值插入到列表头部。 如果 <code>key</code>不存在，一个空列表会被创建并执行 <code>LPUSH</code> 操作。 当 <code>key</code>存在但不是列表类型时，返回一个错误。注意：在Redis 2.4版本以前的 <code>LPUSH</code>命令，都只接受单个 <code>value</code>值。</strong></font></td></tr><tr><td><strong>LPUSHX</strong></td><td><font size="2" color="red"><strong>LPUSHX KEY_NAME VALUE1.. VALUEN         （&gt;= 2.2.0）</strong></font></td><td><font size="2"><strong><code>LPUSHX</code>命令执行之后，列表的长度。</strong></font></td><td><font size="2"><strong>将一个或多个值插入到已存在的列表头部，列表不存在时操作无效。</strong></font></td></tr><tr><td><strong>LRANGE</strong></td><td><font size="2" color="red"><strong>LRANGE KEY_NAME START END                   （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>一个列表，包含指定区间内的元素。</strong></font></td><td><font size="2"><strong>返回列表中指定区间内的元素，区间以偏移量<code>START</code> 和<code>END</code> 指定。 其中 <code>0</code>表示列表的第一个元素， <code>1</code> 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 <code>-1</code>表示列表的最后一个元素， <code>-2</code> 表示列表的倒数第二个元素，以此类推。</strong></font></td></tr><tr><td><strong>LREM</strong></td><td><font size="2" color="red"><strong>LREM KEY_NAME COUNT VALUE （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>被移除元素的数量。 列表不存在返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>根据参数 <code>COUNT</code> 的值，移除列表中与参数 <code>VALUE</code>相等的元素。<code>COUNT</code> 的值可以是以下几种：count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 <code>COUNT</code> 。 count &lt; 0 : 从表尾开始向表头搜索，移除与 <code>VALUE</code> 相等的元素，数量为 <code>COUNT</code> 的绝对值。count = 0 : 移除表中所有与<code>VALUE</code>相等的值。</strong></font></td></tr><tr><td><strong>LSET</strong></td><td><font size="2" color="red"><strong>LSET KEY_NAME INDEX VALUE（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>操作成功返回 <code>ok</code>，否则返回错误信息。</strong></font></td><td><font size="2"><strong>通过索引来设置元素的值。当索引参数超出范围，或对一个空列表进行 <code>LSET</code> 时，返回一个错误。</strong></font></td></tr><tr><td><strong>LTRIM</strong></td><td><font size="2" color="red"><strong>LTRIM KEY_NAME START STOP （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>命令执行成功时，返回 <code>ok</code>。</strong></font></td><td><font size="2"><strong>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标 <code>0</code>表示列表的第一个元素，以 <code>1</code> 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以<code>-1</code> 表示列表的最后一个元素，<code>-2</code>表示列表的倒数第二个元素，以此类推。</strong></font></td></tr><tr><td><strong>RPOP</strong></td><td><font size="2" color="red"><strong>RPOP KEY_NAME           （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>列表的最后一个元素。 当列表不存在时，返回 <code>nil</code>。</strong></font></td><td><font size="2"><strong>用于移除并返回列表的最后一个元素。</strong></font></td></tr><tr><td><strong>RPOPLPUSH</strong></td><td><font size="2" color="red"><strong>RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>被弹出的元素。</strong></font></td><td><font size="2"><strong>用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</strong></font></td></tr><tr><td><strong>RPUSH</strong></td><td><font size="2" color="red"><strong>RPUSH KEY_NAME VALUE1..VALUEN        （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>执行 <code>RPUSH</code>操作后，列表的长度。</strong></font></td><td><font size="2"><strong>用于将一个或多个值插入到列表的尾部(最右边)。如果列表不存在，一个空列表会被创建并执行 <code>RPUSH</code> 操作。 当列表存在但不是列表类型时，返回一个错误。<br>注意：在 Redis 2.4 版本以前的 <code>RPUSH</code>命令，都只接受单个<code>value</code>值。</strong></font></td></tr><tr><td><strong>RPUSHX</strong></td><td><font size="2" color="red"><strong>RPUSHX KEY_NAME VALUE1..VALUEN              （&gt;= 2.2.0）</strong></font></td><td><font size="2"><strong>执行 <code>RPUSHX</code>操作后，列表的长度。</strong></font></td><td><font size="2"><strong>将一个或多个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效。</strong></font></td></tr></tbody></table><h2 id="2-6-Set（集合）"><a href="#2-6-Set（集合）" class="headerlink" title="2.6 Set（集合）"></a>2.6 Set（集合）</h2><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey mysql</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey mysql</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS mykey</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"mysql"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们通过 <strong>SADD</strong> 命令向名为 mykey 的集合插入的三个元素。</p><p><strong>下表给出了与 Redis集合相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>SADD</strong></td><td><font size="2" color="red"><strong>SADD KEY_NAME VALUE1..VALUEN（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>被添加到集合中的新元素的数量，不包括被忽略的元素。</strong></font></td><td><font size="2"><strong>将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。假如集合 <code>key</code>不存在，则创建一个只包含添加的元素作成员的集合。当集合 <code>key</code>不是集合类型时，返回一个错误。注意：在Redis2.4版本以前，<code>SADD</code> 只接受单个成员值。</strong></font></td></tr><tr><td><strong>SCARD</strong></td><td><font size="2" color="red"><strong>SCARD KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>集合的数量。 当集合 <code>key</code>不存在时，返回 0 。</strong></font></td><td><font size="2"><strong>返回集合中元素的数量。</strong></font></td></tr><tr><td><strong>SDIFF</strong></td><td><font size="2" color="red"><strong>SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>包含差集成员的列表。</strong></font></td><td><font size="2"><strong>返回给定集合之间的差集。不存在的集合 <code>key</code>将视为空集。</strong></font></td></tr><tr><td><strong>SDIFFSTORE</strong></td><td><font size="2" color="red"><strong>SDIFFSTORE DESTINATION_KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>结果集中的元素数量。</strong></font></td><td><font size="2"><strong>将给定集合之间的差集存储在指定的集合中。如果指定的集合 <code>key</code>已存在，则会被覆盖。</strong></font></td></tr><tr><td><strong>SINTER</strong></td><td><font size="2" color="red"><strong>SINTER KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>交集成员的列表。</strong></font></td><td><font size="2"><strong>返回给定所有给定集合的交集。 不存在的集合 <code>key</code> 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</strong></font></td></tr><tr><td><strong>SINTERSTORE</strong></td><td><font size="2" color="red"><strong>SINTERSTORE DESTINATION_KEY KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>交集成员的列表。</strong></font></td><td><font size="2"><strong>将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖。</strong></font></td></tr><tr><td><strong>SISMEMBER</strong></td><td><font size="2" color="red"><strong>SISMEMBER KEY VALUE（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>如果成员元素是集合的成员，返回 <code>1</code> 。 如果成员元素不是集合的成员，或 <code>key</code> 不存在，返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>判断成员元素是否是集合的成员。</strong></font></td></tr><tr><td><strong>SMEMBERS</strong></td><td><font size="2" color="red"><strong>SMEMBERS KEY VALUE （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>集合中的所有成员。</strong></font></td><td><font size="2"><strong>返回集合中的所有的成员。 不存在的集合 <code>key</code> 被视为空集合。</strong></font></td></tr><tr><td><strong>SMOVE</strong></td><td><font size="2" color="red"><strong>SMOVE SOURCE DESTINATION MEMBER（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>如果成员元素被成功移除，返回 <code>1</code> 。 如果成员元素不是 <code>source</code>集合的成员，并且没有任何操作对 <code>destination</code> 集合执行，那么返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>将指定成员 <code>member</code>元素从 <code>source</code>集合移动到 <code>destination</code> 集合。<code>SMOVE</code>是原子性操作。如果 <code>source</code> 集合不存在或不包含指定的 <code>member</code> 元素，则 <code>SMOVE</code>命令不执行任何操作，仅返回<code>0</code>。否则， <code>member</code> 元素从 <code>source</code> 集合中被移除，并添加到 <code>destination</code> 集合中去。当 <code>destination</code> 集合已经包含 <code>member</code> 元素时， <code>SMOVE</code> 命令只是简单地将 <code>source</code> 集合中的 <code>member</code> 元素删除。当 <code>source</code> 或 <code>destination</code> 不是集合类型时，返回一个错误。</strong></font></td></tr><tr><td><strong>SPOP</strong></td><td><font size="2" color="red"><strong>SPOP KEY（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>被移除的随机元素。 当集合不存在或是空集时，返回 <code>nil</code> 。</strong></font></td><td><font size="2"><strong>移除并返回集合中的一个随机元素。</strong></font></td></tr><tr><td><strong>SRANDMEMBER</strong></td><td><font size="2" color="red"><strong>SRANDMEMBER KEY [count]（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>只提供集合 <code>key</code> 参数时，返回一个元素；如果集合为空，返回 <code>nil</code>。 如果提供了 <code>count</code>参数，那么返回一个数组；如果集合为空，返回空数组。</strong></font></td><td><font size="2"><strong>返回集合中的一个随机元素。从 Redis 2.6 版本开始， <code>Srandmember</code> 命令接受可选的<code>count</code>参数：如果 <code>count</code>为正数，且小于集合基数，那么命令返回一个包含 <code>count</code>个元素的数组，数组中的元素各不相同。如果 <code>count</code>大于等于集合基数，那么返回整个集合。如果<code>count</code> 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 <code>count</code> 的绝对值。该操作和 <code>SPOP</code> 相似，但 <code>SPOP</code> 将随机元素从集合中移除并返回，而 <code>Srandmember</code> 则仅仅返回随机元素，而不对集合进行任何改动。</strong></font></td></tr><tr><td><strong>SREM</strong></td><td><font size="2" color="red"><strong>SREM KEY MEMBER1..MEMBERN            （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>被成功移除的元素的数量，不包括被忽略的元素。</strong></font></td><td><font size="2"><strong>移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。当 <code>key</code>不是集合类型，返回一个错误。在 Redis 2.4 版本以前， <code>SREM</code> 只接受单个成员值。</strong></font></td></tr><tr><td><strong>SUNION</strong></td><td><font size="2" color="red"><strong>SUNION KEY KEY1..KEYN           （&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>并集成员的列表。</strong></font></td><td><font size="2"><strong>返回给定集合的并集。不存在的集合 <code>key</code> 被视为空集。</strong></font></td></tr><tr><td><strong>SUNIONSTORE</strong></td><td><font size="2" color="red"><strong>SUNIONSTORE DESTINATION KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>结果集中的元素数量。</strong></font></td><td><font size="2"><strong>将给定集合的并集存储在指定的集合<code>destination</code>中。</strong></font></td></tr><tr><td><strong>SSCAN</strong></td><td><font size="2" color="red"><strong>SSCAN KEY [MATCH pattern] [COUNT count]（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>数组列表。</strong></font></td><td><font size="2"><strong>迭代集合键中的元素。</strong></font></td></tr></tbody></table><h2 id="2-7-zset-sorted-set：有序集合"><a href="#2-7-zset-sorted-set：有序集合" class="headerlink" title="2.7 zset(sorted set：有序集合)"></a>2.7 zset(sorted set：有序集合)</h2><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">1</span> redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">2</span> mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">3</span> mysql</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">3</span> mysql</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">4</span> mysql</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE mykey <span class="number">0</span> <span class="number">10</span> WITHSCORES</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"redis"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"mysql"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"4"</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们通过命令 <strong>ZADD</strong> 向 redis 的有序集合中添加了三个值并关联上分数。</p><p><strong>下表给出了与 Redis有序集合相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>ZADD</strong></td><td><font size="2" color="red"><strong>ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN    （&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</strong></font></td><td><font size="2"><strong>将一个或多个成员元素及其分数值加入到有序集当中。如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。如果有序集合 <code>key</code> 不存在，则创建一个空的有序集并执行 <code>ZADD</code> 操作。当<code>key</code> 存在但不是有序集类型时，返回一个错误。<br>注意： 在 Redis 2.4 版本以前， <code>ZADD</code>每次只能添加一个元素。</strong></font></td></tr><tr><td><strong>ZCARD</strong></td><td><font size="2" color="red"><strong>ZCARD KEY_NAME     （&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong>当 <code>key</code>存在且是有序集类型时，返回有序集的基数。 当 <code>key</code> 不存在时，返回 <code>0</code>。</strong></font></td><td><font size="2"><strong>计算集合中元素的数量。</strong></font></td></tr><tr><td><strong>ZCOUNT</strong></td><td><font size="2" color="red"><strong>ZCOUNT key min max（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>分数值在 <code>min</code>和 <code>max</code> 之间的成员的数量。</strong></font></td><td><font size="2"><strong>计算有序集合中指定分数区间的成员数量。</strong></font></td></tr><tr><td><strong>ZINCRBY</strong></td><td><font size="2" color="red"><strong>ZINCRBY key increment member（&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong><code>member</code> 成员的新分数值，以字符串形式表示。</strong></font></td><td><font size="2"><strong>对有序集合中指定成员的分数加上增量<code>increment</code>可以通过传递一个负数值 <code>increment</code> ，让分数减去相应的值，比如 <code>ZINCRBY key -5 member</code>，就是让 <code>member</code>的 <code>score</code> 值减去 <code>5</code>。当 <code>key</code>不存在，或分数不是 key 的成员时， <code>ZINCRBY key increment member</code> 等同于 <code>ZADD key increment member</code>。当 <code>key</code> 不是有序集类型时，返回一个错误。分数值可以是整数值或双精度浮点数。</strong></font></td></tr><tr><td><strong>ZINTERSTORE</strong></td><td><font size="2" color="red"><strong>ZINTERSTORE DESTINATION NUMKEYS KEY [KEY …] [WEIGHTS WEIGHT [WEIGHT …]] [AGGREGATE SUM|MIN|MAX]    （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>保存到目标结果集的的成员数量。</strong></font></td><td><font size="2"><strong>计算给定的一个或多个有序集的交集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code> 参数指定，并将该交集(结果集)储存到 <code>destination</code>。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。</strong></font></td></tr><tr><td><strong>ZLEXCOUNT</strong></td><td><font size="2" color="red"><strong>ZLEXCOUNT KEY MIN MAX（&gt;= 2.8.9）</strong></font></td><td><font size="2"><strong>指定区间内的成员数量。</strong></font></td><td><font size="2"><strong>计算有序集合中指定字典区间内成员数量。</strong></font></td></tr><tr><td><strong>ZRANGE</strong></td><td><font size="2" color="red"><strong>ZRANGE key start stop [WITHSCORES]（&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong>指定区间内，带有分数值(可选)的有序集成员的列表。</strong></font></td><td><font size="2"><strong>返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order )来排列。如果你需要成员按值递减(从大到小)来排列，请使用 ZREVRANGE 命令。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</strong></font></td></tr><tr><td><strong>ZRANGEBYLEX</strong></td><td><font size="2" color="red"><strong>ZRANGEBYLEX KEY MIN MAX [LIMIT OFFSET COUNT]    （&gt;= 2.8.9）</strong></font></td><td><font size="2"><strong>指定区间内的元素列表。</strong></font></td><td><font size="2"><strong>通过字典区间返回有序集合的成员。</strong></font></td></tr><tr><td><strong>ZRANGEBYSCORE</strong></td><td><font size="2" color="red"><strong>ZRANGEBYSCORE KEY MIN MAX [WITHSCORES] [LIMIT OFFSET COUNT]     （&gt;= 1.0.5）</strong></font></td><td><font size="2"><strong>指定区间内，带有分数值(可选)的有序集成员的列表。</strong></font></td><td><font size="2"><strong>返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</strong></font></td></tr><tr><td><strong>ZRANK</strong></td><td><font size="2" color="red"><strong>ZRANK KEY MEMBER（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>如果成员是有序集<code>key</code> 的成员，返回 <code>member</code> 的排名。 如果成员不是有序集<code>key</code>的成员，返回 <code>nil</code> 。</strong></font></td><td><font size="2"><strong>返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。</strong></font></td></tr><tr><td><strong>ZREM</strong></td><td><font size="2" color="red"><strong>ZREM KEY MEMBER [MEMBER …]          （&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong>被成功移除的成员的数量，不包括被忽略的成员。</strong></font></td><td><font size="2"><strong>移除有序集中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。<br>注意： 在 Redis 2.4 版本以前， <code>ZREM</code>每次只能删除一个元素。</strong></font></td></tr><tr><td><strong>ZREMRANGEBYLEX</strong></td><td><font size="2" color="red"><strong>ZREMRANGEBYLEX KEY MIN MAX       （&gt;= 2.8.9）</strong></font></td><td><font size="2"><strong>被成功移除的成员的数量，不包括被忽略的成员。</strong></font></td><td><font size="2"><strong>移除有序集合中给定的字典区间的所有成员。</strong></font></td></tr><tr><td><strong>ZREMRANGEBYRANK</strong></td><td><font size="2" color="red"><strong>ZREMRANGEBYRANK KEY START STOP      （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>被移除成员的数量。</strong></font></td><td><font size="2"><strong>用于移除有序集中，指定排名(rank)区间内的所有成员。</strong></font></td></tr><tr><td><strong>ZREMRANGEBYSCORE</strong></td><td><font size="2" color="red"><strong>ZREMRANGEBYSCORE KEY MIN MAX        （&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong>被移除成员的数量。</strong></font></td><td><font size="2"><strong>移除有序集中，指定分数（score）区间内的所有成员。</strong></font></td></tr><tr><td><strong>ZREVRANGE</strong></td><td><font size="2" color="red"><strong>ZREVRANGE KEY START STOP [WITHSCORES]                （&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong>指定区间内，带有分数值(可选)的有序集成员的列表。</strong></font></td><td><font size="2"><strong>返回有序集中，指定区间内的成员。其中成员的位置按分数值递减(从大到小)来排列。具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按分数值递减的次序排列这一点外， <code>ZREVRANGE</code> 命令的其他方面和 <code>ZRANGE</code> 命令一样。</strong></font></td></tr><tr><td><strong>ZREVRANK</strong></td><td><font size="2" color="red"><strong>ZREVRANK KEY MEMBER（&gt;= 2.2.0）</strong></font></td><td><font size="2"><strong>如果成员是有序集 <code>key</code> 的成员，返回成员的排名。 如果成员不是有序集 <code>key</code> 的成员，返回 <code>nil</code>。</strong></font></td><td><font size="2"><strong>返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。排名以 <code>0</code>为底，也就是说， 分数值最大的成员排名为<code>0</code> 。使用 <code>ZRANK</code> 命令可以获得成员按分数值递增(从小到大)排列的排名。</strong></font></td></tr><tr><td><strong>ZSCAN</strong></td><td><font size="2" color="red"><strong>ZSCAN KEY CURSOR [MATCH PATTERN] [COUNT COUNT]        （&gt;= 2.8.0）</strong></font></td><td><font size="2"><strong>返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</strong></font></td><td><font size="2"><strong>迭代有序集合中的元素（包括元素成员和元素分值）</strong></font></td></tr><tr><td><strong>ZSCORE</strong></td><td><font size="2" color="red"><strong>ZSCORE KEY MEMBER（&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong>成员的分数值，以字符串形式表示。</strong></font></td><td><font size="2"><strong>返回有序集中，成员的分数值。 如果成员元素不是有序集 <code>key</code>的成员，或 <code>key</code>不存在，返回 <code>nil</code> 。</strong></font></td></tr><tr><td><strong>ZUNIONSTORE</strong></td><td><font size="2" color="red"><strong>ZUNIONSTORE DESTINATION NUMKEYS KEY [KEY …] [WEIGHTS WEIGHT [WEIGHT …]] [AGGREGATE SUM|MIN|MAX]（&gt;=2.0.0）</strong></font></td><td><font size="2"><strong>保存到 <code>destination</code>的结果集的成员数量。</strong></font></td><td><font size="2"><strong>计算给定的一个或多个有序集的并集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code>参数指定，并将该并集(结果集)储存到 <code>destination</code>。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和 。</strong></font></td></tr></tbody></table><h2 id="2-8-HyperLogLog"><a href="#2-8-HyperLogLog" class="headerlink" title="2.8 HyperLogLog"></a>2.8 HyperLogLog</h2><p>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据。</p><p>核心是基数估算算法，最终数值存在一定误差。</p><p>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值。</p><p>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数。</p><p>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大。</p><p>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少 。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFADD  databases  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"MySQL"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFCOUNT  databases</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFADD  databases  <span class="string">"Redis"</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFADD  databases  <span class="string">"PostgreSQL"</span>    <span class="comment"># 添加一个不存在的元素</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>下表给出了与 Redis HyperLogLog相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>PFADD</strong></td><td><font size="2" color="red"><strong>PFADD key element [element …]（&gt;= 2.8.9）</strong></font></td><td><font size="2"><strong>整型，如果至少有个元素被添加返回<code>1</code>， 否则返回<code>0</code>。</strong></font></td><td><font size="2"><strong>将所有元素参数添加到 <code>HyperLogLog</code> 数据结构中</strong></font></td></tr><tr><td><strong>PFCOUNT</strong></td><td><font size="2" color="red"><strong>PFCOUNT key [key …]        （&gt;= 2.8.9）</strong></font></td><td><font size="2"><strong>整数，返回给定 <code>HyperLogLog</code>的基数值，如果多个 <code>HyperLogLog</code> 则返回基数估值之和。</strong></font></td><td><font size="2"><strong>返回给定 HyperLogLog 的基数估算值。</strong></font></td></tr><tr><td><strong>PFMERGE</strong></td><td><font size="2" color="red"><strong>PFMERGE destkey sourcekey [sourcekey …]（&gt;= 2.8.9）</strong></font></td><td><font size="2"><strong>返回<code>OK</code>。</strong></font></td><td><font size="2"><strong>将多个 <code>HyperLogLog</code>合并为一个 <code>HyperLogLog</code> ，合并后的 <code>HyperLogLog</code> 的基数估算值是通过对所有 给定 <code>HyperLogLog</code>进行并集计算得出的。</strong></font></td></tr></tbody></table><h2 id="2-9-GEO（地理位置）"><a href="#2-9-GEO（地理位置）" class="headerlink" title="2.9 GEO（地理位置）"></a>2.9 GEO（地理位置）</h2><p>支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> <span class="string">"Palermo"</span> <span class="number">15.087269</span> <span class="number">37.502669</span> <span class="string">"Catania"</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">"166274.15156960039"</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GEORADIUS Sicily <span class="number">15</span> <span class="number">37</span> <span class="number">100</span> km</span><br><span class="line"><span class="number">1</span>) <span class="string">"Catania"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily <span class="number">15</span> <span class="number">37</span> <span class="number">200</span> km</span><br><span class="line"><span class="number">1</span>) <span class="string">"Palermo"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"Catania"</span></span><br></pre></td></tr></table></figure><p><strong>下表给出了与 Redis GEO相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>GEOADD</strong></td><td><font size="2" color="red"><strong>GEOADD key longitude latitude member [longitude latitude member …]（&gt;= 3.2.0）</strong></font></td><td><font size="2"><strong>新添加到键里面的空间元素数量， 不包括那些已经存在但是被更新的元素。</strong></font></td><td><font size="2"><strong>将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 <code>GEORADIUS</code> 和 <code>GEORADIUSBYMEMBER</code> 这样的命令可以在之后通过位置查询取得这些元素。</strong></font></td></tr><tr><td><strong>GEOPOS</strong></td><td><font size="2" color="red"><strong>GEOPOS key member [member …]             （&gt;= 3.2.0）</strong></font></td><td><font size="2"><strong><code>GEOPOS</code> 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。 当给定的位置元素不存在时， 对应的数组项为空值。</strong></font></td><td><font size="2"><strong>从键里面返回所有给定位置元素的位置（经度和纬度）。因为 <code>GEOPOS</code> 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复。</strong></font></td></tr><tr><td><strong>GEODIST</strong></td><td><font size="2" color="red"><strong>GEODIST key member1 member2 [unit]          （&gt;= 3.2.0）</strong></font></td><td><font size="2"><strong>计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值。</strong></font></td><td><font size="2"><strong>返回两个给定位置之间的距离。如果两个位置之间的其中一个不存在， 那么命令返回空值。</strong></font></td></tr><tr><td><strong>GEORADIUS</strong></td><td><font size="2" color="red"><strong>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]（&gt;= 3.2.0）</strong></font></td><td><font size="2"><strong><a href="http://redisdoc.com/geo/georadius.html" target="_blank" rel="noopener">复杂见文档</a></strong></font></td><td><font size="2"><strong><a href="http://redisdoc.com/geo/georadius.html" target="_blank" rel="noopener">复杂见文档</a></strong></font></td></tr><tr><td><strong>GEORADIUSBYMEMBER</strong></td><td><font size="2" color="red"><strong>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]（&gt;= 3.2.0）</strong></font></td><td><font size="2"><strong>一个数组， 数组中的每个项表示一个范围之内的位置元素。</strong></font></td><td><font size="2"><strong>这个命令和 <code>GEORADIUS</code> 命令一样， 都可以找出位于指定范围内的元素， 但是 <code>GEORADIUSBYMEMBER</code> 的中心点是由给定的位置元素决定的， 而不是像 <code>GEORADIUS</code> 那样， 使用输入的经度和纬度来决定中心点。</strong></font></td></tr><tr><td><strong>GEOHASH</strong></td><td><font size="2" color="red"><strong>GEOHASH key member [member …]                （&gt;= 3.2.0）</strong></font></td><td><font size="2"><strong>一个数组， 数组的每个项都是一个<code>geohash</code>。 命令返回的 <code>geohash</code>的位置与用户给定的位置元素的位置一一对应。</strong></font></td><td><font size="2"><strong>返回一个或多个位置元素的 <code>Geohash</code> 表示。</strong></font></td></tr></tbody></table><h2 id="2-10-BitMap（位图）"><a href="#2-10-BitMap（位图）" class="headerlink" title="2.10 BitMap（位图）"></a>2.10 BitMap（位图）</h2><p>BitMap，即位图，其实也就是 byte 数组，用二进制表示，只有 0 和 1 两个数字。可以用于实现用户上线次数统计。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SETBIT bit <span class="number">10086</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GETBIT bit <span class="number">10086</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GETBIT bit <span class="number">100</span>   <span class="comment"># bit 默认被初始化为 0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>下表给出了与 Redis BitMap相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>SETBIT</strong></td><td><font size="2" color="red"><strong>SETBIT key offset value（&gt;=2.2.0）</strong></font></td><td><font size="2"><strong>指定偏移量原来储存的位。</strong></font></td><td><font size="2"><strong>对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。位的设置或清除取决于 <code>value</code> 参数，可以是 <code>0</code> 也可以是 <code>1</code> 。当 <code>key</code> 不存在时，自动生成一个新的字符串值。字符串会进行伸展(grown)以确保它可以将 <code>value</code> 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 <code>0</code> 填充。<code>offset</code> 参数必须大于或等于 <code>0</code> ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</strong></font></td></tr><tr><td><strong>GETBIT</strong></td><td><font size="2" color="red"><strong>GETBIT key offset（&gt;=2.2.0）</strong></font></td><td><font size="2"><strong>字符串值指定偏移量上的位(bit)。</strong></font></td><td><font size="2"><strong>对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。当 <code>offset</code> 比字符串值的长度大，或者 <code>key</code> 不存在时，返回 <code>0</code> 。</strong></font></td></tr><tr><td><strong>BITCOUNT</strong></td><td><font size="2" color="red"><strong>BITCOUNT key [start] [end]（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>被设置为 <code>1</code> 的位的数量。</strong></font></td><td><font size="2"><strong>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行。<code>start</code> 和 <code>end</code> 参数的设置都可以使用负数值： 比如 <code>-1</code> 表示最后一个字节， <code>-2</code> 表示倒数第二个字节，以此类推。不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 <code>0</code> 。</strong></font></td></tr><tr><td><strong>BITPOS</strong></td><td><font size="2" color="red"><strong>BITPOS key bit [start] [end]（&gt;= 2.8.7）</strong></font></td><td><font size="2"><strong>整数回复。</strong></font></td><td><font size="2"><strong>返回位图中第一个值为 <code>bit</code> 的二进制位的位置。在默认情况下， 命令将检测整个位图， 但用户也可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。</strong></font></td></tr><tr><td><strong>BITOP</strong></td><td><font size="2" color="red"><strong>BITOP operation destkey key [key …]（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>保存到 <code>destkey</code> 的字符串的长度，和输入 <code>key</code> 中最长的字符串长度相等。</strong></font></td><td><font size="2"><strong>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。<code>operation</code> 可以是 <code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 、 <code>XOR</code> 这四种操作中的任意一种：<br><code>BITOP AND destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑并，并将结果保存到 <code>destkey</code> 。<br><code>BITOP OR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑或，并将结果保存到 <code>destkey</code> 。<br><code>BITOP XOR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑异或，并将结果保存到 <code>destkey</code> 。<br><code>BITOP NOT destkey key</code> ，对给定 <code>key</code> 求逻辑非，并将结果保存到 <code>destkey</code> 。<br>除了 <code>NOT</code> 操作之外，其他操作都可以接受一个或多个 <code>key</code> 作为输入。<br>当 <code>BITOP</code>处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</strong></font></td></tr><tr><td><strong>BITFIELD</strong></td><td><font size="2" color="red"><strong>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]（&gt;= 3.2.0）</strong></font></td><td><font size="2"><strong><a href="http://redisdoc.com/bitmap/bitfield.html" target="_blank" rel="noopener">复杂见文档</a></strong></font></td><td><font size="2"><strong><a href="http://redisdoc.com/bitmap/bitfield.html" target="_blank" rel="noopener">复杂见文档</a></strong></font></td></tr></tbody></table><h2 id="2-9-Pub-Sub（发布-订阅）"><a href="#2-9-Pub-Sub（发布-订阅）" class="headerlink" title="2.9 Pub/Sub（发布/订阅）"></a>2.9 Pub/Sub（发布/订阅）</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p><strong>实例</strong></p><p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 <strong>redisChat</strong>:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUBSCRIBE redisChat</span><br><span class="line"></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redisChat"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH redisChat <span class="string">"Redis is a great caching technique"</span></span><br><span class="line"> </span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH redisChat <span class="string">"Learn redis by w3cschool.cc"</span></span><br><span class="line"> </span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 订阅者的客户端会显示如下消息</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"message"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redisChat"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"Redis is a great caching technique"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"message"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redisChat"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"Learn redis by w3cschool.cc"</span></span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 发布订阅常用命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>PSUBSCRIBE</strong></td><td><font size="2" color="red"><strong>PSUBSCRIBE pattern [pattern …]（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>接收到的信息。</strong></font></td><td><font size="2"><strong>订阅一个或多个符合给定模式的频道。每个模式以 * 作为匹配符，比如 it* 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)。 news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类。</strong></font></td></tr><tr><td><strong>PUBSUB</strong></td><td><font size="2" color="red"> <strong>PUBSUB <subcommand> [argument [argument …]]（&gt;= 2.8.0）</subcommand></strong></font></td><td><font size="2"><strong>由活跃频道组成的列表。</strong></font></td><td><font size="2"><strong>用于查看订阅与发布系统状态，它由数个不同格式的子命令组成。</strong></font></td></tr><tr><td><strong>PUBLISH</strong></td><td><font size="2" color="red"><strong>PUBLISH channel message（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>接收到信息的订阅者数量。</strong></font></td><td><font size="2"><strong>用于将信息发送到指定的频道。</strong></font></td></tr><tr><td><strong>PUNSUBSCRIBE</strong></td><td><font size="2" color="red"><strong>PUNSUBSCRIBE [pattern [pattern …]]（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>这个命令在不同的客户端中有不同的表现。</strong></font></td><td><font size="2"><strong>用于退订所有给定模式的频道。</strong></font></td></tr><tr><td><strong>SUBSCRIBE</strong></td><td><font size="2" color="red"><strong>SUBSCRIBE channel [channel …]（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>接收到的信息。</strong></font></td><td><font size="2"><strong>用于订阅给定的一个或多个频道的信息。</strong></font></td></tr><tr><td><strong>UNSUBSCRIBE</strong></td><td><font size="2" color="red"><strong>UNSUBSCRIBE channel [channel …]（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>这个命令在不同的客户端中有不同的表现。</strong></font></td><td><font size="2"><strong>用于退订给定的一个或多个频道的信息。</strong></font></td></tr></tbody></table><h2 id="2-10-Transaction（事务）"><a href="#2-10-Transaction（事务）" class="headerlink" title="2.10 Transaction（事务）"></a>2.10 Transaction（事务）</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p><strong>实例</strong></p><p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SET book-name <span class="string">"Mastering C++ in 21 days"</span></span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD tag <span class="string">"C++"</span> <span class="string">"Programming"</span> <span class="string">"Mastering Series"</span></span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) <span class="string">"Mastering C++ in 21 days"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">3</span></span><br><span class="line"><span class="number">4</span>) <span class="number">1</span>) <span class="string">"Mastering Series"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"C++"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"Programming"</span></span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 事务的相关命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>DISCARD</strong></td><td><font size="2" color="red"><strong>DISCARD（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于取消事务，放弃执行事务块内的所有命令。</strong></font></td></tr><tr><td><strong>EXEC</strong></td><td><font size="2" color="red"><strong>EXEC（&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong>事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</strong></font></td><td><font size="2"><strong>用于执行所有事务块内的命令。</strong></font></td></tr><tr><td><strong>MULTI</strong></td><td><font size="2" color="red"><strong>MULTI（&gt;= 1.2.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 <code>EXEC</code>命令原子性(atomic)地执行。</strong></font></td></tr><tr><td><strong>UNWATCH</strong></td><td><font size="2" color="red"><strong>UNWATCH（&gt;= 2.2.0）</strong> </font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于取消 <code>WATCH</code> 命令对所有 key 的监视。</strong></font></td></tr><tr><td><strong>WATCH</strong></td><td><font size="2" color="red"><strong>WATCH（&gt;= 2.2.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于监视一个(或多个)<code>key</code> ，如果在事务执行之前这个(或这些)<code>key</code>被其他命令所改动，那么事务将被打断。</strong></font></td></tr></tbody></table><h2 id="2-11-Script（脚本）"><a href="#2-11-Script（脚本）" class="headerlink" title="2.11 Script（脚本）"></a>2.11 Script（脚本）</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Reids 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong>。</p><p><strong>实例</strong></p><p>以下实例演示了 redis 脚本工作过程：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EVAL <span class="string">"return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"</span> <span class="number">2</span> key1 key2 first second</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"key1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"key2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"second"</span></span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 脚本的相关命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>EVAL</strong></td><td><font size="2" color="red"><strong>EVAL script numkeys key [key …] arg [arg …]（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>无</strong></font></td><td><font size="2"><strong>使用 Lua 解释器执行脚本。<br>参数说明：<br>script： 参数是一段 Lua 5.1 脚本程序。脚本不必(也不应该)定义为一个 Lua 函数。 numkeys： 用于指定键名参数的个数。 key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。 arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</strong></font></td></tr><tr><td><strong>EVALSHA</strong></td><td><font size="2" color="red"><strong>EVALSHA sha1 numkeys key [key …] arg [arg …]（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>无</strong></font></td><td><font size="2"><strong>根据给定的 sha1 校验码，执行缓存在服务器中的脚本。参数说明同上</strong></font></td></tr><tr><td><strong>SCRIPT EXISTS</strong></td><td><font size="2" color="red"><strong>SCRIPT EXISTS scripts（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>一个列表，包含 <code>0</code>和<code>1</code>，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。列表中的元素和给定的 <code>SHA1</code>校验和保持对应关系，比如列表的第三个元素的值就表示第三个 <code>SHA1</code>校验和所指定的脚本在缓存中的状态。</strong></font></td><td><font size="2"><strong>用于校验指定的脚本是否已经被保存在缓存当中。</strong></font></td></tr><tr><td><strong>SCRIPT FLUSH</strong></td><td><font size="2" color="red"><strong>SCRIPT FLUSH（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>总是返回 OK。</strong></font></td><td><font size="2"><strong>用于清除所有 Lua 脚本缓存。</strong></font></td></tr><tr><td><strong>SCRIPT KILL</strong></td><td><font size="2" color="red"><strong>SCRIPT KILL（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>总是返回 OK</strong></font></td><td><font size="2"><strong>用于杀死当前正在运行的 <code>Lua</code>脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限循环的脚本。<code>SCRIPT KILL</code> 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 EVAL 命令的阻塞当中退出，并收到一个错误作为返回值。</strong></font></td></tr><tr><td><strong>SCRIPT LOAD</strong></td><td><font size="2" color="red"><strong>SCRIPT LOAD script（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>给定脚本的 <code>SHA1</code>校验和</strong></font></td><td><font size="2"><strong>用于将脚本 <code>script</code>添加到脚本缓存中，但并不立即执行这个脚本。<code>EVAL</code>命令也会将脚本添加到脚本缓存中，但是它会立即对输入的脚本进行求值。如果给定的脚本已经在缓存里面了，那么不执行任何操作。在脚本被加入到缓存之后，通过 <code>EVALSHA</code>命令，可以使用脚本的 SHA1 校验和来调用这个脚本。脚本可以在缓存中保留无限长的时间，直到执行 <code>SCRIPT FLUSH</code> 为止。</strong></font></td></tr></tbody></table><h2 id="2-12-Connection（连接）"><a href="#2-12-Connection（连接）" class="headerlink" title="2.12 Connection（连接）"></a>2.12 Connection（连接）</h2><p>Redis 连接命令主要是用于连接 redis 服务。</p><p><strong>实例</strong></p><p>以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; AUTH <span class="string">"password"</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 连接的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AUTH</strong></td><td><font size="2" color="red"><strong>AUTH PASSWORD（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>密码匹配时返回 OK ，否则返回一个错误。</strong></font></td><td><font size="2"><strong>用于检测给定的密码和配置文件中的密码是否相符。</strong></font></td></tr><tr><td><strong>ECHO</strong></td><td><font size="2" color="red"><strong>ECHO message（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>返回字符串本身。</strong></font></td><td><font size="2"><strong>用于打印给定的字符串。</strong></font></td></tr><tr><td><strong>PING</strong></td><td><font size="2" color="red"><strong>PING （&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>如果连接正常就返回一个 PONG ，否则返回一个连接错误。</strong></font></td><td><font size="2"><strong>使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。</strong></font></td></tr><tr><td><strong>QUIT</strong></td><td><font size="2" color="red"><strong>QUIT（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于关闭与当前客户端与redis服务的连接。一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</strong></font></td></tr><tr><td><strong>SELECT</strong></td><td><font size="2" color="red"><strong>SELECT index（&gt;=1.0.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。</strong></font></td></tr></tbody></table><h2 id="2-13-Server（服务器）"><a href="#2-13-Server（服务器）" class="headerlink" title="2.13 Server（服务器）"></a>2.13 Server（服务器）</h2><p>Redis 服务器命令主要是用于管理 redis 服务。</p><p><strong>实例</strong></p><p>以下实例演示了如何获取 redis 服务器的统计信息：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; INFO</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line"><span class="comment"># Redis 服务器版本</span></span><br><span class="line">redis_version:<span class="number">2.8</span>.<span class="number">13</span></span><br><span class="line"><span class="comment"># Git SHA1</span></span><br><span class="line">redis_git_sha1:<span class="number">00000000</span></span><br><span class="line"><span class="comment"># Git dirty flag</span></span><br><span class="line">redis_git_dirty:<span class="number">0</span></span><br><span class="line">redis_build_id:c2238b38b1edb0e2</span><br><span class="line">redis_mode:standalone</span><br><span class="line"><span class="comment"># Redis 服务器的宿主操作系统</span></span><br><span class="line">os:Linux <span class="number">3.5</span>.<span class="number">0</span>-<span class="number">48</span>-generic x86_64</span><br><span class="line"><span class="comment"># 架构（32 或 64 位）</span></span><br><span class="line">arch_bits:<span class="number">64</span></span><br><span class="line"><span class="comment"># Redis 所使用的事件处理机制</span></span><br><span class="line">multiplexing_api:epoll</span><br><span class="line"><span class="comment"># 编译 Redis 时所使用的 GCC 版本</span></span><br><span class="line">gcc_version:<span class="number">4.7</span>.<span class="number">2</span></span><br><span class="line"><span class="comment"># 服务器进程的 PID</span></span><br><span class="line">process_id:<span class="number">3856</span></span><br><span class="line"><span class="comment"># Redis 服务器的随机标识符（用于 Sentinel 和集群）</span></span><br><span class="line">run_id:<span class="number">0</span>e61abd297771de3fe812a3c21027732ac9f41fe</span><br><span class="line"><span class="comment"># TCP/IP 监听端口</span></span><br><span class="line">tcp_port:<span class="number">6379</span></span><br><span class="line"><span class="comment"># 自 Redis 服务器启动以来，经过的秒数</span></span><br><span class="line">uptime_in_seconds:<span class="number">11554</span></span><br><span class="line"><span class="comment"># 自 Redis 服务器启动以来，经过的天数</span></span><br><span class="line">uptime_in_days:<span class="number">0</span></span><br><span class="line">hz:<span class="number">10</span></span><br><span class="line"><span class="comment"># 以分钟为单位进行自增的时钟，用于 LRU 管理</span></span><br><span class="line">lru_clock:<span class="number">16651447</span></span><br><span class="line">config_file:</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line"><span class="comment"># 已连接客户端的数量（不包括通过从属服务器连接的客户端）</span></span><br><span class="line">connected_clients:<span class="number">1</span></span><br><span class="line"><span class="comment"># 当前连接的客户端当中，最长的输出列表</span></span><br><span class="line">client-longest_output_list:<span class="number">0</span></span><br><span class="line"><span class="comment"># 当前连接的客户端当中，最大输入缓存</span></span><br><span class="line">client-biggest_input_buf:<span class="number">0</span></span><br><span class="line"><span class="comment"># 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</span></span><br><span class="line">blocked_clients:<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line"><span class="comment"># 由 Redis 分配器分配的内存总量，以字节（byte）为单位</span></span><br><span class="line">used_memory:<span class="number">589016</span></span><br><span class="line"><span class="comment"># 以人类可读的格式返回 Redis 分配的内存总量</span></span><br><span class="line">used_memory_human:<span class="number">575.21</span>K</span><br><span class="line"><span class="comment"># 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</span></span><br><span class="line">used_memory_rss:<span class="number">2461696</span></span><br><span class="line"><span class="comment"># Redis 的内存消耗峰值（以字节为单位）</span></span><br><span class="line">used_memory_peak:<span class="number">667312</span></span><br><span class="line"><span class="comment"># 以人类可读的格式返回 Redis 的内存消耗峰值</span></span><br><span class="line">used_memory_peak_human:<span class="number">651.67</span>K</span><br><span class="line"><span class="comment"># Lua 引擎所使用的内存大小（以字节为单位）</span></span><br><span class="line">used_memory_lua:<span class="number">33792</span></span><br><span class="line"><span class="comment"># used_memory_rss 和 used_memory 之间的比率</span></span><br><span class="line">mem_fragmentation_ratio:<span class="number">4.18</span></span><br><span class="line"><span class="comment"># 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。</span></span><br><span class="line">mem_allocator:jemalloc-<span class="number">3.6</span>.<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Persistence RDB 和 AOF 的相关信息</span></span><br><span class="line">loading:<span class="number">0</span></span><br><span class="line">rdb_changes_since_last_save:<span class="number">3</span></span><br><span class="line">rdb_bgsave_in_progress:<span class="number">0</span></span><br><span class="line">rdb_last_save_time:<span class="number">1409158561</span></span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:<span class="number">0</span></span><br><span class="line">rdb_current_bgsave_time_sec:-<span class="number">1</span></span><br><span class="line">aof_enabled:<span class="number">0</span></span><br><span class="line">aof_rewrite_in_progress:<span class="number">0</span></span><br><span class="line">aof_rewrite_scheduled:<span class="number">0</span></span><br><span class="line">aof_last_rewrite_time_sec:-<span class="number">1</span></span><br><span class="line">aof_current_rewrite_time_sec:-<span class="number">1</span></span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Stats 一般统计信息</span></span><br><span class="line">total_connections_received:<span class="number">24</span></span><br><span class="line">total_commands_processed:<span class="number">294</span></span><br><span class="line">instantaneous_ops_per_sec:<span class="number">0</span></span><br><span class="line">rejected_connections:<span class="number">0</span></span><br><span class="line">sync_full:<span class="number">0</span></span><br><span class="line">sync_partial_ok:<span class="number">0</span></span><br><span class="line">sync_partial_err:<span class="number">0</span></span><br><span class="line">expired_keys:<span class="number">0</span></span><br><span class="line">evicted_keys:<span class="number">0</span></span><br><span class="line">keyspace_hits:<span class="number">41</span></span><br><span class="line">keyspace_misses:<span class="number">82</span></span><br><span class="line">pubsub_channels:<span class="number">0</span></span><br><span class="line">pubsub_patterns:<span class="number">0</span></span><br><span class="line">latest_fork_usec:<span class="number">264</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Replication 主/从复制信息</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_repl_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_active:<span class="number">0</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_histlen:<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># CPU CPU计算量统计信息</span></span><br><span class="line">used_cpu_sys:<span class="number">10.49</span></span><br><span class="line">used_cpu_user:<span class="number">4.96</span></span><br><span class="line">used_cpu_sys_children:<span class="number">0.00</span></span><br><span class="line">used_cpu_user_children:<span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#commandstats : Redis 命令统计信息</span></span><br><span class="line"><span class="comment">#cluster : Redis 集群信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace 数据库相关的统计信息</span></span><br><span class="line">db0:keys=<span class="number">94</span>,expires=<span class="number">1</span>,avg_ttl=<span class="number">41638810</span></span><br><span class="line">db1:keys=<span class="number">1</span>,expires=<span class="number">0</span>,avg_ttl=<span class="number">0</span></span><br><span class="line">db3:keys=<span class="number">1</span>,expires=<span class="number">0</span>,avg_ttl=<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 服务器的相关命令:</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>BGREWRITEAOF</strong></td><td><font size="2" color="red"><strong>BGREWRITEAOF（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>反馈信息。</strong></font></td><td><font size="2"><strong>用于异步执行一个 AOF（AppendOnly File） 文件重写操作。重写会创建一个当前 AOF 文件的体积优化版本。即使 Bgrewriteaof 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 Bgrewriteaof 成功之前不会被修改。<br>注意：<br>从 Redis 2.4 开始， AOF 重写由 Redis 自行触发， BGREWRITEAOF 仅仅用于手动触发重写操作。</strong></font></td></tr><tr><td><strong>BGSAVE</strong></td><td><font size="2" color="red"><strong>BGSAVE（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>反馈信息。</strong></font></td><td><font size="2"><strong>用于在后台异步保存当前数据库的数据到磁盘。BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</strong></font></td></tr><tr><td><strong>CLIENT KILL</strong></td><td><font size="2" color="red"><strong>CLIENT KILL ip:port（&gt;= 2.4.0）</strong></font></td><td><font size="2"><strong>成功关闭时，返回 OK 。</strong></font></td><td><font size="2"><strong>用于关闭客户端连接。</strong></font></td></tr><tr><td><strong>CLIENT LIST</strong></td><td><font size="2" color="red"><strong>CLIENT LIST（&gt;= 2.4.0）</strong></font></td><td><font size="2"><strong>命令返回多行字符串，这些字符串按以下形式被格式化：每个已连接客户端对应一行（以 LF 分割） 每行字符串由一系列 属性=值 形式的域组成，每个域之间以空格分开</strong></font></td><td><font size="2"><strong>用于返回所有连接到服务器的客户端信息和统计数据。</strong></font></td></tr><tr><td><strong>CLIENT GETNAME</strong></td><td><font size="2" color="red"><strong>CLIENT GETNAME（&gt;= 2.6.9）</strong></font></td><td><font size="2"><strong>如果连接没有设置名字，那么返回空白回复； 如果有设置名字，那么返回名字。</strong></font></td><td><font size="2"><strong>用于返回 CLIENT SETNAME 命令为连接设置的名字。 因为新创建的连接默认是没有名字的， 对于没有名字的连接， CLIENT GETNAME 返回空白回复。</strong></font></td></tr><tr><td><strong>CLIENT PAUSE</strong></td><td><font size="2" color="red"><strong>CLIENT PAUSE timeout（&gt;= 2.9.50）</strong></font></td><td><font size="2"><strong>返回 OK。如果 timeout 参数是非法的返回错误。</strong></font></td><td><font size="2"><strong>用于阻塞客户端命令一段时间（以毫秒计）。</strong></font></td></tr><tr><td><strong>CLIENT SETNAME</strong></td><td><font size="2" color="red"><strong>CLIENT SETNAME connection-name（&gt;= 2.6.9）</strong></font></td><td><font size="2"><strong>设置成功时返回 OK 。</strong></font></td><td><font size="2"><strong>用于指定当前连接的名称。这个名字会显示在 CLIENT LIST命令的结果中， 用于识别当前正在与服务器进行连接的客户端。</strong></font></td></tr><tr><td><strong>CLUSTER SLOTS</strong></td><td><font size="2" color="red"><strong>CLUSTER SLOTS（&gt;= 3.0.0）</strong></font></td><td><font size="2"><strong>IP/端口嵌套的列表数组。</strong></font></td><td><font size="2"><strong>用于当前的集群状态，以数组形式展示。</strong></font></td></tr><tr><td><strong>COMMAND</strong></td><td><font size="2" color="red"><strong>COMMAND（&gt;= 2.8.13）</strong></font></td><td><font size="2"><strong>嵌套的Redis命令的详细信息列表。列表顺序是随机的。</strong></font></td><td><font size="2"><strong>用于返回所有的Redis命令的详细信息，以数组形式展示。</strong></font></td></tr><tr><td><strong>COMMAND COUNT</strong></td><td><font size="2" color="red"><strong>COMMAND COUNT（&gt;= 2.8.13）</strong></font></td><td><font size="2"><strong>redis 命令数。</strong></font></td><td><font size="2"><strong>用于统计 redis 命令的个数。</strong></font></td></tr><tr><td><strong>COMMAND GETKEYS</strong></td><td><font size="2" color="red"><strong>COMMAND GETKEYS（&gt;= 2.8.13）</strong></font></td><td><font size="2"><strong>key 的列表。</strong></font></td><td><font size="2"><strong>用于获取所有 key。</strong></font></td></tr><tr><td><strong>TIME</strong></td><td><font size="2" color="red"><strong>TIME（&gt;= 2.6.0）</strong></font></td><td><font size="2"><strong>一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒</strong></font></td><td><font size="2"><strong>用于返回当前服务器时间。</strong></font></td></tr><tr><td><strong>COMMAND INFO</strong></td><td><font size="2" color="red"><strong>COMMAND INFO command-name [command-name …]（&gt;= 2.8.13）</strong></font></td><td><font size="2"><strong>命令描述信息的嵌套列表。</strong></font></td><td><font size="2"><strong>用于获取 redis 命令的描述信息。</strong></font></td></tr><tr><td><strong>CONFIG GET</strong></td><td><font size="2" color="red"><strong>CONFIG GET parameter（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>给定配置参数的值。</strong></font></td><td><font size="2"><strong>用于获取 redis 服务的配置参数。在 Redis 2.4 版本中， 有部分参数没有办法用 CONFIG GET 访问，但是在最新的 Redis 2.6 版本中，所有配置参数都已经可以用 CONFIG GET 访问了。</strong></font></td></tr><tr><td><strong>CONFIG REWRITE</strong></td><td><font size="2" color="red"><strong>CONFIG REWRITE parameter（&gt;= 2.8.0）</strong></font></td><td><font size="2"><strong>一个状态值：如果配置重写成功则返回 OK ，失败则返回一个错误。</strong></font></td><td><font size="2"><strong>对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写。对服务器的当前配置进行修改， 而修改后的配置可能和 redis.conf 文件中所描述的配置不一样， CONFIG REWRITE 的作用就是通过尽可能少的修改， 将服务器当前所使用的配置记录到 redis.conf 文件中。</strong></font></td></tr><tr><td><strong>CONFIG SET</strong></td><td><font size="2" color="red"> <strong>CONFIG SET parameter value （&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>当设置成功时返回 OK ，否则返回一个错误。</strong></font></td><td><font size="2"><strong>可以动态地调整 Redis 服务器的配置(configuration)而无须重启。可以使用它修改配置参数，或者改变 Redis 的持久化(Persistence)方式。</strong></font></td></tr><tr><td><strong>CONFIG RESETSTAT</strong></td><td><font size="2" color="red"><strong>CONFIG RESETSTAT（&gt;= 2.0.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于重置 INFO命令中的某些统计数据，包括：Keyspace hits (键空间命中次数)、Keyspace misses (键空间不命中次数)、Number of commands processed (执行命令的次数)、Number of connections received (连接服务器的次数)、Number of expired keys (过期key的数量)、Number of rejected connections (被拒绝的连接数量)、Latest fork(2) time(最后执行 fork(2) 的时间)、The <code>aof_delayed_fsync</code> counter(<code>aof_delayed_fsync</code> 计数器的值)</strong></font></td></tr><tr><td><strong>DBSIZE</strong></td><td><font size="2" color="red"><strong>DBSIZE（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>当前数据库的 key 的数量。</strong></font></td><td><font size="2"><strong>用于返回当前数据库的 key 的数量。</strong></font></td></tr><tr><td><strong>DEBUG OBJECT</strong></td><td><font size="2" color="red"><strong>DEBUG OBJECT key（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>当 key 存在时，返回有关信息。 当 key 不存在时，返回一个错误。</strong></font></td><td><font size="2"><strong>是一个调试命令，它不应被客户端所使用。</strong></font></td></tr><tr><td><strong>DEBUG SEGFAULT</strong></td><td><font size="2" color="red"><strong>DEBUG SEGFAULT（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>无</strong></font></td><td><font size="2"><strong>执行一个非法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 调试。</strong></font></td></tr><tr><td><strong>FLUSHALL</strong></td><td><font size="2" color="red"><strong>FLUSHALL（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。</strong></font></td></tr><tr><td><strong>FLUSHDB</strong></td><td><font size="2" color="red"><strong>FLUSHDB（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于清空当前数据库中的所有 key。</strong></font></td></tr><tr><td><strong>INFO</strong></td><td><font size="2" color="red"><strong>INFO [section]（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>字符串，文本行的集合。</strong></font></td><td><font size="2"><strong>以一种易于理解和阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。通过给定可选的参数 section ，可以让命令只返回某一部分的信息。</strong></font></td></tr><tr><td><strong>LASTSAVE</strong></td><td><font size="2" color="red"><strong>LASTSAVE（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>字符串，文本行的集合。</strong></font></td><td><font size="2"><strong>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。</strong></font></td></tr><tr><td><strong>MONITOR</strong></td><td><font size="2" color="red"><strong>MONITOR（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>用于实时打印出 Redis 服务器接收到的命令，调试用。</strong></font></td></tr><tr><td><strong>ROLE</strong></td><td><font size="2" color="red"><strong>ROLE（&gt;= 2.8.12）</strong></font></td><td><font size="2"><strong>返回一个数组：第一个参数是 master, slave, sentinel 三个中的一个。</strong></font></td><td><font size="2"><strong>查看主从实例所属的角色，角色有master, slave, sentinel。</strong></font></td></tr><tr><td><strong>SAVE</strong></td><td><font size="2" color="red"><strong>SAVE（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>保存成功时返回 OK 。</strong></font></td><td><font size="2"><strong>执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。</strong></font></td></tr><tr><td><strong>SHUTDOWN</strong></td><td><font size="2" color="red"><strong>SHUTDOWN [NOSAVE] [SAVE]（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>执行失败时返回错误。 执行成功时不返回任何信息，服务器和客户端的连接断开，客户端自动退出。</strong></font></td><td><font size="2"><strong>停止所有客户端。如果有至少一个保存点在等待，执行 SAVE 命令。如果 AOF 选项被打开，更新 AOF 文件。关闭 redis 服务器(server)。</strong></font></td></tr><tr><td><strong>SLAVEOF</strong></td><td><font size="2" color="red"><strong>SLAVEOF host port（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>总是返回 OK 。</strong></font></td><td><font size="2"><strong>可以将当前服务器转变为指定服务器的从属服务器(slave server)。如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行 SLAVEOF host port 将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。另外，对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。利用『 SLAVEOF NO ONE 不会丢弃同步所得数据集』这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</strong></font></td></tr><tr><td><strong>SLOWLOG</strong></td><td><font size="2" color="red"><strong>SLOWLOG subcommand [argument]（&gt;= 2.2.12）</strong></font></td><td><font size="2"><strong>取决于不同命令，返回不同的值。</strong></font></td><td><font size="2"><strong>用来记录查询执行时间的日志系统。查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</strong></font></td></tr><tr><td><strong>SYNC</strong></td><td><font size="2" color="red"><strong>SYNC（&gt;= 1.0.0）</strong></font></td><td><font size="2"><strong>不明确。</strong></font></td><td><font size="2"><strong>用于同步主从服务器。</strong></font></td></tr></tbody></table><h1 id="3-文档"><a href="#3-文档" class="headerlink" title="3.文档"></a>3.文档</h1><h2 id="3-1-KeySpace-Notification（键空间通知）"><a href="#3-1-KeySpace-Notification（键空间通知）" class="headerlink" title="3.1 KeySpace Notification（键空间通知）"></a>3.1 KeySpace Notification（键空间通知）</h2><h2 id="3-2-Transation（-事务）"><a href="#3-2-Transation（-事务）" class="headerlink" title="3.2 Transation（ 事务）"></a>3.2 Transation（ 事务）</h2><p><code>MULTI</code> 、 <code>EXEC</code>、 <code>DISCARD</code> 和 <code>WATCH</code>是 Redis 事务的基础。</p><p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p><code>EXEC</code> 命令负责触发并执行事务中的所有命令：</p><ul><li>如果客户端在使用 <code>MULTI</code>  开启了一个事务之后，却因为断线而没有成功执行 <code>EXEC</code> ，那么事务中的所有命令都不会被执行。</li><li>另一方面，如果客户端成功在开启事务之后执行 <code>EXEC</code> ，那么事务中的所有命令都会被执行。</li></ul></li></ul><h2 id="3-3-Pub-Sub（发布与订阅）"><a href="#3-3-Pub-Sub（发布与订阅）" class="headerlink" title="3.3 Pub/Sub（发布与订阅）"></a>3.3 Pub/Sub（发布与订阅）</h2><h2 id="3-4-Replication（主从复制）"><a href="#3-4-Replication（主从复制）" class="headerlink" title="3.4  Replication（主从复制）"></a>3.4  Replication（主从复制）</h2><h2 id="3-5-Protocol（通信协议）"><a href="#3-5-Protocol（通信协议）" class="headerlink" title="3.5 Protocol（通信协议）"></a>3.5 Protocol（通信协议）</h2><h2 id="3-6-Persistence（持久化）"><a href="#3-6-Persistence（持久化）" class="headerlink" title="3.6 Persistence（持久化）"></a>3.6 Persistence（持久化）</h2><h2 id="3-7-Sentinel（哨兵）"><a href="#3-7-Sentinel（哨兵）" class="headerlink" title="3.7 Sentinel（哨兵）"></a>3.7 Sentinel（哨兵）</h2><h2 id="3-8-Cluster（集群）"><a href="#3-8-Cluster（集群）" class="headerlink" title="3.8 Cluster（集群）"></a>3.8 Cluster（集群）</h2><h2 id="3-9-集群规范"><a href="#3-9-集群规范" class="headerlink" title="3.9 集群规范"></a>3.9 集群规范</h2><h1 id="4-jedis"><a href="#4-jedis" class="headerlink" title="4.jedis"></a>4.jedis</h1><h2 id="4-1-Jedis简介"><a href="#4-1-Jedis简介" class="headerlink" title="4.1 Jedis简介"></a>4.1 Jedis简介</h2><h2 id="4-2-HelloWordl-Jedis版"><a href="#4-2-HelloWordl-Jedis版" class="headerlink" title="4.2 HelloWordl(Jedis版)"></a>4.2 HelloWordl(Jedis版)</h2><ol><li><p>jar包导入</p><blockquote><p>下载地址：<a href="https://mvnrepository.com/artifact/redis.clients/jedis" target="_blank" rel="noopener">https://mvnrepository.com/artifact/redis.clients/jedis</a> </p></blockquote></li><li><p>基于maven</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt; </span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>连接redis</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure></li><li><p>操作redis</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"itheima"</span>); jedis.get(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure></li><li><p>关闭redis连接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li><li><p>API文档</p><p><a href="http://xetorthio.github.io/jedis/" target="_blank" rel="noopener">http://xetorthio.github.io/jedis/</a> </p></li></ol><h2 id="4-3-Jedis读写redis数据"><a href="#4-3-Jedis读写redis数据" class="headerlink" title="4.3 Jedis读写redis数据"></a>4.3 Jedis读写redis数据</h2><h2 id="4-4-Jedis简易工具类开发"><a href="#4-4-Jedis简易工具类开发" class="headerlink" title="4.4 Jedis简易工具类开发"></a>4.4 Jedis简易工具类开发</h2><h2 id="4-5-可视化客户端"><a href="#4-5-可视化客户端" class="headerlink" title="4.5 可视化客户端"></a>4.5 可视化客户端</h2><h1 id="5-删除策略"><a href="#5-删除策略" class="headerlink" title="5. 删除策略"></a>5. 删除策略</h1><p><strong>数据删除策略</strong></p><ol><li><p>定时删除</p><blockquote><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 </p><p>优点：</p><p>​        节约内存，到时就删除，快速释放掉不必要的内存占用 </p><p>缺点：</p><p>​        CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 </p><p>总结：</p><p>​        用处理器性能换取存储空间 （拿时间换空间） </p></blockquote></li><li><p>惰性删除</p><blockquote><p>数据到达过期时间，不做处理。等下次访问该数据时 </p><ul><li>如果未过期，返回数据 </li><li>发现已过期，删除，返回不存在 </li></ul><p>优点：</p><p>​        节约CPU性能，发现必须删除的时候才删除 </p><p>缺点：</p><p>​        内存压力很大，出现长期占用内存的数据 </p><p>总结：</p><p>​        用存储空间换取处理器性能 （拿时间换空间） </p></blockquote></li><li><p>定期删除</p><blockquote><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 </p><p>特点1：</p><p>​        CPU性能占用设置有峰值，检测频度可自定义设置 </p><p>特点2：</p><p>​        内存压力不是很大，长期占用内存的冷数据会被持续清理 </p><p>总结：</p><p>​        周期性抽查存储空间 （随机抽查，重点抽查） </p></blockquote></li></ol><p><strong>三种策略对比</strong></p><table><thead><tr><th>策略</th><th>内存</th><th>CPU</th><th>总结</th></tr></thead><tbody><tr><td>定时删除</td><td>节约内存，无占用</td><td>不分时段占用CPU资源，频度高</td><td>时间换空间</td></tr><tr><td>惰性删除</td><td>内存占用严重</td><td>延时执行，CPU利用率高</td><td>空间换时间</td></tr><tr><td>定期删除</td><td>内存定期随机清理</td><td>每秒花费固定的COU资源维护内存</td><td>随机抽查，重点抽查</td></tr></tbody></table><h1 id="6-redis高可用"><a href="#6-redis高可用" class="headerlink" title="6. redis高可用"></a>6. redis高可用</h1><h2 id="6-1-主从模式"><a href="#6-1-主从模式" class="headerlink" title="6.1 主从模式"></a>6.1 主从模式</h2><h3 id="6-1-1-作用"><a href="#6-1-1-作用" class="headerlink" title="6.1.1 作用"></a>6.1.1 作用</h3><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数 量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 </li></ul><h3 id="6-1-2主从复制工作流程"><a href="#6-1-2主从复制工作流程" class="headerlink" title="6.1.2主从复制工作流程"></a>6.1.2主从复制工作流程</h3><ol><li><p>建立连接阶段（即准备阶段）</p><blockquote><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号 </p></blockquote><ul><li>步骤1：设置master的地址和端口，保存master信息</li><li>步骤2：建立socket连接 </li><li>步骤3：发送ping命令（定时器任务） </li><li>步骤4：身份验证 </li><li>步骤5：发送slave端口信息</li></ul><table><thead><tr><th>master</th><th>slave</th></tr></thead><tbody><tr><td></td><td>①发送指令：slaveof  ip  port</td></tr><tr><td>②接收到指令，响应对方</td><td></td></tr><tr><td></td><td>③保存master的IP与端口     masterhost     masterport</td></tr><tr><td></td><td>④根据保存的信息创建连接master的socket</td></tr><tr><td></td><td>⑤周期性发送命令：ping</td></tr><tr><td>⑥响应pong</td><td></td></tr><tr><td></td><td>⑦发送指令：auth  password</td></tr><tr><td>⑧验证授权</td><td></td></tr><tr><td></td><td>⑨发送指令：replconf listening-port <port-number></port-number></td></tr><tr><td>⑩保存slave的端口号</td><td></td></tr></tbody></table><ol><li><p>主从连接（slave连接master）</p><ul><li><p>方式一：客户端发送命令</p><blockquote><p><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></blockquote></li><li><p>方式二：启动服务器参数 </p><blockquote><p><code>redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></blockquote></li><li><p>方式三：服务器配置 </p><blockquote><p><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></blockquote></li><li><p>slave系统信息 </p><ol><li>master_link_down_since_seconds </li><li>masterhost </li><li>masterport </li></ol></li><li><p>master系统信息</p><ol><li>slave_listening_port(多个) </li></ol></li></ul></li><li><p>主从断开连接</p><ul><li><p>客户端发送命令 </p><blockquote><p> <code>slaveof no one</code></p></blockquote></li><li><p>说明</p><blockquote><p>slave断开连接后，不会删除已有数据，只是不再接受master发送的数据 </p></blockquote></li></ul></li><li><p>授权访问</p><ul><li><p>master客户端发送命令设置密码 </p><blockquote><p><code>requirepass &lt;password&gt;</code></p></blockquote></li><li><p>master配置文件设置密码 </p><blockquote><p><code>config set requirepass &lt;password&gt;</code></p><p><code>config get requirepass</code></p></blockquote></li><li><p>slave客户端发送命令设置密码 </p><blockquote><p><code>auth &lt;password&gt;</code></p></blockquote></li><li><p>slave配置文件设置密码 </p><blockquote><p><code>masterauth &lt;password&gt;</code></p></blockquote></li><li><p>slave启动服务器设置密码 </p><blockquote><p><code>redis-server –a &lt;password&gt;</code></p></blockquote></li></ul></li></ol></li><li><p>数据同步阶段</p><blockquote><p>在slave初次连接master后，复制master中的所有数据到slave</p><p>将slave的数据库状态更新成master当前的数据库状态 </p></blockquote><ul><li>步骤1：请求同步数据 </li><li>步骤2：创建RDB同步数据 </li><li>步骤3：恢复RDB同步数据 </li><li>步骤4：请求部分同步数据 </li><li>步骤5：恢复部分同步数据</li></ul><table><thead><tr><th>master</th><th>slave</th></tr></thead><tbody><tr><td></td><td>①发送指令：psync2</td></tr><tr><td>②执行bgsave</td><td></td></tr><tr><td>③第一个slave连接时， 创建命令缓冲区</td><td></td></tr><tr><td>④生成RDB文件，通过 socket发送给slave</td><td></td></tr><tr><td></td><td>⑤接收RDB，清空数据，执行RDB文件恢复过程</td></tr><tr><td></td><td>⑥发送命令告知RDB恢复已经完成完成</td></tr><tr><td>⑦发送复制缓冲区信息</td><td></td></tr><tr><td></td><td>⑧接收信息，执行bgrewriteaof，恢复数据</td></tr><tr><td></td><td>⑨发送指令：？？？</td></tr><tr><td>⑩接收到指令，响应对方</td><td></td></tr><tr><td>1-5:全量复制</td><td>6-8部分复制</td></tr></tbody></table><ol><li><p>数据同步阶段master说明 </p><ol><li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行 </p></li><li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已 经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。 </p><blockquote><p> repl-backlog-size 1mb</p></blockquote></li><li><p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区 </p></li></ol></li><li><p>数据同步阶段slave说明 </p><ol><li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务 </p><blockquote><p>slave-serve-stale-data yes|no </p></blockquote></li><li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送 命令</p></li><li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果 master带宽不足，因此数据同步需要根据业务需求，适量错峰</p></li><li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择 </p></li></ol></li></ol></li><li><p>命名传播阶段</p><blockquote><p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的 状态，同步的动作称为命令传播 </p><p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令 </p></blockquote><ol><li><p>命令传播阶段的部分复制 </p><ul><li>命令传播阶段出现了断网现象 <ul><li>网络闪断闪连        忽略 </li><li>短时间网络中断    部分复制 </li><li>长时间网络中断    全量复制 </li></ul></li><li>部分复制的三个核心要素 <ul><li>服务器的运行 id（run id） </li><li>主服务器的复制积压缓冲区 </li><li>主从服务器的复制偏移量 </li></ul></li></ul></li><li><p>服务器运行ID（runid） </p><ol><li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id </li><li>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce </li><li>作用：运行id被用于在服务器间进行传输，识别身份 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 </li><li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发 送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid </li></ol></li><li><p>复制缓冲区 </p><ol><li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区<ul><li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队 列长度时，最先入队的元素会被弹出，而新元素会被放入队列 </li></ul></li><li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 </li><li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） </li><li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中 </li></ol></li><li><p>复制缓冲区内部工作原理 </p><ol><li>组成 <ul><li>偏移量 </li><li>字节值 </li></ul></li><li>工作原理 <ul><li>通过offset区分不同的slave当前数据传播的差异 </li><li>master记录已发送的信息对应的offset</li><li>slave记录已接收的信息对应的offset </li></ul></li></ol></li><li><p>主从服务器复制偏移量（offset）</p><ol><li>概念：一个数字，描述复制缓冲区中的指令字节位置 </li><li>分类： <ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）  </li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个） </li></ul></li><li>数据来源： <ul><li>master端：发送一次记录一次 </li><li>slave端：接收一次记录一次</li></ul></li><li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用 </li></ol></li><li><p>数据同步+命令传播阶段工作流程 </p><table><thead><tr><th>master</th><th>slave</th></tr></thead><tbody><tr><td>②执行bgsave生成RDB文件，记录当前的复制偏移量offset</td><td>①发送指令： psync2  ？-1   psync2  <runid> <offset></offset></runid></td></tr><tr><td>③发送 +FULLRESYNC runid offset   通过socket发送RDB文件给slave<br>期间接收客户端命令，offset发生了变化</td><td>④收到 +FULLRESYNC  保存master的runid和offset 清空当前全部数据，通过socket接收RDB文件，恢复RDB数据</td></tr><tr><td>⑥接收命令，判定runid是否匹配，判定offset是否在复制缓冲区中</td><td>⑤发送命令：psync2  runid offset</td></tr><tr><td>⑦如果runid或offset有一个不满足，执行全量复制<br>⑦如果runid或offset校验通过，offset与offset相同，忽略<br>⑦如果runid或offset校验通过，offset与offset不相同   发送 +CONTINUE offset   通过socket发送复制缓冲区中offset到offset的数据</td><td>⑧收到 +CONTINUE  保存master的offset 接收信息后，执行bgrewriteaof，恢复数据</td></tr><tr><td>1-4全量复制</td><td>5-8部分复制</td></tr></tbody></table></li><li><p>心跳机制</p><ul><li>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 </li><li>master心跳： <ul><li>指令：PING </li><li>周期：由repl-ping-slave-period决定，默认10秒 </li><li>作用：判断slave是否在线 </li><li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常 </li></ul></li><li>slave心跳任务 <ul><li>指令：REPLCONF ACK {offset} </li><li>周期：1秒 </li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线 </li></ul></li></ul></li><li><p>心跳阶段注意事项 </p><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 </p><blockquote><p>min-slaves-to-write 2<br>min-slaves-max-lag 8 </p></blockquote><p>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 </p></li><li><p>slave数量由slave发送REPLCONF ACK命令做确认 </p></li><li><p>slave延迟由slave发送REPLCONF ACK命令做确认 </p></li></ul></li><li><p>主从复制工作流程（完整） </p></li></ol></li></ol><h3 id="6-1-3-主从复制常见问题"><a href="#6-1-3-主从复制常见问题" class="headerlink" title="6.1.3 主从复制常见问题"></a>6.1.3 主从复制常见问题</h3><ol><li><p>频繁的全量复制（1） </p><blockquote><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的 全量复制操作 </p><p>内部优化调整方案： </p><ol><li>master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave </li><li>在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中 <ul><li>repl-id repl-offset   </li><li>通过redis-check-rdb命令可以查看该信息 </li></ul></li><li>master重启后加载RDB文件，恢复数据 重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中 <ul><li>master_repl_id = repl    master_repl_offset = repl-offset</li><li>通过info命令可以查看该信息</li></ul></li></ol><p>作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master </p></blockquote></li><li><p>频繁的全量复制（2） </p><blockquote><ul><li>问题现象 <ul><li>网络环境不佳，出现网络中断，slave不提供服务</li></ul></li><li>问题原因 <ul><li>复制缓冲区过小，断网后slave的offset越界，触发全量复制 </li></ul></li><li>最终结果 <ul><li>slave反复进行全量复制 </li></ul></li><li>解决方案 <ul><li>修改复制缓冲区大小 </li></ul></li><li>建议设置如下： <ol><li>测算从master到slave的重连平均时长second </li><li>获取master平均每秒产生写命令数据总量write_size_per_second </li><li>最优复制缓冲区空间 = 2 * second * write_size_per_second </li></ol></li></ul></blockquote></li><li><p>频繁的网络中断（1） </p><ul><li><p>问题现象 </p><ul><li>master的CPU占用过高 或 slave频繁断开连接 </li></ul></li><li><p>问题原因 </p><ul><li>slave每1秒发送REPLCONF ACK命令到master </li><li>当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能 </li><li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应 </li></ul></li><li><p>最终结果 </p><ul><li>master各种资源（输出缓冲区、带宽、连接等）被严重占用 </li></ul></li><li><p>解决方案 </p><ul><li><p>通过设置合理的超时时间，确认是否释放slave </p><blockquote><p>repl-timeout </p></blockquote></li></ul></li></ul></li></ol><pre><code>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave </code></pre><ol start="4"><li><p>频繁的网络中断（2） </p><ul><li><p>问题现象 </p><ul><li>slave与master连接断开</li></ul></li><li><p>问题原因 </p><ul><li>master发送ping指令频度较低</li><li>master设定超时时间较短 </li><li>ping指令在网络中存在丢包 </li></ul></li><li><p>解决方案 </p><ul><li><p>提高ping指令发送的频度 </p><blockquote><p> repl-ping-slave-period  </p></blockquote></li></ul></li></ul></li></ol><pre><code>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时 </code></pre><ol start="5"><li><p>数据不一致 </p><ul><li><p>问题现象 </p><ul><li>多个slave获取相同数据不同步</li></ul></li><li><p>问题原因 </p><ul><li>网络信息不同步，数据发送有延迟</li></ul></li><li><p>解决方案</p><ul><li><p>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p></li><li><p>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问 </p><blockquote><p> slave-serve-stale-data  yes|no </p></blockquote></li></ul></li></ul></li></ol><pre><code>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高） </code></pre><h2 id="6-2-哨兵模式"><a href="#6-2-哨兵模式" class="headerlink" title="6.2 哨兵模式"></a>6.2 哨兵模式</h2><h3 id="6-2-1-作用"><a href="#6-2-1-作用" class="headerlink" title="6.2.1 作用"></a>6.2.1 作用</h3><ul><li>监控 <ul><li>不断的检查master和slave是否正常运行。 </li><li>master存活检测、master与slave运行情况检测 </li></ul></li><li>通知（提醒） <ul><li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。 </li></ul></li><li>自动故障转移 <ul><li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服 务器地址 </li></ul></li></ul><p>注意：</p><p>​        哨兵也是一台redis服务器，只是不提供数据服务 </p><p>​        通常哨兵配置数量为单数 </p><h3 id="6-2-2-启用哨兵模式"><a href="#6-2-2-启用哨兵模式" class="headerlink" title="6.2.2 启用哨兵模式"></a>6.2.2 启用哨兵模式</h3><ol><li><p>配置一拖二的主从结构 </p></li><li><p>配置三个哨兵（配置相同，端口不同） </p><blockquote><p>参看sentinel.conf </p></blockquote></li><li><p>启动哨兵 </p><blockquote><p>redis-sentinel sentinel端口号 .conf </p></blockquote></li></ol><table><thead><tr><th>配置项</th><th>范例</th><th>说明</th></tr></thead><tbody><tr><td>sentinel auth-pass  &lt;服务器名称&gt; <password></password></td><td>&lt;服务器名称&gt; <password> <br>sentinel auth-pass mymaster joey</password></td><td>设置哨兵监听的主服务器信息，最后的参数决定了最终参与选举的服务器（-1）</td></tr><tr><td>sentinel down-after-milliseconds &lt;自定义服 务名称&gt;&lt;主机地址&gt;&lt;端口&gt;&lt;主从服务器总量&gt;</td><td>sentinel monitor mymaster 192.168.194.131 6381 1</td><td>指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒（30000），也是主从切换条件之一</td></tr><tr><td>sentinel down-after-milliseconds  &lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>sentinel down-aftermilliseconds mymaster 3000</td><td>指定同时进行主从的slave数量，数值越大，要求的网络资源越高，要求月洗，同步时间越长</td></tr><tr><td>sentinel parallel-syncs   &lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td>sentinel parallel-syncs mymaster</td><td>指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟</td></tr><tr><td>sentinel failover-timeout   &lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>sentinel failover-timeout mymaster 9000</td><td>服务器无法正常联通时，设定的执行脚本，通常调试使用</td></tr><tr><td>sentinel notification-script   &lt;服务名称&gt;&lt;脚本路径&gt;</td><td></td><td></td></tr></tbody></table><h3 id="6-2-3-哨兵工作原理"><a href="#6-2-3-哨兵工作原理" class="headerlink" title="6.2.3 哨兵工作原理"></a>6.2.3 哨兵工作原理</h3><h2 id="6-3-redis集群"><a href="#6-3-redis集群" class="headerlink" title="6.3 redis集群"></a>6.3 redis集群</h2><h1 id="7-企业级解决方案"><a href="#7-企业级解决方案" class="headerlink" title="7.企业级解决方案"></a>7.企业级解决方案</h1>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2020/02/10/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/02/10/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL服务"><a href="#1-MySQL服务" class="headerlink" title="1.MySQL服务"></a>1.MySQL服务</h1><h2 id="1-1-MySQL服务的启动和停止"><a href="#1-1-MySQL服务的启动和停止" class="headerlink" title="1.1 MySQL服务的启动和停止"></a>1.1 MySQL服务的启动和停止</h2><p>方式一：计算机——右击管理——服务</p><p>方式二：通过管理员身份运行</p><ul><li><code>net start 服务名（启动服务）</code></li><li><code>net stop 服务名（停止服务）</code></li></ul><h2 id="1-2-MySQL服务的登录和退出"><a href="#1-2-MySQL服务的登录和退出" class="headerlink" title="1.2 MySQL服务的登录和退出"></a>1.2 MySQL服务的登录和退出</h2><p>登录：<strong>mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码</strong></p><p>退出：<strong>exit或ctrl+C</strong></p><h1 id="2-DQL-Data-Query-Language-数据查询语言"><a href="#2-DQL-Data-Query-Language-数据查询语言" class="headerlink" title="2.DQL(Data Query Language)数据查询语言"></a>2.DQL(Data Query Language)数据查询语言</h1><h2 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>通过select查询完的结果 ，是一个虚拟的表格，不是真实存在</li><li>要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</li></ol><h2 id="2-2-条件查询"><a href="#2-2-条件查询" class="headerlink" title="2.2 条件查询"></a>2.2 条件查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 WHERE 筛选条件;</span><br></pre></td></tr></table></figure><p><strong>分类：</strong></p><ol><li><p>条件表达式<br>示例：salary&gt;10000<br>条件运算符：&gt;、&lt; 、&gt;=、 &lt;=、 = 、!=、 &lt;&gt;</p></li><li><p>逻辑表达式</p><p>示例：salary&gt;10000 &amp;&amp; salary&lt;20000</p><p>逻辑运算符：</p><ul><li>and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</li><li>or(||)：两个条件只要有一个成立，结果为true，否则为false</li><li>not(!)：如果条件成立，则not后为false，否则为true</li></ul></li><li><p>模糊查询<br>示例：last_name like ‘a%’</p></li></ol><h2 id="2-3-排序查询"><a href="#2-3-排序查询" class="headerlink" title="2.3 排序查询"></a>2.3 排序查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 ORDER BY 排序列表 【asc||desc】;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li><p>asc ：升序，如果不写默认升序</p><p>desc：降序</p></li><li><p>排序列表 支持 单个字段、多个字段、函数、表达式、别名</p></li><li><p>order by的位置一般放在查询语句的最后（除limit语句之外）</p></li></ol><h2 id="2-4-常见函数"><a href="#2-4-常见函数" class="headerlink" title="2.4 常见函数"></a>2.4 常见函数</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(实参列表);</span><br></pre></td></tr></table></figure><p><strong>分类：</strong></p><ol><li><p>单行函数</p><ol><li><p>字符函数</p><ul><li><p>concat：连接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(&apos;Hello&apos;,&apos;_&apos;,&apos;World&apos;);</span><br><span class="line">#结果：Hello_World</span><br></pre></td></tr></table></figure></li><li><p>substr：截取子串</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#注意：索引从1开始</span><br><span class="line">#截取从指定索引处后面所有字符</span><br><span class="line">SELECT SUBSTR(&apos;Hello World&apos;,7);</span><br><span class="line">#结果：World</span><br><span class="line">#截取从指定索引处指定字符长度的字符</span><br><span class="line">SELECT SUBSTR(&apos;Hello World&apos;,1,3);</span><br><span class="line">#结果：Hel</span><br></pre></td></tr></table></figure></li><li><p>upper：变大写</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT UPPER(&apos;john&apos;);</span><br><span class="line">#结果：JOHN</span><br></pre></td></tr></table></figure></li><li><p>lower：变小写</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   SELECT LOWER(&apos;joHn&apos;);</span><br><span class="line">#结果：john</span><br></pre></td></tr></table></figure></li><li><p>replace：替换</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT REPLACE(&apos;Hello World&apos;,&apos;l&apos;,&apos;i&apos;);</span><br><span class="line">#结果：Heiio Worid</span><br></pre></td></tr></table></figure></li><li><p>length：获取字节长度</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(&apos;john&apos;);</span><br><span class="line">#结果：4</span><br></pre></td></tr></table></figure></li><li><p>trim：去前后空格</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(TRIM(&apos;    Hello    &apos;));</span><br><span class="line">#结果：5</span><br></pre></td></tr></table></figure></li><li><p>lpad：左填充</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRIM(&apos;l&apos; FROM &apos;llllllllHellolllll&apos;);</span><br><span class="line">#结果：Hello</span><br></pre></td></tr></table></figure></li><li><p>rpad：右填充</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LPAD(&apos;john&apos;,6,&apos;*&apos;);</span><br><span class="line">#结果：**john</span><br></pre></td></tr></table></figure></li><li><p>instr：获取子串第一次出现的索引</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT INSTR(&apos;Hello World&apos;,&apos;o&apos;);</span><br><span class="line">#结果：5</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数学函数</p><ul><li><p>ceil：向上取整</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CEIL(-1.02);</span><br><span class="line">#结果：-1</span><br></pre></td></tr></table></figure></li><li><p>round：四舍五入</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ROUND(-1.55);</span><br><span class="line">#结果：-2</span><br><span class="line">SELECT ROUND(1.567,2);</span><br><span class="line">#结果：1.57</span><br></pre></td></tr></table></figure></li><li><p>mod：取模</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MOD(10,-3);</span><br><span class="line">#结果：1</span><br><span class="line">SELECT 10%3;</span><br><span class="line">#结果：1</span><br></pre></td></tr></table></figure></li><li><p>floor：向下取整</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT FLOOR(-9.99);</span><br><span class="line">#结果：-10</span><br></pre></td></tr></table></figure></li><li><p>truncate：截断</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRUNCATE(1.69999,1);</span><br><span class="line">#结果：1.6</span><br></pre></td></tr></table></figure></li><li><p>rand：获取随机数，返回0-1之间的小数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT RAND();</span><br><span class="line">#结果：0.2870596892079894</span><br></pre></td></tr></table></figure></li></ul></li><li><p>日期函数</p><ul><li><p>now：返回当前日期+时间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW();</span><br><span class="line">#结果：2020-02-10 16:05:07</span><br></pre></td></tr></table></figure></li><li><p>curdate：返回当前日期</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURDATE();</span><br><span class="line">#结果：2020-02-10</span><br></pre></td></tr></table></figure></li><li><p>curtime：返回当前时间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURTIME();</span><br><span class="line">#结果：16:05:07</span><br></pre></td></tr></table></figure></li><li><p>year：返回年</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT YEAR(NOW()) 年;</span><br><span class="line">#结果：2020</span><br><span class="line">SELECT YEAR(&apos;1998-1-1&apos;) 年;</span><br><span class="line">#结果：1998</span><br></pre></td></tr></table></figure></li><li><p>month：返回月</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MONTH(NOW()) 月;</span><br><span class="line">#结果：2</span><br></pre></td></tr></table></figure></li><li><p>monthname：以英文形式返回月</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MONTHNAME(NOW()) 月;</span><br><span class="line">#结果：February</span><br></pre></td></tr></table></figure></li><li><p>day：返回日</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DAY(NOW()) 日;</span><br><span class="line">#结果：10</span><br></pre></td></tr></table></figure></li><li><p>hour：小时</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT HOUR(NOW()) 小时;</span><br><span class="line">#结果：16</span><br></pre></td></tr></table></figure></li><li><p>minute：分钟</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MINUTE(NOW()) 分钟;</span><br><span class="line">#结果：6</span><br></pre></td></tr></table></figure></li><li><p>second：秒</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SECOND(NOW()) 秒;</span><br><span class="line">#结果：50</span><br></pre></td></tr></table></figure></li><li><p>date_format：将日期转换成字符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(),&apos;%y年%m月%d日&apos;);</span><br><span class="line">#结果：20年02月10日</span><br></pre></td></tr></table></figure></li><li><p>str_to_date：将字符转换成日期</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&apos;1998-3-2&apos;,&apos;%Y-%c-%d&apos;);</span><br><span class="line">#结果：1998-03-02</span><br></pre></td></tr></table></figure></li><li><p>datediff：返回两个日期相差的天数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATEDIFF(&apos;2020-12-30&apos;,&apos;2020-12-29&apos;);</span><br><span class="line">#结果：1</span><br></pre></td></tr></table></figure></li></ul></li><li><p>流程控制函数</p><ul><li><p><strong>if</strong>(条件表达式，表达式1，表达式2)：</p><p> 如果条件表达式成立，返回表达式1，否则返回表达式2</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT IF(10&lt;5,&apos;大&apos;,&apos;小&apos;);</span><br><span class="line">#结果：小</span><br></pre></td></tr></table></figure></li><li><p><strong>case情况1</strong></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 变量或表达式或字段</span><br><span class="line">when 常量1 then 值1</span><br><span class="line">when 常量2 then 值2</span><br><span class="line">...</span><br><span class="line">else 值n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#示例</span><br><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></li><li><p><strong>case情况2</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 值1</span><br><span class="line">when 条件2 then 值2</span><br><span class="line">...</span><br><span class="line">else 值n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#示例</span><br><span class="line">SELECT salary,</span><br><span class="line">CASE </span><br><span class="line">WHEN salary&gt;20000 THEN &apos;A&apos;</span><br><span class="line">    WHEN salary&gt;15000 THEN &apos;B&apos;</span><br><span class="line">WHEN salary&gt;10000 THEN &apos;C&apos;</span><br><span class="line">    ELSE &apos;D&apos;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他函数</p><ul><li><p>version：当前数据库服务器的版本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br><span class="line">#结果：5.7.18-log</span><br></pre></td></tr></table></figure></li><li><p>database：当前打开的数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br><span class="line">#结果：joeychat</span><br></pre></td></tr></table></figure></li><li><p>user：当前用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT USER();</span><br><span class="line">#结果：root@localhost</span><br></pre></td></tr></table></figure></li><li><p>password(‘字符’)：返回该字符的密码形式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT PASSWORD(&apos;Hello&apos;);</span><br><span class="line">#结果：*FCA02337EEB51C3EE398B473FD9A9AFD093F9E64</span><br></pre></td></tr></table></figure></li><li><p>md5(‘字符’)：返回该字符的md5加密形式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MD5(&apos;Hello&apos;);</span><br><span class="line">#结果：8b1a9953c4611296a827abf8c47804d7</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>分组函数</p><ol><li><p>函数</p><ul><li><p>sum：求和</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(salary) FROM employees;</span><br></pre></td></tr></table></figure></li><li><p>max：最大值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary) FROM employees;</span><br></pre></td></tr></table></figure></li><li><p>min：最小值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary) FROM employees;</span><br></pre></td></tr></table></figure></li><li><p>avg：平均值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary) FROM employees;</span><br></pre></td></tr></table></figure></li><li><p>count：计数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(salary) FROM employees;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特点</p><ol><li>以上五个分组函数都忽略<code>null</code>值，除了count(*)</li><li>sum和avg一般用于处理数值型，max、min、count可以处理任何数据类型</li><li>可以搭配distinct使用，用于统计去重后的结果</li><li>count的参数可以支持：字段、*、常量值，一般放1</li><li>效率：<ul><li>MYISAM存储引擎下 ，COUNT(*)的效率高</li><li>INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些</li></ul></li></ol></li></ol></li></ol><h2 id="2-5-分组查询"><a href="#2-5-分组查询" class="headerlink" title="2.5 分组查询"></a>2.5 分组查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 GROUP BY 分组的字段 HAVING 分组后的筛选 ORDER BY 排序列表;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li><p>可以按单个字段分组</p></li><li><p>和分组函数一同查询的字段最好是分组后的字段</p></li><li><table><thead><tr><th>分组筛选</th><th>针对的表</th><th>位置</th><th>关键字</th></tr></thead><tbody><tr><td>分组前筛选</td><td>原始表</td><td>group by的前面</td><td>where</td></tr><tr><td>分组后筛选</td><td>分组后的结果集</td><td>group by的后面</td><td>having</td></tr></tbody></table></li><li><p>可以按多个字段分组，字段之间用逗号隔开</p></li><li><p>可以支持排序</p></li><li><p>having后可以支持别名</p></li></ol><h2 id="2-6-连接查询"><a href="#2-6-连接查询" class="headerlink" title="2.6 连接查询"></a>2.6 连接查询</h2><p><strong>sql99语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段，...</span><br><span class="line">FROM 表1</span><br><span class="line">INNER|LEFT OUTER|RIGHT OUTER|CROSS JOIN 表2 ON 连接条件</span><br><span class="line">INNER|LEFT OUTER|RIGHT OUTER|CROSS JOIN 表3 ON 连接条件</span><br><span class="line">WHERE 筛选条件</span><br><span class="line">GROUP BY 分组字段</span><br><span class="line">HAVING 分组后的筛选条件</span><br><span class="line">ORDER BY 排序的字段或表达式</span><br></pre></td></tr></table></figure><h2 id="2-7-子查询"><a href="#2-7-子查询" class="headerlink" title="2.7 子查询"></a>2.7 子查询</h2><p><strong>含义：</strong></p><p>​        一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询。<br>​        在外面的查询语句，称为主查询或外查询。</p><p><strong>特点：</strong></p><ol><li><p>子查询都放在小括号内</p></li><li><p>子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧</p></li><li><p>子查询优先于主查询执行，主查询使用了子查询的执行结果</p></li><li><p>子查询根据查询结果的行数不同分为以下两类：</p><ul><li><p>单行子查询</p><p>结果集只有一行，一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= </p><p>非法使用子查询的情况：</p><ul><li>子查询的结果为一组值</li><li>子查询的结果为空</li></ul></li><li><p>多行子查询</p><p>结果集有多行，一般搭配多行操作符使用：any、all、in、not in</p><p>in： 属于子查询结果中的任意一个就行</p><p>any和all往往可以用其他查询代替</p></li></ul></li></ol><h2 id="2-8-分页查询"><a href="#2-8-分页查询" class="headerlink" title="2.8 分页查询"></a>2.8 分页查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表</span><br><span class="line">LIMIT offset,size;</span><br><span class="line">#offset代表的是起始的条目索引，默认从0开始,可省略</span><br><span class="line">#size代表的是显示的条目数</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li><p>起始条目索引从0开始</p></li><li><p>limit子句放在查询语句的最后</p></li><li><p>公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage，</p><p>说明：</p><p>​        sizePerPage：每页显示条目数</p><p>​        page：要显示的页数 </p></li></ol><h2 id="2-9-联合查询"><a href="#2-9-联合查询" class="headerlink" title="2.9 联合查询"></a>2.9 联合查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件 UNION all</span><br><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件 UNION all</span><br><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件 UNION all</span><br><span class="line">.....</span><br><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>多条查询语句的查询的列数必须是一致的</li><li>多条查询语句的查询的列的类型几乎相同</li><li><strong>union代表去重，union all代表不去重</strong></li></ol><h1 id="3-DML-Data-Manipulate-Language-数据操作语言"><a href="#3-DML-Data-Manipulate-Language-数据操作语言" class="headerlink" title="3. DML(Data Manipulate Language)数据操作语言"></a>3. DML(Data Manipulate Language)数据操作语言</h1><h2 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一</span><br><span class="line">INSERT INTO 表名(字段名，...)VALUES(值1，...);</span><br><span class="line">#方式二</span><br><span class="line">INSERT INTO 表名 SET 字段=值,字段=值,...;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>字段类型和值类型一致或兼容，而且一一对应</li><li>可以为空的字段，可以不用插入值，或用null填充</li><li>不可以为空的字段，必须插入值</li><li>字段个数和值的个数必须一致</li><li>字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</li></ol><h2 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#单表更新</span><br><span class="line">UPDATE 表名 SET 字段=值,字段=值 WHERE 筛选条件;</span><br><span class="line">#多表更新</span><br><span class="line">UPDATE 表1 别名 </span><br><span class="line">LEFT|RIGHT|INNER JOIN 表2 别名 </span><br><span class="line">ON 连接条件  </span><br><span class="line">SET 字段=值,字段=值 </span><br><span class="line">WHERE 筛选条件;</span><br></pre></td></tr></table></figure><h2 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用DELETE</span><br><span class="line"> #一、删除单表的记录</span><br><span class="line"> DELETE FROM 表名 WHERE 筛选条件;</span><br><span class="line"> #二、级联删除</span><br><span class="line"> DELETE 别名1,别名2 FROM 表1 别名 </span><br><span class="line"> LEFT|RIGHT|INNER JOIN 表2 别名 </span><br><span class="line"> ON 连接条件</span><br><span class="line"> WHERE 筛选条件;</span><br><span class="line">#使用TRUNCATE</span><br><span class="line">TRUNCATE TABLE 表名;</span><br><span class="line">#区别：</span><br><span class="line">#1.truncate删除后，如果再插入，标识列从1开</span><br><span class="line">#  delete删除后，如果再插入，标识列从断点开始</span><br><span class="line">#2.delete可以添加筛选条件</span><br><span class="line">#     truncate不可以添加筛选条件</span><br><span class="line">#3.truncate效率较高</span><br><span class="line">#4.truncate没有返回值</span><br><span class="line">#  delete可以返回受影响的行数</span><br><span class="line">#5.truncate不可以回滚</span><br><span class="line">#  delete可以回滚</span><br></pre></td></tr></table></figure><h1 id="4-DDL-Data-Define-Language-数据定义语言"><a href="#4-DDL-Data-Define-Language-数据定义语言" class="headerlink" title="4.DDL(Data Define Language)数据定义语言"></a>4.DDL(Data Define Language)数据定义语言</h1><h2 id="4-1-库的管理"><a href="#4-1-库的管理" class="headerlink" title="4.1 库的管理"></a>4.1 库的管理</h2><ol><li><p>创建库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 【IF NOT EXISTS】 库名【 CHARACTER SET 字符集名】</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 库名 CHARACTER SET 字符集名;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>删除库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 【IF EXISTS】 库名;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-2-表的管理"><a href="#4-2-表的管理" class="headerlink" title="4.2 表的管理"></a>4.2 表的管理</h2><ol><li><p>创建表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">stuId INT,</span><br><span class="line">stuName VARCHAR(20),</span><br><span class="line">gender CHAR,</span><br><span class="line">bornDate DATETIME</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>修改表</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</span><br></pre></td></tr></table></figure><ol><li><p>添加字段</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD COLUMN 列名 类型 【First|After 字段名】;</span><br></pre></td></tr></table></figure></li><li><p>修改字段名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 类型;</span><br></pre></td></tr></table></figure></li><li><p>修改字段的类型或约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 列名 新类型 【新约束】;</span><br></pre></td></tr></table></figure></li><li><p>删除列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP COLUMN 列名;</span><br></pre></td></tr></table></figure></li><li><p>修改表名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME 【to】 新表名;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>删除表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] studentinfo;</span><br></pre></td></tr></table></figure></li><li><p>复制表</p><ol><li><p>复制表结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 LIKE 旧表;</span><br></pre></td></tr></table></figure></li><li><p>复制表结构+数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名</span><br><span class="line">SELECT 查询列表 FROM 旧表 【WHERE筛选】;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h2><ol><li><p>整型</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 byte</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table></li><li><p>浮点型</p><table><thead><tr><th>类型</th><th>DECIMAL(M,D)</th><th>FLOAT</th><th>DOUBLE</th></tr></thead><tbody><tr><td>长度</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>4</td><td>8</td></tr></tbody></table></li><li><p>字符型</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255 bytes</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 bytes</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255 bytes</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255 bytes</td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65 535 bytes</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65 535 bytes</td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16 777 215 bytes</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16 777 215 bytes</td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294 967 295 bytes</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294 967 295 bytes</td><td align="left">极大文本数据</td></tr></tbody></table></li><li><p>日期型</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYYMMDD HHMMSS</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table></li></ol><h2 id="4-4-常见的约束"><a href="#4-4-常见的约束" class="headerlink" title="4.4 常见的约束"></a>4.4 常见的约束</h2><ol><li><p>常见约束</p><ol><li>NOT NULL：非空，该字段的值必填</li><li>UNIQUE：唯一，该字段的值不可重复</li><li>DEFAULT：默认，该字段的值不用手动插入有默认值</li><li>CHECK：检查，MYSQL不支持</li><li>PRIMARY KEY：主键，该字段的值不可重复并且非空  NIQUE+NOT NULL</li><li>FOREIGN KEY：外键，该字段的值引用了另外的表的字段</li></ol><p><strong>其中，主键和唯一</strong></p><ol><li>区别：<ul><li>一个表至多有一个主键，但可以有多个唯一</li><li>主键不允许为空，唯一可以为空</li></ul></li><li>相同点<ul><li>都具有唯一性</li><li>都支持组合键，但不推荐</li></ul></li></ol><p><strong>外键</strong></p><ol><li><p>用于限制两个表的关系，从表的字段值引用了主表的某字段值</p></li><li><p>外键列和主表的被引用列要求类型一致，意义一样，名称无要求</p></li><li><p>主表的被引用列要求是一个KEY（一般就是主键）</p></li><li><p>插入数据，先插入主表</p></li><li><p>当设置有外键的时候，可以通过一下两种方式实现删除主表的记录：</p><ul><li><p><strong>方式一：级联删除</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table stuinfo add CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) on DELETE CASCADE;</span><br></pre></td></tr></table></figure><p>说明：这样删除主表中的数据的时候，引用他外键的表的数据也都会进行删除，当然这种做法有点残忍，但是在实际的业务中，进行数据维护的时候，确实也有这么干的</p></li><li><p><strong>方式二：级联置空</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table stuinfo add CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) on DELETE set null;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>这样删除主表中的数据的时候，引用他外键的表的数据不会进行删除，对应的引用外键的那一列会置为空，这种方法比较好。<br><strong>综上所述，要结合具体的业务场景进行选择。</strong></p></li></ul></li></ol></li><li><p>创建表时添加约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段名 字段类型 NOT NULL,#非空</span><br><span class="line">字段名 字段类型 PRIMARY KEY,#主键</span><br><span class="line">字段名 字段类型 UNIQUE,#唯一</span><br><span class="line">字段名 字段类型 DEFAULT 值,#默认</span><br><span class="line">CONSTRAINT 约束名 FOREIGN KEY(字段名) REFERENCES 主表（被引用列）</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p><p><strong>对比：</strong></p><table><thead><tr><th></th><th>支持类型</th><th>可以起约束名</th></tr></thead><tbody><tr><td>列级约束</td><td>除了外键</td><td>不可以</td></tr><tr><td>表级约束</td><td>除了非空和默认</td><td>可以，但对主键无效</td></tr></tbody></table></li><li><p>修改表时添加或删除约束</p><ol><li><p>非空</p><ol><li><p>添加非空</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 NOT NULL;</span><br></pre></td></tr></table></figure></li><li><p>删除非空</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 ;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>默认</p><ol><li><p>添加默认</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 DEFAULT 值;</span><br></pre></td></tr></table></figure></li><li><p>删除默认</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 ;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>主键</p><ol><li><p>添加主键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD【 CONSTRAINT 约束名】 PRIMARY KEY(字段名);</span><br></pre></td></tr></table></figure></li><li><p>删除主键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>唯一</p><ol><li><p>添加唯一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD【 CONSTRAINT 约束名】 UNIQUE(字段名);</span><br></pre></td></tr></table></figure></li><li><p>删除唯一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP INDEX 索引名;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>外键</p><ol><li><p>添加外键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD【 CONSTRAINT 约束名】 FOREIGN KEY(字段名) REFERENCES 主表（被引用列）;</span><br></pre></td></tr></table></figure></li><li><p>删除外键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 约束名;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>自增长列</p><ol><li><p>特点：</p><ol><li><p>不用手动插入值，可以自动提供序列值，默认从1开始，步长为1</p><p>AUTO_INCREMENT_INCREMENT</p><p>如果要更改起始值：手动插入值</p><p>如果要更改步长：更改系统变量 SET AUTO_INCREMENT_INCREMENT=值;</p></li><li><p>一个表至多有一个自增长列</p></li><li><p>自增长列只能支持数值型</p></li><li><p>自增长列必须为一个KEY</p></li></ol></li><li><p>创建表时设置自增长列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表(</span><br><span class="line">字段名 字段类型 约束 AUTO_INCREMENT</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>修改表时设置自增长列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表 MODIFY COLUMN 字段名 字段类型 约束 AUTO_INCREMENT</span><br></pre></td></tr></table></figure></li><li><p>删除自增长列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表 MODIFY COLUMN 字段名 字段类型 约束</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="5-TCL-Transaction-Control-Language-事务控制语言"><a href="#5-TCL-Transaction-Control-Language-事务控制语言" class="headerlink" title="5.TCL(Transaction Control Language)事务控制语言"></a>5.TCL(Transaction Control Language)事务控制语言</h1><h2 id="5-1含义"><a href="#5-1含义" class="headerlink" title="5.1含义"></a>5.1含义</h2><p><strong>事务：</strong></p><p>​        一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行</p><h2 id="5-2-特点（ACID）"><a href="#5-2-特点（ACID）" class="headerlink" title="5.2 特点（ACID）"></a>5.2 特点（ACID）</h2><ul><li>A 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行</li><li>C 一致性：一个事务可以使数据从一个一致状态切换到另外一个一致的状态</li><li>I 隔离性：一个事务不受其他事务的干扰，多个事务互相隔离的</li><li>D 持久性：一个事务一旦提交了，则永久的持久化到本地</li></ul><h2 id="5-3-使用步骤"><a href="#5-3-使用步骤" class="headerlink" title="5.3 使用步骤"></a>5.3 使用步骤</h2><p><strong>了解：</strong><br>隐式（自动）事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete<br>显式事务：具有明显的开启和结束</p><p><strong>使用显式事务：</strong></p><p>①开启事务<br>set autocommit=0;<br>start transaction;#可以省略</p><p>②编写一组逻辑sql语句<br>注意：sql语句支持的是insert、update、delete</p><p>设置回滚点：<br>savepoint 回滚点名;</p><p>③结束事务<br>提交：commit;<br>回滚：rollback;<br>回滚到指定的地方：rollback to 回滚点名;</p><h2 id="5-4-并发事务"><a href="#5-4-并发事务" class="headerlink" title="5.4 并发事务"></a>5.4 并发事务</h2><ol><li><p>事务的并发问题是如何发生的？<br>多个事务同时操作 同一个数据库的相同数据时</p></li><li><p>并发问题都有哪些？<br>脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据<br>不可重复读：一个事务多次读取，结果不一样<br>幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的数据</p></li><li><p>如何解决并发问题<br>通过设置隔离级别来解决并发问题</p></li><li><p>隔离级别</p><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED:读未提交</td><td>×</td><td>×</td><td>×</td></tr><tr><td>READ COMMITTED：读已提交</td><td>√</td><td>×</td><td>×</td></tr><tr><td>REPEATABLE READ：可重复读</td><td>√</td><td>√</td><td>×</td></tr><tr><td>SERIALIZABLE：串行化</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></li><li><p>设置和查看隔离级别</p><ol><li><p>设置隔离级别</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set session|global  transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure></li><li><p>查看隔离级别</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h1><h2 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h2><ol><li><p>含义：</p><p>​        mysql5.1版本出现的新特性，本身是一个虚拟表，它的数据来自于表，通过执行时动态生成。</p></li><li><p>好处：</p><ol><li>简化sql语句</li><li>提高了sql的重用性</li><li>保护基表的数据，提高了安全性</li></ol></li><li><p>语法</p><ol><li><p>创建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li><li><p>修改</p><ol><li><p>方式一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view 视图1，视图2,...;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc 视图名;</span><br><span class="line">show create view 视图名;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.插入</span><br><span class="line">insert</span><br><span class="line">2.修改</span><br><span class="line">update</span><br><span class="line">3.删除</span><br><span class="line">delete</span><br><span class="line">4.查看</span><br><span class="line">select</span><br></pre></td></tr></table></figure></li><li><p>注意</p><p>视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新<br>①包含分组函数、group by、distinct、having、union、<br>②join<br>③常量视图<br>④where后的子查询用到了from中的表<br>⑤用到了不可更新的视图</p></li><li><p>视图和表的对比</p><table><thead><tr><th></th><th>关键字</th><th>是否占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td>视图</td><td>view</td><td>占用较小，只保存sql逻辑</td><td>一般用于查询</td></tr><tr><td>表</td><td>table</td><td>保存实际的数据</td><td>增删改查</td></tr></tbody></table></li></ol></li></ol><h2 id="6-2-变量"><a href="#6-2-变量" class="headerlink" title="6.2 变量"></a>6.2 变量</h2><ol><li><p>系统变量</p><p><strong>说明：</strong>变量由系统提供的，不用自定义。</p><ol><li><p>全局变量</p><p>服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效</p></li><li><p>会话变量</p><p>服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p></li></ol><p><strong>语法：</strong></p><ul><li><p>查看系统变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有显式声明global还是session，则默认是session</span><br><span class="line">show 【global|session 】variables like &apos;&apos;;</span><br></pre></td></tr></table></figure></li><li><p>查看指定的系统变量的值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有显式声明global还是session，则默认是session</span><br><span class="line">select @@【global|session】.变量名;</span><br></pre></td></tr></table></figure></li><li><p>为系统变量赋值</p><ul><li><p>方式一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有显式声明global还是session，则默认是session</span><br><span class="line">set 【global|session 】 变量名=值;</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @@global.变量名=值;</span><br><span class="line">set @@变量名=值；</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>自定义变量</p><ol><li><p>用户变量</p><p>作用域：针对于当前连接（会话）生效</p><p>位置：begin end里面，也可以放在外面</p><p>使用：</p><ol><li><p>声明并赋值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @变量名=值;或</span><br><span class="line">set @变量名:=值;或</span><br><span class="line">select @变量名:=值;</span><br></pre></td></tr></table></figure></li><li><p>更新值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @变量名=值;或</span><br><span class="line">set @变量名:=值;或</span><br><span class="line">select @变量名:=值;</span><br><span class="line">select xx into @变量名 from 表;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @变量名;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>局部变量</p><p>作用域：仅仅在定义它的begin end中有效</p><p>位置：只能放在begin end中，而且只能放在第一句</p><p>使用：</p><ol><li><p>声明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare 变量名 类型 【default 值】;</span><br></pre></td></tr></table></figure></li><li><p>赋值或更新</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set 变量名=值;或</span><br><span class="line">set 变量名:=值;或</span><br><span class="line">select @变量名:=值;</span><br><span class="line">select xx into 变量名 from 表;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 变量名;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="6-3-存储过程"><a href="#6-3-存储过程" class="headerlink" title="6.3 存储过程"></a>6.3 存储过程</h2><ol><li><p>创建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程名(参数模式 参数名 参数类型)</span><br><span class="line">begin</span><br><span class="line">存储过程体</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>1.参数模式：in、out、inout，其中in可以省略</strong></p><p><strong>2.存储过程体的每一条sql语句都需要用分号结尾</strong></p></li><li><p>调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call 存储过程名(实参列表)</span><br><span class="line">#举例：</span><br><span class="line">#调用in模式的参数：call sp1（‘值’）;</span><br><span class="line">#调用out模式的参数：set @name; call sp1(@name);select @name;</span><br><span class="line">#调用inout模式的参数：set @name=值; call sp1(@name); select @name;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create procedure 存储过程名;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop procedure 存储过程名;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-4-函数"><a href="#6-4-函数" class="headerlink" title="6.4 函数"></a>6.4 函数</h2><ol><li><p>创建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create function 函数名(参数名 参数类型) returns  返回类型</span><br><span class="line">begin</span><br><span class="line">函数体</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>注意：函数体中肯定需要有return语句</strong></p></li><li><p>调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 函数名(实参列表);</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create function 函数名;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop function 函数名;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-5-流程控制结构"><a href="#6-5-流程控制结构" class="headerlink" title="6.5 流程控制结构"></a>6.5 流程控制结构</h2><h3 id="6-5-1-分支结构"><a href="#6-5-1-分支结构" class="headerlink" title="6.5.1 分支结构"></a>6.5.1 分支结构</h3><ol><li><p>IF函数</p><p>功能：实现简单双分支</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件，值1，值2)</span><br></pre></td></tr></table></figure><p>位置：可以作为表达式放在任何位置</p></li><li><p>CASE结构</p><p>功能：实现多分支</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一种</span><br><span class="line">case 表达式或字段</span><br><span class="line">when 值1 then 语句1;</span><br><span class="line">when 值2 then 语句2；</span><br><span class="line">..</span><br><span class="line">else 语句n;</span><br><span class="line">end [case];</span><br><span class="line">#第二种</span><br><span class="line">case </span><br><span class="line">when 条件1 then 语句1;</span><br><span class="line">when 条件2 then 语句2；</span><br><span class="line">..</span><br><span class="line">else 语句n;</span><br><span class="line">end [case];</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>IF结构</p><p>功能：实现多分支</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件1 then 语句1;</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure><p>位置：只能放在begin end中</p></li></ol><h3 id="6-5-2-循环结构"><a href="#6-5-2-循环结构" class="headerlink" title="6.5.2 循环结构"></a>6.5.2 循环结构</h3><ol><li><p>WHILE</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【名称:】while 循环条件 do</span><br><span class="line">循环体</span><br><span class="line">end while 【名称】;</span><br></pre></td></tr></table></figure></li><li><p>LOOP</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【名称：】loop</span><br><span class="line">循环体</span><br><span class="line">end loop 【名称】;</span><br></pre></td></tr></table></figure></li><li><p>REPEAT</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【名称:】repeat</span><br><span class="line">循环体</span><br><span class="line">until 结束条件 </span><br><span class="line">end repeat 【名称】;</span><br></pre></td></tr></table></figure></li><li><p>对比</p><ol><li><p>这三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称</p><ul><li>leave：类似于break，用于跳出所在的循环</li><li>iterate：类似于continue，用于结束本次循环，继续下一次</li></ul></li><li><p>loop 一般用于实现简单的死循环</p><p>while 先判断后执行</p><p>repeat 先执行后判断，无条件至少执行一次</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高德地图绘制矢量图</title>
      <link href="/2019/12/19/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E7%94%BB%E7%82%B9%E3%80%81%E6%8A%98%E7%BA%BF%E3%80%81%E5%A4%9A%E8%BE%B9%E5%BD%A2%E3%80%81%E9%95%BF%E6%96%B9%E5%BD%A2%E3%80%81%E5%9C%86/"/>
      <url>/2019/12/19/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E7%94%BB%E7%82%B9%E3%80%81%E6%8A%98%E7%BA%BF%E3%80%81%E5%A4%9A%E8%BE%B9%E5%BD%A2%E3%80%81%E9%95%BF%E6%96%B9%E5%BD%A2%E3%80%81%E5%9C%86/</url>
      
        <content type="html"><![CDATA[<h1 id="高德地图绘制矢量图"><a href="#高德地图绘制矢量图" class="headerlink" title="高德地图绘制矢量图"></a>高德地图绘制矢量图</h1><h1 id="地图坐标选取器"><a href="#地图坐标选取器" class="headerlink" title="地图坐标选取器"></a>地图坐标选取器</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"chrome=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1.0, user-scalable=no, width=device-width"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html, body, #container &#123;</span><br><span class="line">            height: 100%;</span><br><span class="line">            width: 100%;</span><br><span class="line">            font-size: 14px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        body &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";</span><br><span class="line">            line-height: 1.5;</span><br><span class="line">            font-weight: 300;</span><br><span class="line">            color: #111213;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        * &#123;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .input-item &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            display: -ms-flexbox;</span><br><span class="line">            display: flex;</span><br><span class="line">            -ms-flex-wrap: wrap;</span><br><span class="line">            flex-wrap: wrap;</span><br><span class="line">            -ms-flex-align: center;</span><br><span class="line">            align-items: center;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 2.2rem;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .info &#123;</span><br><span class="line">            padding: .75rem 1.25rem;</span><br><span class="line">            margin-bottom: 1rem;</span><br><span class="line">            border-radius: .25rem;</span><br><span class="line">            position: fixed;</span><br><span class="line">            top: 1rem;</span><br><span class="line">            background-color: white;</span><br><span class="line">            width: auto;</span><br><span class="line">            min-width: 22rem;</span><br><span class="line">            border-width: 0;</span><br><span class="line">            left: 1rem;</span><br><span class="line">            right: auto;</span><br><span class="line">            box-shadow: 0 2px 6px 0 rgba(114, 124, 245, .5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .input-card &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            flex-direction: column;</span><br><span class="line">            min-width: 0;</span><br><span class="line">            word-wrap: break-word;</span><br><span class="line">            background-color: #fff;</span><br><span class="line">            background-clip: border-box;</span><br><span class="line">            border-radius: .25rem;</span><br><span class="line">            width: 22rem;</span><br><span class="line">            border-width: 0;</span><br><span class="line">            box-shadow: 0 2px 6px 0 rgba(114, 124, 245, .5);</span><br><span class="line">            position: fixed;</span><br><span class="line">            bottom: 1rem;</span><br><span class="line">            right: 1rem;</span><br><span class="line">            -ms-flex: 1 1 auto;</span><br><span class="line">            flex: 1 1 auto;</span><br><span class="line">            padding: 0.75rem 1.25rem;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .btn &#123;</span><br><span class="line">            width: 6rem;</span><br><span class="line">            margin: 0 1rem 0 2rem;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            font-weight: 400;</span><br><span class="line">            text-align: center;</span><br><span class="line">            white-space: nowrap;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">            -webkit-user-select: none;</span><br><span class="line">            -moz-user-select: none;</span><br><span class="line">            -ms-user-select: none;</span><br><span class="line">            user-select: none;</span><br><span class="line">            border: 1px solid transparent;</span><br><span class="line">            transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, box-shadow .15s ease-in-out;</span><br><span class="line">            background-color: transparent;</span><br><span class="line">            background-image: none;</span><br><span class="line">            color: #25A5F7;</span><br><span class="line">            border-color: #25A5F7;</span><br><span class="line">            padding: .25rem .5rem;</span><br><span class="line">            line-height: 1.5;</span><br><span class="line">            border-radius: 1rem;</span><br><span class="line">            -webkit-appearance: button;</span><br><span class="line">            cursor: pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            .btn:focus,</span><br><span class="line">            .btn:active:focus,</span><br><span class="line">            .btn.active:focus,</span><br><span class="line">            .btn.focus,</span><br><span class="line">            .btn:active.focus,</span><br><span class="line">            .btn.active.focus &#123;</span><br><span class="line">                outline: none;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        .input-text &#123;</span><br><span class="line">            width: 4rem;</span><br><span class="line">            margin-right: 1rem;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>鼠标工具绘制<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'container'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'info'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>操作说明：圆和矩形通过拖拽来绘制，其他覆盖物通过单击来绘制，双击结束绘制<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>当前类型：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"type"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>坐标信息：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"lnglat"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"location"</span>&gt;</span>位置信息： <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-card"</span> <span class="attr">style</span>=<span class="string">'width: 24rem;'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">checked</span> <span class="attr">value</span>=<span class="string">'marker'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span>&gt;</span>画点<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">value</span>=<span class="string">'polyline'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span>&gt;</span>画折线<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">value</span>=<span class="string">'polygon'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span> <span class="attr">style</span>=<span class="string">'width:5rem;'</span>&gt;</span>画多边形<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">value</span>=<span class="string">'rectangle'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span>&gt;</span>画矩形<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">value</span>=<span class="string">'circle'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span>&gt;</span>画圆<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"clear"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"清除"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"confirm"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"确定"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://webapi.amap.com/maps?v=1.4.15&amp;key=你的key&amp;plugin=AMap.MouseTool&amp;plugin=AMap.PolyEditor"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> map = <span class="keyword">new</span> AMap.Map(<span class="string">'container'</span>, &#123;</span></span><br><span class="line">            zoom: 13,</span><br><span class="line">            center: [110.255414, 20.009835],</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//自定义控件</span></span></span><br><span class="line"><span class="javascript">        AMap.plugin([<span class="string">'AMap.ToolBar'</span>, <span class="string">'AMap.Scale'</span>, <span class="string">'AMap.OverView'</span>, <span class="string">'AMap.MapType'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//map.addControl(new AMap.ToolBar());</span></span></span><br><span class="line"><span class="javascript">            map.addControl(<span class="keyword">new</span> AMap.Scale());</span></span><br><span class="line"><span class="javascript">            <span class="comment">//map.addControl(new AMap.OverView(&#123; isOpen: true &#125;));</span></span></span><br><span class="line"><span class="javascript">            map.addControl(<span class="keyword">new</span> AMap.MapType(&#123; <span class="attr">defaultType</span>: <span class="number">0</span> &#125;));</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> mouseTool = <span class="keyword">new</span> AMap.MouseTool(map);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//监听draw事件可获取画好的覆盖物</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> overlays = [];</span></span><br><span class="line"><span class="javascript">        <span class="comment">//结果集</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> result = &#123;</span></span><br><span class="line"><span class="javascript">            type: <span class="string">""</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                location: &#123; <span class="attr">lng</span>: <span class="string">""</span>, <span class="attr">lat</span>: <span class="string">""</span> &#125;, <span class="attr">path</span>: [],</span></span><br><span class="line"><span class="javascript">                bounds: &#123; <span class="attr">southwest</span>: &#123; <span class="attr">lng</span>: <span class="string">""</span>, <span class="attr">lat</span>: <span class="string">""</span> &#125;, <span class="attr">northeast</span>: &#123; <span class="attr">lng</span>: <span class="string">""</span>, <span class="attr">lat</span>: <span class="string">""</span> &#125;, &#125;,</span></span><br><span class="line"><span class="javascript">                circle: &#123; <span class="attr">center</span>: <span class="string">""</span>, <span class="attr">radius</span>: <span class="string">""</span> &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        mouseTool.on(<span class="string">'draw'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//清空覆盖物</span></span></span><br><span class="line">            map.remove(overlays);</span><br><span class="line">            overlays = [];</span><br><span class="line"><span class="javascript">            <span class="comment">//根据类型处理地图覆盖物</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> lnglat = [];<span class="comment">//单项目点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span> (e.obj.getExtData().type) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'marker'</span>: &#123;</span></span><br><span class="line">                    lnglat.push(e.obj.getPosition().lng);</span><br><span class="line">                    lnglat.push(e.obj.getPosition().lat);</span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"marker"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = lnglat;</span></span><br><span class="line">                    Geocoder(lnglat, e.obj.getExtData().type);</span><br><span class="line">                    overlays.push(e.obj);</span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'marker'</span>;</span></span><br><span class="line">                    result.data.location.lng = e.obj.getPosition().lng;</span><br><span class="line">                    result.data.location.lat = e.obj.getPosition().lat;</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'polyline'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = e.obj.getPath();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> tmp = [];</span></span><br><span class="line">                        tmp.push(data[i].lng);</span><br><span class="line">                        tmp.push(data[i].lat);</span><br><span class="line">                        lnglat.push(tmp);</span><br><span class="line">                        result.data.path.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'polyline'</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"polyline"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = lnglat;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> polyline = <span class="keyword">new</span> AMap.Polyline(&#123;</span></span><br><span class="line">                        path: data,</span><br><span class="line"><span class="javascript">                        isOutline: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                        outlineColor: <span class="string">'#ffeeff'</span>,</span></span><br><span class="line">                        borderWeight: 3,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">"#3366FF"</span>,</span></span><br><span class="line">                        strokeOpacity: 1,</span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line"><span class="javascript">                        <span class="comment">// 折线样式还支持 'dashed'</span></span></span><br><span class="line"><span class="javascript">                        strokeStyle: <span class="string">"solid"</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// strokeStyle是dashed时有效</span></span></span><br><span class="line">                        strokeDasharray: [10, 5],</span><br><span class="line"><span class="javascript">                        lineJoin: <span class="string">'round'</span>,</span></span><br><span class="line"><span class="javascript">                        lineCap: <span class="string">'round'</span>,</span></span><br><span class="line">                        zIndex: 50,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'polyline'</span> &#125;,</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    overlays.push(polyline);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    polyline.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">"AMap.PolyEditor"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> PolylineEditor = <span class="keyword">new</span> AMap.PolyEditor(map, polyline);</span></span><br><span class="line">                        overlays.push(PolylineEditor);</span><br><span class="line">                        PolylineEditor.open();</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定增加节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolylineEditor.on(<span class="string">'addnode'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定调整节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolylineEditor.on(<span class="string">'adjust'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定删除节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolylineEditor.on(<span class="string">'removenode'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'polygon'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = e.obj.getPath();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> tmp = [];</span></span><br><span class="line">                        tmp.push(data[i].lng);</span><br><span class="line">                        tmp.push(data[i].lat);</span><br><span class="line">                        lnglat.push(tmp);</span><br><span class="line">                        result.data.path.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'polygon'</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"polygon"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = lnglat;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> polygon = <span class="keyword">new</span> AMap.Polygon(&#123;</span></span><br><span class="line">                        path: data,</span><br><span class="line"><span class="javascript">                        isOutline: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                        outlineColor: <span class="string">'#ffeeff'</span>,</span></span><br><span class="line">                        borderWeight: 3,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">"#3366FF"</span>,</span></span><br><span class="line">                        strokeOpacity: 1,</span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line"><span class="javascript">                        <span class="comment">// 折线样式还支持 'dashed'</span></span></span><br><span class="line"><span class="javascript">                        strokeStyle: <span class="string">"solid"</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// strokeStyle是dashed时有效</span></span></span><br><span class="line">                        strokeDasharray: [10, 5],</span><br><span class="line"><span class="javascript">                        lineJoin: <span class="string">'round'</span>,</span></span><br><span class="line"><span class="javascript">                        lineCap: <span class="string">'round'</span>,</span></span><br><span class="line">                        zIndex: 50,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'polygon'</span> &#125;,</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    overlays.push(polygon);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    polygon.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">"AMap.PolyEditor"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> PolygonEditor = <span class="keyword">new</span> AMap.PolyEditor(map, polygon);</span></span><br><span class="line">                        overlays.push(PolygonEditor);</span><br><span class="line">                        PolygonEditor.open();</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定增加节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolygonEditor.on(<span class="string">'addnode'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定调整节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolygonEditor.on(<span class="string">'adjust'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定删除节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolygonEditor.on(<span class="string">'removenode'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'rectangle'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = e.obj.getBounds();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> southwestlng = data.southwest.lng;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> southwestlat = data.southwest.lat;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> northeastlng = data.northeast.lng;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> northeastlat = data.northeast.lat;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"rectangle"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">"southwest:["</span> + southwestlng + <span class="string">","</span> + southwestlat + <span class="string">"],northeast:["</span> + northeastlng + <span class="string">","</span> + northeastlat + <span class="string">"]"</span>;</span></span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'polygon'</span>;</span></span><br><span class="line">                    result.data.bounds.southwest.lng = southwestlng;</span><br><span class="line">                    result.data.bounds.southwest.lat = southwestlat;</span><br><span class="line">                    result.data.bounds.northeast.lng = northeastlng;</span><br><span class="line">                    result.data.bounds.northeast.lat = northeastlat;</span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//重新声明矩形对象</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> rectangle = <span class="keyword">new</span> AMap.Rectangle(&#123;</span></span><br><span class="line">                        bounds: data,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'red'</span>,</span></span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line">                        strokeOpacity: 0.5,</span><br><span class="line">                        strokeDasharray: [30, 10],</span><br><span class="line"><span class="javascript">                        <span class="comment">// strokeStyle还支持 solid</span></span></span><br><span class="line"><span class="javascript">                        strokeStyle: <span class="string">'dashed'</span>,</span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">'blue'</span>,</span></span><br><span class="line">                        fillOpacity: 0.5,</span><br><span class="line"><span class="javascript">                        cursor: <span class="string">'pointer'</span>,</span></span><br><span class="line">                        zIndex: 50,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'rectangle'</span> &#125;,</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    overlays.push(rectangle);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    rectangle.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">"AMap.RectangleEditor"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> RectangleEditor = <span class="keyword">new</span> AMap.RectangleEditor(map, rectangle);</span></span><br><span class="line">                        overlays.push(RectangleEditor);</span><br><span class="line">                        RectangleEditor.open();</span><br><span class="line"><span class="javascript">                        RectangleEditor.on(<span class="string">'adjust'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'circle'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> radius = e.obj.getRadius();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> center = e.obj.getCenter();</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"circle"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">"圆心："</span> + center + <span class="string">"半径："</span> + radius;</span></span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'circle'</span>;</span></span><br><span class="line">                    result.data.circle.center = center;</span><br><span class="line">                    result.data.circle.radius = radius;</span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> circle = <span class="keyword">new</span> AMap.Circle(&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">//map: mapObj,</span></span></span><br><span class="line">                        center: center,</span><br><span class="line">                        radius: radius,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">"#F33"</span>,</span></span><br><span class="line">                        strokeOpacity: 1,</span><br><span class="line">                        strokeWeight: 3,</span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">"ee2200"</span>,</span></span><br><span class="line">                        fillOpacity: 0.35,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'circle'</span> &#125;,</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    overlays.push(circle);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    circle.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">"AMap.CircleEditor"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> CircleEditor = <span class="keyword">new</span> AMap.CircleEditor(map, circle);</span></span><br><span class="line">                        overlays.push(CircleEditor);</span><br><span class="line">                        CircleEditor.open();</span><br><span class="line"><span class="javascript">                        CircleEditor.on(<span class="string">'move'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        CircleEditor.on(<span class="string">'adjust'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//绘制图形</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">type</span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">//清空上一次覆盖物</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//不是点需要先通过编辑工具关闭</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (overlays.length &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type != <span class="string">'marker'</span>) &#123;</span></span><br><span class="line">                    overlays[1].close();</span><br><span class="line">                &#125;</span><br><span class="line">                map.remove(overlays[0]);</span><br><span class="line">                overlays = [];</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"address"</span>).innerHTML = <span class="string">""</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (type == <span class="string">'marker'</span>)</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"location"</span>).style.display = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"location"</span>).style.display = <span class="string">"none"</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span> (type) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'marker'</span>: &#123;</span></span><br><span class="line">                    mouseTool.marker(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Marker的Option设置</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">//draggable: true,</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">//类型参数，用作区分</span></span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'marker'</span> &#125;,</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'polyline'</span>: &#123;</span></span><br><span class="line">                    mouseTool.polyline(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Polyline的Option设置</span></span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'#80d8ff'</span>,</span></span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'polyline'</span> &#125;,</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'polygon'</span>: &#123;</span></span><br><span class="line">                    mouseTool.polygon(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Polygon的Option设置</span></span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">'#00b0ff'</span>,</span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'#80d8ff'</span>,</span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'polygon'</span> &#125;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'rectangle'</span>: &#123;</span></span><br><span class="line">                    mouseTool.rectangle(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Polygon的Option设置</span></span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">'#00b0ff'</span>,</span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'#80d8ff'</span>,</span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'rectangle'</span> &#125;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'circle'</span>: &#123;</span></span><br><span class="line">                    mouseTool.circle(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Circle的Option设置</span></span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">'#00b0ff'</span>,</span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'#80d8ff'</span>,</span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'circle'</span> &#125;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> radios = <span class="built_in">document</span>.getElementsByName(<span class="string">'func'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; radios.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            radios[i].onchange = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line">                draw(e.target.value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">//默认画点</span></span></span><br><span class="line"><span class="javascript">        draw(<span class="string">'marker'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//逆地理编码</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Geocoder</span>(<span class="params">lnglat, type</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            AMap.plugin(<span class="string">'AMap.Geocoder'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> geocoder = <span class="keyword">new</span> AMap.Geocoder(&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// city 指定进行编码查询的城市，支持传入城市名、adcode 和 citycode</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// city: '010'</span></span></span><br><span class="line">                    radius: 1000,</span><br><span class="line"><span class="javascript">                    extensions: <span class="string">"all"</span></span></span><br><span class="line">                &#125;)</span><br><span class="line"><span class="javascript">                geocoder.getAddress(lnglat, <span class="function"><span class="keyword">function</span> (<span class="params">status, result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (status === <span class="string">'complete'</span> &amp;&amp; result.info === <span class="string">'OK'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// result为对应的地理位置详细信息</span></span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">"address"</span>).innerHTML = result.regeocode.formattedAddress;</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//编辑事件绑定方法，实时更新左上角数据</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">updateData</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type == <span class="string">"polyline"</span> || overlays[<span class="number">0</span>].getExtData().type == <span class="string">"polygon"</span>) &#123;</span></span><br><span class="line">                data = overlays[0].getPath();</span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> lnglat = [];</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> tmp = [];</span></span><br><span class="line">                    tmp.push(data[i].lng);</span><br><span class="line">                    tmp.push(data[i].lat);</span><br><span class="line">                    lnglat.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"polygon"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = lnglat;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type == <span class="string">"rectangle"</span>) &#123;</span></span><br><span class="line">                data = overlays[0].getBounds();</span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">"southwest:["</span> + data.southwest.lng + <span class="string">","</span> + data.southwest.lat</span></span><br><span class="line"><span class="javascript">                    + <span class="string">"],northeast:["</span> + data.northeast.lng + <span class="string">","</span> + data.northeast.lat + <span class="string">"]"</span>;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type == <span class="string">"circle"</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">"圆心："</span> + overlays[<span class="number">0</span>].getCenter() + <span class="string">"半径："</span> + overlays[<span class="number">0</span>].getRadius();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//清除</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'clear'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//不是点需要先关闭编辑工具</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (overlays.length &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type != <span class="string">'marker'</span>) &#123;</span></span><br><span class="line">                    overlays[1].close();</span><br><span class="line">                &#125;</span><br><span class="line">                map.remove(overlays[0]);</span><br><span class="line">                draw(overlays[0].getExtData().type);</span><br><span class="line">            &#125;</span><br><span class="line">            overlays = [];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">//确认，自定义保存结果</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'confirm'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="built_in">JSON</span>.stringify(result));</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(result));</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 地图 </category>
          
          <category> 高德地图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地图 </tag>
            
            <tag> 高德地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsplumb绘制流程图</title>
      <link href="/2019/11/06/JsPlumb%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
      <url>/2019/11/06/JsPlumb%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>背景：公司项目需要一个能绘制流程图的功能，能绘制能保存，并且能够将每个节点和表单数据关联起来。决定使用jsPlumb，然后在github查阅资料看到<a href="https://github.com/smile1828/demo-jsPlumb" target="_blank" rel="noopener">demo-jsPlumb</a>，在这个基础上进行了修改完善，一些细节方面也进行了优化，非常感谢 smile1828。</p><p>功能：</p><ul><li><p>按钮点击新增节点，或者拖拽新增节点</p><blockquote><p>项目上只需要用到一个图形，所以就做成新增按钮，需要多个节点拖动，html可以取消隐藏</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-body"</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-menu"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">h5</span>&gt;</span>节点类型列表<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"flow-btns"</span> <span class="attr">class</span>=<span class="string">"flow-btns"</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-btn btn-base"</span> <span class="attr">data-type</span>=<span class="string">"base"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-btn btn-flow"</span> <span class="attr">data-type</span>=<span class="string">"flow"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-btn btn-node"</span> <span class="attr">data-type</span>=<span class="string">"node"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-btn btn-judge"</span> <span class="attr">data-type</span>=<span class="string">"judge"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-container"</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-main"</span> <span class="attr">id</span>=<span class="string">"flow-main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20191106161400.png" alt="新增节点"></p></li><li><p>单击节点，右上角出现删除角标点击删除，也可以按delete删除</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20191106161444.png" alt="删除节点"></p></li><li><p>双击节点，可打开自定义窗口</p></li><li><p>节点支持连线</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20191106161630.png" alt="连线节点"></p></li><li><p>连线单击选中后，按delete删除</p></li><li><p>连线双击可以添加label</p></li><li><p>点击保存按钮，可以将流程图存为json数据通过ajax传给后端保存</p></li><li><p>对于已经存在数据的可以直接调用draw方法绘制</p></li><li><p>支持清空画布</p></li></ul><p>参考链接：</p><ul><li><a href="https://github.com/smile1828/demo-jsPlumb" target="_blank" rel="noopener">demo-jsPlumb</a></li><li><a href="https://www.cnblogs.com/xcj26/p/9870734.html" target="_blank" rel="noopener">jsplumb 中文教程</a></li><li><a href="https://blog.csdn.net/T_tq_bnsg_bs_ll/article/details/91380367" target="_blank" rel="noopener">jsPlumb应用指南（一）概念部分</a></li></ul><p>注：文件在<a href="https://github.com/fangchenyong/jsPlumb-Flowchart" target="_blank" rel="noopener">Github地址</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> Jsplumb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Jsplumb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript常用方法</title>
      <link href="/2019/10/29/JS%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/10/29/JS%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript常用方法"><a href="#JavaScript常用方法" class="headerlink" title="JavaScript常用方法"></a>JavaScript常用方法</h1><h2 id="1-将数值四舍五入-保留2位小数-后格式化成金额形式"><a href="#1-将数值四舍五入-保留2位小数-后格式化成金额形式" class="headerlink" title="1. 将数值四舍五入(保留2位小数)后格式化成金额形式"></a>1. 将数值四舍五入(保留2位小数)后格式化成金额形式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数值四舍五入(保留2位小数)后格式化成金额形式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param num 数值(Number或者String)</span></span><br><span class="line"><span class="comment"> * @return 金额格式的字符串,如'1,234,567.45'</span></span><br><span class="line"><span class="comment"> * @type String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatCurrency</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    num = num.toString().replace(<span class="regexp">/\$|\,/g</span>,<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(num))</span><br><span class="line">        num = <span class="string">"0"</span>;</span><br><span class="line">    sign = (num == (num = <span class="built_in">Math</span>.abs(num)));</span><br><span class="line">    num = <span class="built_in">Math</span>.floor(num*<span class="number">100</span>+<span class="number">0.50000000001</span>);</span><br><span class="line">    cents = num%<span class="number">100</span>;</span><br><span class="line">    num = <span class="built_in">Math</span>.floor(num/<span class="number">100</span>).toString();</span><br><span class="line">    <span class="keyword">if</span>(cents&lt;<span class="number">10</span>)</span><br><span class="line">    cents = <span class="string">"0"</span> + cents;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor((num.length-(<span class="number">1</span>+i))/<span class="number">3</span>); i++)</span><br><span class="line">    num = num.substring(<span class="number">0</span>,num.length-(<span class="number">4</span>*i+<span class="number">3</span>))+<span class="string">','</span>+</span><br><span class="line">    num.substring(num.length-(<span class="number">4</span>*i+<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> (((sign)?<span class="string">''</span>:<span class="string">'-'</span>) + num + <span class="string">'.'</span> + cents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-金额转大写"><a href="#2-金额转大写" class="headerlink" title="2. 金额转大写"></a>2. 金额转大写</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//金额转大写</span></span><br><span class="line"><span class="keyword">var</span> digitUppercase = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fraction = [<span class="string">'角'</span>, <span class="string">'分'</span>];</span><br><span class="line">    <span class="keyword">var</span> digit = [</span><br><span class="line">        <span class="string">'零'</span>, <span class="string">'壹'</span>, <span class="string">'贰'</span>, <span class="string">'叁'</span>, <span class="string">'肆'</span>,</span><br><span class="line">        <span class="string">'伍'</span>, <span class="string">'陆'</span>, <span class="string">'柒'</span>, <span class="string">'捌'</span>, <span class="string">'玖'</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">var</span> unit = [</span><br><span class="line">        [<span class="string">'元'</span>, <span class="string">'万'</span>, <span class="string">'亿'</span>],</span><br><span class="line">        [<span class="string">''</span>, <span class="string">'拾'</span>, <span class="string">'佰'</span>, <span class="string">'仟'</span>]</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">var</span> head = n &lt; <span class="number">0</span> ? <span class="string">'欠'</span> : <span class="string">''</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.abs(n);</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fraction.length; i++) &#123;</span><br><span class="line">        s += (digit[<span class="built_in">Math</span>.floor(n * <span class="number">10</span> * <span class="built_in">Math</span>.pow(<span class="number">10</span>, i)) % <span class="number">10</span>] + fraction[i]).replace(<span class="regexp">/零./</span>, <span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = s || <span class="string">'整'</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; unit[<span class="number">0</span>].length &amp;&amp; n &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; unit[<span class="number">1</span>].length &amp;&amp; n &gt; <span class="number">0</span>; j++) &#123;</span><br><span class="line">            p = digit[n % <span class="number">10</span>] + unit[<span class="number">1</span>][j] + p;</span><br><span class="line">            n = <span class="built_in">Math</span>.floor(n / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s = p.replace(<span class="regexp">/(零.)*零$/</span>, <span class="string">''</span>).replace(<span class="regexp">/^$/</span>, <span class="string">'零'</span>) + unit[<span class="number">0</span>][i] + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head + s.replace(<span class="regexp">/(零.)*零元/</span>, <span class="string">'元'</span>)</span><br><span class="line">        .replace(<span class="regexp">/(零.)+/g</span>, <span class="string">'零'</span>)</span><br><span class="line">        .replace(<span class="regexp">/^整$/</span>, <span class="string">'零元整'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-计算文件大小"><a href="#3-计算文件大小" class="headerlink" title="3. 计算文件大小"></a>3. 计算文件大小</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算文件大小函数(保留两位小数),Size为字节大小</span></span><br><span class="line"><span class="comment">// size：初始文件大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getfilesize</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1024.00</span>; <span class="comment">//byte</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; num)</span><br><span class="line">        <span class="keyword">return</span> size + <span class="string">"B"</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="built_in">Math</span>.pow(num, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> (size / num).toFixed(<span class="number">2</span>) + <span class="string">"K"</span>; <span class="comment">//kb</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="built_in">Math</span>.pow(num, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> (size / <span class="built_in">Math</span>.pow(num, <span class="number">2</span>)).toFixed(<span class="number">2</span>) + <span class="string">"M"</span>; <span class="comment">//M</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="built_in">Math</span>.pow(num, <span class="number">4</span>))</span><br><span class="line">        <span class="keyword">return</span> (size / <span class="built_in">Math</span>.pow(num, <span class="number">3</span>)).toFixed(<span class="number">2</span>) + <span class="string">"G"</span>; <span class="comment">//G</span></span><br><span class="line">    <span class="keyword">return</span> (size / <span class="built_in">Math</span>.pow(num, <span class="number">4</span>)).toFixed(<span class="number">2</span>) + <span class="string">"T"</span>; <span class="comment">//T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-获取输入框选中值"><a href="#4-获取输入框选中值" class="headerlink" title="4. 获取输入框选中值"></a>4. 获取输入框选中值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"dxs"</span> name=<span class="string">"name"</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"获取"</span>  onclick=<span class="string">"getSelectedText()"</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"><span class="keyword">var</span> inputDom =  <span class="built_in">document</span>.getElementById(<span class="string">"dxs"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.selection) <span class="comment">//IE</span></span><br><span class="line">    &#123; </span><br><span class="line">        alert(<span class="built_in">document</span>.selection.createRange().text); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        alert(inputDom.value.substring(inputDom.selectionStart,  </span><br><span class="line">                inputDom.selectionEnd));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><h2 id="5-判断对象是不是数组"><a href="#5-判断对象是不是数组" class="headerlink" title="5. 判断对象是不是数组"></a>5. 判断对象是不是数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[object Array]'</span> == <span class="built_in">Object</span>.prototype.toString.call(source);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-获取url根路径"><a href="#6-获取url根路径" class="headerlink" title="6. 获取url根路径"></a>6. 获取url根路径</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如  http://12.3.4.5/joey/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRootPath</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> strFullPath = <span class="built_in">window</span>.document.location.href;</span><br><span class="line">    <span class="keyword">var</span> strPath = <span class="built_in">window</span>.document.location.pathname;</span><br><span class="line">    <span class="keyword">var</span> pos = strFullPath.indexOf(strPath);</span><br><span class="line">    <span class="keyword">var</span> prePath = strFullPath.substring(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="keyword">var</span> postPath = strPath.substring(<span class="number">0</span>, strPath.substr(<span class="number">1</span>).indexOf(<span class="string">'/'</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (prePath + postPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-获取url指定参数"><a href="#7-获取url指定参数" class="headerlink" title="7. 获取url指定参数"></a>7. 获取url指定参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//strParame为参数名称,url为地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">strParame, url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> query = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (!url)</span><br><span class="line">        query = <span class="built_in">unescape</span>(location.search.substring(<span class="number">1</span>)); <span class="comment">// Get query string</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = url.indexOf(<span class="string">"?"</span>);</span><br><span class="line">        query = url.substring(index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pairs = query.split(<span class="string">"&amp;"</span>); <span class="comment">// Break at ampersand</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> pos = pairs[i].indexOf(<span class="string">'='</span>); <span class="comment">// Look for "name=value"</span></span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// If not found, skip</span></span><br><span class="line">        <span class="keyword">var</span> argname = pairs[i].substring(<span class="number">0</span>, pos); <span class="comment">// Extract the name</span></span><br><span class="line">        <span class="keyword">var</span> value = pairs[i].substring(pos + <span class="number">1</span>); <span class="comment">// Extract the value</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = <span class="built_in">decodeURIComponent</span>(value); <span class="comment">// Decode it, if needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">        args[argname] = value; <span class="comment">// Store as a property</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args[strParame]; <span class="comment">// Return the object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-创建GUID"><a href="#8-创建GUID" class="headerlink" title="8. 创建GUID"></a>8. 创建GUID</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//补了零的标准的guid格式（当然多了个“guid_”前缀,以及使用“_”代替“-”）。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateGUID</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">s4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor((<span class="number">1</span> + <span class="built_in">Math</span>.random()) * <span class="number">0x10000</span>)</span><br><span class="line">          .toString(<span class="number">16</span>)</span><br><span class="line">          .substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s4() + s4() + <span class="string">'-'</span> + s4() + <span class="string">'-'</span> + s4() + <span class="string">'-'</span> +</span><br><span class="line">      s4() + <span class="string">'-'</span> + s4() + s4() + s4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-判断一个值是否为空"><a href="#9-判断一个值是否为空" class="headerlink" title="9. 判断一个值是否为空"></a>9. 判断一个值是否为空</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsEmpty</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">"00000000-0000-0000-0000-000000000000"</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-设置cookie"><a href="#10-设置cookie" class="headerlink" title="10. 设置cookie"></a>10. 设置cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Days = <span class="number">300</span>; <span class="comment">//此 cookie 将被保存 30 天</span></span><br><span class="line">    <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>();    <span class="comment">//new Date("December 31, 9998");</span></span><br><span class="line">    exp.setTime(exp.getTime() + Days * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">"="</span> + <span class="built_in">escape</span>(value) + <span class="string">";expires="</span> + exp.toGMTString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-获取cookie"><a href="#11-获取cookie" class="headerlink" title="11. 获取cookie"></a>11. 获取cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="built_in">document</span>.cookie.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^| )"</span> + name + <span class="string">"=([^;]*)(;|$)"</span>));</span><br><span class="line">    <span class="keyword">if</span> (arr != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(arr[<span class="number">2</span>]); <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-删除cookie"><a href="#12-删除cookie" class="headerlink" title="12. 删除cookie"></a>12. 删除cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    exp.setTime(exp.getTime() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> cval = getCookie(name);</span><br><span class="line">    <span class="keyword">if</span> (cval != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">document</span>.cookie = name + <span class="string">"="</span> + cval + <span class="string">";expires="</span> + exp.toGMTString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-对象数组去重"><a href="#13-对象数组去重" class="headerlink" title="13. 对象数组去重"></a>13. 对象数组去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对connects进行去重，el.pageSourceId == element.pageSourceId是去重条件</span></span><br><span class="line"><span class="keyword">var</span> connects = connects.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!prev.find(<span class="function"><span class="params">el</span>=&gt;</span>(el.pageSourceId == element.pageSourceId))) &#123;</span><br><span class="line">        prev.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯地图坐标选取器</title>
      <link href="/2019/10/15/%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E6%8B%BE%E5%8F%96%E5%99%A8/"/>
      <url>/2019/10/15/%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E6%8B%BE%E5%8F%96%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="腾讯地图坐标选取器"><a href="#腾讯地图坐标选取器" class="headerlink" title="腾讯地图坐标选取器"></a>腾讯地图坐标选取器</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>项目地图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">src</span>=<span class="string">"http://map.qq.com/api/js?v=2.exp&amp;key=你的key"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://open.map.qq.com/apifiles/2/4/79/main.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/Scripts/plugins/jQuery/jquery-2.2.4.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/Scripts/plugins/bootstrap/bootstrap.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/App_Themes/Default/assets/plugins/bootstrap/css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .map-seach &#123;</span><br><span class="line">            background: #50a4ec;</span><br><span class="line">            padding: 5px 20px;</span><br><span class="line">            color: #fff;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line">            .map-seach:active &#123;</span><br><span class="line">                background: rgba(80, 164, 236, 0.4);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"toolbar"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-group"</span> <span class="attr">style</span>=<span class="string">"float: left;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font-style"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-pencil"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        &amp;nbsp;经度:</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"longitude"</span> <span class="attr">name</span>=<span class="string">"longitude"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-group"</span> <span class="attr">style</span>=<span class="string">"float: left"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font-style"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-pencil"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        &amp;nbsp;纬度:</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"latitude"</span> <span class="attr">name</span>=<span class="string">"latitude"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-group"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"font-style"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-map-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        &amp;nbsp;详细地址:</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"form-control box-wight"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mapseacrh"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"confirm"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">style</span>=<span class="string">"width:100%;height:500px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> lat=<span class="string">""</span>, lng=<span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> geocoder, citylocation, map, marker, label = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> center = <span class="keyword">new</span> qq.maps.LatLng(<span class="number">19.940433</span>, <span class="number">110.362473</span>);</span></span><br><span class="line"><span class="javascript">            map = <span class="keyword">new</span> qq.maps.Map(<span class="built_in">document</span>.getElementById(<span class="string">'container'</span>), &#123;</span></span><br><span class="line">                center: center,</span><br><span class="line">                zoom: 13</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            label = <span class="keyword">new</span> qq.maps.Label(&#123;</span></span><br><span class="line">                map: map,</span><br><span class="line"><span class="javascript">                offset: <span class="keyword">new</span> qq.maps.Size(<span class="number">15</span>, <span class="number">-12</span>),</span></span><br><span class="line"><span class="javascript">                draggable: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                clickable: <span class="literal">false</span></span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            geocoder = <span class="keyword">new</span> qq.maps.Geocoder(&#123;</span></span><br><span class="line"><span class="javascript">                complete: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">                    map.setCenter(result.detail.location);</span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> marker = <span class="keyword">new</span> qq.maps.Marker(&#123;</span></span><br><span class="line">                        map: map,</span><br><span class="line">                        position: result.detail.location</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            marker = <span class="keyword">new</span> qq.maps.Marker(&#123;</span></span><br><span class="line"><span class="javascript">                position: <span class="keyword">new</span> qq.maps.LatLng(lat, lng),</span></span><br><span class="line">                map: map</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="comment">//获取城市列表接口设置中心点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (lat == <span class="string">''</span> || lng == <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">                citylocation = <span class="keyword">new</span> qq.maps.CityService(&#123;</span></span><br><span class="line"><span class="javascript">                    complete: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">                        map.setCenter(result.detail.latLng);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="javascript">                <span class="comment">//调用searchLocalCity();方法    根据用户IP查询城市信息。</span></span></span><br><span class="line">                citylocation.searchLocalCity();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">//绑定单击事件添加参数</span></span></span><br><span class="line"><span class="javascript">            qq.maps.event.addListener(map, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                marker.setMap(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"longitude"</span>).value = event.latLng.getLng().toFixed(<span class="number">6</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"latitude"</span>).value = event.latLng.getLat().toFixed(<span class="number">6</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> url = <span class="built_in">encodeURI</span>(<span class="string">"https://apis.map.qq.com/ws/geocoder/v1/?location="</span> + event.latLng.getLat() + <span class="string">","</span> + event.latLng.getLng() + <span class="string">"&amp;key=你的key&amp;output=jsonp&amp;&amp;callback=?"</span>);</span></span><br><span class="line"><span class="javascript">                $.getJSON(url, <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (result.result != <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">"address"</span>).value = result.result.address;</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">"address"</span>).value = <span class="string">""</span>;</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line"><span class="javascript">                marker = <span class="keyword">new</span> qq.maps.Marker(&#123;</span></span><br><span class="line"><span class="javascript">                    position: <span class="keyword">new</span> qq.maps.LatLng(event.latLng.getLat(), event.latLng.getLng()),</span></span><br><span class="line">                    map: map</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">            qq.maps.event.addListener(map, <span class="string">"mousemove"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> latlng = e.latLng;</span></span><br><span class="line">                label.setPosition(latlng);</span><br><span class="line"><span class="javascript">                label.setContent(latlng.getLat().toFixed(<span class="number">6</span>) + <span class="string">","</span> + latlng.getLng().toFixed(<span class="number">6</span>));</span></span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">            geocoder = <span class="keyword">new</span> qq.maps.Geocoder(&#123;</span></span><br><span class="line"><span class="javascript">                complete: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    marker.setMap(<span class="literal">null</span>);</span></span><br><span class="line">                    map.setCenter(result.detail.location);</span><br><span class="line"><span class="javascript">                    marker = <span class="keyword">new</span> qq.maps.Marker(&#123;</span></span><br><span class="line">                        map: map,</span><br><span class="line">                        position: result.detail.location</span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"latitude"</span>).value = marker.position.lat;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"longitude"</span>).value = marker.position.lng;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">//查询按钮绑定事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#mapseacrh"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                geocoder.getLocation($(<span class="string">"#address"</span>).val());</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="comment">//输入框值变化绑定事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#address"</span>).bind(<span class="string">"input propertychange change"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                geocoder.getLocation($(<span class="string">"#address"</span>).val());</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="comment">//回车事件绑定事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#address"</span>).keypress(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (e.which == <span class="number">13</span>) geocoder.getLocation($(<span class="string">"#address"</span>).val());</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">//确定</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#confirm"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//关闭事件给上一个页面传参赋值自动关闭当前窗口</span></span></span><br><span class="line"><span class="javascript">                lng = <span class="built_in">document</span>.getElementById(<span class="string">"longitude"</span>).value;</span></span><br><span class="line"><span class="javascript">                lat = <span class="built_in">document</span>.getElementById(<span class="string">"latitude"</span>).value;</span></span><br><span class="line"><span class="javascript">                ComToolsCloseWindow(<span class="string">"ok"</span>, <span class="literal">null</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .font-style &#123;</span><br><span class="line">        /*background: #50a4ec;*/</span><br><span class="line">        display: inline-block;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">        padding: 1px 10px;</span><br><span class="line">        font-weight: 600;</span><br><span class="line">        color: #4f5155;</span><br><span class="line">    &#125;</span><br><span class="line">        .font-style span &#123;</span><br><span class="line">            float: right;</span><br><span class="line">        &#125;</span><br><span class="line">    .form-control &#123;</span><br><span class="line">        width: 120px;</span><br><span class="line">        float: right;</span><br><span class="line">    &#125;</span><br><span class="line">    .box-group &#123;</span><br><span class="line">        /*background: rgba(125, 180, 200, 0.53);*/</span><br><span class="line">        padding: 5px;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    #toolbar &#123;</span><br><span class="line">        padding: 10px 30px;</span><br><span class="line">        background: rgba(136, 195, 214, 0.89);</span><br><span class="line">    &#125;</span><br><span class="line">    .box-wight &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">    .btn-primary &#123;</span><br><span class="line">        width: 80px;</span><br><span class="line">        margin-left: 30px;</span><br><span class="line">        margin-top: 3px;</span><br><span class="line">        padding: 4px 10px;</span><br><span class="line">        background: #f2f1ed;</span><br><span class="line">        color: #4f5155;</span><br><span class="line">        border: 0px solid #87c0d1;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">        font-weight: 600;</span><br><span class="line">        letter-spacing: 2px;</span><br><span class="line">    &#125;</span><br><span class="line">        .btn-primary:hover &#123;</span><br><span class="line">            background: #ff9b08;</span><br><span class="line">            opacity: 0.8;</span><br><span class="line">        &#125;</span><br><span class="line">        .btn-primary:active &#123;</span><br><span class="line">            background: #ff9b08;</span><br><span class="line">            color: white;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 地图 </category>
          
          <category> 腾讯地图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地图 </tag>
            
            <tag> 腾讯地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8 String源码</title>
      <link href="/2019/09/06/JDK8-String/"/>
      <url>/2019/09/06/JDK8-String/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JDK8-String"><a href="#JDK8-String" class="headerlink" title="JDK8 String"></a>JDK8 String</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure><p>从上可以看出：</p><ul><li>String 是final类，不能被继承。</li><li>实现了java.io.Serializable接口，这个序列化接口没有任何方法和域，仅用于标识序列化的语意。</li><li>实现了Comparable<string>接口，这个接口只有一个compareTo(T 0)接口，用于对两个实例化对象比较大小。</string></li><li>实现了CharSequence接口，这个接口是一个只读的字符序列。包括length(), charAt(int index), subSequence(int start, int end)这几个API接口，值得一提的是，StringBuffer和StringBuild也是实现了该接口。</li></ul><h2 id="2-主要字段属性"><a href="#2-主要字段属性" class="headerlink" title="2.主要字段属性"></a>2.主要字段属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来存字符串，是一个final的char型数组，不可修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line"><span class="comment">//缓存字符串的哈希。而hash是String实例化的hashcode的一个缓存。因为String经常被用于比较，比如在HashMap中。如果每次进行比较都重新计算hashcode的值的话，那无疑是比较麻烦的，而保存一个hashcode的缓存无疑能优化这样的操作。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="comment">//实现序列化的标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields </span><br><span class="line">= <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//静态内部类，用于忽略大小写得比较两个字符串。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">= <span class="keyword">new</span> CaseInsensitiveComparator(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3.构造方法"></a>3.构造方法</h2><table><thead><tr><th>Constructor</th><th>Method</th></tr></thead><tbody><tr><td>String()</td><td>初始化新创建的 <code>String</code>对象，使其表示空字符序列。</td></tr><tr><td>String(byte[] bytes)</td><td>通过使用平台的默认字符集解码指定的字节数组来构造新的 <code>String</code> 。</td></tr><tr><td>String(byte[] bytes, Charset charset)</td><td>构造一个新的<code>String</code>由指定用指定的字节的数组解码charset 。</td></tr><tr><td>String(byte[] bytes, int offset, int length)</td><td>通过使用平台的默认字符集解码指定的字节子阵列来构造新的 <code>String</code> 。</td></tr><tr><td>String(byte[] bytes,  int offset, int length,Charset charset)</td><td>构造一个新的<code>String</code>通过使用指定的指定字节子阵列解码charset  。</td></tr><tr><td>String(byte[] bytes,  int offset, int length, String charsetName)</td><td>构造一个新的 <code>String</code>通过使用指定的字符集解码指定的字节子阵列。</td></tr><tr><td>String(byte[] bytes,  String charsetName)</td><td>构造一个新的<code>String</code>由指定用指定的字节的数组解码charset 。</td></tr><tr><td>String(char[] value)</td><td>分配一个新的 <code>String</code> ，以便它表示当前包含在字符数组参数中的字符序列。</td></tr><tr><td>String(char[] value,  int offset, int count)</td><td>分配一个新的 <code>String</code> ，其中包含字符数组参数的子阵列中的字符。</td></tr><tr><td>String(int[] codePoints,  int offset, int count)</td><td>分配一个新的 <code>String</code> ，其中包含 Unicode code  point数组参数的子阵列中的字符 。</td></tr><tr><td>String(String original)</td><td>初始化新创建的<code>String</code>对象，使其表示与参数相同的字符序列;  换句话说，新创建的字符串是参数字符串的副本。</td></tr><tr><td>String(StringBuffer buffer)</td><td>分配一个新的字符串，其中包含当前包含在字符串缓冲区参数中的字符序列。</td></tr><tr><td>String(StringBuilder builder)</td><td>分配一个新的字符串，其中包含当前包含在字符串构建器参数中的字符序列。</td></tr></tbody></table><h2 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4.常用方法"></a>4.常用方法</h2><ul><li><p><strong>长度和判空</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回的就是char数组的长度，中文是两个字节的，char也是两个字节的。String a="中文"，a的长度为2。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当char数组的长度为0，则代表String为""，是空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>charAt、codePointAt类函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//返回String对象的char数组index位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;   <span class="comment">//index不允许小于0，不允许大于等于String的长度</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回String对象的char数组index位置的元素的ASSIC码(int类型)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointAtImpl(value, index, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回index位置元素的前一个元素的ASSIC码(int型)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = index - <span class="number">1</span>;  <span class="comment">//获得index前一个元素的索引位置</span></span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= value.length)) &#123; <span class="comment">//所以，index不能等于0，因为i = 0 - 1 = -1</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointBeforeImpl(value, index, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法返回的是代码点个数，是实际上的字符个数,功能类似于length()</span></span><br><span class="line"><span class="comment">* 对于正常的String来说，length方法和codePointCount没有区别，都是返回字符个数。</span></span><br><span class="line"><span class="comment">* 但当String是Unicode类型时则有区别了。</span></span><br><span class="line"><span class="comment">* 例如：String str = “/uD835/uDD6B” (即使 'Z' ), length() = 2 ,codePointCount() = 1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span> || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 也是相对Unicode字符集而言的，从index索引位置算起，偏移codePointOffset个位置，返回偏移后的位置是多少</span></span><br><span class="line"><span class="comment">* 例如，index = 2 ，codePointOffset = 3 ，maybe返回 5 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.offsetByCodePointsImpl(value, <span class="number">0</span>, value.length,</span><br><span class="line">                                            index, codePointOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>getChars、getBytes类函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个不对外的方法，是给String内部调用的，因为它是没有访问修饰符的，只允许同一包下的类访问</span></span><br><span class="line"><span class="comment">* 参数：dst[]是目标数组，dstBegin是目标数组的偏移量，既要复制过去的起始位置(从目标数组的什么位置覆盖)</span></span><br><span class="line"><span class="comment">* 作用就是将String的字符数组value整个复制到dst字符数组中，在dst数组的dstBegin位置开始拷贝</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, dst, dstBegin, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 得到char字符数组，原理是getChars() 方法将一个字符串的字符复制到目标字符数组中。 </span></span><br><span class="line"><span class="comment">* 参数：srcBegin是原始字符串的起始位置，srcEnd是原始字符串要复制的字符末尾的后一个位置(既复制区域不包括srcEnd)</span></span><br><span class="line"><span class="comment">* dst[]是目标字符数组，dstBegin是目标字符的复制偏移量，复制的字符从目标字符数组的dstBegin位置开始覆盖。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;           <span class="comment">//如果srcBegin小于，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;  <span class="comment">//如果srcEnd大于字符串的长度，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;      <span class="comment">//如果原始字符串其实位置大于末尾位置，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得charsetName编码格式的bytes数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName)</span><br><span class="line">    <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(charsetName, value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与上个方法类似，java内部存储字符串使用的unicode编码，注意编码转换！！！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(Charset charset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(charset, value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用平台默认的编码格式获得bytes数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong></p><ul><li>getChars是没有返回值的 ，使用System.arraycopy()方法直接拷贝至目标数组中，并且目标数组有个@NotNull非空注解，否则会抛出java.lang.ArrayIndexOutOfBoundsException异常。</li><li>getBytes是由返回值的。</li></ul></li><li><p><strong>equals类函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String的equals方法，重写了Object的equals方法（区分大小写）</span></span><br><span class="line"><span class="comment">* 比较的是两个字符串的值是否相等</span></span><br><span class="line"><span class="comment">* 参数是一个Object对象，而不是一个String对象。这是因为重写的是Object的equals方法，所以是Object</span></span><br><span class="line"><span class="comment">* 如果是String自己独有的方法，则可以传入String对象，不用多此一举</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 实例：str1.equals(str2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;   <span class="comment">//首先判断形参str2是否跟当前对象str1是同一个对象，既比较地址是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;          <span class="comment">//如果地址相等，那么自然值也相等，毕竟是同一个字符串对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;  <span class="comment">//判断str2对象是否是一个String类型，过滤掉非String类型的比较</span></span><br><span class="line">        String anotherString = (String)anObject; <span class="comment">//如果是String类型，转换为String类型</span></span><br><span class="line">        <span class="keyword">int</span> n = value.length;                    <span class="comment">//获得当前对象str1的长度</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;   <span class="comment">//比较str1的长度和str2的长度是否相等</span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;  <span class="comment">//v1为当前对象str1的值，v2为参数对象str2的值</span></span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;                <span class="comment">//就类似于for的int i =0的作用，因为这里使用while</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;                <span class="comment">//每次循环长度-1,直到长度消耗完，循环结束 </span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])              <span class="comment">//同索引位置的字符元素逐一比较</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                <span class="comment">//只要有一个不相等，则返回false</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;                     <span class="comment">//如比较期间没有问题，则说明相等，返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这也是一个String的equals方法，与上一个方法不同，该方法(不区分大小写)，从名字也能看出来</span></span><br><span class="line"><span class="comment">* 是对String的equals方法的补充。</span></span><br><span class="line"><span class="comment">* 这里参数这是一个String对象，而不是Object了，因为这是String本身的方法，不是重写谁的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span>        <span class="comment">//一样，先判断是否为同一个对象</span></span><br><span class="line">        : (anotherString != <span class="keyword">null</span>) </span><br><span class="line">    &amp;&amp; (anotherString.value.length == value.length) <span class="comment">//再判断长度是否相等</span></span><br><span class="line">    &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);  <span class="comment">//再执行regionMatchs方法 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个公有的比较方法，参数是StringBuffer类型</span></span><br><span class="line"><span class="comment">* 实际调用的是contentEquals(CharSequence cs)方法，可以说是StringBuffer的特供版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contentEquals((CharSequence)sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个私有方法，特供给比较StringBuffer和StringBuilder使用的。</span></span><br><span class="line"><span class="comment">* 比如在contentEquals方法中使用，参数是AbstractStringBuilder抽象类的子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonSyncContentEquals</span><span class="params">(AbstractStringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;               <span class="comment">//当前String对象的值</span></span><br><span class="line">    <span class="keyword">char</span> v2[] = sb.getValue();       <span class="comment">//AbstractStringBuilder子类对象的值</span></span><br><span class="line">    <span class="keyword">int</span> n = v1.length;         <span class="comment">//后面就不说了，其实跟equals方法是一样的，只是少了一些判断</span></span><br><span class="line">    <span class="keyword">if</span> (n != sb.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != v2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个常用于String对象跟StringBuffer和StringBuilder比较的方法</span></span><br><span class="line"><span class="comment">* 参数是StringBuffer或StringBuilder或String或CharSequence</span></span><br><span class="line"><span class="comment">* StringBuffer和StringBuilder和String都实现了CharSequence接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Argument is a StringBuffer, StringBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> AbstractStringBuilder) &#123;   <span class="comment">//如果是AbstractStringBuilder抽象类或其子类</span></span><br><span class="line">        <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> StringBuffer) &#123;        <span class="comment">//如果是StringBuffer类型，进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span>(cs) &#123;</span><br><span class="line">                <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">//如果是StringBuilder类型，则进入非同步块</span></span><br><span class="line">            <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***下面就是String和CharSequence类型的比较算法*****/</span></span><br><span class="line">    <span class="comment">// Argument is a String</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> String) &#123;                    </span><br><span class="line">        <span class="keyword">return</span> equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a generic CharSequence</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">int</span> n = v1.length;</span><br><span class="line">    <span class="keyword">if</span> (n != cs.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != cs.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong></p><ul><li>equals()方法怎么重写Object中的equals()实现对String内容的判断</li><li>equalsIgnoreCase()方法是对equals()方法补充，不区分大小写的判断，是String类自己的方法</li><li>contentEquals()则是用于String对象与4种类型的判断，通常用于跟StringBuilder和StringBuffer的判断,也是对equals方法的一个补充，如果是参数是String类型，就调用equals()方法</li></ul></li><li><p><strong>regionMatchs()方法</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个类似于equals的方法，比较的是字符串的片段，也即是部分区域的比较</span></span><br><span class="line"><span class="comment">* toffset是当前字符串的比较起始位置(偏移量),other是要比较的String对象参数，ooffset是要参数String的比较片段起始位置，len是两个字符串要比较的片段的长度大小</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 例子：String str1 = "0123456",Str2 = "0123456789"; </span></span><br><span class="line"><span class="comment">* str1.regionMatchs(0,str2,0,6);意思是str1从0位置开始于str2的0位置开始比较6个长度的字符串片段</span></span><br><span class="line"><span class="comment">* 相等则返回 true,不等返回false </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;  <span class="comment">//当前对象的值</span></span><br><span class="line">    <span class="keyword">int</span> to = toffset;   <span class="comment">//当前对象的比较片段的起始位置，既偏移量</span></span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;  <span class="comment">//参数，既比较字符串的值</span></span><br><span class="line">    <span class="keyword">int</span> po = ooffset;         <span class="comment">//比较字符串的起始位置</span></span><br><span class="line">    <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)  <span class="comment">//起始位置不小于0或起始位置不大于字符串长度 - 片段长度，大于就截取不到这么长的片段了</span></span><br><span class="line">        || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">        || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;      <span class="comment">//惊讶脸，居然不是抛异常，而是返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;               <span class="comment">//使用while循环，当然也可以使for循环</span></span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;   <span class="comment">//片段区域的字符元素逐个比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这个跟上面的方法一样，只不过多了一个参数，既ignoreCase,既是否为区分大小写。</span></span><br><span class="line"><span class="comment">* 是equalsIgnoreCase()方法的片段比较版本，实际上equalsIgnoreCase()也是调用regionMatches函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                             String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">    <span class="keyword">int</span> po = ooffset;</span><br><span class="line">    <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">        || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">        || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面的解释同上</span></span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">        <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ignoreCase) &#123;   <span class="comment">//当ignoreCase为true时，既忽视大小写时</span></span><br><span class="line">            <span class="comment">// If characters don't match but case may be ignored,</span></span><br><span class="line">            <span class="comment">// try converting both characters to uppercase.</span></span><br><span class="line">            <span class="comment">// If the results match, then the comparison scan should</span></span><br><span class="line">            <span class="comment">// continue.</span></span><br><span class="line">            <span class="keyword">char</span> u1 = Character.toUpperCase(c1);   <span class="comment">//片段中每个字符转换为大写</span></span><br><span class="line">            <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">            <span class="keyword">if</span> (u1 == u2) &#123; <span class="comment">//大写比较一次，如果相等则不执行下面的语句，进入下一个循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Unfortunately, conversion to uppercase does not work properly</span></span><br><span class="line">            <span class="comment">// for the Georgian alphabet, which has strange rules about case</span></span><br><span class="line">            <span class="comment">// conversion.  So we need to make one last check before</span></span><br><span class="line">            <span class="comment">// exiting.</span></span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                <span class="comment">//每个字符换行成小写比较一次</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>从上可以看出：</strong></p><ul><li>片段比较时针对的是String对象。所以如果要跟StringBuffer和StringBuilder比较，那么要toString。</li><li>两个字符串之间的片段比较，使用regionMatches，完整的比较，使用equals。</li></ul></li><li><p><strong>compareTo类函数和CaseInsensitiveComparator静态内部类</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个比较字符串中字符大小的函数，因为String实现了Comparable&lt;String&gt;接口，所以重写了compareTo方法</span></span><br><span class="line"><span class="comment">* Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。</span></span><br><span class="line"><span class="comment">* 实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 参数是需要比较的另一个String对象</span></span><br><span class="line"><span class="comment">* 返回的int类型，正数为大，负数为小，是基于字符的ASSIC码比较的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;                  <span class="comment">//当前对象的长度</span></span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;    <span class="comment">//比较对象的长度</span></span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);           <span class="comment">//获得最小长度</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;                        <span class="comment">//获得当前对象的值</span></span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;          <span class="comment">//获得比较对象的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;                    <span class="comment">//相当于for的int k = 0,就是为while循环的数组服务的</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;             <span class="comment">//当当前索引小于两个字符串中较短字符串的长度时，循环继续</span></span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];          <span class="comment">//获得当前对象的字符</span></span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];          <span class="comment">//获得比较对象的字符</span></span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;    <span class="comment">//从前向后遍历，只要其实一个不相等，返回字符ASSIC的差值,int类型</span></span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;   <span class="comment">//如果两个字符串同样位置的索引都相等，返回长度差值，完全相等则为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  这时一个类似compareTo功能的方法，但是不是comparable接口的方法，是String本身的方法</span></span><br><span class="line"><span class="comment">*  使用途径，我目前只知道可以用来不区分大小写的比较大小，但是不知道如何让它被工具类Collections和Arrays运用</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CASE_INSENSITIVE_ORDER.compare(<span class="keyword">this</span>, str);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个饿汉单例模式，是String类型的一个不区分大小写的比较器</span></span><br><span class="line"><span class="comment">* 提供给Collections和Arrays的sort方法使用</span></span><br><span class="line"><span class="comment">* 例如：Arrays.sort(strs,String.CASE_INSENSITIVE_ORDER);</span></span><br><span class="line"><span class="comment">* 效果就是会将strs字符串数组中的字符串对象进行忽视大小写的排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">                                         = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这一个私有的静态内部类，只允许String类本身调用</span></span><br><span class="line"><span class="comment">* 实现了序列化接口和比较器接口，comparable接口和comparator是有区别的</span></span><br><span class="line"><span class="comment">* 重写了compare方法，该静态内部类实际就是一个String类的比较器</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveComparator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8575799808933029326L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length();                 <span class="comment">//s1字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> n2 = s2.length();                 <span class="comment">//s2字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> min = Math.min(n1, n2);           <span class="comment">//获得最小长度 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s1.charAt(i);           <span class="comment">//逐一获得字符串i位置的字符</span></span><br><span class="line">            <span class="keyword">char</span> c2 = s2.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;                   <span class="comment">//部分大小写比较一次</span></span><br><span class="line">                c1 = Character.toUpperCase(c1);    <span class="comment">//转换大写比较一次</span></span><br><span class="line">                c2 = Character.toUpperCase(c2);</span><br><span class="line">                <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                    c1 = Character.toLowerCase(c1);  <span class="comment">//转换小写比较一次</span></span><br><span class="line">                    c2 = Character.toLowerCase(c2);</span><br><span class="line">                    <span class="keyword">if</span> (c1 != c2) &#123;                  <span class="comment">//返回字符差值</span></span><br><span class="line">                        <span class="comment">// No overflow because of numeric promotion</span></span><br><span class="line">                        <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;<span class="comment">//如果字符相等，但长度不等，则返回长度差值，短的教小，所以小-大为负数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Replaces the de-serialized object. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CASE_INSENSITIVE_ORDER; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上的代码可以看出：</p><p>  以上的最大问题可以能就是为什么要有个静态内部类，为什么实现了compareTo又有compare，移步到下面，有解答</p><p>  String实现了comparable接口，重写了compareTo方法，可以用于自己写类进行判断排序，也可以使用collections，Arrays工具类的sort进行排序。只有集合或数组中的元素实现了comparable接口，并重写了compareTo才能使用工具类排序。</p><p>  CASE_INSENSITIVE_ORDER是一个单例，是String提供为外部的比较器，该比较器的作用是忽视大小写进行比较，我们可以通过Collections或Arrays的sort方法将CASE_INSENSITIVE_ORDER比较器作为参数传入，进行排序。</p></li><li><p><strong>startWith、endWith类函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 作用就是当前对象[toffset,toffset + prefix.value.lenght]区间的字符串片段等于prefix</span></span><br><span class="line"><span class="comment">* 也可以说当前对象的toffset位置开始是否以prefix作为前缀</span></span><br><span class="line"><span class="comment">* prefix是需要判断的前缀字符串，toffset是当前对象的判断起始位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;     <span class="comment">//获得当前对象的值</span></span><br><span class="line">    <span class="keyword">int</span> to = toffset;      <span class="comment">//获得需要判断的起始位置，偏移量</span></span><br><span class="line">    <span class="keyword">char</span> pa[] = prefix.value; <span class="comment">//获得前缀字符串的值</span></span><br><span class="line">    <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">    <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;  <span class="comment">//偏移量不能小于0且能截取pc个长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//不能则返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;                  <span class="comment">//循环pc次，既prefix的长度</span></span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;      <span class="comment">//每次比较当前对象的字符串的字符是否跟prefix一样</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;                <span class="comment">//一样则pc--,to++,po++,有一个不同则返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//没有不一样则返回true，当前对象是以prefix在toffset位置做为开头</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断当前字符串对象是否以字符串prefix起头</span></span><br><span class="line"><span class="comment">* 是返回true,否返回fasle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startsWith(prefix, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断当前字符串对象是否以字符串prefix结尾</span></span><br><span class="line"><span class="comment">* 是返回true,否返回fasle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//suffix是需要判断是否为尾部的字符串。</span></span><br><span class="line">    <span class="comment">//value.length - suffix.value.length是suffix在当前对象的起始位置</span></span><br><span class="line">    <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>所以我们知道：</strong></p><ul><li>endsWith的实现也是startWith()，作用就是判断前后缀</li></ul></li><li><p><strong>hashCode()函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这是String字符串重写了Object类的hashCode方法。</span></span><br><span class="line"><span class="comment">   * 给由哈希表来实现的数据结构来使用，比如String对象要放入HashMap中。</span></span><br><span class="line"><span class="comment">   * 如果没有重写HashCode，或HaseCode质量很差则会导致严重的后果，既不靠谱的后果</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;  <span class="comment">//hash是属性字段，是成员变量，所以默认为0</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123; <span class="comment">//如果hash为0，且字符串对象长度大于0，不为""</span></span><br><span class="line">        <span class="keyword">char</span> val[] = value;   <span class="comment">//获得当前对象的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重点，String的哈希函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;  <span class="comment">//遍历len次</span></span><br><span class="line">            h = <span class="number">31</span> * h + val[i]; <span class="comment">//每次都是31 * 每次循环获得的h +第i个字符的ASSIC码</span></span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;  <span class="comment">//由此可见""空字符对象的哈希值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>所以我们可以知道：</strong></p><ul><li>hashCode的重点就是哈希函数</li><li>String的哈希函数就是循环len次，每次循环体为 <code>31 * 每次循环获得的hash + 第i次循环的字符</code></li></ul></li><li><p>indexOf、lastIndexOf类函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回cn对应的字符在字符串中第一次出现的位置，从字符串的索引0位置开始遍历</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(ch, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * index方法就是返回ch字符第一次在字符串中出现的位置</span></span><br><span class="line"><span class="comment"> * 既从fromIndex位置开始查找，从头向尾遍历，ch整数对应的字符在字符串中第一次出现的位置</span></span><br><span class="line"><span class="comment"> * -1代表字符串没有这个字符，整数代表字符第一次出现在字符串的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> max = value.length; <span class="comment">//获得字符串对象的长度</span></span><br><span class="line">       <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;             <span class="comment">//如果偏移量小于0，则代表偏移量为0，校正偏移量</span></span><br><span class="line">           fromIndex = <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromIndex &gt;= max) &#123;   <span class="comment">//如果偏移量大于最大长度，则返回-1，代表没有字符串没有ch对应的字符</span></span><br><span class="line">           <span class="comment">// Note: fromIndex might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; <span class="comment">//emmm,这个判断，不懂</span></span><br><span class="line">           <span class="comment">// handle most cases here (ch is a BMP code point or a</span></span><br><span class="line">           <span class="comment">// negative value (invalid code point))</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;             <span class="comment">//获得字符串值</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;      <span class="comment">//从fromIndex位置开始向后遍历</span></span><br><span class="line">               <span class="keyword">if</span> (value[i] == ch) &#123;                    <span class="comment">//只有字符串中的某个位置的元素等于ch</span></span><br><span class="line">                   <span class="keyword">return</span> i;                            <span class="comment">//返回对应的位置，函数结束，既第一次出现的位置</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果没有出现，则返回-1</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> indexOfSupplementary(ch, fromIndex);  <span class="comment">//emmm,紧紧接着没看懂的地方</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Character.isValidCodePoint(ch)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span> hi = Character.highSurrogate(ch);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span> lo = Character.lowSurrogate(ch);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> max = value.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="number">1</span>] == lo) &#123;</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从尾部向头部遍历，返回cn第一次出现的位置，value.length - 1就是起点 </span></span><br><span class="line"><span class="comment">* 为了理解，我们可以认为是返回cn对应的字符在字符串中最后出现的位置</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">* ch是字符对应的整数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(ch, value.length - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从尾部向头部遍历，从fromIndex开始作为起点，返回ch对应字符第一次在字符串出现的位置</span></span><br><span class="line"><span class="comment">* 既从头向尾遍历，返回cn对应字符在字符串中最后出现的一次位置，fromIndex为结束点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;  <span class="comment">//之后不解释了,emmmmmmm</span></span><br><span class="line">           <span class="comment">// handle most cases here (ch is a BMP code point or a</span></span><br><span class="line">           <span class="comment">// negative value (invalid code point))</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="comment">//取最小值，作用就是校正，如果fromIndex传大了，就当时len - 1</span></span><br><span class="line">           <span class="keyword">int</span> i = Math.min(fromIndex, value.length - <span class="number">1</span>);   </span><br><span class="line">           <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;      <span class="comment">//算法中是从后向前遍历，直到i&lt;0,退出循环</span></span><br><span class="line">               <span class="keyword">if</span> (value[i] == ch) &#123;  <span class="comment">//只有有相等，返回对应的索引位置</span></span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;   <span class="comment">//没有找到则返回-1</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> lastIndexOfSupplementary(ch, fromIndex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lastIndexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Character.isValidCodePoint(ch)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="keyword">char</span> hi = Character.highSurrogate(ch);</span><br><span class="line">           <span class="keyword">char</span> lo = Character.lowSurrogate(ch);</span><br><span class="line">           <span class="keyword">int</span> i = Math.min(fromIndex, value.length - <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="number">1</span>] == lo) &#123;</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回第一次出现的字符串的位置</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 从fromIndex开始遍历，返回第一次出现str字符串的位置</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">               str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个不对外公开的静态函数</span></span><br><span class="line"><span class="comment">* source就是原始字符串，sourceOffset就是原始字符串的偏移量，起始位置。</span></span><br><span class="line"><span class="comment">* sourceCount就是原始字符串的长度，target就是要查找的字符串。</span></span><br><span class="line"><span class="comment">* fromIndex就是从原始字符串的第fromIndex开始遍历</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           String target, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(source, sourceOffset, sourceCount,</span><br><span class="line">                      target.value, <span class="number">0</span>, target.value.length,</span><br><span class="line">                      fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 同是一个不对外公开的静态函数</span></span><br><span class="line"><span class="comment">* 比上更为强大。</span></span><br><span class="line"><span class="comment">* 多了一个targetOffset和targetCount，既代表别查找的字符串也可以被切割</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;   <span class="comment">//如果查找的起点大于当前对象的大小</span></span><br><span class="line">        <span class="comment">//如果目标字符串的长度为0，则代表目标字符串为""，""在任何字符串都会出现</span></span><br><span class="line">        <span class="comment">//配合fromIndex &gt;= sourceCount,所以校正第一次出现在最尾部，仅仅是校正作用</span></span><br><span class="line">           <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>); </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;  <span class="comment">//也是校正，如果起始点小于0，则返回0</span></span><br><span class="line">           fromIndex = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果目标字符串长度为0，代表为""，则第一次出现在遍历起始点fromIndex</span></span><br><span class="line">       <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123; </span><br><span class="line">           <span class="keyword">return</span> fromIndex;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">char</span> first = target[targetOffset];   <span class="comment">//目标字符串的第一个字符</span></span><br><span class="line">       <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount); <span class="comment">//最大遍历次数</span></span><br><span class="line">    </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">           <span class="comment">/* Look for first character. */</span></span><br><span class="line">           <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">               <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">           &#125;</span><br><span class="line">    </span><br><span class="line">           <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">           <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">               <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                       == target[k]; j++, k++);</span><br><span class="line">    </span><br><span class="line">               <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                   <span class="comment">/* Found whole string. */</span></span><br><span class="line">                   <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查找字符串Str最后一次出现的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(str, value.length);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">               str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           String target, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(source, sourceOffset, sourceCount,</span><br><span class="line">                      target.value, <span class="number">0</span>, target.value.length,</span><br><span class="line">                      fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Check arguments; return immediately where possible. For</span></span><br><span class="line"><span class="comment">        * consistency, don't check for null str.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> rightIndex = sourceCount - targetCount;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &gt; rightIndex) &#123;</span><br><span class="line">           fromIndex = rightIndex;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* Empty string always matches. */</span></span><br><span class="line">       <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> fromIndex;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">int</span> strLastIndex = targetOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">char</span> strLastChar = target[strLastIndex];</span><br><span class="line">       <span class="keyword">int</span> min = sourceOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> i = min + fromIndex;</span><br><span class="line">    </span><br><span class="line">   startSearchForLastChar:</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">while</span> (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</span><br><span class="line">               i--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (i &lt; min) &#123;</span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> start = j - (targetCount - <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">int</span> k = strLastIndex - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">           <span class="keyword">while</span> (j &gt; start) &#123;</span><br><span class="line">               <span class="keyword">if</span> (source[j--] != target[k--]) &#123;</span><br><span class="line">                   i--;</span><br><span class="line">                   <span class="keyword">continue</span> startSearchForLastChar;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> start - sourceOffset + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  <strong>从上可以看出：</strong></p><ul><li>只对外提供了int整形，String字符串两种参数的重载方法(虽然是Int型，其实我们就当做是传char也无所谓，因为虚拟机会帮我们解决这个事情的)</li></ul></li><li><p>substring()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  截取当前字符串对象的片段，组成一个新的字符串对象</span></span><br><span class="line"><span class="comment">*  beginIndex为截取的初始位置，默认截到len - 1位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;   <span class="comment">//小于0抛异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> subLen = value.length - beginIndex;  <span class="comment">//新字符串的长度</span></span><br><span class="line">       <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;       <span class="comment">//小于0抛异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果beginIndex是0，则不用截取，返回自己(非新对象)，否则截取0到subLen位置，不包括(subLen)</span></span><br><span class="line">       <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 截取一个区间范围</span></span><br><span class="line"><span class="comment">* [beginIndex,endIndex)，不包括endIndex</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">       <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">               : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.substring(beginIndex, endIndex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  <strong>从上面可以看到：</strong></p><ul><li>substring函数是一个不完全闭包的区间，是[beginIndex,end)，不包括end位置</li><li><strong>subString的原理是通过String的构造函数实现的</strong></li></ul></li><li><p>concat()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String的拼接函数</span></span><br><span class="line"><span class="comment">* 例如:String  str = "abc"; str.concat("def")    output: "abcdef"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();<span class="comment">//获得参数字符串的长度</span></span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123; <span class="comment">//如果长度为0，则代表不需要拼接，因为str为""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****重点****/</span></span><br><span class="line">    <span class="keyword">int</span> len = value.length;  <span class="comment">//获得当前对象的长度 </span></span><br><span class="line">    <span class="comment">//将数组扩容，将value数组拷贝到buf数组中，长度为len + str.lenght</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen); </span><br><span class="line">    str.getChars(buf, len); <span class="comment">//然后将str字符串从buf字符数组的len位置开始覆盖，得到一个完整的buf字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);<span class="comment">//构建新的String对象，调用私有的String构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>replace、replaceAll类函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换，将字符串中的oldChar字符全部替换成newChar</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;    <span class="comment">//如果旧字符不等于新字符的情况下</span></span><br><span class="line">        <span class="keyword">int</span> len = value.length;  <span class="comment">//获得字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;              <span class="comment">//flag</span></span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;      <span class="comment">//循环len次</span></span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123; <span class="comment">//找到第一个旧字符，打断循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;   <span class="comment">//如果第一个旧字符的位置小于len</span></span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len]; 新<span class="keyword">new</span>一个字符数组，len个长度</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    buf[j] = val[j];        把旧字符的前面的字符都复制到新字符数组上</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;           <span class="comment">//从i位置开始遍历</span></span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c; <span class="comment">//发生旧字符就替换，不想关的则直接复制</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);  <span class="comment">//通过新字符数组buf重构一个新String对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">//如果old = new ，直接返回自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换第一个旧字符</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceFirst(replacement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不是正规表达式时，与replace效果一样，都是全体换。如果字符串的正则表达式，则规矩表达式全体替换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用旧字符串去替换新字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(</span><br><span class="line">        <span class="keyword">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>从replace的算法中，我们可以发现，它不是从头开始遍历替换的，而是首先找到第一个要替换的字符，从要替换的字符开始遍历，发现一个替换一个。四种用法，字符全替换字符，表达式全体换字符，表达式只替换第一个字符，字符串替换字符串</code></pre><ul><li><p>matches()和contains()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* matches() 方法用于检测字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="comment">* regex -- 匹配字符串的正则表达式。</span></span><br><span class="line"><span class="comment">* 如：String Str = new String("www.snailmann.com");</span></span><br><span class="line"><span class="comment">* System.out.println(Str.matches("(.*)snailmann(.*)"));   output:true</span></span><br><span class="line"><span class="comment">* System.out.println(Str.matches("www(.*)"));             output:true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Pattern.matches(regex, <span class="keyword">this</span>);   <span class="comment">//实际使用的是Pattern.matches()方法</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//是否含有CharSequence这个子类元素，通常用于StrngBuffer,StringBuilder</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(s.toString()) &gt; -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>split()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">       <span class="comment">/* fastpath if the regex is a</span></span><br><span class="line"><span class="comment">        (1)one-char String and this character is not one of the</span></span><br><span class="line"><span class="comment">           RegEx's meta characters ".$|()[&#123;^?*+\\", or</span></span><br><span class="line"><span class="comment">        (2)two-char String and the first char is the backslash and</span></span><br><span class="line"><span class="comment">           the second is not the ascii digit or ascii letter.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">            (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">             regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">             (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">           (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">            ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</span><br><span class="line">           ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</span><br><span class="line">                   list.add(substring(off, next));</span><br><span class="line">                   off = next + <span class="number">1</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></span><br><span class="line">                   <span class="comment">//assert (list.size() == limit - 1);</span></span><br><span class="line">                   list.add(substring(off, value.length));</span><br><span class="line">                   off = value.length;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// If no match was found, return this</span></span><br><span class="line">           <span class="keyword">if</span> (off == <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line">    </span><br><span class="line">           <span class="comment">// Add remaining segment</span></span><br><span class="line">           <span class="keyword">if</span> (!limited || list.size() &lt; limit)</span><br><span class="line">               list.add(substring(off, value.length));</span><br><span class="line">    </span><br><span class="line">           <span class="comment">// Construct result</span></span><br><span class="line">           <span class="keyword">int</span> resultSize = list.size();</span><br><span class="line">           <span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line">                   resultSize--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line">           <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> String[] split(String regex) &#123;</span><br><span class="line">       <span class="keyword">return</span> split(regex, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>join()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* join方法是JDK1.8加入的新函数，静态方法</span></span><br><span class="line"><span class="comment">* 这个方法就是跟split有些对立的函数,不过join是静态方法</span></span><br><span class="line"><span class="comment">* delimiter就是分割符，后面就是要追加的可变参数，比如str1,str2,str3</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 例子：String.join(",",new String("a"),new String("b"),new String("c"))</span></span><br><span class="line"><span class="comment">* output: "a,b,c"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(delimiter);  <span class="comment">//就是检测是否为Null,是null,抛异常</span></span><br><span class="line">      Objects.requireNonNull(elements);   <span class="comment">//不是就返回自己，即nothing happen</span></span><br><span class="line">      <span class="comment">// Number of elements not likely worth Arrays.stream overhead.</span></span><br><span class="line">      StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);  <span class="comment">//嗯，有兴趣自己看StringJoiner类源码啦</span></span><br><span class="line">      <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">          joiner.add(cs);   <span class="comment">//既用分割符delimiter将所有可变参数的字符串分割，合并成一个字符串</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> joiner.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能是一样的，不过传入的参数不同</span></span><br><span class="line"><span class="comment"> * 这里第二个参数一般就是装着CharSequence子类的集合</span></span><br><span class="line"><span class="comment"> * 比如String.join(",",lists)   </span></span><br><span class="line"><span class="comment"> * list可以是一个Collection接口实现类，所含元素的基类必须是CharSequence类型</span></span><br><span class="line"><span class="comment"> * 比如String,StringBuilder,StringBuffer等</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter,</span></span></span><br><span class="line"><span class="function"><span class="params">          Iterable&lt;? extends CharSequence&gt; elements)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(delimiter);</span><br><span class="line">      Objects.requireNonNull(elements);</span><br><span class="line">      StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);</span><br><span class="line">      <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">          joiner.add(cs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> joiner.toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>Java 1.8加入的新功能，有点跟split对立的意思，是个静态方法</li><li>有两个重载方法，一个是直接传字符串数组，另个是传集合。传集合的方式是一个好功能，很方遍将集合的字符串元素拼接成一个字符串。(分割符为 <code>&quot;&quot;</code> ,well, It’s great!!)</li></ul></li><li><p>trim()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 去除字符串首尾部分的空值，如,' ' or " ",非""</span></span><br><span class="line"><span class="comment">* 原理是通过substring去实现的，首尾各一个指针</span></span><br><span class="line"><span class="comment">* 头指针发现空值就++，尾指针发现空值就--</span></span><br><span class="line"><span class="comment">* ' '的Int值为32，其实不仅仅是去空的作用，应该是整数值小于等于32的去除掉</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = value.length; <span class="comment">//代表尾指针，实际是尾指针+1的大小</span></span><br><span class="line"><span class="keyword">int</span> st = <span class="number">0</span>;             <span class="comment">//代表头指针</span></span><br><span class="line">       <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//st&lt;len,且字符的整数值小于32则代表有空值，st++</span></span><br><span class="line">       <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">' '</span>)) &#123;   </span><br><span class="line">           st++;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//len - 1才是真正的尾指针，如果尾部元素的整数值&lt;=32,则代表有空值，len--</span></span><br><span class="line">       <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">           len--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//截取st到len的字符串(不包括len位置)</span></span><br><span class="line">       <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  常见去首尾的空值，实际是去除首尾凡是小于32的字符</p></li><li><p>toString()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>toCharArray()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 就是将String转换为字符数组并返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">    <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">    <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];    <span class="comment">//定义一个要返回的空数组，长度为字符串长度</span></span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length); <span class="comment">//拷贝</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>toLowerCase()、toUpperCase()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locale == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> firstUpper;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> len = value.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now check if there are any characters that need to be changed. */</span></span><br><span class="line">    scan: &#123;</span><br><span class="line">        <span class="keyword">for</span> (firstUpper = <span class="number">0</span> ; firstUpper &lt; len; ) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = value[firstUpper];</span><br><span class="line">            <span class="keyword">if</span> ((c &gt;= Character.MIN_HIGH_SURROGATE)</span><br><span class="line">                &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123;</span><br><span class="line">                <span class="keyword">int</span> supplChar = codePointAt(firstUpper);</span><br><span class="line">                <span class="keyword">if</span> (supplChar != Character.toLowerCase(supplChar)) &#123;</span><br><span class="line">                    <span class="keyword">break</span> scan;</span><br><span class="line">                &#125;</span><br><span class="line">                firstUpper += Character.charCount(supplChar);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != Character.toLowerCase(c)) &#123;</span><br><span class="line">                    <span class="keyword">break</span> scan;</span><br><span class="line">                &#125;</span><br><span class="line">                firstUpper++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">    <span class="keyword">int</span> resultOffset = <span class="number">0</span>;  <span class="comment">/* result may grow, so i+resultOffset</span></span><br><span class="line"><span class="comment">                                * is the write location in result */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just copy the first few lowerCase characters. */</span></span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, firstUpper);</span><br><span class="line"></span><br><span class="line">    String lang = locale.getLanguage();</span><br><span class="line">    <span class="keyword">boolean</span> localeDependent =</span><br><span class="line">        (lang == <span class="string">"tr"</span> || lang == <span class="string">"az"</span> || lang == <span class="string">"lt"</span>);</span><br><span class="line">    <span class="keyword">char</span>[] lowerCharArray;</span><br><span class="line">    <span class="keyword">int</span> lowerChar;</span><br><span class="line">    <span class="keyword">int</span> srcChar;</span><br><span class="line">    <span class="keyword">int</span> srcCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = firstUpper; i &lt; len; i += srcCount) &#123;</span><br><span class="line">        srcChar = (<span class="keyword">int</span>)value[i];</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">char</span>)srcChar &gt;= Character.MIN_HIGH_SURROGATE</span><br><span class="line">            &amp;&amp; (<span class="keyword">char</span>)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123;</span><br><span class="line">            srcChar = codePointAt(i);</span><br><span class="line">            srcCount = Character.charCount(srcChar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            srcCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (localeDependent ||</span><br><span class="line">            srcChar == <span class="string">'\u03A3'</span> || <span class="comment">// GREEK CAPITAL LETTER SIGMA</span></span><br><span class="line">            srcChar == <span class="string">'\u0130'</span>) &#123; <span class="comment">// LATIN CAPITAL LETTER I WITH DOT ABOVE</span></span><br><span class="line">            lowerChar = ConditionalSpecialCasing.toLowerCaseEx(<span class="keyword">this</span>, i, locale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lowerChar = Character.toLowerCase(srcChar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((lowerChar == Character.ERROR)</span><br><span class="line">            || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lowerChar == Character.ERROR) &#123;</span><br><span class="line">                lowerCharArray =</span><br><span class="line">                    ConditionalSpecialCasing.toLowerCaseCharArray(<span class="keyword">this</span>, i, locale);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcCount == <span class="number">2</span>) &#123;</span><br><span class="line">                resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lowerCharArray = Character.toChars(lowerChar);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Grow result if needed */</span></span><br><span class="line">            <span class="keyword">int</span> mapLen = lowerCharArray.length;</span><br><span class="line">            <span class="keyword">if</span> (mapLen &gt; srcCount) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] result2 = <span class="keyword">new</span> <span class="keyword">char</span>[result.length + mapLen - srcCount];</span><br><span class="line">                System.arraycopy(result, <span class="number">0</span>, result2, <span class="number">0</span>, i + resultOffset);</span><br><span class="line">                result = result2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; mapLen; ++x) &#123;</span><br><span class="line">                result[i + resultOffset + x] = lowerCharArray[x];</span><br><span class="line">            &#125;</span><br><span class="line">            resultOffset += (mapLen - srcCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i + resultOffset] = (<span class="keyword">char</span>)lowerChar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, len + resultOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toLowerCase(Locale.getDefault());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locale == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> firstLower;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> len = value.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now check if there are any characters that need to be changed. */</span></span><br><span class="line">    scan: &#123;</span><br><span class="line">        <span class="keyword">for</span> (firstLower = <span class="number">0</span> ; firstLower &lt; len; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = (<span class="keyword">int</span>)value[firstLower];</span><br><span class="line">            <span class="keyword">int</span> srcCount;</span><br><span class="line">            <span class="keyword">if</span> ((c &gt;= Character.MIN_HIGH_SURROGATE)</span><br><span class="line">                &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123;</span><br><span class="line">                c = codePointAt(firstLower);</span><br><span class="line">                srcCount = Character.charCount(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                srcCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> upperCaseChar = Character.toUpperCaseEx(c);</span><br><span class="line">            <span class="keyword">if</span> ((upperCaseChar == Character.ERROR)</span><br><span class="line">                || (c != upperCaseChar)) &#123;</span><br><span class="line">                <span class="keyword">break</span> scan;</span><br><span class="line">            &#125;</span><br><span class="line">            firstLower += srcCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* result may grow, so i+resultOffset is the write location in result */</span></span><br><span class="line">    <span class="keyword">int</span> resultOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[len]; <span class="comment">/* may grow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just copy the first few upperCase characters. */</span></span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, firstLower);</span><br><span class="line"></span><br><span class="line">    String lang = locale.getLanguage();</span><br><span class="line">    <span class="keyword">boolean</span> localeDependent =</span><br><span class="line">        (lang == <span class="string">"tr"</span> || lang == <span class="string">"az"</span> || lang == <span class="string">"lt"</span>);</span><br><span class="line">    <span class="keyword">char</span>[] upperCharArray;</span><br><span class="line">    <span class="keyword">int</span> upperChar;</span><br><span class="line">    <span class="keyword">int</span> srcChar;</span><br><span class="line">    <span class="keyword">int</span> srcCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = firstLower; i &lt; len; i += srcCount) &#123;</span><br><span class="line">        srcChar = (<span class="keyword">int</span>)value[i];</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">char</span>)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp;</span><br><span class="line">            (<span class="keyword">char</span>)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123;</span><br><span class="line">            srcChar = codePointAt(i);</span><br><span class="line">            srcCount = Character.charCount(srcChar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            srcCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (localeDependent) &#123;</span><br><span class="line">            upperChar = ConditionalSpecialCasing.toUpperCaseEx(<span class="keyword">this</span>, i, locale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            upperChar = Character.toUpperCaseEx(srcChar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((upperChar == Character.ERROR)</span><br><span class="line">            || (upperChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (upperChar == Character.ERROR) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localeDependent) &#123;</span><br><span class="line">                    upperCharArray =</span><br><span class="line">                        ConditionalSpecialCasing.toUpperCaseCharArray(<span class="keyword">this</span>, i, locale);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    upperCharArray = Character.toUpperCaseCharArray(srcChar);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcCount == <span class="number">2</span>) &#123;</span><br><span class="line">                resultOffset += Character.toChars(upperChar, result, i + resultOffset) - srcCount;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                upperCharArray = Character.toChars(upperChar);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Grow result if needed */</span></span><br><span class="line">            <span class="keyword">int</span> mapLen = upperCharArray.length;</span><br><span class="line">            <span class="keyword">if</span> (mapLen &gt; srcCount) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] result2 = <span class="keyword">new</span> <span class="keyword">char</span>[result.length + mapLen - srcCount];</span><br><span class="line">                System.arraycopy(result, <span class="number">0</span>, result2, <span class="number">0</span>, i + resultOffset);</span><br><span class="line">                result = result2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; mapLen; ++x) &#123;</span><br><span class="line">                result[i + resultOffset + x] = upperCharArray[x];</span><br><span class="line">            &#125;</span><br><span class="line">            resultOffset += (mapLen - srcCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i + resultOffset] = (<span class="keyword">char</span>)upperChar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, len + resultOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toUpperCase(Locale.getDefault());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>format()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JAVA字符串格式化</span></span><br><span class="line"><span class="comment">//新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Formatter().format(format, args).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(Locale l, String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Formatter(l).format(format, args).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>valueOf类函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将Object转换为String</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将char数组转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符数组的子数组转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将布尔值转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将单个字符转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data[] = &#123;c&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将int转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将long转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Long.toString(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将float转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Float.toString(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将double转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.toString(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>**从上看：**</code></pre><ul><li><p>copyValueOf和valueOf在Java8看来已经是完全没有区别的函数</p><ul><li>所有的value的本质都是新new一个String对象</li></ul></li><li><p>intern()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><pre><code>**String类中唯一的一条本地方法，既不是用Java语言实现的方法。**比如str.intern(),作用就是去字符串常量池中寻找str字符串，如果有则返回str在常量池中的引用，如果没有则在常量池中创建str对象</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 源码 </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring笔记</title>
      <link href="/2019/09/02/Spring/"/>
      <url>/2019/09/02/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring笔记"><a href="#Spring笔记" class="headerlink" title="Spring笔记"></a>Spring笔记</h2><h3 id="1-Spring-IOC"><a href="#1-Spring-IOC" class="headerlink" title="1. Spring IOC"></a>1. Spring IOC</h3><h4 id="1-1-Spring核心包"><a href="#1-1-Spring核心包" class="headerlink" title="1.1 Spring核心包"></a>1.1 Spring核心包</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190905092338.png" alt="Spring核心包"></p><blockquote><p><em>XML编写提示：配置Schema，修改Key type 为Schema location</em></p></blockquote><h4 id="1-2-SpringIOC入门"><a href="#1-2-SpringIOC入门" class="headerlink" title="1.2. SpringIOC入门"></a>1.2. SpringIOC入门</h4><ol><li><p>IOC: Inversion of Control(控制反转)。将对象的创建权反转给（交给）Spring。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"com.joey.spring.Bean1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DI：依赖注入，前提必须有IOC的环境，Spring管理这个类的时候将类的依赖的属性注入（设置）进来。</p></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190902210244.png" alt="IOC"></p><h4 id="1-3-Spring工厂类结构图"><a href="#1-3-Spring工厂类结构图" class="headerlink" title="1.3. Spring工厂类结构图"></a>1.3. Spring工厂类结构图</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190902210417.png" alt="工厂类结构图"></p><ol><li><p>ApplicationContext继承BeanFactory</p></li><li><p>BeanFactory</p><blockquote><p>老版本的工厂类，在调用getBean的时候才会产生类的实例</p></blockquote></li><li><p>ApplicationContext</p><blockquote><p>新版本的工厂类，加载配置文件的时候，将Spring管理的类都实例化</p><p>两个实现类：</p><ul><li>ClassPathXmlApplicationContext：加载类路径下的配置文件</li><li>FileSystemXmlApplicationContext：加载文件系统下的配置文件</li></ul></blockquote></li></ol><h4 id="1-4-Spring-Bean配置"><a href="#1-4-Spring-Bean配置" class="headerlink" title="1.4. Spring Bean配置"></a>1.4. Spring Bean配置</h4><ol><li><p><bean>标签的id和name配置</bean></p><blockquote><p>id：使用了约束中的唯一约束，里面不能出现特殊字符。</p><p>name：没有使用约束中的唯一约束（理论上可以出现重复的，但是实际开发不能出现），里面可以出现特殊字符。</p></blockquote></li><li><p>Bean的生命周期配置</p><blockquote><p>init-method：Bean被初始化的时候执行的方法</p><p>destory-method：Bean被销毁的时候执行的方法（Bean是单例创建，工厂关闭）</p></blockquote></li><li><p>Bean的作用范围配置</p><blockquote><p>scope：Bean的作用范围</p><ul><li>singleton：默认单例模式创建对象</li><li>prototype：多例模式</li><li>request：应用在web项目中，Spring创建这个类以后存到request范围中</li><li>session：应用在web项目中，Spring创建这个类以后存到session范围中</li><li>globalsession：应用在web项目中，必须在porlet环境下使用，但是如果没有这种环境，相对于session</li></ul></blockquote></li></ol><h4 id="1-5-Spring的Bean管理（XML方式）"><a href="#1-5-Spring的Bean管理（XML方式）" class="headerlink" title="1.5. Spring的Bean管理（XML方式）"></a>1.5. Spring的Bean管理（XML方式）</h4><ol><li><p>Spring的Bean的实例化方式</p><blockquote><ol><li><p>无参构造方法</p><ul><li><p>编写类构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span>&#123;</span><br><span class="line">&gt;          <span class="function"><span class="keyword">public</span> <span class="title">Bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;              <span class="keyword">super</span>();</span><br><span class="line">&gt;              System.out.pringt(<span class="string">"Bean1的无参构造方法执行。。。"</span>);</span><br><span class="line">&gt;          &#125;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol></blockquote><blockquote><ul><li><p>编写XML配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"com.joey.spring.Bean1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ol start="2"><li><p>静态工厂实例化</p><ul><li><p>编写静态工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean2Factory</span></span>&#123;</span><br><span class="line">&gt;          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bean2 <span class="title">createBean2</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;              System.out.pringt(<span class="string">"Bean2的静态工厂方法执行。。。"</span>);</span><br><span class="line">&gt;              <span class="keyword">return</span> <span class="keyword">new</span> Bean2();</span><br><span class="line">&gt;          &#125;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol></blockquote><blockquote><ul><li><p>编写XML配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"com.joey.spring.Bean2Factory"</span> <span class="attr">factory-method</span>=<span class="string">"createBean2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ol start="3"><li><p>实例工厂实例化</p><ul><li><p>编写实例工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean3Factory</span></span>&#123;</span><br><span class="line">&gt;          <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bean3 <span class="title">createBean3</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;              System.out.pringt(<span class="string">"Bean3的实例工厂方法执行。。。"</span>);</span><br><span class="line">&gt;              <span class="keyword">return</span> <span class="keyword">new</span> Bean3();</span><br><span class="line">&gt;          &#125;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol></blockquote><blockquote><ul><li><p>配置XML文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean3Factory"</span> <span class="attr">class</span>=<span class="string">"com.joey.spring.Bean3Factory"</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">&gt;      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean3"</span> <span class="attr">factory-bean</span>=<span class="string">"bean3Factory"</span> <span class="attr">factory-method</span>=<span class="string">"createBean3"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>Spring的属性注入(DI)</p><ol><li><p>构造方法的方式属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个可以执行批量的sqlSession --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"executorType"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Set方法的方式属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--================== 配置和MyBatis的整合=============== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mybatis全局配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"pooledDataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mybatis，mapper文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>P名称空间属性注入</p><ol><li><p>引入P名称空间</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>P名称空间的属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.joey.spring.Car"</span> <span class="attr">p:name</span>=<span class="string">""</span> <span class="attr">p:price</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"employee"</span> <span class="attr">class</span>=<span class="string">"com.joey.spring.Employee"</span> <span class="attr">p:name</span>=<span class="string">""</span> <span class="attr">p:car-ref</span>=<span class="string">"car"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>SpEL的属性注入（Spring3.0以后）</p><blockquote><p>spring表达式语言简称<strong>SPEL</strong>：是一个支持运行时查询和操作对象图的强大的表达式语言。语法类似于<strong>EL</strong>，SpEL 使用 #{…} 作为定界符 , 所有在大括号中的字符都将被认为是 SpEL , SpEL 为 bean 的属性进行动态赋值提供了便利。</p></blockquote><blockquote><h5 id="通过-SpEL-可以实现："><a href="#通过-SpEL-可以实现：" class="headerlink" title="通过 SpEL 可以实现："></a>通过 SpEL 可以实现：</h5><ul><li>通过 bean 的 id 对 bean 进行引用。</li><li>调用方式以及引用对象中的属性。</li><li>计算表达式的值</li><li>正则表达式的匹配</li></ul></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"carInfo"</span> <span class="attr">class</span>=<span class="string">"com.joey.spring.CarInfo"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.joey.spring.car"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"#&#123;carInfo.name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"drive"</span> <span class="attr">value</span>=<span class="string">"#&#123;carInfo.drive()&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Spring集合类型属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring的集合属性的注入============================ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注入数组类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"collectionBean"</span> <span class="attr">class</span>=<span class="string">"com.joey.spring.CollectionBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数组类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arrs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入list集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>7<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入set集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入Map集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"aaa"</span> <span class="attr">value</span>=<span class="string">"111"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"bbb"</span> <span class="attr">value</span>=<span class="string">"222"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"ccc"</span> <span class="attr">value</span>=<span class="string">"333"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分模块开发配置</p><ol><li><p>加载配置文件的时候加载多个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationCOntext applicationCOntext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationConetxt.xml"</span>,<span class="string">"applicationConetxt.xml2"</span>);</span><br></pre></td></tr></table></figure></li><li><p>在一个配置文件中引入多个配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">import</span> resource=<span class="string">"applicationConetxt2.xml"</span>/&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="1-6-Spring的Bean管理（注解开发）"><a href="#1-6-Spring的Bean管理（注解开发）" class="headerlink" title="1.6. Spring的Bean管理（注解开发）"></a>1.6. Spring的Bean管理（注解开发）</h4><ol><li><p>引入context约束</p></li><li><p>开启Spring组件扫描</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.joey.spring"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>类上添加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Compoent</span>(<span class="string">"userDao"</span>) <span class="comment">//相当于&lt;bean id="userDao" class="com.joey.spring.UserDaoImpl"&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注解方式设置属性值</p><blockquote><p>使用注解方式，可以没有set方法的</p><ul><li><p>属性如果有set方法，需要将属性注入的注解添加到set方法</p></li><li><p>如果没有set方法，需要将属性注入的注解添加属性上</p></li></ul></blockquote></li><li><p>IOC 注解</p><ol><li>@Component：组件，修饰一个类，将这个类交给Spring管理</li><li>三个衍生注解，修饰类<ul><li>@Controller：Web层</li><li>@ServIce：service层</li><li>@Respository：dao层</li></ul></li><li>属性注入的注解：<ul><li>普通属性：@Value</li><li>按照类型对象注入：@Autoware</li><li>按照名称对象注入：@Resource</li></ul></li><li>Bean的其他注解：<ul><li>生命周期相关注解<ul><li>PostConstruct：初始化方法</li><li>PreDestory：销毁方法</li></ul></li><li>Bean作用范围的注解<ul><li>@Scope<ul><li>Singleton</li><li>prototype</li><li>request</li><li>session</li><li>globalsession</li></ul></li></ul></li></ul></li></ol></li><li><p>IOC的XML和注解开发比较</p><blockquote><p>XML ：可以适用任何场景，结构清晰，维护方便</p><p>注解：有些地方用不了，类不是自己提供，开发方便</p><p>XML和注解整合开发：XML管理Bean，注解完成属性注入</p><p>没有使用扫描类上的注解，需要开启属性注入的注解</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">context：annotation-config</span>/&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><table><thead><tr><th></th><th>基于XML配置</th><th>基于注解配置</th></tr></thead><tbody><tr><td>Bean定义</td><td><bean id class></bean></td><td>@Component，衍生类：@Repository、@Service、@Controller</td></tr><tr><td>Bean名称</td><td>通过id或name指定</td><td>@Component(“person”)</td></tr><tr><td>Bean注入</td><td><property>或者通过p命名空间</property></td><td>@Autowired按照类型注入，@Qualifier按照名称注入</td></tr><tr><td>生命过程，Bean作用范围</td><td>init-method，destory-method，范围scope属性</td><td>@PostConstructa初始化、@PreDestory销毁、@Scope设置作用范围</td></tr><tr><td>适合场景</td><td>Bean来自第三方，使用其它</td><td>Bean的实现类由用户自己开发</td></tr></tbody></table></blockquote></li></ol><h3 id="2-Spring-AOP"><a href="#2-Spring-AOP" class="headerlink" title="2. Spring AOP"></a>2. Spring AOP</h3><h4 id="2-1-Spring-底层实现原理"><a href="#2-1-Spring-底层实现原理" class="headerlink" title="2.1 Spring 底层实现原理"></a>2.1 Spring 底层实现原理</h4><blockquote><p>动态代理</p><ul><li><p>JDK动态代理（默认，先修改java文件然后再编译成class文件）</p><blockquote><p>JDK动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）</p><p>JDK动态代理主要涉及java.lang.reflect包下的两个类：Proxy类和InvocationHandler接口。<br>JDK动态代理实现的三个要点：</p><ol><li>通过java.lang.reflect.Proxy类来动态生成代理类</li><li>代理类要实现InvocationHandler接口</li><li>JDK动态代理只能基于接口进行动态代理的</li></ol></blockquote></li><li><p>Cglib动态代理（运行更快,在内存直接生成子类class文件继承父类重写所有父类方法(不能声明成final)）</p><blockquote><p>Cglib采用非常底层的字节码技术，可以为一个类创建子类，并在子类中采用方法拦截的技术拦截所有的父类方法的调用，并顺势织入横切逻辑。</p></blockquote></li><li><p>区别</p><blockquote><p>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p><p>而Cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p><ol><li><p>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</p></li><li><p>如果目标对象实现了接口，可以强制使用CGLIB实现AOP’</p><blockquote><p>如何强制使用Cglib：</p><ol><li>在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=“true”/&gt;</li><li>EnableAspectJAutoProxy注解参数proxyTargetClass=true使用Cglib</li></ol></blockquote></li><li><p>如果目标对象没有实现了接口，必须采用Cglib库，spring会自动在JDK动态代理和Cglib之间转换</p></li><li><p>JDK动态代理和Cglib字节码生成的区别？<br>（1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br>（2）Cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。   因为是继承，所以该类或方法最好不要声明成final</p></li></ol></blockquote></li><li><p>性能问题</p><blockquote><p>由于Cglib代理是利用ASM字节码生成框架在内存中生成一个需要被代理类的子类完成代理，而JDK动态代理是利用反射原理完成动态代理，所以Cglib创建的动态代理对象性能比JDK动态代理动态创建出来的代理对象新能要好的多，但是对象创建的速度比JDK动态代理要慢，所以，当Spring使用的是单例情况下可以选用Cglib代理，反之使用JDK动态代理更加合适。同时还有一个问题，被final修饰的类只能使用JDK动态代理，因为被final修饰的类不能被继承，而Cglib则是利用的继承原理实现代理的。</p></blockquote></li></ul></blockquote><h4 id="2-2-Spring-AOP相关术语"><a href="#2-2-Spring-AOP相关术语" class="headerlink" title="2.2 Spring AOP相关术语"></a>2.2 Spring AOP相关术语</h4><blockquote><ul><li><p>Joinpoint(连接点) : </p><p>​        所谓连接点是指那些被拦截到的点。在Spring中,这些点指的是方法，因为Spring只支持方法类型的连接点。</p></li><li><p>Pointcut(切入点) : </p><p>​        所谓的切入点是指我们要对哪些Joinpoint进行拦截的定义。</p></li><li><p>Advice(通知/增强) : </p><p>​        所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。</p><p>​        通知的类型：前置类型，后置通知，异常通知，环绕通知。</p></li><li><p>Introduction(引介) : </p><p>​        引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field。</p></li><li><p>Target(目标对象) : </p><p>​        代理的目标对象。</p></li><li><p>Weaving(织入) : </p><p>​        是指把增强应用到目标对象来创建新的代理对象的过程。</p><p>​        Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。</p></li><li><p>Proxy(代理) : </p><p>​        一个类被AOP织入增强，就产生一个结果代理类。</p></li><li><p>Aspect(切面) : </p><p>​        是切入点和通知（引介）的结合。</p></li></ul></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190905152719.png" alt="AOP相关术语"></p><h4 id="2-3-SpringAOP-的入门开发"><a href="#2-3-SpringAOP-的入门开发" class="headerlink" title="2.3 SpringAOP 的入门开发"></a>2.3 SpringAOP 的入门开发</h4><ol><li><p>引入jar包</p></li><li><p>编写目标类并配置</p></li><li><p>编写切面类并配置</p></li><li><p>进行aop配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(表达式"</span> <span class="attr">id</span>=<span class="string">"pc1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">"pc1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类型</p><ul><li>前置通知</li><li>后置通知</li><li>环绕通知</li><li>异常抛出通知</li><li>最终通知</li></ul></li><li><p>XML配置</p></li><li><p>基于execution的函数完成</p><blockquote><p>[访问修饰符] 方法返回值 包名.类名.方法名(参数)</p></blockquote></li></ol><h4 id="2-4-基于AspectJ的XML配置"><a href="#2-4-基于AspectJ的XML配置" class="headerlink" title="2.4  基于AspectJ的XML配置"></a>2.4  基于AspectJ的XML配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前置通知 : 获得切入点信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">"pc1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--后置通知 : 获得方法的返回值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">"pc1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--环绕通知 : 阻止目标方法的执行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">"pc1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--异常抛出通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">"pc1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最终通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">""</span> <span class="attr">pointcut-ref</span>=<span class="string">"pc1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-基于AspectJ的注解配置"><a href="#2-5-基于AspectJ的注解配置" class="headerlink" title="2.5 基于AspectJ的注解配置"></a>2.5 基于AspectJ的注解配置</h4><ol><li><p>在配置文件中开启AOP注解开发</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>切面类上使用注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectj</span></span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(value=<span class="string">"execution(* com.joey.spring.save(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.joey.spring.save(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around</span>(value=<span class="string">"execution(* com.joey.spring.save(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(* com.joey.spring.save(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常抛出通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(value=<span class="string">"execution(* com.joey.spring.save(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"最终通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Spring的JDBC模板使用"><a href="#3-Spring的JDBC模板使用" class="headerlink" title="3. Spring的JDBC模板使用"></a>3. Spring的JDBC模板使用</h3><ul><li><p>Spring的JDBC模板</p><table><thead><tr><th>ORM持久化技术</th><th>模板类</th></tr></thead><tbody><tr><td>JDBC</td><td>org.springframework.jdbc.core.JdbcTemplate</td></tr><tr><td>Hibernate3.0</td><td>org.springframework.orm.hibernate3.HeibernateTemplate</td></tr><tr><td>IBatis(Mybatis)</td><td>org.springframework.orm.ibatis.SqlMapClientTemplate</td></tr><tr><td>JPA</td><td>org.springframework.orm.jpa.JpaTemplate</td></tr></tbody></table></li><li><p>JDBC模板使用(例: c3p0)</p><ol><li><p>引入jar包</p></li><li><p>配置c3p0连接池</p></li><li><p>抽取配置到属性文件</p></li><li><p>在Spring的配置文件中引入属性文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一种(常用)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:dbconfig.properties"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第二种--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"classpath:dbconfig.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入属性文件的值 </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pooledDataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.jdbcUrl&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClass&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.user&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="4-Spring-的事务管理"><a href="#4-Spring-的事务管理" class="headerlink" title="4. Spring 的事务管理"></a>4. Spring 的事务管理</h3><h4 id="4-1-事务特性"><a href="#4-1-事务特性" class="headerlink" title="4. 1 事务特性"></a>4. 1 事务特性</h4><ul><li>原子性 : 事务不可分割</li><li>一致性 : 事务执行前后数据完整性保持一致</li><li>隔离性 : 一个事务的执行不应该受到其他事务的干扰</li><li>持久性 : 一旦事务结束,数据就持久到数据库</li></ul><h4 id="4-2-事务隔离级别"><a href="#4-2-事务隔离级别" class="headerlink" title="4.2 事务隔离级别"></a>4.2 事务隔离级别</h4><ul><li><p>Read uncommitted ：未提交读，任何读问题解决不了。</p></li><li><p>Read committed      ：已提交读，解决脏读，但是不可重复读和虚读有可能发生。</p></li><li><p>Repeatable read      ：重复读，解决脏读和不可重复读，但是虚读有可能发生。</p></li><li><p>Serializable               ：解决所有读问题。</p></li></ul><h4 id="4-3-事务管理的API"><a href="#4-3-事务管理的API" class="headerlink" title="4.3 事务管理的API"></a>4.3 事务管理的API</h4><ol><li><p>PlatformTransactionManager: 平台事务管理器</p><blockquote><ul><li>DataSourceTransactionManager: 底层使用JDBC管理事务</li><li>HibernateTransactionManager   : 底层使用Hibernate管理事务</li></ul></blockquote></li><li><p>事务定义信息</p><blockquote><p> 用于定义事务的相关信息</p><ul><li>隔离级别</li><li>超时信息</li><li>传播行为</li><li>是否只读 </li></ul></blockquote></li><li><p>事务的状态</p><blockquote><p>用于记录在事务管理过程中, 事务的状态的对象</p></blockquote></li></ol><h4 id="4-4-Spring事务的传播行为-七种事务"><a href="#4-4-Spring事务的传播行为-七种事务" class="headerlink" title="4.4 Spring事务的传播行为(七种事务)"></a>4.4 Spring事务的传播行为(七种事务)</h4><ol><li>保证多个操作在同一个事务中<ul><li><strong>PROPAGATION_REQUIRED</strong>     <strong>：默认值，如果A中有事务，使用A中的事务，如果A没有，创建一个新的事务，将操作包含进来</strong></li><li><strong>PROPAGATION_SUPPORTS   ：支持事务，如果A中有事务，使用A中的事务。如果A没有事务，不使用事务。</strong></li><li><strong>PROPAGATION_MANDATORY：如果A中有事务，使用A中的事务。如果A没有事务，抛出异常。</strong></li></ul></li><li>保证多个操作不在同一个事务中<ul><li><strong>PROPAGATION_REQUIRES_NEW   ：如果A中有事务，将A的事务挂起（暂停），创建新事务，只包含自身操作。如果A中没有事务，创建一个新事务，包含自身操作。</strong></li><li><strong>PROPAGATION_NOT_SUPPORTED ：如果A中有事务，将A的事务挂起。不使用事务管理。</strong></li><li><strong>PROPAGATION_NEVER：如果A中有事务，报异常。</strong></li></ul></li><li>嵌套式事务<ul><li><strong>PROPAGATION_NESTED：嵌套事务，如果A中有事务，按照A的事务执行，执行完成后，设置一个保存点，执行B中的操作，如果没有异常，执行通过，如果有异常，可以选择回滚到最初始位置，也可以回滚到保存点。</strong></li></ul></li></ol><h4 id="4-5-Spring事务管理"><a href="#4-5-Spring事务管理" class="headerlink" title="4.5 Spring事务管理"></a>4.5 Spring事务管理</h4><ol><li><p>编程式事务(需手动编写代码)</p><ol><li>配置平台事务管理器</li><li>配置事务管理的模板类</li><li>在业务层注入事务管理的模板</li><li>编写事务管理的代码</li></ol></li><li><p>声明式事务管理(XML方式)</p><ol><li><p>配置事务管理器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--控制住数据源  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"pooledDataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置增强</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 所有方法都是事务方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以get开始的所有方法  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>AOP配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 切入点表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.joey.service..*(..))"</span> <span class="attr">id</span>=<span class="string">"txPoint"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPoint"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>声明式事务管理(注解方式)</p><ol><li><p>配置事务管理器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务增强，事务如何切入  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 所有方法都是事务方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以get开始的所有方法  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>开启注解事务</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transationManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在业务层添加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImple</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Netty+WebSocket简易版微信</title>
      <link href="/2019/08/23/%E5%9F%BA%E4%BA%8ENetty+WebSocket%E7%AE%80%E6%98%93%E7%89%88%E5%BE%AE%E4%BF%A1/"/>
      <url>/2019/08/23/%E5%9F%BA%E4%BA%8ENetty+WebSocket%E7%AE%80%E6%98%93%E7%89%88%E5%BE%AE%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Netty-WebSocket简易版微信-慕课网"><a href="#基于Netty-WebSocket简易版微信-慕课网" class="headerlink" title="基于Netty+WebSocket简易版微信-慕课网"></a>基于Netty+WebSocket简易版微信-慕课网</h1><h3 id="1-技术栈"><a href="#1-技术栈" class="headerlink" title="1. 技术栈"></a>1. 技术栈</h3><p><strong>前端：MUI 、H5PLUS</strong></p><p><strong>后端：SpringBoot 、Netty、WebSocket、Mysql、FastDFS、Nginx、Mybatis</strong></p><h3 id="2-数据库建表"><a href="#2-数据库建表" class="headerlink" title="2. 数据库建表"></a>2. 数据库建表</h3><h4 id="表：users"><a href="#表：users" class="headerlink" title="表：users"></a>表：users</h4><table><thead><tr><th>表名</th><th align="left">users</th><th>表名中文</th><th>用户表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td align="left">列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td align="left">id</td><td>主键</td><td>varchar</td><td>64</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td align="left">username</td><td>名称</td><td>varchar</td><td>20</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td align="left">password</td><td>密码</td><td>varchar</td><td>64</td><td></td><td>M</td><td></td><td></td></tr><tr><td>4</td><td align="left">face_image</td><td>头像</td><td>varchar</td><td>255</td><td></td><td>N</td><td></td><td></td></tr><tr><td>5</td><td align="left">face_image_big</td><td>大头像</td><td>varchar</td><td>255</td><td></td><td>N</td><td></td><td></td></tr><tr><td>6</td><td align="left">nickname</td><td>昵称</td><td>varchar</td><td>20</td><td></td><td>N</td><td></td><td></td></tr><tr><td>7</td><td align="left">qrcode</td><td>二维码</td><td>varchar</td><td>255</td><td></td><td>N</td><td></td><td></td></tr><tr><td>8</td><td align="left">cid</td><td>设备ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr></tbody></table><h4 id="表：friends-request"><a href="#表：friends-request" class="headerlink" title="表：friends_request"></a>表：friends_request</h4><table><thead><tr><th>表名</th><th>friends_request</th><th>表名中文</th><th>用户请求表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>id</td><td>主键</td><td>varchar</td><td>64</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>send_user_id</td><td>发送者ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td>accept_user_id</td><td>接收者ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>4</td><td>request_date_time</td><td>接收时间</td><td>datetime</td><td>0</td><td></td><td>N</td><td></td><td></td></tr></tbody></table><h4 id="表：my-friends"><a href="#表：my-friends" class="headerlink" title="表：my_friends"></a>表：my_friends</h4><table><thead><tr><th>表名</th><th>my_friends</th><th>表名中文</th><th>好友中间表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>id</td><td>主键</td><td>varchar</td><td>64</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>my_user_id</td><td>我的ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td>my_friend_user_id</td><td>好友的ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr></tbody></table><h4 id="表：chat-msg"><a href="#表：chat-msg" class="headerlink" title="表：chat_msg"></a>表：chat_msg</h4><table><thead><tr><th>表名</th><th>chat_msg</th><th>表名中文</th><th>好友中间表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>id</td><td>主键</td><td>varchar</td><td>64</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>send_user_id</td><td>我的ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td>accept_user_id</td><td>好友的ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>4</td><td>msg</td><td>消息</td><td>varchar</td><td>255</td><td></td><td>N</td><td></td><td></td></tr><tr><td>5</td><td>sign_flag</td><td>已读未读</td><td>int</td><td>1</td><td></td><td>N</td><td></td><td></td></tr><tr><td>6</td><td>create_time</td><td>发送时间</td><td>datetime</td><td>0</td><td></td><td>N</td><td></td><td></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">username <span class="built_in">varchar</span>(<span class="number">20</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'名称'</span>,</span><br><span class="line"><span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">face_image <span class="built_in">varchar</span>(<span class="number">255</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'头像'</span>,</span><br><span class="line">face_image_big  <span class="built_in">varchar</span>(<span class="number">255</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'大头像'</span>,</span><br><span class="line">nickname <span class="built_in">varchar</span>(<span class="number">20</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'昵称'</span>,</span><br><span class="line">qrcode <span class="built_in">varchar</span>(<span class="number">255</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'二维码'</span>,</span><br><span class="line">cid <span class="built_in">VARCHAR</span>(<span class="number">64</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'设备ID'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> friends_request(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">send_user_id <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'发送者ID'</span>,</span><br><span class="line">accept_user_id <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'接收者ID'</span>,</span><br><span class="line">request_date_time datetime  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'接收时间'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> my_friends(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">my_user_id <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'我的ID'</span>,</span><br><span class="line">my_friend_user_id <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'好友的ID'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> chat_msg(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">send_user_id <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'我的ID'</span>,</span><br><span class="line">accept_user_id <span class="built_in">varchar</span>(<span class="number">64</span>)  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'好友的ID'</span>,</span><br><span class="line">msg <span class="built_in">varchar</span>(<span class="number">255</span>)   <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'消息'</span>,</span><br><span class="line">    sign_flag <span class="built_in">int</span> <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'已读未读'</span>,</span><br><span class="line">    create_time datetime  <span class="literal">null</span> <span class="keyword">COMMENT</span> <span class="string">'发送时间'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><h3 id="问题解决记录"><a href="#问题解决记录" class="headerlink" title="问题解决记录"></a>问题解决记录</h3><ul><li><a href="https://fangchenyong.top/2019/08/14/install_FastDFS+Nginx/">安装fastDFS+nginx实现文件存储服务器</a></li><li><a href="https://blog.csdn.net/svneclipse/article/details/80719480" target="_blank" rel="noopener">The type org.springframework.context.ConfigurableApplicationContext cannot be resolved.</a></li><li><a href="https://www.iteye.com/blog/1615714" target="_blank" rel="noopener">Spring配置事务的传播行为（PROPAGATION)和隔离级别(Isolation)（终于懂了）</a></li><li><a href="https://ask.dcloud.net.cn/question/8161" target="_blank" rel="noopener">mui.ajax() abort</a></li><li><a href="https://blog.csdn.net/bmw601055/article/details/77414855" target="_blank" rel="noopener">Uncaught SyntaxError: Unexpected token o</a> </li></ul><p><em>注：安装测试需要更改application.properties中fastdfs配置以及数据库连接，修改前端app.js配置以及后端新增用户产生二维码的文件目录和文件上传目录</em></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8 Object源码</title>
      <link href="/2019/08/23/JDK8-Object/"/>
      <url>/2019/08/23/JDK8-Object/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JDK8-Object"><a href="#JDK8-Object" class="headerlink" title="JDK8 Object"></a>JDK8 Object</h1><h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h2><p>Java对象被设计成单继承，所有的对象都直接或者间接的继承Object类，拥有Object的一些属性和方法。所以Object也可以理解为所有类的父类。</p><h2 id="2-方法汇总"><a href="#2-方法汇总" class="headerlink" title="2.方法汇总"></a>2.方法汇总</h2><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>protected Object</td><td>clone()</td><td>Creates and returns a copy of this object.</td></tr><tr><td>boolean</td><td>equals(Object obj)</td><td>Indicates whether some other object is “equal to” this one.</td></tr><tr><td>protected void</td><td>finalize()</td><td>Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.</td></tr><tr><td>Class&lt;?&gt;</td><td>getClass()</td><td>Returns the runtime class of this Object.</td></tr><tr><td>int</td><td>hashCode()</td><td>Returns a hash code value for the object.</td></tr><tr><td>String</td><td>toString()</td><td>Returns a string representation of the object.</td></tr><tr><td>void</td><td>notify()</td><td>Wakes up a single thread that is waiting on this object’s monitor.</td></tr><tr><td>void</td><td>notifyAll()</td><td>Wakes up all threads that are waiting on this object’s monitor.</td></tr><tr><td>void</td><td>wait()</td><td>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.</td></tr><tr><td>void</td><td>wait(long timeout)</td><td>Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.</td></tr><tr><td>void</td><td>wait(long timeout, int nanos)</td><td>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object, or some other thread interrupts the current thread, or a certain amount of real time has elapsed.</td></tr></tbody></table><h2 id="3-方法详细信息"><a href="#3-方法详细信息" class="headerlink" title="3.方法详细信息"></a>3.方法详细信息</h2><ol><li><p>Clone()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建并返回此对象的副本。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br></pre></td></tr></table></figure><p> 如何实现拷贝，到底是浅拷贝？还是深拷贝？</p><ol><li><p>要想重写clone方法，需要实现Cloneable接口</p></li><li><p>通过super.clone()获取Objec.clone()方法返回的拷贝对象</p></li><li><p>如果你想要实现深拷贝，你需要在对象返回前进行修改</p><blockquote><p>情况一：创建一个Person类，实现Cloneable接口，重写clone方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> com.joey.object;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">int</span> age;</span><br><span class="line">&gt;     String name;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.age = age;</span><br><span class="line">&gt;         <span class="keyword">this</span>.name = name;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> age;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.age = age;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> name;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.name = name;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">//不重写toString()方法，为了看哈希值是否一致</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="string">"年龄："</span> + <span class="keyword">this</span>.age + <span class="string">",姓名："</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span></span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">&gt;         Person person = <span class="keyword">new</span> Person(<span class="number">18</span>,<span class="string">"joey"</span>);</span><br><span class="line">&gt;         <span class="comment">//深拷贝一个对象</span></span><br><span class="line">&gt;         Person person1 = (Person)person.clone();</span><br><span class="line">&gt;         <span class="comment">//输出对象的哈希地址值</span></span><br><span class="line">&gt;         System.out.println(person);</span><br><span class="line">&gt;         System.out.println(person1);</span><br><span class="line">&gt;         <span class="comment">//输出对象的内容</span></span><br><span class="line">&gt;         System.out.println(person.show());</span><br><span class="line">&gt;         System.out.println(person1.show());</span><br><span class="line">&gt;         <span class="comment">//修改复制的对象</span></span><br><span class="line">&gt;         person1.setAge(<span class="number">24</span>);</span><br><span class="line">&gt;         person1.setName(<span class="string">"方陈勇"</span>);</span><br><span class="line">&gt;         <span class="comment">//输出判断是否会修改person的值，其实地址值不一样就已经很清楚了</span></span><br><span class="line">&gt;         System.out.println(person.show());</span><br><span class="line">&gt;         System.out.println(person1.show());</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">&gt; com.joey.object.Person@1b6d3586</span></span><br><span class="line"><span class="comment">&gt; com.joey.object.Person@4554617c</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey</span></span><br><span class="line"><span class="comment">&gt; 年龄：24,姓名：方陈勇</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>结论一：单纯看地址值能够判断两个是不同的对象，属于深拷贝，并且修改person1的值不会影响person的值。</strong></p><p>情况二：创建一个Address类，重写toString()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> com.joey.object;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>&#123;</span><br><span class="line">&gt;     String location;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.location = location;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> location;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.location = location;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="string">"Address&#123;"</span> +</span><br><span class="line">&gt;                 <span class="string">"location='"</span> + location + <span class="string">'\''</span> +</span><br><span class="line">&gt;                 <span class="string">'&#125;'</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Person类做一下修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> com.joey.object;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&gt;     <span class="keyword">private</span> String name;</span><br><span class="line">&gt;     <span class="keyword">private</span> Address address;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name,Address address)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.age = age;</span><br><span class="line">&gt;         <span class="keyword">this</span>.name = name;</span><br><span class="line">&gt;         <span class="keyword">this</span>.address= address;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> age;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.age = age;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> name;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.name = name;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> address;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.address = address;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">//不重写toString()方法，为了看地址值是否一致</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="string">"年龄："</span> + <span class="keyword">this</span>.age + <span class="string">",姓名："</span> + <span class="keyword">this</span>.name +<span class="string">",地址："</span> +<span class="keyword">this</span>.address;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span></span>&#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">&gt;      Person person = <span class="keyword">new</span> Person(<span class="number">18</span>,<span class="string">"joey"</span>,<span class="keyword">new</span> Address(<span class="string">"杭州西湖"</span>));</span><br><span class="line">&gt;      <span class="comment">//拷贝一个对象</span></span><br><span class="line">&gt;      Person person1 = (Person)person.clone();</span><br><span class="line">&gt;         <span class="comment">//输出对象的哈希地址值</span></span><br><span class="line">&gt;         System.out.println(person);</span><br><span class="line">&gt;         System.out.println(person1);</span><br><span class="line">&gt;         <span class="comment">//输出对象的内容</span></span><br><span class="line">&gt;         System.out.println(<span class="string">"**********************复制后************************"</span>);</span><br><span class="line">&gt;         System.out.println(person.show());</span><br><span class="line">&gt;         System.out.println(person1.show());</span><br><span class="line">&gt;    </span><br><span class="line">&gt;         <span class="comment">//修改复制的对象</span></span><br><span class="line">&gt;         System.out.println(<span class="string">"*****************修改person1中的age和name*************"</span>);</span><br><span class="line">&gt;         person1.setAge(<span class="number">24</span>);</span><br><span class="line">&gt;      person1.setName(<span class="string">"方陈勇"</span>);</span><br><span class="line">&gt;         <span class="comment">//输出判断</span></span><br><span class="line">&gt;         System.out.println(person.show());</span><br><span class="line">&gt;         System.out.println(person1.show());</span><br><span class="line">&gt;    </span><br><span class="line">&gt;         <span class="comment">//修改复制的对象</span></span><br><span class="line">&gt;         System.out.println(<span class="string">"*****************修改person1中的age和name*************"</span>);</span><br><span class="line">&gt;         Address address = person1.getAddress();</span><br><span class="line">&gt;      address.setLocation(<span class="string">"杭州滨江"</span>);</span><br><span class="line">&gt;         <span class="comment">//输出判断</span></span><br><span class="line">&gt;         System.out.println(person.show());</span><br><span class="line">&gt;         System.out.println(person1.show());</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">&gt;    com.joey.object.Person@1b6d3586</span></span><br><span class="line"><span class="comment">&gt;    com.joey.object.Person@4554617c</span></span><br><span class="line"><span class="comment">&gt; **********************复制后************************</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey,地址：Address&#123;location='杭州西湖'&#125;</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey,地址：Address&#123;location='杭州西湖'&#125;</span></span><br><span class="line"><span class="comment">&gt; *****************修改person1中的age和name*************</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey,地址：Address&#123;location='杭州西湖'&#125;</span></span><br><span class="line"><span class="comment">&gt; 年龄：24,姓名：方陈勇,地址：Address&#123;location='杭州西湖'&#125;</span></span><br><span class="line"><span class="comment">&gt; *****************修改person1中的age和name*************</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey,地址：Address&#123;location='杭州滨江'&#125;</span></span><br><span class="line"><span class="comment">&gt; 年龄：24,姓名：方陈勇,地址：Address&#123;location='杭州滨江'&#125;</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>结论二：person1只修改age和name时发现不会影响person的值，但是修改address对象的值时就会有影响。是因为Address类没有重写Clone()方法，person和person1指向的都是同一个Address对象</strong></p><p>情况三：那么如何实现深拷贝。修改Address类实现Cloneable接口，重写clone()方法，在Person类中重写Clone()方法的时候调用Address重写后的clone()方法，即同时克隆Person类和Address类。</p><p>修改Address类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> com.joey.object;</span><br><span class="line">&gt; </span><br><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;  String location;</span><br><span class="line">&gt; </span><br><span class="line">&gt;  <span class="meta">@Override</span></span><br><span class="line">&gt;  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.location = location;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> location;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.location = location;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="string">"Address&#123;"</span> +</span><br><span class="line">&gt;              <span class="string">"location='"</span> + location + <span class="string">'\''</span> +</span><br><span class="line">&gt;                 <span class="string">'&#125;'</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>   修改Person类中重写的Clone()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">&gt; <span class="comment">//深拷贝</span></span><br><span class="line">&gt;  Person person = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">&gt;  person.address = (Address) <span class="keyword">this</span>.address.clone();</span><br><span class="line">&gt;  <span class="keyword">return</span> person;</span><br><span class="line">&gt;     <span class="comment">//return super.clone();</span></span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">&gt;    com.joey.object.Person@1b6d3586</span></span><br><span class="line"><span class="comment">&gt; com.joey.object.Person@4554617c</span></span><br><span class="line"><span class="comment">&gt; **********************复制后************************</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey,地址：Address&#123;location='杭州西湖'&#125;</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey,地址：Address&#123;location='杭州西湖'&#125;</span></span><br><span class="line"><span class="comment">&gt; *****************修改person1中的age和name*************</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey,地址：Address&#123;location='杭州西湖'&#125;</span></span><br><span class="line"><span class="comment">&gt; 年龄：24,姓名：方陈勇,地址：Address&#123;location='杭州西湖'&#125;</span></span><br><span class="line"><span class="comment">&gt; *****************修改person1中的age和name*************</span></span><br><span class="line"><span class="comment">&gt; 年龄：18,姓名：joey,地址：Address&#123;location='杭州西湖'&#125;</span></span><br><span class="line"><span class="comment">&gt; 年龄：24,姓名：方陈勇,地址：Address&#123;location='杭州滨江'&#125;</span></span><br><span class="line"><span class="comment">&gt; */</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>结论三：可以看到最后person的address内容也没有改变。也就是说，当一个类里有很多引用类型时，如果想实现深拷贝那就得将每个引用类型都实现Cloneable接口重写一下clone()方法，比较麻烦的。可能好奇为什么String为什么没有影响，因为String是不可变的，相当于重新new了一个String。</strong></p><p><strong>所以，对于很多引用类型，可以使用序列化对象的方式进行深拷贝。</strong></p></blockquote></li></ol></li><li><p>equals(Object obj)</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接判断的是引用，若想判断内容是否相同，需要重写此方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure><p> 常见问题：equals()和==的比较</p><ul><li><p>equals()用于引用类型的比较，如果引用类型没有重写equals()方法，调用的就是Object类中的equals()，比较的是地址值。</p></li><li><p>==用于在基本数据类型和引用数据类型的比较。如果是基本数据类型，比较的是内容，如果是引用数据类型，那比较的就是地址值。</p><p>哪些类重写了equals()方法</p></li><li><p>String</p></li><li><p>Date</p></li><li><p>File</p></li><li><p>包装类</p></li><li><p>…</p><p>如何重写equals方法</p><blockquote><p>equals()方法里面提到了四个原则：</p><ol><li>自反性reflexive，a.equals(a) == true</li><li>对称性symmetric，a.equals(b) == b.equals(a)</li><li>传递性transitive，当a.equals(b) == true且b.equals(c) == true时，a.equals(c) == true</li><li>一致性consistent，当equals实现不变时，a.equals(b)返回值永远不变</li></ol><p>例如String中的equals()，重写判断的是内容相等，hashCode()方法也重写了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">&gt;         String anotherString = (String)anObject;</span><br><span class="line">&gt;         <span class="keyword">int</span> n = value.length;</span><br><span class="line">&gt;         <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">&gt;             <span class="keyword">char</span> v1[] = value;</span><br><span class="line">&gt;             <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">&gt;             <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">&gt;             <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">&gt;                 <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">&gt;                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&gt;                 i++;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p> <strong>注意：重写equals()方法，需要重写hashCode()</strong></p></li><li><p>finalize()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>finalize的原理</p><p>（1）对象在初始化的过程中会判断是否重写了finalize，方法是判断两个字段标志has_finalizer_flag和RegisterFinalizersAtInit。</p><p>（2）如果重写了finalize，那就把当前对象注册到FinalizerThread的ReferenceQueue队列中。注册之后的对象就叫做Finalizer。方法是调用register_finalizer函数。此时java虚拟机一看当前有这个对象的引用，于是就不进行垃圾回收了。</p><p>（3）对象开始被调用，FinalizerThread线程负责从ReferenceQueue队列中获取Finalizer对象。开始执行finalize方法，在执行之前，这个对象一直在堆中。</p><p>（4）对象执行完毕之后，将这个Finalizer对象从队列中移除，java虚拟机一看对象没有引用了，就进行垃圾回收了。</p><p>这就是整个过程。不过在这里我们主要看的是finalize方法对垃圾回收的影响，其实就是在第三步，也就是这个对象含有finalize，进入了队列但一直没有被调用的这段时间，会一直占用内存。</p></blockquote><p> <strong>注意：应该避免使用finalize()方法，可能会导致内存溢出。</strong></p></li><li><p>getClass()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回此Object运行时类类型，final修饰不可重写，一般和getName()联合使用，如getName().getClass().</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p> getClass()返回调用对象的包名+类名，jvm可以根据这个唯一定位一个类</p></li><li><p>hashCode()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回对象的哈希码值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p> 这里存在一种情况，重写了equals()方法没有重写，两个对象的内容确实相等了。但是，地址值还是不一样。</p><p> 比如String类中，String a = “a”;String b = new String(“a”); a在字符串常量池中，b在堆中，地址值不一样。比如在使用集合Set或者其他一些需要唯一性判断的地方，内容相等其实就是相等，但是有两个地址值，可能会造成重复。</p><p> 所以说重写equals()方法同时也要注意重写hashCode()方法</p></li><li><p>toString()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回了Object对象的全限定类名+@+16进制表示的物理地址，它建议所有的子类都重写该方法，以致于可以打印出关键信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>notify()</p></li><li><p>notifyAll()</p></li><li><p>wait()</p></li><li><p>wait(long timeout)</p></li><li><p>wait(long timeout, int nanos)</p></li></ol><p>到线程再看这几个……</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 源码 </category>
          
          <category> Object </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 安装FastDFS+nginx</title>
      <link href="/2019/08/14/install_FastDFS+Nginx/"/>
      <url>/2019/08/14/install_FastDFS+Nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS7-安装FastDFS-nginx"><a href="#CentOS7-安装FastDFS-nginx" class="headerlink" title="CentOS7 安装FastDFS+nginx"></a>CentOS7 安装FastDFS+nginx</h2><h4 id="1-先查看有没有安装gcc，FastDFS是C语言开发，编译依赖gcc环境"><a href="#1-先查看有没有安装gcc，FastDFS是C语言开发，编译依赖gcc环境" class="headerlink" title="1.  先查看有没有安装gcc，FastDFS是C语言开发，编译依赖gcc环境"></a>1.  先查看有没有安装gcc，FastDFS是C语言开发，编译依赖gcc环境</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# gcc -v</span><br><span class="line">bash: gcc: 未找到命令...</span><br><span class="line"><span class="meta">#</span>安装gcc、libevent、perl</span><br><span class="line">[root@root ~]# yum install gcc-c++</span><br><span class="line">[root@root ~]# yum -y install libevent</span><br><span class="line">[root@root ~]# yum install perl</span><br></pre></td></tr></table></figure><h4 id="2-解压libfastcommon"><a href="#2-解压libfastcommon" class="headerlink" title="2.  解压libfastcommon"></a>2.  解压libfastcommon</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root opt]# cd fastDFS/</span><br><span class="line">[root@root fastDFS]# ls</span><br><span class="line">fastdfs-nginx-module_v1.16.tar.gz  FastDFS_v5.05.tar.gz  libfastcommonV1.0.7.tar.gz</span><br><span class="line"><span class="meta">#</span>解压libfastcommon</span><br><span class="line">[root@root fastDFS]# tar -zxvf libfastcommonV1.0.7.tar.gz </span><br><span class="line">[root@root fastDFS]# cd libfastcommon-1.0.7/</span><br><span class="line">[root@root libfastcommon-1.0.7]# ls</span><br><span class="line">HISTORY  INSTALL  libfastcommon.spec  make.sh  README  src</span><br><span class="line"><span class="meta">#</span>编译</span><br><span class="line">[root@root libfastcommon-1.0.7]# ./make.sh </span><br><span class="line"><span class="meta">#</span>安装</span><br><span class="line">[root@root libfastcommon-1.0.7]# ./make.sh install</span><br><span class="line">mkdir -p /usr/lib64</span><br><span class="line">install -m 755 libfastcommon.so /usr/lib64</span><br><span class="line">mkdir -p /usr/include/fastcommon</span><br><span class="line">install -m 644 common_define.h hash.h chain.h logger.h base64.h shared_func.h pthread_func.h ini_file_reader.h _os_bits.h sockopt.h sched_thread.h http_func.h md5.h local_ip_func.h avl_tree.h ioevent.h ioevent_loop.h fast_task_queue.h fast_timer.h process_ctrl.h fast_mblock.h connection_pool.h /usr/include/fastcommon</span><br><span class="line">[root@root lib64]# cd /usr/lib64</span><br><span class="line">[root@root lib64]# ls libfastcommon.*</span><br><span class="line">libfastcommon.so</span><br><span class="line"><span class="meta">#</span>拷贝到32位环境中</span><br><span class="line">[root@root lib64]# cp libfastcommon.so /usr/lib</span><br><span class="line">[root@root lib64]# cd /usr/lib</span><br><span class="line">[root@root lib]# ls libfastcommon.*</span><br><span class="line">libfastcommon.so</span><br></pre></td></tr></table></figure><h4 id="3-安装FastDFS"><a href="#3-安装FastDFS" class="headerlink" title="3.安装FastDFS"></a>3.安装FastDFS</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>解压</span><br><span class="line">[root@root fastDFS]# tar -zxvf FastDFS_v5.05.tar.gz </span><br><span class="line">[root@root fastDFS]# cd FastDFS/</span><br><span class="line">[root@root FastDFS]# ls</span><br><span class="line">client  conf             fastdfs.spec  init.d   make.sh     README.md   stop.sh  test</span><br><span class="line">common  COPYING-3_0.txt  HISTORY       INSTALL  php_client  restart.sh  storage  tracker</span><br><span class="line"><span class="meta">#</span>编译</span><br><span class="line">[root@root FastDFS]# ./make.sh </span><br><span class="line"><span class="meta">#</span>安装</span><br><span class="line">[root@root FastDFS]# ./make.sh install</span><br></pre></td></tr></table></figure><h4 id="4-配置tracker节点"><a href="#4-配置tracker节点" class="headerlink" title="4.  配置tracker节点"></a>4.  配置tracker节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root FastDFS]# cd conf/</span><br><span class="line">[root@root conf]# ls</span><br><span class="line">anti-steal.jpg  client.conf  http.conf  mime.types  storage.conf  storage_ids.conf  tracker.conf</span><br><span class="line"><span class="meta">#</span>拷贝所有配置文件到 /etc/fdfs目录下</span><br><span class="line">[root@root conf]# cp * /etc/fdfs/</span><br><span class="line">[root@root conf]# cd /etc/fdfs/</span><br><span class="line">[root@root fdfs]# ls</span><br><span class="line">anti-steal.jpg  client.conf.sample  mime.types    storage.conf.sample  tracker.conf</span><br><span class="line">client.conf     http.conf           storage.conf  storage_ids.conf     tracker.conf.sample</span><br><span class="line"><span class="meta">#</span>修改tracker配置文件修改存储和日志路径</span><br><span class="line">[root@root fdfs]# vim tracker.conf</span><br><span class="line"><span class="meta">#</span> the base path to store data and log files</span><br><span class="line">base_path=/fastdfs/tracker</span><br><span class="line"><span class="meta">#</span>创建存储路径，顺带创建storage和client存储路径</span><br><span class="line">[root@root /]# mkdir /fastdfs/tracker -p</span><br><span class="line">[root@root fastdfs]# mkdir storage</span><br><span class="line">[root@root fastdfs]# mkdir client</span><br><span class="line"><span class="meta">#</span>进入usr/bin文件夹，以/etc/fdfs/tracker.conf配置文件启动tracker</span><br><span class="line">[root@root bin]# /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start</span><br><span class="line"><span class="meta">#</span>重启</span><br><span class="line">[root@root bin]# /usr/bin/fdfs_trackerd fdfs_trackerd /etc/fdfs/tracker.conf restart</span><br></pre></td></tr></table></figure><h4 id="5-配置storage节点"><a href="#5-配置storage节点" class="headerlink" title="5. 配置storage节点"></a>5. 配置storage节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root bin]# cd /etc/fdfs/</span><br><span class="line"><span class="meta">#</span>编辑storage配置文件，修改以下配置</span><br><span class="line">[root@root fdfs]# vim storage.conf</span><br><span class="line">group_name=joey   #组名，可根据实际情况修改，</span><br><span class="line">base_path=/fastdfs/storage #设置storage数据文件和日志目录，需预先创建</span><br><span class="line">store_path0=/fastdfs/storage #存储路径</span><br><span class="line">tracker_server=192.168.116.145:22122 # #tracker 服务器的 IP地址和端口号，如果是单机搭建，IP不要写127.0.0.1，否则启动不成功。</span><br><span class="line"><span class="meta">#</span>启动storage</span><br><span class="line">[root@root bin]# /usr/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br><span class="line"><span class="meta">#</span>重启storage</span><br><span class="line">[root@root bin]# /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart</span><br></pre></td></tr></table></figure><h4 id="6-配置client"><a href="#6-配置client" class="headerlink" title="6. 配置client"></a>6. 配置client</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>编辑client，修改存储路径和tracker_server为本机IP</span><br><span class="line">[root@root fdfs]# vim client.conf</span><br><span class="line"><span class="meta">#</span> the base path to store log files</span><br><span class="line">base_path=/fastdfs/client</span><br><span class="line"><span class="meta">#</span> tracker_server can ocur more than once, and tracker_server format is</span><br><span class="line"><span class="meta">#</span>  "host:port", host can be hostname or ip address</span><br><span class="line">tracker_server=192.168.1.20:22122</span><br></pre></td></tr></table></figure><h4 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. 测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root home]# /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/guanli.png </span><br><span class="line">This is FastDFS client test program v5.05</span><br><span class="line"></span><br><span class="line">Copyright (C) 2008, Happy Fish / YuQing</span><br><span class="line"></span><br><span class="line">FastDFS may be copied only under the terms of the GNU General</span><br><span class="line">Public License V3, which may be found in the FastDFS source kit.</span><br><span class="line">Please visit the FastDFS Home Page http://www.csource.org/ </span><br><span class="line">for more detail.</span><br><span class="line"></span><br><span class="line">[2019-08-14 15:55:42] DEBUG - base_path=/fastdfs/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0</span><br><span class="line"></span><br><span class="line">tracker_query_storage_store_list_without_group: </span><br><span class="line">server 1. group_name=, ip_addr=192.168.1.20, port=23000</span><br><span class="line"></span><br><span class="line">group_name=joey, ip_addr=192.168.1.20, port=23000</span><br><span class="line">storage_upload_by_filename</span><br><span class="line">group_name=joey, remote_filename=M00/00/00/wKgBFF1Tvn6AL_ulAAhuqKakO_M091.png</span><br><span class="line">source ip address: 192.168.1.20</span><br><span class="line">file timestamp=2019-08-14 15:55:42</span><br><span class="line">file size=552616</span><br><span class="line">file crc32=2795781107</span><br><span class="line">example file url: http://192.168.1.20/joey/M00/00/00/wKgBFF1Tvn6AL_ulAAhuqKakO_M091.png</span><br><span class="line">storage_upload_slave_by_filename</span><br><span class="line">group_name=joey, remote_filename=M00/00/00/wKgBFF1Tvn6AL_ulAAhuqKakO_M091_big.png</span><br><span class="line">source ip address: 192.168.1.20</span><br><span class="line">file timestamp=2019-08-14 15:55:42</span><br><span class="line">file size=552616</span><br><span class="line">file crc32=2795781107</span><br><span class="line">example file url: http://192.168.1.20/joey/M00/00/00/wKgBFF1Tvn6AL_ulAAhuqKakO_M091_big.png</span><br><span class="line"><span class="meta">#</span>返回链接就是成功了，但是还是访问不了，需要安装nginx服务器</span><br></pre></td></tr></table></figure><h4 id="8-安装nginx"><a href="#8-安装nginx" class="headerlink" title="8.  安装nginx"></a>8.  安装nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>解压安装fastdfs-nginx-module</span><br><span class="line">[root@root fastDFS]# tar -zxvf fastdfs-nginx-module_v1.16.tar.gz </span><br><span class="line"><span class="meta">#</span> 编辑 Nginx 模块的配置文件</span><br><span class="line"><span class="meta">#</span> 复制配置文件至/etc/fdfs/，编辑config文件删除路径中的local</span><br><span class="line">[root@root src]# cp * /etc/fdfs/</span><br><span class="line">[root@root src]# vim /fastdfs-nginx-module/src/config</span><br><span class="line">ngx_addon_name=ngx_http_fastdfs_module</span><br><span class="line">HTTP_MODULES="$HTTP_MODULES ngx_http_fastdfs_module"</span><br><span class="line">NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_fastdfs_module.c"</span><br><span class="line">CORE_INCS="$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/"</span><br><span class="line">CORE_LIBS="$CORE_LIBS -L/usr/lib -lfastcommon -lfdfsclient"</span><br><span class="line">CFLAGS="$CFLAGS -D_FILE_OFFSET_BITS=64 -DFDFS_OUTPUT_CHUNK_SIZE='256*1024' -DFDFS_MOD_CONF_FILENAME='\"/etc/fdfs/mod_fastdfs.conf\"'"</span><br><span class="line"><span class="meta">#</span>安装nginx依赖</span><br><span class="line">[root@root fastDFS]# yum install -y pcre pcre-devel</span><br><span class="line">[root@root fastDFS]# yum install -y zlib zlib-devel</span><br><span class="line">[root@root fastDFS]# yum install -y openssl openssl-devel</span><br><span class="line"><span class="meta">#</span> 解压nginx wget http://nginx.org/download/nginx-1.8.0.tar.gz</span><br><span class="line">[root@root fastDFS]# tar -zxvf nginx-1.8.0.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>nginx配置记得修改最后的module路径</span><br><span class="line"><span class="meta">#</span>复制粘贴在nginx目录下执行</span><br><span class="line">[root@root nginx-1.8.0]# ./configure \</span><br><span class="line"><span class="meta">&gt;</span> --prefix=/usr/local/nginx \</span><br><span class="line"><span class="meta">&gt;</span> --pid-path=/var/local/nginx/nginx.pid \</span><br><span class="line"><span class="meta">&gt;</span> --lock-path=/var/lock/nginx/nginx.lock \</span><br><span class="line"><span class="meta">&gt;</span> --error-log-path=/var/log/nginx/error.log \</span><br><span class="line"><span class="meta">&gt;</span> --http-log-path=/var/log/nginx/access.log \</span><br><span class="line"><span class="meta">&gt;</span> --with-http_gzip_static_module \</span><br><span class="line"><span class="meta">&gt;</span> --http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line"><span class="meta">&gt;</span> --http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line"><span class="meta">&gt;</span> --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line"><span class="meta">&gt;</span> --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line"><span class="meta">&gt;</span> --http-scgi-temp-path=/var/temp/nginx/scgi \</span><br><span class="line"><span class="meta">&gt;</span> --add-module=/opt/fastDFS/fastdfs-nginx-module/src</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>编译</span><br><span class="line">[root@root nginx-1.8.0]# make</span><br><span class="line"><span class="meta">#</span>安装</span><br><span class="line">[root@root nginx-1.8.0]# make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看安装文件</span><br><span class="line">[root@root nginx-1.8.0]# cd /usr/local/</span><br><span class="line">[root@root local]# ls</span><br><span class="line">bin  etc  games  include  lib  lib64  libexec  nginx  sbin  share  src</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>复制粘贴配置文件</span><br><span class="line">[root@root local]# cd /opt/fastDFS/fastdfs-nginx-module/src/</span><br><span class="line">[root@root src]# ls</span><br><span class="line">common.c  common.h  config  mod_fastdfs.conf  ngx_http_fastdfs_module.c</span><br><span class="line">[root@root src]# cp mod_fastdfs.conf /etc/fdfs/</span><br><span class="line">[root@root src]# vim /etc/fdfs/mod_fastdfs.conf</span><br><span class="line"><span class="meta">#</span>修改日志存储路径</span><br><span class="line"><span class="meta">#</span> the base path to store log files</span><br><span class="line">base_path=/fastdfs/tmp</span><br><span class="line"><span class="meta">#</span>修改tracker路径</span><br><span class="line"><span class="meta">#</span> FastDFS tracker_server can ocur more than once, and tracker_server format is</span><br><span class="line"><span class="meta">#</span>  "host:port", host can be hostname or ip address</span><br><span class="line"><span class="meta">#</span> valid only when load_fdfs_parameters_from_tracker is true</span><br><span class="line">tracker_server=192.168.1.20:22122</span><br><span class="line"><span class="meta">#</span> the group name of the local storage server</span><br><span class="line">group_name=joey</span><br><span class="line"><span class="meta">#</span> if the url / uri including the group name</span><br><span class="line"><span class="meta">#</span> set to false when uri like /M00/00/00/xxx</span><br><span class="line"><span class="meta">#</span> set to true when uri like $&#123;group_name&#125;/M00/00/00/xxx, such as group1/M00/xxx</span><br><span class="line"><span class="meta">#</span> default value is false</span><br><span class="line"><span class="meta">#</span> store_path#, based 0, if store_path0 not exists, it's value is base_path</span><br><span class="line"><span class="meta">#</span> the paths must be exist</span><br><span class="line"><span class="meta">#</span> must same as storage.conf</span><br><span class="line">store_path0=/fastdfs/storage</span><br><span class="line"><span class="meta">#</span>store_path1=/home/yuqing/fastdfs1</span><br><span class="line"><span class="meta">#</span>编辑配置文件添加下面这段，注意nginx使用的配置文件是哪个，/usr/local/nginx/conf/nginx.conf</span><br><span class="line">[root@root conf]# vim nginx.conf</span><br><span class="line">        server &#123;</span><br><span class="line">            listen       88;</span><br><span class="line">            server_name  192.168.1.20 ;</span><br><span class="line"></span><br><span class="line">            location / &#123;</span><br><span class="line">                nginx_fastdfs_module;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#</span>检查</span><br><span class="line">[root@root conf]cd /usr/local/nginx/sbin/</span><br><span class="line">[root@root sbin]# ./nginx -t</span><br><span class="line">ngx_http_fastdfs_set pid=33746</span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: [emerg] mkdir() "/var/temp/nginx/client" failed (2: No such file or directory)</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test failed</span><br><span class="line"><span class="meta">#</span>[emerg] mkdir() "/var/temp/nginx/client" failed (2: No such file or directory)</span><br><span class="line"><span class="meta">#</span>报错显示没有目录/var/temp/nginx/client</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>去创建目录</span><br><span class="line">[root@root sbin]# mkdir /var/temp/nginx -p</span><br><span class="line"><span class="meta">#</span>再次检查</span><br><span class="line">[root@root sbin]# ./nginx -t</span><br><span class="line">ngx_http_fastdfs_set pid=33766</span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>检查失败，访问失败，去查看防火墙状态：active (running)</span><br><span class="line">[root@root sbin]# sudo systemctl status firewalld</span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 三 2019-08-14 11:34:40 CST; 5h 51min ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line"> Main PID: 771 (firewalld)</span><br><span class="line">    Tasks: 2</span><br><span class="line">   CGroup: /system.slice/firewalld.service</span><br><span class="line">           └─771 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line"></span><br><span class="line">8月 14 11:34:38 root systemd[1]: Starting firewalld - dynamic firewall daemon...</span><br><span class="line">8月 14 11:34:40 root systemd[1]: Started firewalld - dynamic firewall daemon.</span><br><span class="line"><span class="meta">#</span>暂时关闭防火墙，下次重启会失效或者disable掉</span><br><span class="line">[root@root sbin]# sudo systemctl stop firewalld</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190814172907.png" alt="访问nginx成功"></p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190814173428.png" alt="访问图片失败"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>修改配置</span><br><span class="line">[root@root fdfs]# vim mod_fastdfs.conf </span><br><span class="line"><span class="meta">#</span> store_path#, based 0, if store_path0 not exists, it's value is base_path</span><br><span class="line"><span class="meta">#</span> the paths must be exist</span><br><span class="line"><span class="meta">#</span> must same as storage.conf</span><br><span class="line">store_path0=/fastdfs/storage</span><br><span class="line"><span class="meta">#</span>store_path1=/home/yuqing/fastdfs1</span><br><span class="line"><span class="meta">#</span>重启所有服务</span><br><span class="line">[root@root fdfs]# /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart</span><br><span class="line">waiting for pid [28338] exit ...</span><br><span class="line">starting ...</span><br><span class="line">[root@root fdfs]# /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart</span><br><span class="line">waiting for pid [28841] exit ...</span><br><span class="line">starting ...</span><br><span class="line">[root@root fdfs]# cd /usr/local/nginx/sbin/</span><br><span class="line">[root@root sbin]# ./nginx -s reload</span><br><span class="line">ngx_http_fastdfs_set pid=34197</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190814174007.png" alt="图片访问成功"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> FastDFS </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> FastDFS </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理财产品系统（慕课网）</title>
      <link href="/2019/07/29/%E7%90%86%E8%B4%A2%E4%BA%A7%E5%93%81%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/29/%E7%90%86%E8%B4%A2%E4%BA%A7%E5%93%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="理财产品系统（慕课网）"><a href="#理财产品系统（慕课网）" class="headerlink" title="理财产品系统（慕课网）"></a><a href="https://coding.imooc.com/class/211.html" target="_blank" rel="noopener">理财产品系统（慕课网）</a></h1><p>junit、swagger、JSON-RPC、MySql、hazelcast、HTTPS、RSA签名、权限控制、节流限速、访问统计、TYK</p><p>快速：</p><ol><li>开发快</li><li>迭代快</li></ol><p>高效：</p><ol><li>高并发 </li><li>响应快</li></ol><p>安全：</p><ol><li>加密</li><li>权限</li></ol><p>模块化开发：</p><ol><li>Manager</li><li>Seller</li><li>Entity</li><li>Api</li><li>Util</li><li>Quartz</li><li>Swagger</li></ol><p>数据库设计：</p><ul><li><p>产品表</p><table><thead><tr><th>表名</th><th>product</th><th>表名中文</th><th>产品表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>id</td><td>编号</td><td>varchar</td><td>50</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>name</td><td>名称</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td>threshold_amount</td><td>起投金额</td><td>decimal</td><td>15,4</td><td></td><td>M</td><td>0</td><td></td></tr><tr><td>4</td><td>step_amount</td><td>投资步长</td><td>decimal</td><td>15,4</td><td></td><td>N</td><td>0</td><td></td></tr><tr><td>5</td><td>lock_term</td><td>锁定期</td><td>smallint</td><td></td><td></td><td>N</td><td>0</td><td>单位天</td></tr><tr><td>6</td><td>reward_rate</td><td>收益率</td><td>decimal</td><td>5,4</td><td></td><td>N</td><td></td><td>0-100，百分比</td></tr><tr><td>7</td><td>status</td><td>状态</td><td>varchar</td><td>20</td><td></td><td>N</td><td></td><td>审核中：Audinting，销售中：In_Sell，暂停销售：Locked，已结束：Finished</td></tr><tr><td>8</td><td>memo</td><td>备注</td><td>varchar</td><td>200</td><td></td><td>N</td><td></td><td></td></tr><tr><td>9</td><td>create_at</td><td>创建时间</td><td>datetime</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td>create_user</td><td>创建者ID</td><td>varchar</td><td>20</td><td></td><td></td><td></td><td></td></tr><tr><td>11</td><td>update_at</td><td>更新时间</td><td>datetime</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>12</td><td>update_user</td><td>更新者ID</td><td>varchar</td><td>20</td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>订单表</p><table><thead><tr><th>表名</th><th>order_t</th><th>表名中文</th><th>订单表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>order_id</td><td>订单编号</td><td>varchar</td><td>50</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>chan_id</td><td>渠道编号</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>套壳公司编号</td></tr><tr><td>3</td><td>product_id</td><td>产品编号</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td></td></tr><tr><td>4</td><td>chan_user_id</td><td>用户编号</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>套壳公司的用户编号</td></tr><tr><td>5</td><td>order_type</td><td>订单类型</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>申购：Apply，赎回：Redeem</td></tr><tr><td>6</td><td>order_status</td><td>订单状态</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>初始化：Init，处理中：Process，成功：Success，失败：Fail</td></tr><tr><td>7</td><td>outer_order_id</td><td>外部订单编号</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>套壳公司的订单编号</td></tr><tr><td>8</td><td>amount</td><td>订单金额</td><td>decimal</td><td>15，4</td><td></td><td>N</td><td></td><td></td></tr><tr><td>9</td><td>memo</td><td>备注</td><td>varchar</td><td>200</td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td>create_at</td><td>创建时间</td><td>datetime</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>11</td><td>update_at</td><td>更新时间</td><td>datetime</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>创建项目添加依赖</p><p>SpringBoot    1.5.4 Release</p><p>spring-boot-starter-web</p><p>Spring-boot-starter-data-jpa</p><p>commons-lang3    3.5</p><p>mysql-connector-java    5.1.29</p><p>spring-boot-starter-test</p></li><li><p>创建每个模块</p><ol><li>Manager</li><li>Seller</li><li>Entity</li><li>Api</li><li>Util</li><li>Quartz</li><li>Swagger</li></ol></li><li><p>创建Entity实体类</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate各种主键生成策略与配置详解（转自[starskyhu])</title>
      <link href="/2019/07/26/Hibernate%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
      <url>/2019/07/26/Hibernate%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Hibernate各种主键生成策略与配置详解（转自-starskyhu"><a href="#Hibernate各种主键生成策略与配置详解（转自-starskyhu" class="headerlink" title="Hibernate各种主键生成策略与配置详解（转自[starskyhu])"></a><a href="https://www.cnblogs.com/hoobey/p/5508992.html" target="_blank" rel="noopener"><strong>Hibernate各种主键生成策略与配置详解（转自[starskyhu])</strong></a></h2><blockquote><p>在项目中使用Hibernate+Oracle，在是生成GUID时遇到问题，查询解决后记录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="meta">@GenericGenerator</span>(name = <span class="string">"generator"</span>, strategy = <span class="string">"uuid.hex"</span>)</span><br><span class="line">&gt; <span class="meta">@Id</span></span><br><span class="line">&gt; <span class="meta">@GeneratedValue</span>(generator = <span class="string">"generator"</span>)</span><br><span class="line">&gt; <span class="meta">@Column</span>(name = <span class="string">"ID"</span>, unique = <span class="keyword">true</span>, nullable = <span class="keyword">false</span>, length = <span class="number">36</span>)</span><br><span class="line">&gt; <span class="keyword">private</span> String ID;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1、assigned"><a href="#1、assigned" class="headerlink" title="1、assigned"></a><strong>1、assigned</strong></h3><p>主键由外部程序负责生成，在 save() 之前必须指定一个。Hibernate不负责维护主键生成。与Hibernate和底层数据库都无关，可以跨数据库。在存储对象前，必须要使用主键的setter方法给主键赋值，至于这个值怎么生成，完全由自己决定，这种方法应该尽量避免。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"assigned"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>“ud”是自定义的策略名，人为起的名字，后面均用“ud”表示。</p><p><strong>特点：可以跨数据库，人为控制主键生成，应尽量避免。</strong></p><h3 id="2、increment"><a href="#2、increment" class="headerlink" title="2、increment"></a><strong>2、increment</strong></h3><p>由Hibernate从数据库中取出主键的最大值（每个session只取1次），以该值为基础，每次增量为1，在内存中生成主键，不依赖于底层的数据库，因此可以跨数据库。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"increment"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Hibernate调用org.hibernate.id.IncrementGenerator类里面的generate()方法，使用select max(idColumnName) from tableName语句获取主键最大值。该方法被声明成了synchronized，所以在一个独立的Java虚拟机内部是没有问题的，然而，在多个JVM同时并发访问数据库select max时就可能取出相同的值，再insert就会发生Dumplicate entry的错误。所以只能有一个Hibernate应用进程访问数据库，否则就可能产生主键冲突，所以不适合多进程并发更新数据库，适合单一进程访问数据库，不能用于群集环境。</p><p>官方文档：只有在没有其他进程往同一张表中插入数据时才能使用，在集群下不要使用。</p><p><strong>特点：跨数据库，不适合多进程并发更新数据库，适合单一进程访问数据库，不能用于群集环境。</strong></p><h3 id="3、hilo"><a href="#3、hilo" class="headerlink" title="3、hilo"></a><strong>3、hilo</strong></h3><p>hilo（高低位方式high low）是hibernate中最常用的一种生成方式，需要一张额外的表保存hi的值。保存hi值的表至少有一条记录（只与第一条记录有关），否则会出现错误。<strong>可以跨数据库。</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"hilo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"table"</span>&gt;</span>hibernate_hilo<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"column"</span>&gt;</span>next_hi<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max_lo"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"table"</span>&gt;</span>hibernate_hilo<span class="tag">&lt;/<span class="name">param</span>&gt;</span> 指定保存hi值的表名</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"column"</span>&gt;</span>next_hi<span class="tag">&lt;/<span class="name">param</span>&gt;</span> 指定保存hi值的列名</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max_lo"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">param</span>&gt;</span> 指定低位的最大值</span><br></pre></td></tr></table></figure><p>也可以省略table和column配置，其默认的表为hibernate_unique_key，列为next_hi</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"hilo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max_lo"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hilo生成器生成主键的过程（以hibernate_unique_key表，next_hi列为例）：</p><ol><li><p>获得hi值：读取并记录数据库的hibernate_unique_key表中next_hi字段的值，数据库中此字段值加1保存。</p></li><li><p>获得lo值：从0到max_lo循环取值，差值为1，当值为max_lo值时，重新获取hi值，然后lo值继续从0到max_lo循环。</p></li><li><p>根据公式 hi * (max_lo + 1) + lo计算生成主键值。</p></li></ol><p>注意：当hi值是0的时候，那么第一个值不是0*(max_lo+1)+0=0，而是lo跳过0从1开始，直接是1、2、3……</p><p>那max_lo配置多大合适呢？</p><p>这要根据具体情况而定，如果系统一般不重启，而且需要用此表建立大量的主键，可以吧max_lo配置大一点，这样可以减少读取数据表的次数，提高效率；反之，如果服务器经常重启，可以吧max_lo配置小一点，可以避免每次重启主键之间的间隔太大，造成主键值主键不连贯。</p><p><strong>特点：跨数据库，hilo算法生成的标志只能在一个数据库中保证唯一。</strong></p><h3 id="4、seqhilo"><a href="#4、seqhilo" class="headerlink" title="4、seqhilo"></a><strong>4、seqhilo</strong></h3><p>与hilo类似，通过hi/lo算法实现的主键生成机制，只是将hilo中的数据表换成了序列sequence，需要数据库中先创建sequence，适用于支持sequence的数据库，如Oracle。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"seqhilo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"sequence"</span>&gt;</span>hibernate_seq<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max_lo"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>特点：与hilo类似，只能在支持序列的数据库中使用。</strong></p><h3 id="5、sequence"><a href="#5、sequence" class="headerlink" title="5、sequence"></a><strong>5、sequence</strong></h3><p>采用数据库提供的sequence机制生成主键，需要数据库支持sequence。如oralce、DB、SAP DB、PostgerSQL、McKoi中的sequence。MySQL这种不支持sequence的数据库则不行（可以使用identity）。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"sequence"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"sequence"</span>&gt;</span>hibernate_id<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"sequence"</span>&gt;</span>hibernate_id<span class="tag">&lt;/<span class="name">param</span>&gt;</span> 指定sequence的名称**</span><br></pre></td></tr></table></figure><p>Hibernate生成主键时，查找sequence并赋给主键值，主键值由数据库生成，Hibernate不负责维护，使用时必须先创建一个sequence，如果不指定sequence名称，则使用Hibernate默认的sequence，名称为hibernate_sequence，前提要在数据库中创建该sequence。</p><p><strong>特点：只能在支持序列的数据库中使用，如Oracle。</strong></p><h3 id="6、identity"><a href="#6、identity" class="headerlink" title="6、identity"></a><strong>6、identity</strong></h3><p>identity由底层数据库生成标识符。identity是由数据库自己生成的，但这个主键必须设置为自增长，使用identity的前提条件是底层数据库支持自动增长字段类型，如DB2、SQL Server、MySQL、Sybase和HypersonicSQL等，Oracle这类没有自增字段的则不支持。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"identity"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例：如果使用MySQL数据库，则主键字段必须设置成auto_increment。</p><p>id int(11) primary key auto_increment</p><p><strong>特点：只能用在支持自动增长的字段数据库中使用，如MySQL。</strong></p><h3 id="7、native"><a href="#7、native" class="headerlink" title="7、native"></a><strong>7、native</strong></h3><p>native由hibernate根据使用的数据库自行判断采用identity、hilo、sequence其中一种作为主键生成方式，灵活性很强。如果能支持identity则使用identity，如果支持sequence则使用sequence。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如MySQL使用identity，Oracle使用sequence</p><p>注意：如果Hibernate自动选择sequence或者hilo，则所有的表的主键都会从Hibernate默认的sequence或hilo表中取。并且，有的数据库对于默认情况主键生成测试的支持，效率并不是很高。</p><p>使用sequence或hilo时，可以加入参数，指定sequence名称或hi值表名称等，如</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"sequence"</span>&gt;</span>hibernate_id<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>特点：根据数据库自动选择，项目中如果用到多个数据库时，可以使用这种方式，使用时需要设置表的自增字段或建立序列，建立表等。</strong></p><p><strong>8、uuid</strong></p><p>UUID：Universally Unique Identifier，是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字，标准的UUID格式为：</p><p><strong>xxxxxxxx-xxxx-xxxx-xxxxxx-xxxxxxxxxx (8-4-4-4-12)</strong></p><p>其中每个 <strong>x</strong> 是 0-9 或 a-f 范围内的一个十六进制的数字。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"uuid"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Hibernate在保存对象时，生成一个UUID字符串作为主键，保证了唯一性，但其并无任何业务逻辑意义，只能作为主键，唯一缺点长度较大，32位（Hibernate将UUID中间的“-”删除了）的字符串，占用存储空间大，但是有两个很重要的优点，Hibernate在维护主键时，不用去数据库查询，从而提高效率，而且它是跨数据库的，以后切换数据库极其方便。</p><p><strong>特点：uuid长度大，占用空间大，跨数据库，不用访问数据库就生成主键值，所以效率高且能保证唯一性，移植非常方便，推荐使用。</strong></p><p><strong>9、guid</strong></p><p>GUID：Globally Unique Identifier全球唯一标识符，也称作 UUID，是一个128位长的数字，用16进制表示。算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成GUID。从理论上讲，如果一台机器每秒产生10000000个GUID，则可以保证（概率意义上）3240年不重复。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"guid"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Hibernate在维护主键时，先查询数据库，获得一个uuid字符串，该字符串就是主键值，该值唯一，缺点长度较大，支持数据库有限，优点同uuid，跨数据库，但是仍然需要访问数据库。</p><p><strong>注意：长度因数据库不同而不同</strong></p><p>MySQL中使用select uuid()语句获得的为36位（包含标准格式的“-”）</p><p>Oracle中，使用select rawtohex(sys_guid()) from dual语句获得的为32位（不包含“-”） </p><p><strong>特点：需要数据库支持查询uuid，生成时需要查询数据库，效率没有uuid高，推荐使用uuid。</strong></p><h3 id="10、foreign"><a href="#10、foreign" class="headerlink" title="10、foreign"></a><strong>10、foreign</strong></h3><p>使用另外一个相关联的对象的主键作为该对象主键。主要用于一对一关系中。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"foreign"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"property"</span>&gt;</span>user<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"domain.User"</span> <span class="attr">constrained</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>该例使用domain.User的主键作为本类映射的主键。</p><p><strong>特点：很少使用，大多用在一对一关系中。</strong></p><h3 id="11、select"><a href="#11、select" class="headerlink" title="11、select"></a><strong>11、select</strong></h3><p>使用触发器生成主键，主要用于早期的数据库主键生成机制，能用到的地方非常少。</p><h3 id="12、其他注释方式配置"><a href="#12、其他注释方式配置" class="headerlink" title="12、其他注释方式配置"></a><strong>12、其他注释方式配置</strong></h3><p>注释方式与配置文件底层实现方式相同，只是配置的方式换成了注释方式</p><p>自动增长，适用于支持自增字段的数据库</p><p><strong>@Id</strong></p><p><strong>@GeneratedValue(strategy = GenerationType.IDENTITY)</strong></p><p>根据底层数据库自动选择方式，需要底层数据库的设置</p><p>如MySQL，会使用自增字段，需要将主键设置成auto_increment。</p><p><strong>@Id</strong></p><p><strong>@GeneratedValue(strategy = GenerationType.AUTO)</strong></p><p>使用表存储生成的主键，可以跨数据库。</p><p>每次需要主键值时，查询名为<strong>“hibernate_table”</strong>的表，查找主键列<strong>“gen_pk”</strong>值为<strong>“2”</strong>记录，得到这条记录的<strong>“gen_val”</strong>值，根据这个值，和<strong>allocationSize</strong>的值生成主键值。</p><p><strong>@Id</strong></p><p><strong>@GeneratedValue(strategy = GenerationType.<em>TABLE</em>, generator = “ud”)</strong></p><p><strong>@TableGenerator(name = “ud”,</strong></p><p><strong>table = “hibernate_table”,</strong></p><p><strong>pkColumnName = “gen_pk”,</strong></p><p><strong>pkColumnValue = “2”,</strong></p><p><strong>valueColumnName = “gen_val”,</strong></p><p><strong>initialValue = 2,</strong></p><p><strong>allocationSize = 5)</strong></p><p>使用序列存储主键值</p><p><strong>@Id</strong></p><p><strong>@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = “ud”)</strong></p><p><strong>@SequenceGenerator(name = “ud”,</strong></p><p><strong>sequenceName = “hibernate_seq”,</strong></p><p><strong>allocationSize = 1,</strong></p><p><strong>initialValue = 2)</strong></p><h3 id="13、小结"><a href="#13、小结" class="headerlink" title="13、小结"></a><strong>13、小结</strong></h3><p><strong>1、为了保证对象标识符的唯一性与不可变性，应该让Hibernate来为主键赋值，而不是程序。</strong></p><p><strong>2、正常使用Hibernate维护主键，最好将主键的setter方法设置成private，从而避免人为或程序修改主键，而使用assigned方式，就不能用private，否则无法给主键赋值。</strong></p><p><strong>2、Hibernate中唯一一种最简单通用的主键生成器就是uuid。虽然是个32位难读的长字符串，但是它没有跨数据库的问题，将来切换数据库极其简单方便，推荐使用！</strong></p><p><strong>3、自动增长字段类型与序列</strong></p><table><thead><tr><th><strong>数据库</strong></th><th><strong>自动增长字段</strong></th><th><strong>序列</strong></th></tr></thead><tbody><tr><td><strong>MySQL</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>Oracle</strong></td><td></td><td><strong>是</strong></td></tr><tr><td><strong>DB2</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td><strong>MS SQL Server</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>Sybase</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>HypersonicSQL</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>PostgreSQL</strong></td><td></td><td><strong>是</strong></td></tr><tr><td><strong>SAP DB</strong></td><td></td><td><strong>是</strong></td></tr><tr><td><strong>HSQLDB</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>Infomix</strong></td><td><strong>是</strong></td><td></td></tr></tbody></table><p><strong>4、关于hilo机制注意：</strong></p><p><strong>hilo算法生成的标志只能在一个数据库中保证唯一。</strong></p><p><strong>当用户为Hibernate自行提供连接，或者Hibernate通过JTA，从应用服务器的数据源获取数据库连接时，无法使用hilo，因为这不能保证hilo单独在新的数据库连接的事务中访问hi值表，这种情况，如果数据库支持序列，可以使用seqhilo。</strong></p><p><strong>5、使用identity、native、GenerationType.AUTO等方式生成主键时，只要用到自增字段，数据库表的字段必须设置成自动增加的，否则出错。</strong></p><p><strong>6、还有一些方法未列出来，例如uuid.hex，sequence-identity等，这些方法不是很常用，且已被其他方法代替，如uuid.hex，官方文档里建议不使用，而直接使用uuid方法。</strong></p><p><strong>7、Hibernate的各版本主键生成策略配置有略微差别，但实现基本相同。如，有的版本默认sequence不指定序列名，则使用名为hibernate_sequence的序列，有的版本则必须指定序列名。</strong></p><p><strong>8、还可以自定义主键生成策略，这里暂时不讨论，只讨论官方自带生成策略。</strong> </p>]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
          <category> Hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ORM </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维码扫描下载APP页面</title>
      <link href="/2019/07/25/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E4%B8%8B%E8%BD%BDAPP/"/>
      <url>/2019/07/25/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E4%B8%8B%E8%BD%BDAPP/</url>
      
        <content type="html"><![CDATA[<h1 id="二维码扫描下载APP页面"><a href="#二维码扫描下载APP页面" class="headerlink" title="二维码扫描下载APP页面"></a>二维码扫描下载APP页面</h1><p><strong>将该页面链接转成二维码即可实现扫描同一个二维码下载苹果或者安卓APP</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>APP下载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">        /*</span><br><span class="line">         * 智能机浏览器版本信息:</span><br><span class="line">         *</span><br><span class="line">         */</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> browser = &#123;</span></span><br><span class="line"><span class="javascript">            versions: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> u = navigator.userAgent, app = navigator.appVersion;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="comment">//移动终端浏览器版本信息</span></span></span><br><span class="line"><span class="javascript">                    trident: u.indexOf(<span class="string">'Trident'</span>) &gt; <span class="number">-1</span>, <span class="comment">//IE内核</span></span></span><br><span class="line"><span class="javascript">                    presto: u.indexOf(<span class="string">'Presto'</span>) &gt; <span class="number">-1</span>, <span class="comment">//opera内核</span></span></span><br><span class="line"><span class="javascript">                    webKit: u.indexOf(<span class="string">'AppleWebKit'</span>) &gt; <span class="number">-1</span>, <span class="comment">//苹果、谷歌内核</span></span></span><br><span class="line"><span class="javascript">                    gecko: u.indexOf(<span class="string">'Gecko'</span>) &gt; <span class="number">-1</span> &amp;&amp; u.indexOf(<span class="string">'KHTML'</span>) == <span class="number">-1</span>, <span class="comment">//火狐内核</span></span></span><br><span class="line"><span class="javascript">                    mobile: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>) || !!u.match(<span class="regexp">/AppleWebKit/</span>), <span class="comment">//是否为移动终端</span></span></span><br><span class="line"><span class="javascript">                    ios: !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span></span><br><span class="line"><span class="javascript">                    android: u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Linux'</span>) &gt; <span class="number">-1</span>, <span class="comment">//android终端或者uc浏览器</span></span></span><br><span class="line"><span class="javascript">                    iPhone: u.indexOf(<span class="string">'iPhone'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Mac'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否为iPhone或者QQHD浏览器</span></span></span><br><span class="line"><span class="javascript">                    iPad: u.indexOf(<span class="string">'iPad'</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否iPad</span></span></span><br><span class="line"><span class="javascript">                    webApp: u.indexOf(<span class="string">'Safari'</span>) == <span class="number">-1</span> <span class="comment">//是否web应该程序，没有头部与底部</span></span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;(),</span><br><span class="line">            language: (navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (browser.versions.ios || browser.versions.iPhone || browser.versions.iPad) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//  此处写ios的下载地址，从AppStore获取              </span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.location = <span class="string">""</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">else</span> <span class="keyword">if</span> (browser.versions.android) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 此处写Andoird 的下载地址               </span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.location = <span class="string">""</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">"语言版本: "</span> + browser.language);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">" 是否为移动终端: "</span> + browser.versions.mobile);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">" ios终端: "</span> + browser.versions.ios);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">" android终端: "</span> + browser.versions.android);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">" 是否为iPhone: "</span> + browser.versions.iPhone);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">" 是否iPad: "</span> + browser.versions.iPad);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(navigator.userAgent);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 二维码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.2安装ActiveMQ 5.14.5</title>
      <link href="/2019/07/23/install_ActiveMQ/"/>
      <url>/2019/07/23/install_ActiveMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-2安装ActiveMQ-5-14-5"><a href="#CentOS-7-2安装ActiveMQ-5-14-5" class="headerlink" title="CentOS 7.2安装ActiveMQ 5.14.5"></a>CentOS 7.2安装ActiveMQ 5.14.5</h2><h4 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos activemq]# wget http://apache.fayea.com/activemq/5.14.5/apache-activemq-5.14.5-bin.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E4%B8%8B%E8%BD%BD.png" alt="img"></p><blockquote><p>具体版本下载可进入<a href="http://apache.fayea.com/activemq/查看" target="_blank" rel="noopener">http://apache.fayea.com/activemq/查看</a></p></blockquote><h4 id="2-解压压缩包"><a href="#2-解压压缩包" class="headerlink" title="2. 解压压缩包"></a>2. 解压压缩包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos activemq]# tar -zxvf apache-activemq-5.14.5-bin.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E8%A7%A3%E5%8E%8B.png" alt="img"></p><h4 id="3-进入bin文件下的Linux文件下启动"><a href="#3-进入bin文件下的Linux文件下启动" class="headerlink" title="3. 进入bin文件下的Linux文件下启动"></a>3. 进入bin文件下的Linux文件下启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos activemq]# ls</span><br><span class="line">apache-activemq-5.14.5  apache-activemq-5.14.5-bin.tar.gz</span><br><span class="line">[root@VM_0_5_centos activemq]# cd apache-activemq-5.14.5/</span><br><span class="line">[root@VM_0_5_centos apache-activemq-5.14.5]# ls</span><br><span class="line">activemq-all-5.14.5.jar  conf  docs      lib      NOTICE      webapps</span><br><span class="line">bin                      data  examples  LICENSE  README.txt  webapps-demo</span><br><span class="line">[root@VM_0_5_centos apache-activemq-5.14.5]# cd bin/linux-x86-64/</span><br><span class="line">[root@VM_0_5_centos linux-x86-64]# ./activemq start</span><br><span class="line">Starting ActiveMQ Broker...</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E5%90%AF%E5%8A%A8.png" alt="img"></p><h4 id="4-查看启动状态"><a href="#4-查看启动状态" class="headerlink" title="4. 查看启动状态"></a>4. 查看启动状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>activemq未启动</span><br><span class="line">[root@VM_0_5_centos bin]# ps -ef|grep activemq</span><br><span class="line">root      2756 25178  0 16:44 pts/0    00:00:00 grep --color=auto activemq</span><br></pre></td></tr></table></figure><h4 id="5-查看启动日志，解决报错"><a href="#5-查看启动日志，解决报错" class="headerlink" title="5. 查看启动日志，解决报错"></a>5. 查看启动日志，解决报错</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos bin]# ./activemq console</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0.png" alt="img"></p><ol><li><strong>报错原因</strong>-服务器主机名有下划线存在特殊字符</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR | Failed to start Apache ActiveMQ ([localhost, ID:VM_0_5_centos-39529-1548405340021-0:1], java.net.URISyntaxException: Illegal character in hostname at index 7: ws://VM_0_5_centos:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>修改conf目录下的activemq.xml文件</strong></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos bin]# cd ..</span><br><span class="line">[root@VM_0_5_centos apache-activemq-5.14.5]# cd conf/</span><br><span class="line">[root@VM_0_5_centos conf]# ls</span><br><span class="line">activemq.xml           client.ks                   groups.properties       jmx.access          login.config</span><br><span class="line">broker.ks              client.ts                   java.security           jmx.password        users.properties</span><br><span class="line">broker-localhost.cert  credentials-enc.properties  jetty-realm.properties  log4j.properties</span><br><span class="line">broker.ts              credentials.properties      jetty.xml               logging.properties</span><br><span class="line">[root@VM_0_5_centos conf]# vim activemq.xml </span><br><span class="line"><span class="meta">#</span>将127.0.0.1修改为0.0.0.0 【重新改为0.0.0.0 否则后续远程连接访问报错】</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E5%A4%B1%E8%B4%A5%E4%BF%AE%E6%94%B9.png" alt="img"></p><ol start="3"><li><p><strong>始终报错，修改etc/hosts文件，删除映射到VM_0_5_centos的配置</strong></p><blockquote><p><strong>hostnamectl set-hostname  XXX</strong></p><p>或者直接设置host名称然后reboot重启</p></blockquote></li><li><p><strong>重新启动，运行activemq，查看运行状态</strong></p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos bin]# ./activemq status</span><br><span class="line">INFO: Loading '/usr/local/activemq/apache-activemq-5.14.5//bin/env'</span><br><span class="line">INFO: Using java '/usr/java/jdk1.8.0_192/bin/java'</span><br><span class="line">ActiveMQ is running (pid '3941')</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E6%88%90%E5%8A%9F.png" alt="img"></p><ol start="5"><li><strong>访问8161管理员页面,使用配置的账号密码登录</strong></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E6%88%90%E5%8A%9F1.png" alt="activemq成功"></p><ol start="6"><li><strong>进入conf文件夹下配置文件，修改密码</strong></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos apache-activemq-5.14.5]# cd conf/</span><br><span class="line">[root@VM_0_5_centos conf]# ls</span><br><span class="line">activemq.xml           client.ks                   groups.properties       jmx.access          login.config</span><br><span class="line">broker.ks              client.ts                   java.security           jmx.password        users.properties</span><br><span class="line">broker-localhost.cert  credentials-enc.properties  jetty-realm.properties  log4j.properties</span><br><span class="line">broker.ts              credentials.properties      jetty.xml               logging.properties</span><br><span class="line">[root@VM_0_5_centos conf]# vim jetty-realm.properties</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E5%AF%86%E7%A0%81.png" alt="img"></p><h4 id="6-SpringBoot整合ActiveMQ"><a href="#6-SpringBoot整合ActiveMQ" class="headerlink" title="6. SpringBoot整合ActiveMQ"></a>6. SpringBoot整合ActiveMQ</h4><ol><li>maven引入jar包</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--整合activemq--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编辑配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>    </span><br><span class="line"><span class="attr">  activemq:</span></span><br><span class="line"><span class="attr">    broker-url:</span> <span class="attr">tcp://IP+端口号61616</span></span><br><span class="line"><span class="attr">    in-memory:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">    pool:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>window客户端可使用telnet 命令查看端口是否可以访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet IP 端口号 例：telnet 127.0.0.1 8080</span><br></pre></td></tr></table></figure></li><li><p>编写服务提供方</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.activemq;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsMessagingTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈服务者〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-01-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, <span class="keyword">final</span> String message)</span></span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(destination, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写消费方</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.activemq;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.annotation.JmsListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈消费者〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-01-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"myqueues"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"message:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写控制器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.controller;</span><br><span class="line"><span class="keyword">import</span> com.joey.activemq.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.command.ActiveMQQueue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/activemq"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tests</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Destination destination = <span class="keyword">new</span> ActiveMQQueue(<span class="string">"myqueues"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) &#123;</span><br><span class="line">            producer.sendMessage(destination, <span class="string">"hello world! 第"</span>+i+<span class="string">"次"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问成功</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E6%88%90%E5%8A%9F2.png" alt="activemq成功"></p></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E6%88%90%E5%8A%9F3.png" alt="activemq成功"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> ActiveMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> ActiveMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7.2下安装JDK三种方法</title>
      <link href="/2019/07/23/install_JDK1.8/"/>
      <url>/2019/07/23/install_JDK1.8/</url>
      
        <content type="html"><![CDATA[<h2 id="Centos7-2下安装JDK三种方法"><a href="#Centos7-2下安装JDK三种方法" class="headerlink" title="Centos7.2下安装JDK三种方法"></a>Centos7.2下安装JDK三种方法</h2><h3 id="方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量"><a href="#方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量" class="headerlink" title="方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量"></a>方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量</h3><h4 id="1-在-usr-目录下创建java目录"><a href="#1-在-usr-目录下创建java目录" class="headerlink" title="1. 在/usr/目录下创建java目录"></a>1. 在/usr/目录下创建java目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir/usr/java</span><br><span class="line">[root@localhost ~]# cd /usr/java</span><br></pre></td></tr></table></figure><h4 id="2-下载jdk-然后解压"><a href="#2-下载jdk-然后解压" class="headerlink" title="2. 下载jdk,然后解压"></a>2. 下载jdk,然后解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# curl -O （jdk下载链接）</span><br><span class="line">[root@localhost java]# tar -zxvf jdk-8u192-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h4 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3. 设置环境变量"></a>3. 设置环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# vim /etc/profile</span><br></pre></td></tr></table></figure><blockquote><p>在profile中最后添加如下内容:</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_192</span><br><span class="line">JRE_HOME=/usr/java/jdk1.8.0_192/jre</span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br></pre></td></tr></table></figure><blockquote><p>让修改生效:</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# source /etc/profile</span><br></pre></td></tr></table></figure><blockquote><p> 若因修改环境变量导致系统出现command not found错误,可尝试以下方法</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>编辑环境变量文件</span><br><span class="line">[root@localhost java]# /usr/bin/vim /etc/profile</span><br><span class="line"><span class="meta">#</span>修改或删除原先配置文件 :wq 保存退出 执行export</span><br><span class="line">[root@localhost java]# export PATH=/usr/bin:/usr/sbin:/bin:/sbin</span><br><span class="line"><span class="meta">#</span>重新执行使更改立即生效</span><br><span class="line">[root@localhost java]# source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="4-验证JDK有效性"><a href="#4-验证JDK有效性" class="headerlink" title="4. 验证JDK有效性"></a>4. 验证JDK有效性</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos jdk1.8.0_192]# java -version</span><br><span class="line">java version "1.8.0_192"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_192-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.192-b12, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="方法二：使用yum命令在线安装JDK"><a href="#方法二：使用yum命令在线安装JDK" class="headerlink" title="方法二：使用yum命令在线安装JDK"></a>方法二：使用yum命令在线安装JDK</h3><h4 id="1-查看yum库中都有哪些jdk版本，全是openjdk"><a href="#1-查看yum库中都有哪些jdk版本，全是openjdk" class="headerlink" title="1. 查看yum库中都有哪些jdk版本，全是openjdk"></a>1. 查看yum库中都有哪些jdk版本，全是openjdk</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos jdk1.8.0_192]# yum search java|grep jdk</span><br><span class="line">ldapjdk-javadoc.noarch : Javadoc for ldapjdk</span><br><span class="line">java-1.6.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">...</span><br><span class="line">java-1.7.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">...</span><br><span class="line">java-1.8.0-openjdk.i686 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk-accessibility.i686 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-accessibility-debug.i686 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-accessibility-debug.x86_64 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-debug.i686 : OpenJDK Runtime Environment with full debug on</span><br><span class="line">java-1.8.0-openjdk-debug.x86_64 : OpenJDK Runtime Environment with full debug on</span><br><span class="line">java-1.8.0-openjdk-demo.i686 : OpenJDK Demos</span><br><span class="line">java-1.8.0-openjdk-demo.x86_64 : OpenJDK Demos</span><br><span class="line">java-1.8.0-openjdk-demo-debug.i686 : OpenJDK Demos with full debug on</span><br><span class="line">java-1.8.0-openjdk-demo-debug.x86_64 : OpenJDK Demos with full debug on</span><br><span class="line">java-1.8.0-openjdk-devel.i686 : OpenJDK Development Environment</span><br><span class="line">java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment</span><br><span class="line">java-1.8.0-openjdk-devel-debug.i686 : OpenJDK Development Environment with full</span><br><span class="line">java-1.8.0-openjdk-devel-debug.x86_64 : OpenJDK Development Environment with</span><br><span class="line">java-1.8.0-openjdk-headless.i686 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk-headless.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk-headless-debug.i686 : OpenJDK Runtime Environment with full</span><br><span class="line">java-1.8.0-openjdk-headless-debug.x86_64 : OpenJDK Runtime Environment with full</span><br><span class="line">java-1.8.0-openjdk-javadoc.noarch : OpenJDK API Documentation</span><br><span class="line">java-1.8.0-openjdk-javadoc-debug.noarch : OpenJDK API Documentation for packages</span><br><span class="line">java-1.8.0-openjdk-javadoc-zip.noarch : OpenJDK API Documentation compressed in</span><br><span class="line">java-1.8.0-openjdk-javadoc-zip-debug.noarch : OpenJDK API Documentation</span><br><span class="line">java-1.8.0-openjdk-src.i686 : OpenJDK Source Bundle</span><br><span class="line">java-1.8.0-openjdk-src.x86_64 : OpenJDK Source Bundle</span><br><span class="line">java-1.8.0-openjdk-src-debug.i686 : OpenJDK Source Bundle for packages with</span><br><span class="line">java-1.8.0-openjdk-src-debug.x86_64 : OpenJDK Source Bundle for packages with</span><br><span class="line">java-11-openjdk.i686 : OpenJDK Runtime Environment 11</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-选择版本进行安装"><a href="#2-选择版本进行安装" class="headerlink" title="2. 选择版本进行安装"></a>2. 选择版本进行安装</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>选择1.8版本进行安装,安装完之后，默认的安装目录是在: /usr/lib/jvm/</span><br><span class="line">[root@localhost ~]# yum install java-1.8.0-openjdk</span><br></pre></td></tr></table></figure><h4 id="3-设置环境变量-，使修改立即生效，查看是否安装成功参考方法一"><a href="#3-设置环境变量-，使修改立即生效，查看是否安装成功参考方法一" class="headerlink" title="3. 设置环境变量 ，使修改立即生效，查看是否安装成功参考方法一"></a>3. 设置环境变量 ，使修改立即生效，查看是否安装成功参考方法一</h4><h3 id="方法三：使用rpm安装"><a href="#方法三：使用rpm安装" class="headerlink" title="方法三：使用rpm安装"></a>方法三：使用rpm安装</h3><h4 id="1-其他步骤具体参考上述方法"><a href="#1-其他步骤具体参考上述方法" class="headerlink" title="1. 其他步骤具体参考上述方法"></a>1. 其他步骤具体参考上述方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost  ~]# rpm -ivh jdk-7u79-linux-x64.rpm</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.2安装MongoDB 4.0.5</title>
      <link href="/2019/07/23/install_MongoDB4.0.5/"/>
      <url>/2019/07/23/install_MongoDB4.0.5/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-2安装MongoDB-4-0-5"><a href="#CentOS-7-2安装MongoDB-4-0-5" class="headerlink" title="CentOS 7.2安装MongoDB 4.0.5"></a>CentOS 7.2安装MongoDB 4.0.5</h2><h4 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h4><blockquote><p><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">MongoDB官网</a>下载安装包上传至服务器或者获取下载链接使用wget命令</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E5%AE%98%E7%BD%91.png" alt="MongoDB官网"></p><blockquote><p>创建mongdb目录，使用wget命令下载压缩包</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E4%B8%8B%E8%BD%BD.png" alt="MongoDB下载"></p><h4 id="2-解压压缩包"><a href="#2-解压压缩包" class="headerlink" title="2. 解压压缩包"></a>2. 解压压缩包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos mongodb]# tar zxvf mongodb-linux-x86_64-4.0.5.tgz</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E8%A7%A3%E5%8E%8B.png" alt="MongoDB解压"></p><h4 id="3-新建data文件夹用于存放数据，logs文件夹存放日志"><a href="#3-新建data文件夹用于存放数据，logs文件夹存放日志" class="headerlink" title="3. 新建data文件夹用于存放数据，logs文件夹存放日志"></a>3. 新建data文件夹用于存放数据，logs文件夹存放日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos mongodb-linux-x86_64-4.0.5]# mkdir data</span><br><span class="line">[root@VM_0_5_centos mongodb-linux-x86_64-4.0.5]# mkdir logs</span><br><span class="line">[root@VM_0_5_centos mongodb-linux-x86_64-4.0.5]# ls</span><br><span class="line">bin  data  LICENSE-Community.txt  logs  MPL-2  README  THIRD-PARTY-NOTICES</span><br></pre></td></tr></table></figure><h4 id="4-新建一个配置文件mongodb-conf"><a href="#4-新建一个配置文件mongodb-conf" class="headerlink" title="4. 新建一个配置文件mongodb.conf"></a>4. 新建一个配置文件mongodb.conf</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="MongoDB配置文件"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#端口</span><br><span class="line">port=27017</span><br><span class="line">#数据库存文件存放目录</span><br><span class="line">dbpath=/usr/local/mongodb/mongodb-linux-x86_64-4.0.5/data</span><br><span class="line">#日志文件存放路径</span><br><span class="line">logpath=/usr/local/mongodb/mongodb-linux-x86_64-4.0.5/data/mongodb.log</span><br><span class="line">#使用追加的方式写日志</span><br><span class="line">logappend=true</span><br><span class="line">#在后台运行</span><br><span class="line">fork=true </span><br><span class="line">#最大同时连接数</span><br><span class="line">maxConns=100</span><br><span class="line">#不启用验证</span><br><span class="line">noauth=true</span><br><span class="line">#每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）</span><br><span class="line">journal=true</span><br><span class="line">#存储引擎有mmapv1、wiretiger、mongorocks，即使宕机，启动时wiredtiger会先将数据恢复到最近一次的checkpoint点，然后重放后续的journal日志来恢复。</span><br><span class="line">storageEngine=wiredTiger</span><br><span class="line">#配置外部访问</span><br><span class="line">bind_ip = 0.0.0.0</span><br></pre></td></tr></table></figure><h4 id="5-用配置文件启动MongoDB"><a href="#5-用配置文件启动MongoDB" class="headerlink" title="5. 用配置文件启动MongoDB"></a>5. 用配置文件启动MongoDB</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos bin]# ./mongod --config /usr/local/mongodb/mongodb-linux-x86_64-4.0.5/mongodb.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 26478</span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure><h4 id="6-用RoBo连接MongoDB"><a href="#6-用RoBo连接MongoDB" class="headerlink" title="6. 用RoBo连接MongoDB"></a>6. 用RoBo连接MongoDB</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E8%BF%9E%E6%8E%A51.png" alt="MongoDB连接1"></p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E8%BF%9E%E6%8E%A52.png" alt="MongoDB连接2"></p><h4 id="7-java连接MongoDB"><a href="#7-java连接MongoDB" class="headerlink" title="7. java连接MongoDB"></a>7. java连接MongoDB</h4><blockquote><p>出现报错</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E6%8A%A5%E9%94%99.png" alt="MongoDB报错"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.2 安装MySql 5.7</title>
      <link href="/2019/07/23/install_MySql5.7/"/>
      <url>/2019/07/23/install_MySql5.7/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-2-安装MySql-5-7"><a href="#CentOS-7-2-安装MySql-5-7" class="headerlink" title="CentOS 7.2 安装MySql 5.7"></a>CentOS 7.2 安装MySql 5.7</h2><h4 id="1-下载rpm包"><a href="#1-下载rpm包" class="headerlink" title="1. 下载rpm包"></a>1. 下载rpm包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# wget http://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E4%B8%8B%E8%BD%BD.png" alt="mysql下载"></p><h4 id="2-下载安装软件源"><a href="#2-下载安装软件源" class="headerlink" title="2. 下载安装软件源"></a>2. 下载安装软件源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# yum localinstall mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E5%AE%89%E8%A3%85.png" alt="mysql安装"></p><h4 id="3-查看系统是否添加该源"><a href="#3-查看系统是否添加该源" class="headerlink" title="3. 查看系统是否添加该源"></a>3. 查看系统是否添加该源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# yum repolist all | grep mysql</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E6%BA%90.png" alt="mysql源"></p><h4 id="4-安装MySql"><a href="#4-安装MySql" class="headerlink" title="4. 安装MySql"></a>4. 安装MySql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# yum install mysql-community-server.x86_64</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B.png" alt="mysql安装过程"></p><h4 id="5-启动MySql-Server"><a href="#5-启动MySql-Server" class="headerlink" title="5. 启动MySql Server"></a>5. 启动MySql Server</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>启动Mysql</span><br><span class="line">[root@VM_0_5_centos home]# systemctl start mysqld</span><br><span class="line"><span class="meta">#</span>查看启动状态</span><br><span class="line">[root@VM_0_5_centos home]# systemctl status mysqld</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E5%90%AF%E5%8A%A8.png" alt="mysql启动"></p><h4 id="6-查看MySQL随机临时密码"><a href="#6-查看MySQL随机临时密码" class="headerlink" title="6. 查看MySQL随机临时密码"></a>6. 查看MySQL随机临时密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# grep 'temporary password' /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E4%B8%B4%E6%97%B6%E5%AF%86%E7%A0%81.png" alt="mysql临时密码"></p><h4 id="7-修改MySql密码"><a href="#7-修改MySql密码" class="headerlink" title="7. 修改MySql密码"></a>7. 修改MySql密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# mysql_secure_installation</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%8A%A5%E9%94%99.png" alt="mysql修改密码报错"></p><blockquote><p>MySQL里带了一个密码验证的插件来防止密码设置过于简单。</p><p>密码要求：</p><ul><li>特殊字符</li><li>大小写字母</li><li>数字</li><li>长度8位</li></ul><p>实例密码：Fangchy1120.！</p></blockquote><h4 id="8-登录MySql修改密码"><a href="#8-登录MySql修改密码" class="headerlink" title="8. 登录MySql修改密码"></a>8. 登录MySql修改密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# mysql -uroot -p</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E6%8A%A5%E9%94%99.png" alt="mysql报错"></p><blockquote><p>原来MySQL5.6.6版本之后增加了密码强度验证插件validate_password，相关参数设置的较为严格。<br>使用了该插件会检查设置的密码是否符合当前设置的强度规则，若不满足则拒绝设置。影响的语句和函数有：create user,grant,set password,password(),old password。</p></blockquote><ol><li><strong>查看mysql全局参数</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &apos;validate_password%&apos;;</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| validate_password_check_user_name    | OFF    |</span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 8      |</span><br><span class="line">| validate_password_mixed_case_count   | 1      |</span><br><span class="line">| validate_password_number_count       | 1      |</span><br><span class="line">| validate_password_policy             | MEDIUM |</span><br><span class="line">| validate_password_special_char_count | 1      |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>参数解释</strong></p><blockquote><ul><li><p>validate_password_dictionary_file</p><p>插件用于验证密码强度的字典文件路径。</p></li><li><p>validate_password_length</p><p>密码最小长度，参数默认为8，它有最小值的限制，最小值为：validate_password_number_count + validate_password_special_char_count + (2 * validate_password_mixed_case_count)</p></li><li><p>validate_password_mixed_case_count</p><p>密码至少要包含的小写字母个数和大写字母个数。</p></li><li><p>validate_password_number_count</p><p>密码至少要包含的数字个数。</p></li><li><p>validate_password_policy</p><p>密码强度检查等级，0/LOW、1/MEDIUM、2/STRONG。有以下取值：</p><table><thead><tr><th>Policy</th><th>Tests Performed</th></tr></thead><tbody><tr><td>0 or LOW</td><td>Length</td></tr><tr><td>1 or MEDIUM</td><td>Length; numeric, lowercase/uppercase, and special characters</td></tr><tr><td>2 or STRONG</td><td>Length; numeric, lowercase/uppercase, and special characters; dictionary file</td></tr></tbody></table><p>默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。</p></li><li><p>validate_password_special_char_count</p><p>密码至少要包含的特殊字符数。  </p></li></ul></blockquote></li><li><p><strong>修改上面的各项参数，全部执行成功</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_mixed_case_count=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_number_count=3;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_special_char_count=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_length=3;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>查看修改后的参数</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;validate_password%&apos;;</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| Variable_name                        | Value |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| validate_password_check_user_name    | OFF   |</span><br><span class="line">| validate_password_dictionary_file    |       |</span><br><span class="line">| validate_password_length             | 3     |</span><br><span class="line">| validate_password_mixed_case_count   | 0     |</span><br><span class="line">| validate_password_number_count       | 3     |</span><br><span class="line">| validate_password_policy             | LOW   |</span><br><span class="line">| validate_password_special_char_count | 0     |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>修改成简单密码</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>使用新密码登录</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos ~]# mysql -uroot -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 16</span><br><span class="line">Server version: 5.7.24 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br></pre></td></tr></table></figure><ol start="7"><li>配置远程连接(腾讯云不需要配置端口)</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>查看mysql端口</span><br><span class="line">[root@VM_0_5_centos ~]# netstat -ntlp|grep 3306</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      13929/mysqld</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置远程连接，赋予任何主机上以root身份访问数据的权限 </span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E8%BF%9E%E6%8E%A51.png" alt="mysql连接1"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos 7.2 安装目前最新版Redis5.0.3</title>
      <link href="/2019/07/23/install_Redis5.0.3/"/>
      <url>/2019/07/23/install_Redis5.0.3/</url>
      
        <content type="html"><![CDATA[<h2 id="Centos-7-2-安装目前最新版Redis5-0-3"><a href="#Centos-7-2-安装目前最新版Redis5-0-3" class="headerlink" title="Centos 7.2 安装目前最新版Redis5.0.3"></a>Centos 7.2 安装目前最新版Redis5.0.3</h2><h4 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E4%B8%8B%E8%BD%BD.png" alt="redis下载"></p><h4 id="2-解压安装包"><a href="#2-解压安装包" class="headerlink" title="2. 解压安装包"></a>2. 解压安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# tar -zxvf redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure><h4 id="3-进入解压后的目录，编译"><a href="#3-进入解压后的目录，编译" class="headerlink" title="3. 进入解压后的目录，编译"></a>3. 进入解压后的目录，编译</h4><blockquote><p>redis使用c语言开发的，所以编译依赖gcc环境，先查看是否安装了gcc</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/gcc.png" alt="gcc"></p><blockquote><p>如果没有安装，先执行安装gcc命令</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos local]# yum -y install gcc-c++</span><br></pre></td></tr></table></figure><blockquote><p>再进行编译</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# cd redis-5.0.3/</span><br><span class="line">[root@VM_0_5_centos redis-5.0.3]# make</span><br></pre></td></tr></table></figure><h4 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-5.0.3]# ls</span><br><span class="line">00-RELEASENOTES  COPYING  Makefile   redis.conf       runtest-sentinel  tests</span><br><span class="line">BUGS             deps     MANIFESTO  runtest          sentinel.conf     utils</span><br><span class="line">CONTRIBUTING     INSTALL  README.md  runtest-cluster  src</span><br><span class="line">[root@VM_0_5_centos redis-5.0.3]# vim redis.conf </span><br><span class="line"><span class="meta">#</span>修改绑定ip为0.0.0.0，支持远程访问</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="meta">#</span> 指定日志文件目录</span><br><span class="line">logfile "/usr/local/redis/log/server-out.log"</span><br><span class="line"><span class="meta">#</span> 启用后台启动</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><h4 id="5-启动redis"><a href="#5-启动redis" class="headerlink" title="5. 启动redis"></a>5. 启动redis</h4><blockquote><p>进入src目录，用配置文件启动redis</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>进入src目录</span><br><span class="line">[root@VM_0_5_centos redis-5.0.3]# cd src</span><br><span class="line"><span class="meta">#</span>启动redis</span><br><span class="line">[root@VM_0_5_centos src]# ./redis-server ../redis.conf</span><br></pre></td></tr></table></figure><h4 id="6-查看redis是否启动"><a href="#6-查看redis是否启动" class="headerlink" title="6. 查看redis是否启动"></a>6. 查看redis是否启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos src]# netstat -nlpt|grep 6379</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E5%90%AF%E5%8A%A8.png" alt="redis启动"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos src]# ps -aux|grep redis</span><br><span class="line">root      7655  0.0  0.5 159456 10264 ?        Ssl  16:41   0:00 ./redis-server 0.0.0.0:6379</span><br><span class="line">root      7971  0.0  0.0 112644   964 pts/0    R+   16:45   0:00 grep --color=auto redis</span><br><span class="line"><span class="meta">#</span>进入redis客户端</span><br><span class="line">[root@VM_0_5_centos src]# ./redis-cli</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E5%AE%A2%E6%88%B7%E7%AB%AF.png" alt="redis客户端"></p><h4 id="7-给redis添加密码"><a href="#7-给redis添加密码" class="headerlink" title="7. 给redis添加密码"></a>7. 给redis添加密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos src]# vim ../redis.conf </span><br><span class="line"><span class="meta">#</span>命令行状态/requirepass 按回车查找 ，n查找下一个，添加下面一行</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><h4 id="8-重启redis"><a href="#8-重启redis" class="headerlink" title="8. 重启redis"></a>8. 重启redis</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>关闭客户端</span><br><span class="line">[root@VM_0_5_centos src]# ./redis-cli shutdown</span><br><span class="line"><span class="meta">#</span>重启redis服务</span><br><span class="line">[root@VM_0_5_centos src]# ./redis-server ../redis.conf </span><br><span class="line"><span class="meta">#</span>重新连接客户端（没有权限访问）</span><br><span class="line">[root@VM_0_5_centos src]# ./redis-cli </span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line"><span class="meta">#</span>密码登录</span><br><span class="line">[root@VM_0_5_centos src]# ./redis-cli -a 123456</span><br><span class="line">Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "name"</span><br></pre></td></tr></table></figure><h4 id="9-SpringBoot连接redis"><a href="#9-SpringBoot连接redis" class="headerlink" title="9. SpringBoot连接redis"></a>9. SpringBoot连接redis</h4><blockquote><p>引入maven依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--整合单机版redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>添加配置</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">118.25</span><span class="number">.24</span><span class="number">.23</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    jedis:</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">        max-active:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        max-wait:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">        max-idle:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">        min-idle:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>启动类开启缓存</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>service实现类中的方法添加@Cacheable接口</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"mybook"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Books <span class="title">getBooksById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"从数据库中查询。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> booksMapper.getBooksById(id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>bean未序列化报错解决</p><p>解决办法：Bean类实现Serializable接口</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E7%BC%93%E5%AD%98%E6%8A%A5%E9%94%99.png" alt="redis缓存报错"></p><blockquote><p>单机版部署成功</p><p>执行两次查询，输出一次</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E6%88%90%E5%8A%9F.png" alt="redis成功"></p><blockquote><p>查看redis客户端</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="redis服务器"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.2安装Redis 5.0.3集群</title>
      <link href="/2019/07/23/install_Redis5.0.3_cluster/"/>
      <url>/2019/07/23/install_Redis5.0.3_cluster/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-2安装Redis-5-0-3集群"><a href="#CentOS-7-2安装Redis-5-0-3集群" class="headerlink" title="CentOS 7.2安装Redis 5.0.3集群"></a>CentOS 7.2安装Redis 5.0.3集群</h2><h4 id="1-安装redis-5-0（参考install-Redis5-0-3-md）"><a href="#1-安装redis-5-0（参考install-Redis5-0-3-md）" class="headerlink" title="1. 安装redis 5.0（参考install_Redis5.0.3.md）"></a>1. 安装redis 5.0（参考install_Redis5.0.3.md）</h4><h4 id="2-创建redis-cluster目录，方便管理我们创建的redis实例，复制之前安装好的redis为redis01"><a href="#2-创建redis-cluster目录，方便管理我们创建的redis实例，复制之前安装好的redis为redis01" class="headerlink" title="2. 创建redis-cluster目录，方便管理我们创建的redis实例，复制之前安装好的redis为redis01"></a>2. 创建redis-cluster目录，方便管理我们创建的redis实例，复制之前安装好的redis为redis01</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# mkdir redis-cluster</span><br><span class="line">[root@VM_0_5_centos redis]# ls</span><br><span class="line">log  redis-5.0.3  redis-5.0.3.tar.gz  redis-cluster</span><br><span class="line">[root@VM_0_5_centos redis]# cp -r redis-5.0.3 ./redis-cluster/redis01</span><br><span class="line">[root@VM_0_5_centos redis]# ls redis-cluster/</span><br><span class="line">redis01</span><br></pre></td></tr></table></figure><h4 id="3-修改redis01的配置文件"><a href="#3-修改redis01的配置文件" class="headerlink" title="3. 修改redis01的配置文件"></a>3. 修改redis01的配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# cd redis-cluster/redis01/</span><br><span class="line">[root@VM_0_5_centos redis01]# ls</span><br><span class="line">00-RELEASENOTES  COPYING  Makefile   redis.conf       runtest-sentinel  tests</span><br><span class="line">BUGS             deps     MANIFESTO  runtest          sentinel.conf     utils</span><br><span class="line">CONTRIBUTING     INSTALL  README.md  runtest-cluster  src</span><br><span class="line">[root@VM_0_5_centos redis01]# vim redis.conf</span><br></pre></td></tr></table></figure><h4 id="4-把-bind-127-0-0-1-给注释掉或者改为0-0-0-0，这里的bind指的是只有指定的网段才能远程访问这个redis"><a href="#4-把-bind-127-0-0-1-给注释掉或者改为0-0-0-0，这里的bind指的是只有指定的网段才能远程访问这个redis" class="headerlink" title="4. 把 bind 127.0.0.1 给注释掉或者改为0.0.0.0，这里的bind指的是只有指定的网段才能远程访问这个redis"></a>4. 把 bind 127.0.0.1 给注释掉或者改为0.0.0.0，这里的bind指的是只有指定的网段才能远程访问这个redis</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A41.png" alt="集群1"></p><h4 id="5-开启远程访问-protected-mode-no-和-修改端口-port-7001"><a href="#5-开启远程访问-protected-mode-no-和-修改端口-port-7001" class="headerlink" title="5. 开启远程访问 protected-mode no 和 修改端口 port 7001"></a>5. 开启远程访问 protected-mode no 和 修改端口 port 7001</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A42.png" alt="集群2"></p><h4 id="6-设置后台运行-daemonize-yes"><a href="#6-设置后台运行-daemonize-yes" class="headerlink" title="6. 设置后台运行 daemonize yes"></a>6. 设置后台运行 daemonize yes</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A43.png" alt="集群3"></p><h4 id="7-设置pidfile存放在-run目录下的文件名-pidfile-var-run-redis-7001-pid"><a href="#7-设置pidfile存放在-run目录下的文件名-pidfile-var-run-redis-7001-pid" class="headerlink" title="7. 设置pidfile存放在 run目录下的文件名  pidfile  /var/run/redis_7001.pid"></a>7. 设置pidfile存放在 run目录下的文件名  pidfile  /var/run/redis_7001.pid</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A44.png" alt="集群4"></p><h4 id="8-设置redis集群密码-masterauth-123456-和-requirepass-123456-注意：所有节点的密码都必须一致，masterauth也要加"><a href="#8-设置redis集群密码-masterauth-123456-和-requirepass-123456-注意：所有节点的密码都必须一致，masterauth也要加" class="headerlink" title="8. 设置redis集群密码 masterauth 123456 和 requirepass 123456       注意：所有节点的密码都必须一致，masterauth也要加"></a>8. 设置redis集群密码 masterauth 123456 和 requirepass 123456       注意：所有节点的密码都必须一致，masterauth也要加</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A45.1.png" alt="集群5.1"></p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A45.2.png" alt="集群5.2"></p><h4 id="9-设置开启AOF模式-appendonly-yes"><a href="#9-设置开启AOF模式-appendonly-yes" class="headerlink" title="9. 设置开启AOF模式  appendonly yes"></a>9. 设置开启AOF模式  appendonly yes</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A46.png" alt="集群6"></p><h4 id="10-设置启用集群模式-cluster-enabled-yes，开启配置文件cluster-config-file-nodes-conf-，超时时间-cluster-node-timeout-5000"><a href="#10-设置启用集群模式-cluster-enabled-yes，开启配置文件cluster-config-file-nodes-conf-，超时时间-cluster-node-timeout-5000" class="headerlink" title="10. 设置启用集群模式 cluster-enabled yes，开启配置文件cluster-config-file nodes.conf ，超时时间 cluster-node-timeout 5000"></a>10. 设置启用集群模式 cluster-enabled yes，开启配置文件cluster-config-file nodes.conf ，超时时间 cluster-node-timeout 5000</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A47.png" alt="集群7"></p><h4 id="11-配置好后，拷贝-redis01再创建五个redis实例"><a href="#11-配置好后，拷贝-redis01再创建五个redis实例" class="headerlink" title="11. 配置好后，拷贝 redis01再创建五个redis实例"></a>11. 配置好后，拷贝 redis01再创建五个redis实例</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A48.png" alt="集群8"></p><h4 id="12-修改redis02-06的配置文件，修改端口号，修改pidfile存放文件名"><a href="#12-修改redis02-06的配置文件，修改端口号，修改pidfile存放文件名" class="headerlink" title="12. 修改redis02~06的配置文件，修改端口号，修改pidfile存放文件名"></a>12. 修改redis02~06的配置文件，修改端口号，修改pidfile存放文件名</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis02/redis.conf </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis03/redis.conf </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis04/redis.conf </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis05/redis.conf </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis06/redis.conf</span><br></pre></td></tr></table></figure><h4 id="13-在redis-cluster目录下，编写redis-start-all-sh启动脚本，启动redis实例"><a href="#13-在redis-cluster目录下，编写redis-start-all-sh启动脚本，启动redis实例" class="headerlink" title="13. 在redis-cluster目录下，编写redis_start_all.sh启动脚本，启动redis实例"></a>13. 在redis-cluster目录下，编写redis_start_all.sh启动脚本，启动redis实例</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A410.png" alt="集群10"></p><h4 id="14-刚创建好的启动脚本没有权限，会提示Permission-denied，所以需要给脚本添加可执行权限"><a href="#14-刚创建好的启动脚本没有权限，会提示Permission-denied，所以需要给脚本添加可执行权限" class="headerlink" title="14. 刚创建好的启动脚本没有权限，会提示Permission denied，所以需要给脚本添加可执行权限"></a>14. 刚创建好的启动脚本没有权限，会提示Permission denied，所以需要给脚本添加可执行权限</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A411.png" alt="集群11"></p><blockquote><p><strong>权限部分说明</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &gt; -rw-r--r-- 1 root root  490 Jan 13 22:32 redis_cluster_start_all.sh</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p><strong>含义</strong></p><p>u 代表所有者（user）<br>g 代表所有者所在的组群（group）<br>o 代表其他用户（other）<br>a 代表全部的人（u、g、o）</p><p>r 表示文件可读（read）<br>w 表示文件可写（write）<br>x 表示文件可执行（是程序）<br>– 表示相应的权限为空</p><p>+ 表示添加权限<br>– 表示删除权限<br>= 表示使之成为唯一的权限</p><p><strong>数字表示</strong></p><p>0代表—<br>1代表–x<br>2代表-w-<br>3代表-wx<br>4代表r–<br>5代表r-x<br>6代表rw-<br>7代表rwx</p><p>-rw——-    (600) 只有所有者才有读和写的权限</p><p>-rw-r–r–    (644) 只有所有者才有读和写的权限，组群和其他用户只有读的权限</p><p>-rwx——    (700) 只有所有者才有读，写，执行的权限</p><p>-rwxr-xr-x    (755) 只有所有者才有读，写，执行的权限，组群和其他用户只有读和执行的权限</p><p>-rwx–x–x    (711) 只有所有者才有读，写，执行的权限，组群和其用户只有执行的权限</p><p>-rw-rw-rw- (666) 每个人都有读写的权限</p><p>-rwxrwxrwx (777) 每个人都有读写和执行的权限</p></blockquote></blockquote><h4 id="15-启动redis集群"><a href="#15-启动redis集群" class="headerlink" title="15. 启动redis集群"></a>15. 启动redis集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-cluster]# ./redis_cluster_start_all.sh</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A412.png" alt="集群12"></p><h4 id="16-复进入到redis01-bin-目录下，拷贝一份-redis-cli-到-redis-cluster-目录下"><a href="#16-复进入到redis01-bin-目录下，拷贝一份-redis-cli-到-redis-cluster-目录下" class="headerlink" title="16. 复进入到redis01/bin/ 目录下，拷贝一份 redis-cli 到  redis-cluster/ 目录下"></a>16. 复进入到redis01/bin/ 目录下，拷贝一份 redis-cli 到  redis-cluster/ 目录下</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos src]# cp redis-cli /usr/local/redis/redis-cluster/</span><br><span class="line">[root@VM_0_5_centos src]# ls ../../</span><br><span class="line">redis01  redis02  redis03  redis04  redis05  redis06  redis-cli  redis_cluster_start_all.sh</span><br></pre></td></tr></table></figure><h4 id="17-创建redis集群"><a href="#17-创建redis集群" class="headerlink" title="17. 创建redis集群"></a>17. 创建redis集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-cluster]# ./redis-cli --cluster create 118.25.24.23:7001 118.25.24.23:7002 118.25.24.23:7003 118.25.24.23:7004 118.25.24.23:7005 118.25.24.23:7006 --cluster-replicas 1 -a 123456</span><br><span class="line">Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 118.25.24.23:7004 to 118.25.24.23:7001</span><br><span class="line">Adding replica 118.25.24.23:7005 to 118.25.24.23:7002</span><br><span class="line">Adding replica 118.25.24.23:7006 to 118.25.24.23:7003</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Trying to optimize slaves allocation for anti-affinity</span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: b50c435cf63df50862a94dadadd9ca5e051449fd 118.25.24.23:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: acf23e9fdab3c902d3cdae65b3120361aabb916f 118.25.24.23:7002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 9608312874a165adcea031713c5256c4c3d7eb63 118.25.24.23:7003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 30a12a011575d62c8865c0e9249e7e768c1a9bae 118.25.24.23:7004</span><br><span class="line">   replicates acf23e9fdab3c902d3cdae65b3120361aabb916f</span><br><span class="line">S: 1733a42b8b6471f81d9dab5f8213ea62b1492fe8 118.25.24.23:7005</span><br><span class="line">   replicates 9608312874a165adcea031713c5256c4c3d7eb63</span><br><span class="line">S: dfac6c68ed0204eda79ceff6b4fd688b1e68df7e 118.25.24.23:7006</span><br><span class="line">   replicates b50c435cf63df50862a94dadadd9ca5e051449fd</span><br><span class="line">Can I set the above configuration? (type 'yes' to accept): yes</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Nodes configuration updated</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Assign a different config epoch to each node</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Performing Cluster Check (using node 118.25.24.23:7001)</span><br><span class="line">M: b50c435cf63df50862a94dadadd9ca5e051449fd 118.25.24.23:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: dfac6c68ed0204eda79ceff6b4fd688b1e68df7e 118.25.24.23:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b50c435cf63df50862a94dadadd9ca5e051449fd</span><br><span class="line">S: 1733a42b8b6471f81d9dab5f8213ea62b1492fe8 118.25.24.23:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 9608312874a165adcea031713c5256c4c3d7eb63</span><br><span class="line">M: acf23e9fdab3c902d3cdae65b3120361aabb916f 118.25.24.23:7002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 30a12a011575d62c8865c0e9249e7e768c1a9bae 118.25.24.23:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates acf23e9fdab3c902d3cdae65b3120361aabb916f</span><br><span class="line">M: 9608312874a165adcea031713c5256c4c3d7eb63 118.25.24.23:7003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Check for open slots...</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><h4 id="18-在redis-cluster目录下，编写redis-cluster-stop-all-sh关闭脚本"><a href="#18-在redis-cluster目录下，编写redis-cluster-stop-all-sh关闭脚本" class="headerlink" title="18. 在redis-cluster目录下，编写redis_cluster_stop_all.sh关闭脚本"></a>18. 在redis-cluster目录下，编写redis_cluster_stop_all.sh关闭脚本</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A415.png" alt="集群15"></p><h4 id="19-给redis-cluster-stop-all-sh脚本添加可执行权限-参考11点给启动脚本添加权限"><a href="#19-给redis-cluster-stop-all-sh脚本添加可执行权限-参考11点给启动脚本添加权限" class="headerlink" title="19. 给redis_cluster_stop_all.sh脚本添加可执行权限(参考11点给启动脚本添加权限)"></a>19. 给redis_cluster_stop_all.sh脚本添加可执行权限(参考11点给启动脚本添加权限)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-cluster]# ll | grep redis_cluster_stop_all.sh</span><br><span class="line">-rw-r--r-- 1 root root     552 Jan 14 10:42 redis_cluster_stop_all.sh</span><br><span class="line">[root@VM_0_5_centos redis-cluster]# chmod +x redis_cluster_stop_all.sh </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# ll | grep redis_cluster_stop_all.sh</span><br><span class="line">-rwxr-xr-x 1 root root     552 Jan 14 10:42 redis_cluster_stop_all.sh</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A416.png" alt="集群16"></p><h4 id="20-执行停止脚本"><a href="#20-执行停止脚本" class="headerlink" title="20. 执行停止脚本"></a>20. 执行停止脚本</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A417.png" alt="集群17"></p><h4 id="21-java使用jedis连接集群"><a href="#21-java使用jedis连接集群" class="headerlink" title="21. java使用jedis连接集群"></a>21. java使用jedis连接集群</h4><blockquote><ol><li><strong>pom.xml中引入相关jar包</strong></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">&lt;!--整合redis--&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="2"><li><strong>配置文件中添加集群节点信息</strong></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt; spring: </span></span><br><span class="line"><span class="string">&gt;   redis:</span></span><br><span class="line"><span class="string">&gt;     cluster:</span></span><br><span class="line"><span class="string">&gt;       nodes: 118.25.24.23:7001,118.25.24.23:7002,118.25.24.23:7003,118.25.24.23:7004,118.25.24.23:7005,118.25.24.23:7006</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="3"><li><strong>编写redis配置类</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> com.joey.config;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line">&gt; <span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line">&gt; <span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line">&gt; <span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> java.util.HashSet;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.Set;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;  * 〈redis集群配置〉</span></span><br><span class="line"><span class="comment">&gt;  *</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@author</span> Joey</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@create</span> 2019-01-14</span></span><br><span class="line"><span class="comment">&gt;  * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment">&gt;  */</span></span><br><span class="line">&gt; <span class="meta">@Configuration</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.cluster.nodes&#125;"</span>)</span><br><span class="line">&gt;     <span class="keyword">private</span> String redisNodes;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="meta">@Bean</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">getJedisCluster</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;         Set&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&gt;         <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;             String[] redisnodes = redisNodes.split(<span class="string">","</span>);</span><br><span class="line">&gt;             <span class="keyword">for</span> (String node:redisnodes)&#123;</span><br><span class="line">&gt;                 String[] arr = node.split(<span class="string">":"</span>);</span><br><span class="line">&gt;                 HostAndPort hostAndPort = <span class="keyword">new</span> HostAndPort(arr[<span class="number">0</span>], Integer.parseInt(arr[<span class="number">1</span>]));</span><br><span class="line">&gt;                 nodes.add(hostAndPort);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">&gt;             System.out.println(<span class="string">"集群节点配置有误"</span>);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">&gt;         <span class="comment">//配置password否则会报权限错误</span></span><br><span class="line">&gt;         JedisCluster cluster = <span class="keyword">new</span> JedisCluster(nodes,<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="string">"123456"</span>,jedisPoolConfig);</span><br><span class="line">&gt;         <span class="keyword">return</span> cluster;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="4"><li><p><strong>编写Service接口类，实现类以及Controller类</strong></p><p>(1). 接口类</p></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A4%E6%8E%A5%E5%8F%A3%E7%B1%BB.png" alt="集群接口类"></p><p>​    (2). 实现类</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="集群实现类"></p><p>​    (3). Controller类</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A4%E6%8E%A7%E5%88%B6%E7%B1%BB.png" alt="集群控制类"></p><ol start="5"><li><strong>浏览器访问</strong></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A4%E6%88%90%E5%8A%9F.png" alt="集群成功"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7.2 安装tomcat8.5</title>
      <link href="/2019/07/23/install_Tomcat8/"/>
      <url>/2019/07/23/install_Tomcat8/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS7-2-安装tomcat8-5"><a href="#CentOS7-2-安装tomcat8-5" class="headerlink" title="CentOS7.2 安装tomcat8.5"></a>CentOS7.2 安装tomcat8.5</h2><h4 id="1-官网下载tomcat压缩包"><a href="#1-官网下载tomcat压缩包" class="headerlink" title="1.  官网下载tomcat压缩包"></a>1.  <a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">官网下载</a>tomcat压缩包</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E4%B8%8B%E8%BD%BD.png" alt="tomcat下载"></p><h4 id="2-上传至云服务器（本人使用xFtp6上传）"><a href="#2-上传至云服务器（本人使用xFtp6上传）" class="headerlink" title="2. 上传至云服务器（本人使用xFtp6上传）"></a>2. 上传至云服务器（本人使用xFtp6上传）</h4><h4 id="3-执行解压操作"><a href="#3-执行解压操作" class="headerlink" title="3. 执行解压操作"></a>3. 执行解压操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos tomcat]# tar -zxvf apache-tomcat-8.5.37</span><br><span class="line">[root@VM_0_5_centos tomcat]# ls</span><br><span class="line">apache-tomcat-8.5.37  apache-tomcat-8.5.37.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>解压后文件目录结构</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E8%A7%A3%E5%8E%8B.png" alt="tomcat解压"></p><h4 id="4-查看是否已经正确配置JAVA-HOME，输出JAVA-HOME路径"><a href="#4-查看是否已经正确配置JAVA-HOME，输出JAVA-HOME路径" class="headerlink" title="4. 查看是否已经正确配置JAVA_HOME，输出JAVA_HOME路径"></a>4. 查看是否已经正确配置JAVA_HOME，输出JAVA_HOME路径</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos apache-tomcat-8.5.37]# echo $JAVA_HOME</span><br><span class="line">/usr/java/jdk1.8.0_192</span><br></pre></td></tr></table></figure><h4 id="5-可以将解压后的tomcat文件复制到所需位置"><a href="#5-可以将解压后的tomcat文件复制到所需位置" class="headerlink" title="5. 可以将解压后的tomcat文件复制到所需位置"></a>5. 可以将解压后的tomcat文件复制到所需位置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos tomcat]# cp -r /usr/tomcat/apache-tomcat-8.5.37 /usr/local/tomcat/</span><br><span class="line">[root@VM_0_5_centos tomcat]# ls /usr/local/tomcat/</span><br><span class="line">apache-tomcat-8.5.37</span><br></pre></td></tr></table></figure><h4 id="6-进入bin文件，启动tomcat"><a href="#6-进入bin文件，启动tomcat" class="headerlink" title="6. 进入bin文件，启动tomcat"></a>6. 进入bin文件，启动tomcat</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E5%90%AF%E5%8A%A8.png" alt="tomcat启动"></p><h4 id="7-查看是否启动成功"><a href="#7-查看是否启动成功" class="headerlink" title="7. 查看是否启动成功"></a>7. 查看是否启动成功</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>访问8080端口出现html代码即启动成功</span><br><span class="line">[root@VM_0_5_centos ~]# curl http://localhost:8080</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E6%88%90%E5%8A%9F.png" alt="tomcat成功"></p><h4 id="8-查看tomcat启动日志"><a href="#8-查看tomcat启动日志" class="headerlink" title="8. 查看tomcat启动日志"></a>8. 查看tomcat启动日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos ~]# cd /usr/local/tomcat/apache-tomcat-8.5.37/logs/</span><br><span class="line">[root@VM_0_5_centos logs]# tail -f catalina.out</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E6%97%A5%E5%BF%97.png" alt="tomcat日志"></p><h4 id="9-查看端口监听"><a href="#9-查看端口监听" class="headerlink" title="9. 查看端口监听"></a>9. 查看端口监听</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>查看所有端口</span><br><span class="line">[root@VM_0_5_centos logs]# netstat -ntlp  </span><br><span class="line"><span class="meta">#</span>查看指定端口</span><br><span class="line">[root@VM_0_5_centos logs]# netstat -an | grep 8080</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E7%AB%AF%E5%8F%A3.png" alt="tomcat端口"></p><h4 id="10-本地浏览器打开直接可以远程访问8080端口-本人使用的是腾讯云，其他云可能需要设置一下防火墙，具体情况具体分析"><a href="#10-本地浏览器打开直接可以远程访问8080端口-本人使用的是腾讯云，其他云可能需要设置一下防火墙，具体情况具体分析" class="headerlink" title="10. 本地浏览器打开直接可以远程访问8080端口(本人使用的是腾讯云，其他云可能需要设置一下防火墙，具体情况具体分析)"></a>10. 本地浏览器打开直接可以远程访问8080端口(本人使用的是腾讯云，其他云可能需要设置一下防火墙，具体情况具体分析)</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E6%9C%AC%E5%9C%B0.png" alt="tomcat本地"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlServer存储过程使用游标循环</title>
      <link href="/2019/07/23/sqlserver%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/07/23/sqlserver%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>项目需求描述：</strong></p><blockquote><p>公司架构：–总公司(LongCode:1)</p><p>​                        –子公司A(LongCode:1.1)</p><p>​                            –孙公司A1(LongCode:1.1.1)</p><p>​                                –A1孙公司项目(LongCode:1.1.1.1)</p><p>​                            –孙公司A2(LongCode:1.1.2)</p><p>​                            –A公司项目(LongCode:1.1.3)</p><p>​                        –子公司B(LongCode:1.2)</p><p>​                            –B公司项目(LongCode:1.2.1)</p><p>​                        –…</p><p>要求：汇总每个子公司下所有项目（包括孙公司的项目）信息，层级关系通过LongCode确定。</p><p>​            并且返回多条汇总信息。</p></blockquote><p><strong>解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Create Proc P_GetCompanyNewSign </span><br><span class="line">AS </span><br><span class="line">Begin</span><br><span class="line">--判断有没有临时表有的话先删除</span><br><span class="line">if OBJECT_ID(&apos;tempdb..#tblTmp&apos;) is not null drop table #tblTmp;</span><br><span class="line">--创建存储返回数据的临时表</span><br><span class="line">create table #tblTmp(</span><br><span class="line">    Name nvarchar(100),FinishedInvestAmount decimal(30,6),ShortName nvarchar(100),EpsProjLongCode nvarchar(100)</span><br><span class="line">)</span><br><span class="line">--声明临时变量用来存储循环的LongCode</span><br><span class="line">Declare @temp varchar(50)</span><br><span class="line">--声明游标</span><br><span class="line">declare mycursor cursor</span><br><span class="line">--获取需要循环的子公司LongC0de</span><br><span class="line">for(select LongCode from XX where  Name = &apos;子公司&apos;)</span><br><span class="line">--开启游标</span><br><span class="line">open mycursor</span><br><span class="line">--获取下一个传给临时变量，相当于for循环中的i变量</span><br><span class="line">fetch next from mycursor into @temp</span><br><span class="line">--假如检索到了数据继续执行</span><br><span class="line">while @@FETCH_STATUS = 0</span><br><span class="line">Begin</span><br><span class="line">--将一个子公司的数据插入临时表</span><br><span class="line">insert into #tblTmp select * from XX where LongCode=&apos;1.1&apos;</span><br><span class="line">--获取下一个传给临时变量，相当于for循环中的i变量</span><br><span class="line">fetch next from mycursor into @temp</span><br><span class="line">End</span><br><span class="line">--关闭释放游标</span><br><span class="line">close mycursor</span><br><span class="line">deallocate mycursor</span><br><span class="line">--查询临时表中的结果集</span><br><span class="line">select * from #tblTmp;</span><br><span class="line">--使用完删除临时表</span><br><span class="line">if OBJECT_ID(&apos;tempdb..#tblTmp&apos;) is not null drop table #tblTmp;</span><br><span class="line">End</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> SqlServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SqlServer </tag>
            
            <tag> 存储过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlServer 备份还原</title>
      <link href="/2019/07/23/sqlserver%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/"/>
      <url>/2019/07/23/sqlserver%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="SqlServer-备份"><a href="#SqlServer-备份" class="headerlink" title="SqlServer 备份"></a>SqlServer 备份</h2><ol><li><p>右键数据库，选择任务–&gt;备份</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725120751.jpg" alt="备份"></p></li><li><p>在常规选项中，选择要备份的文件路径及名称</p><ul><li>清空原先备份的文件路径</li><li>点击添加，选择磁盘文件目录</li><li>可先选中一个备份文件，然后再修改文件名</li></ul><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725130924.png" alt="备份2"></p></li><li><p>确定后会添加到图中选中部分，点击确定，备份完成。</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725103541.jpg" alt="备份3"></p><h2 id="SqlServer还原"><a href="#SqlServer还原" class="headerlink" title="SqlServer还原"></a>SqlServer还原</h2><ol><li><p>将还原的.bak文件拷贝至服务器</p></li><li><p>右键要还原的数据库，选择任务–&gt;还原–&gt;数据库</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725110916.png" alt="还原"></p></li><li><p>左边选择常规，源选择设备，添加文件，选择刚才拷贝的备份文件</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725111102.jpg" alt="备份2"></p></li><li><p>如果已经存在数据库，直接左边选择选项，勾选覆盖现有数据库，确定即可。</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725111200.jpg" alt="备份3"></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> SqlServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SqlServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7.2 系统服务器中挖矿病毒查杀</title>
      <link href="/2019/07/23/zigw%E7%97%85%E6%AF%92%E6%9F%A5%E6%9D%80/"/>
      <url>/2019/07/23/zigw%E7%97%85%E6%AF%92%E6%9F%A5%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS7-2-系统服务器中挖矿病毒查杀"><a href="#CentOS7-2-系统服务器中挖矿病毒查杀" class="headerlink" title="CentOS7.2 系统服务器中挖矿病毒查杀"></a>CentOS7.2 系统服务器中挖矿病毒查杀</h2><p>本文参考链接如下：</p><ul><li><a href="https://blog.csdn.net/sayWhat_sayHello/article/details/83988443" target="_blank" rel="noopener">zigw挖矿病毒查杀</a></li><li><a href="https://mp.weixin.qq.com/s/FhcoPGXG_udkRCj3AFOmxA" target="_blank" rel="noopener">如何排查常见挖矿木马</a></li></ul><h4 id="1-服务卡顿，执行top-c命令"><a href="#1-服务卡顿，执行top-c命令" class="headerlink" title="1. 服务卡顿，执行top c命令"></a>1. 服务卡顿，执行top c命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos ~]# top c</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%97%85%E6%AF%92.png" alt="服务器病毒"></p><blockquote><p><strong>关于top命令</strong>（<a href="https://blog.csdn.net/wxh2013/article/details/50995501" target="_blank" rel="noopener">参考</a>）</p><p>1.作用<br>top命令用来显示执行中的程序进程，使用权限是所有用户。</p><p>2.格式<br>top [－] [d delay] [q] [c] [S] [s] [i] [n]</p><p>3.主要参数<br>d：指定更新的间隔，以秒计算。<br>q：没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行。<br>c：显示进程完整的路径与名称。<br>S：累积模式，会将己完成或消失的子行程的CPU时间累积起来。<br>s：安全模式。<br>i：不显示任何闲置(Idle)或无用(Zombie)的行程。<br>n：显示更新的次数，完成后将会退出top。</p><p>4.每行信息详解</p><ul><li><p>第一行表示的项目依次为当前时间、系统运行时间、当前系统登录用户数目、1/5/10分钟系统平均负载(一般来说，这个负载值应该不太可能超过 1 才对，除非您的系统很忙碌。 如果持续高于 5 的话，那么…..仔细的看看到底是那个程序在影响整体系统吧！)。</p></li><li><p>第二行显示的是所有启动的进程、目前运行、挂起 (Sleeping)的和无用(Zombie)的进程。(比较需要注意的是最后的 zombie 那个数值，如果不是 0 ，嘿嘿！好好看看到底是那个 process 变成疆尸了吧？！)(stop模式：与sleep进程应区别，sleep会主动放弃cpu，而stop是被动放弃cpu ，例单步跟踪，stop（暂停）的进程是无法自己回到运行状态的)</p></li><li><p>第三行显示的是目前CPU的使用情况，包括us用户空间占用CPU百分比、sy 内核空间占用CPU百分比、ni 用户进程空间内改变过优先级的进程占用CPU百分比(中断处理占用)、id 空闲CPU百分比、wa 等待输入输出的CPU时间百分比、hi,si,st 三者的意思目录还不清楚</p></li><li><p>第四行显示物理内存的使用情况，包括总的可以使用的内存、已用内存、空闲内存、缓冲区占用的内存。</p></li><li><p>第五行显示交换分区使用情况，包括总的交换分区、使用的、空闲的和用于高速缓存的大小。</p></li><li><p>第六行显示的项目最多，下面列出了详细解释。<br>PID（Process ID）：进程标示号 ( 每个 process 的 ID )<br>USER：进程所有者的用户名 ( 该 process 所属的使用者 )<br>PR：进程的优先级别 ( Priority 的简写，程序的优先执行顺序，越小越早被执行 )<br>NI：进程的优先级别数值 ( Nice 的简写，与 Priority 有关，也是越小越早被执行 )<br>VIRT：进程占用的虚拟内存值。<br>RES：进程占用的物理内存值。<br>SHR：进程使用的共享内存值。<br>S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。<br>%CPU：该进程占用的CPU使用率。<br>%MEM：该进程占用的物理内存和总内存的百分比。<br>TIME＋：该进程启动后占用的总的CPU时间 ( CPU 使用时间的累加 )<br>Command：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行。</p></li></ul><p>top命令使用过程中，还可以使用一些交互的命令来完成其它参数的功能。这些命令是通过快捷键启动的。<br>＜空格＞：立刻刷新。<br>P：根据CPU使用大小进行排序。<br>T：根据时间、累计时间排序。<br>q：退出top命令。<br>m：切换显示内存信息。<br>t：切换显示进程和CPU状态信息。<br>c：切换显示命令名称和完整命令行。<br>M：根据使用内存大小进行排序。<br>W：将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</p></blockquote><h4 id="2-查看系统运行情况，记录PID"><a href="#2-查看系统运行情况，记录PID" class="headerlink" title="2.查看系统运行情况，记录PID"></a>2.查看系统运行情况，记录PID</h4><blockquote><p>可以看到./zigw正在运行占用了系统98%的CPU从而导致系统卡顿</p><p>记录运行的PID 3692</p></blockquote><h4 id="3-查看定时任务"><a href="#3-查看定时任务" class="headerlink" title="3. 查看定时任务"></a>3. 查看定时任务</h4><blockquote><p>进入/var/spool/cron 目录以及/etc/cron.daily/、/etc/cron.hourly/、/etc/cron.monthly……等</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E7%97%85%E6%AF%92%E6%9F%A5%E6%89%BE.png" alt="病毒查找"></p><h4 id="4-删除定时任务文件"><a href="#4-删除定时任务文件" class="headerlink" title="4. 删除定时任务文件"></a>4. 删除定时任务文件</h4><blockquote><p>执行rm -rf 删除root以及dump.rdb文件（第一次未成功使用xftp连接直接删除成功）</p><p>执行过程可能会报没有权限删除，查看是否是因为chattr命令锁定了</p><p>先使用lsattr命令查看文件属性，如果有权限锁定使用chattr命令修改权限</p><p>chattr命令的用法：chattr [ -RVf ] [ -v version ] [ mode ] files…</p><p>例：chattr -i root </p><p><strong>参数说明</strong></p><blockquote><p>+：在原有参数设定基础上，追加参数。</p><p>-：在原有参数设定基础上，移除参数。<br>= ：更新为指定参数设定。<br>A：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防例如手提电脑磁盘I/O错误的发生。<br>S：硬盘I/O同步选项，功能类似sync。<br>a：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，只有root才能设定这个属性。<br>c：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。<br>d：即no dump，设定文件不能成为dump程序的备份目标。<br>i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。<br>j：即journal，设定此参数使得当通过mount参数：data=ordered 或者 data=writeback 挂 载的文件系统，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效。<br>s：保密性地删除文件或目录，即硬盘空间被全部收回。<br>u：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。<br>各参数选项中常用到的是a和i。a选项强制只可添加不可删除，多用于日志系统的安全设定。而i是更为严格的安全设定，只有superuser (root) 或具有CAP_LINUX_IMMUTABLE处理能力（标识）的进程能够施加该选项。</p><p>…….</p></blockquote></blockquote><h4 id="5-进入-proc目录，查看指定端口信息"><a href="#5-进入-proc目录，查看指定端口信息" class="headerlink" title="5. 进入/proc目录，查看指定端口信息"></a>5. 进入/proc目录，查看指定端口信息</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E7%97%85%E6%AF%92%E6%9F%A5%E6%89%BE2.png" alt="病毒查找2"></p><blockquote><p>可以看到有一条指向/etc/zigw</p></blockquote><h4 id="6-进入etc目录"><a href="#6-进入etc目录" class="headerlink" title="6. 进入etc目录"></a>6. 进入etc目录</h4><blockquote><p>先杀进程 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span> [root@VM_0_5_centos 3692]# kill -9 3692</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>再用chattr改变zigw等病毒文件的权限进行删除。</p></blockquote><h4 id="7-删除ssh-keys"><a href="#7-删除ssh-keys" class="headerlink" title="7. 删除ssh-keys"></a>7. 删除ssh-keys</h4><blockquote><p>进入/root/.ssh目录 ，删除authorize_keys</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/ssh%E5%88%A0%E9%99%A4.png" alt="ssh删除"></p></blockquote><h4 id="8-再执行top-c查看"><a href="#8-再执行top-c查看" class="headerlink" title="8. 再执行top c查看"></a>8. 再执行top c查看</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E7%97%85%E6%AF%92%E5%A4%8D%E5%8F%91.png" alt="病毒复发"></p><h4 id="9-重新执行"><a href="#9-重新执行" class="headerlink" title="9. 重新执行"></a>9. 重新执行</h4><blockquote><p> 重新删除root以及dump.rdb文件，查看定时任务情况，在xftp下都进行删除，重新执行kill -9 14120杀死进程，不再复发。</p></blockquote><h4 id="10-重新配置redis安全配置"><a href="#10-重新配置redis安全配置" class="headerlink" title="10. 重新配置redis安全配置"></a>10. 重新配置redis安全配置</h4>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> zigw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> zigw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle中使用正则表达式</title>
      <link href="/2019/07/23/Oracle%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/07/23/Oracle%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle中使用正则表达式"><a href="#Oracle中使用正则表达式" class="headerlink" title="Oracle中使用正则表达式"></a>Oracle中使用正则表达式</h2><ol><li><h3 id="regexp-like"><a href="#regexp-like" class="headerlink" title="regexp_like"></a>regexp_like</h3><blockquote><p><strong>regexp_like</strong> 只能用于条件表达式，和 like 类似，但是使用的正则表达式进行匹配</p><p>语法： REGEXP_LIKE(srcstr, pattern [,match_option])</p><ol><li>srcstr : 搜索值</li><li>pattern : 正则表达式</li><li>match_option : 匹配选项，可以包含一个或多个<ul><li>“c” : 使用区分大小写的匹配（默认值）</li><li>“i” : 使用不区分大小写的匹配</li><li>“n” : 允许匹配任何字符的运算符来匹配换行符</li><li>“m” : 将源字符串作为多行处理</li></ul></li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; select str from tmp where id='like' and regexp_like(str,'A\d+','i');</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="regexp-substr"><a href="#regexp-substr" class="headerlink" title="regexp_substr"></a>regexp_substr</h3><blockquote><p><strong>regexp_substr</strong> 函数，和 substr 类似，截取符合正则匹配的字符串</p><p>语法：REGEXP_SUBSTR(srcstr, pattern [, position [, occurrence [, match_option]]])</p><ol><li>position : 搜索的起始位置</li><li>occurrence : 搜索的匹配项</li><li>match_option : 匹配选项，可以包含一个或多个<ul><li>“c” : 使用区分大小写的匹配（默认值）</li><li>“i” : 使用不区分大小写的匹配</li><li>“n” : 允许匹配任何字符的运算符来匹配换行符</li><li>“m” : 将源字符串作为多行处理</li></ul></li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; select</span><br><span class="line">&gt; str, </span><br><span class="line">&gt; regexp_substr(str,'[^,]+') str,</span><br><span class="line">&gt; regexp_substr(str,'[^,]+',1,1) str,</span><br><span class="line">&gt; regexp_substr(str,'[^,]+',1,2) str,</span><br><span class="line">&gt; regexp_substr(str,'[^,]+',2,1) str</span><br><span class="line">&gt; from tmp</span><br><span class="line">&gt; where id='substr';</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="regexp-instr"><a href="#regexp-instr" class="headerlink" title="regexp_instr"></a>regexp_instr</h3><blockquote><p><strong>regexp_instr</strong>函数， 和 instr 类似，用于标定正则匹配的字符子串的开始位置</p><p>语法：REGEXP_INSTR(srcstr, pattern [, position [, occurrence[, return_option [, match_option]]]])</p><ol><li>srcstr : 搜索值</li><li>pattern : 正则表达式</li><li>position : 搜索的起始位置</li><li>occurrence : 搜索的匹配项</li><li>return_option : 匹配项的开头或结尾位置</li><li>match_option : 匹配选项，可以包含一个或多个<ul><li>“c” : 使用区分大小写的匹配（默认值）</li><li>“i” : 使用不区分大小写的匹配</li><li>“n” : 允许匹配任何字符的运算符来匹配换行符</li><li>“m” : 将源字符串作为多行处理</li></ul></li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; select</span><br><span class="line">&gt; str, </span><br><span class="line">&gt; regexp_instr(str,'\.'    ) ind ,</span><br><span class="line">&gt; regexp_instr(str,'\.',1,2) ind ,</span><br><span class="line">&gt; regexp_instr(str,'\.',5,2) ind</span><br><span class="line">&gt; from tmp where id='instr';</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="regexp-replace"><a href="#regexp-replace" class="headerlink" title="regexp_replace"></a>regexp_replace</h3><blockquote><p><strong>regexp_replace</strong> 函数，和 replace 类似，用于替换符合正则表达式的字符串</p><p>语法：REGEXP_REPLACE(srcstr, pattern [,replacestr [, position[, occurrence [, match_option]]]])</p><ol><li>srcstr : 搜索值</li><li>pattern : 正则表达式</li><li>replacestr : 替换模式的字符串</li><li>position : 搜索的起始位置</li><li>occurrence : 搜索的匹配项</li><li>match_option : 匹配选项，可以包含一个或多个<ul><li>“c” : 使用区分大小写的匹配（默认值）</li><li>“i” : 使用不区分大小写的匹配</li><li>“n” : 允许匹配任何字符的运算符来匹配换行符</li><li>“m” : 将源字符串作为多行处理</li></ul></li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; select</span><br><span class="line">&gt; str,</span><br><span class="line">&gt; regexp_replace(str,'020','GZ') str,</span><br><span class="line">&gt; regexp_replace(str,'(\d&#123;3&#125;)(\d&#123;3&#125;)','&lt;\2\1&gt;') str </span><br><span class="line">&gt; -- 将第一、第二捕获组交换位置，用尖括号标识出来</span><br><span class="line">&gt; from tmp</span><br><span class="line">&gt; where id='replace';</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Oracle </category>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Oracle </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle常用操作</title>
      <link href="/2019/07/23/Oracle%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/07/23/Oracle%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库误删恢复"><a href="#数据库误删恢复" class="headerlink" title="数据库误删恢复"></a>数据库误删恢复</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--10分钟前数据可用于误删回复</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名_tmp <span class="keyword">as</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">AS</span> <span class="keyword">OF</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">SYSDATE</span> - <span class="number">10</span>/<span class="number">1440</span></span><br><span class="line">)；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名_tmp；</span><br><span class="line"><span class="keyword">update</span> 表名A  <span class="keyword">set</span> A.S_GRADE=(<span class="keyword">select</span> S_GRADE  <span class="keyword">from</span> 表名_TMP B <span class="keyword">where</span> A.ID=B.ID)；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--闪回</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">enable</span> <span class="keyword">row</span> <span class="keyword">movement</span>;</span><br><span class="line">flashback table 表名 to timestamp to_timestamp('2018-08-09 10:00:00','yyyy-mm-dd HH24:MI:SS');</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">disable</span> <span class="keyword">row</span> <span class="keyword">movement</span>;</span><br></pre></td></tr></table></figure><h2 id="处理锁定"><a href="#处理锁定" class="headerlink" title="处理锁定"></a>处理锁定</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--处理锁定</span></span><br><span class="line"><span class="keyword">select</span> t1.sid, t1.serial<span class="comment">#, t1.username, t1.logon_time from v$session t1 , v$locked_object t2</span></span><br><span class="line"><span class="keyword">where</span> t1.sid = t2.session_id <span class="keyword">order</span> <span class="keyword">by</span> t1.logon_time;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">kill</span> <span class="keyword">session</span> <span class="string">'1025,1152'</span></span><br></pre></td></tr></table></figure><h2 id="查询历史执行记录"><a href="#查询历史执行记录" class="headerlink" title="查询历史执行记录"></a>查询历史执行记录</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看oracle执行的语句</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v$<span class="keyword">sql</span> t</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">t.PARSING_SCHEMA_NAME = <span class="string">'数据库名称'</span> <span class="comment">--数据库</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">lower</span>(t.SQL_TEXT) <span class="keyword">like</span> <span class="string">'%sql语句中包含的信息%'</span> <span class="comment">--查询某类SQL语句</span></span><br><span class="line"><span class="keyword">and</span>  t.LAST_ACTIVE_TIME&gt;(<span class="keyword">sysdate</span> - <span class="built_in">interval</span> <span class="string">'1'</span> <span class="keyword">MINUTE</span>)  <span class="comment">--执行1分钟内的SQL语句</span></span><br><span class="line"><span class="keyword">and</span> (t.MODULE <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> t.MODULE <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">'%PL/SQL%'</span>) <span class="comment">--不是在某些终端里的执行</span></span><br></pre></td></tr></table></figure><h2 id="触发器和序列"><a href="#触发器和序列" class="headerlink" title="触发器和序列"></a>触发器和序列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--序列</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> POWERPMS.S_NBG_MAT_APPLY</span><br><span class="line">    <span class="keyword">INCREMENT</span> <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span></span><br><span class="line">    MAXVALUE <span class="number">1000000000000000000000000000</span></span><br><span class="line">    <span class="keyword">NOMINVALUE</span></span><br><span class="line">    <span class="keyword">NOCYCLE</span></span><br><span class="line">    <span class="keyword">CACHE</span> <span class="number">20</span></span><br><span class="line">    <span class="keyword">NOORDER</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="comment">--触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">TRIGGER</span> POWERPMS.TID_NBG_MAT_APPLY</span><br><span class="line">  <span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> NBG_MAT_APPLY</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> S_NBG_MAT_APPLYT.NEXTVAL <span class="keyword">INTO</span> :NEW.OLD_UNIQUEID <span class="keyword">FROM</span> DUAL; </span><br><span class="line"><span class="keyword">END</span> TID_NBG_MAT_APPLY;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h2 id="关联更新"><a href="#关联更新" class="headerlink" title="关联更新"></a>关联更新</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span>  表A <span class="keyword">USING</span>  表B <span class="keyword">ON</span> ( 表A.字段= 表B.字段) <span class="keyword">WHEN</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">SET</span> 表A.字段 = 表B.字段</span><br></pre></td></tr></table></figure><h2 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h2><blockquote><p>10g ：wm_concat</p><p>11g : pivot ，unpivot </p><p>12c :  listagg</p><p><a href="https://www.cnblogs.com/mellowsmile/p/4642306.html" target="_blank" rel="noopener">参考链接</a></p></blockquote><h2 id="表空间不足"><a href="#表空间不足" class="headerlink" title="表空间不足"></a>表空间不足</h2><p>项目中使用出现报错</p><blockquote><p>ORA-01653: 表xx无法通过 8192 (在表空间 xx_data 中) 扩展。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询剩余表空间，发现没有要找的表空间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UPPER</span>(F.TABLESPACE_NAME) <span class="string">"表空间名"</span>,D.TOT_GROOTTE_MB <span class="string">"表空间大小(M)"</span>,D.TOT_GROOTTE_MB - F.TOTAL_BYTES <span class="string">"已使用空间(M)"</span>,</span><br><span class="line">TO_CHAR(<span class="keyword">ROUND</span>((D.TOT_GROOTTE_MB - F.TOTAL_BYTES)/D.TOT_GROOTTE_MB * <span class="number">100</span>,<span class="number">2</span>),<span class="string">'990.99'</span>) <span class="string">"使用比"</span>,</span><br><span class="line">F.TOTAL_BYTES <span class="string">"空闲空间(M)"</span>,</span><br><span class="line">F.MAX_BYTES <span class="string">"最大块(M)"</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> TABLESPACE_NAME,</span><br><span class="line"><span class="keyword">ROUND</span>(<span class="keyword">SUM</span>(<span class="keyword">BYTES</span>)/(<span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>) TOTAL_BYTES,</span><br><span class="line"><span class="keyword">ROUND</span>(<span class="keyword">MAX</span>(<span class="keyword">BYTES</span>)/(<span class="number">1024</span> * <span class="number">1024</span>), <span class="number">2</span>) MAX_BYTES</span><br><span class="line"><span class="keyword">FROM</span> SYS.DBA_FREE_SPACE</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TABLESPACE_NAME) F,</span><br><span class="line">(<span class="keyword">SELECT</span> DD.TABLESPACE_NAME,</span><br><span class="line"><span class="keyword">ROUND</span>(<span class="keyword">SUM</span>(DD.BYTES)/(<span class="number">1024</span> * <span class="number">1024</span>),<span class="number">2</span>) TOT_GROOTTE_MB</span><br><span class="line"><span class="keyword">FROM</span> SYS.DBA_DATA_FILES DD</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> DD.TABLESPACE_NAME) D</span><br><span class="line"><span class="keyword">WHERE</span> D.TABLESPACE_NAME = F.TABLESPACE_NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">4</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看表空间是否具有自动扩展的能力   </span></span><br><span class="line"><span class="keyword">SELECT</span> T.TABLESPACE_NAME,D.FILE_NAME,D.AUTOEXTENSIBLE,D.BYTES,D.MAXBYTES,D.STATUS</span><br><span class="line"><span class="keyword">FROM</span> DBA_TABLESPACES T,DBA_DATA_FILES D</span><br><span class="line"><span class="keyword">WHERE</span> T.TABLESPACE_NAME =D.TABLESPACE_NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> TABLESPACE_NAME,FILE_NAME;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改表空间文件扩展方式:  路径是上面查询的 FILE_NAME</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span>  <span class="keyword">DATAFILE</span> <span class="string">'D:\ORACLE\PRODUCT\10.2.0\ORADATA\NBGPMC\POWERPMS.ORA'</span> <span class="keyword">AUTOEXTEND</span>  <span class="keyword">ON</span> <span class="keyword">NEXT</span> <span class="number">50</span>M <span class="keyword">MAXSIZE</span> <span class="keyword">UNLIMITED</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔记</title>
      <link href="/2019/07/20/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/20/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Java基础笔记"><a href="#Java基础笔记" class="headerlink" title="Java基础笔记"></a>Java基础笔记</h1><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h2><h3 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h3><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p><p><strong>特点：关键字中所字母都为小写</strong></p><p>具体如下：</p><ul><li><p>用于定义数据类型的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>class</td><td>interface</td><td>enum</td><td>byte</td><td>short</td></tr><tr><td>int</td><td>long</td><td>float</td><td>double</td><td>char</td></tr><tr><td>boolean</td><td>void</td><td></td><td></td><td></td></tr></tbody></table></li><li><p>用于定义流程控制的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>if</td><td>else</td><td>switch</td><td>case</td><td>default</td></tr><tr><td>while</td><td>do</td><td>for</td><td>break</td><td>continue</td></tr><tr><td>return</td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>用于定义访问权限修饰符的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>private</td><td>protected</td><td>public</td><td></td><td></td></tr></tbody></table></li><li><p>用于定义类、函数、变量修饰符的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abstract</td><td>final</td><td>static</td><td>synchronized</td><td></td></tr></tbody></table></li><li><p>用于定义类与类之间关系的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>extents</td><td>implements</td><td></td><td></td><td></td></tr></tbody></table></li><li><p>用于定义建立实例及引用实例、判断实例的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>new</td><td>this</td><td>super</td><td>instanceof</td><td></td></tr></tbody></table></li><li><p>用于异常处理的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>try</td><td>catch</td><td>finally</td><td>throw</td><td>throws</td></tr></tbody></table></li></ul><h3 id="1-2保留字"><a href="#1-2保留字" class="headerlink" title="1.2保留字"></a>1.2保留字</h3><p>goto、const</p><h3 id="1-3标识符"><a href="#1-3标识符" class="headerlink" title="1.3标识符"></a>1.3标识符</h3><p>定义：凡是自己可以起名字的地方都叫标识符</p><p>涉及到的结构：包名、类名、接口名、变量名、方法名、常量名</p><p>规则：</p><ul><li><strong>由26个英文字母大小写，0-9，_或$组成</strong></li><li><strong>数字不可以开头</strong></li><li><strong>不可以使用关键字和保留字，但能包含关键字和保留字</strong></li><li><strong>Java中严格区分大小写，长度无限制</strong></li><li><strong>标识符不能包含空格</strong></li></ul><p>规范：</p><ul><li>包名：多单词组成时所有字符都小写</li><li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li><li>变量名、方法名：多单词组成时，第一个单词的首字母小写，第二个单词开始每个单词首字母大写：XxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li></ul><h3 id="1-4变量"><a href="#1-4变量" class="headerlink" title="1.4变量"></a>1.4变量</h3><ol><li><p>变量的分类</p><ol><li><p>按数据类型分类</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522100724.png" alt></p></li><li><p>详细说明</p><ol><li>整型：byte(1字节=8bit) \ short(2字节) \ int(4字节) \ long(8字节)<ul><li>① byte范围：-128 ~ 127</li><li>② 声明long型变量，必须以”l”或”L”结尾</li><li>③ 通常，定义整型变量时，使用int型。</li><li>④整型的常量，默认类型是：int型</li></ul></li><li>浮点型：float(4字节) \ double(8字节)<ul><li>① 浮点型，表示带小数点的数值</li><li>② float表示数值的范围比long还大</li><li>③ 定义float类型变量时，变量要以”f”或”F”结尾</li><li>④ 通常，定义浮点型变量时，使用double型。</li><li>⑤ 浮点型的常量，默认类型为：double</li></ul></li><li>字符型：char (1字符=2字节)<ul><li>① 定义char型变量，通常使用一对’’,内部只能写一个字符</li><li>② 表示方式：1.声明一个字符 2.转义字符 3.直接使用 Unicode 值来表示字符型常量</li></ul></li><li>布尔型：boolean<ul><li>① 只能取两个值之一：true 、 false</li><li>② 常常在条件判断、循环结构中使用</li></ul></li></ol></li><li><p>按声明的位置分类</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522123945.png" alt></p></li></ol></li><li><p>定义变量的格式</p><p> 数据类型  变量名 = 变量值;<br> 数据类型  变量名;<br> 变量名 = 变量值;</p></li><li><p>变量使用的注意点</p><ul><li>变量必须先声明，后使用</li><li>变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了</li><li>同一个作用域内，不可以声明两个同名的变量</li></ul></li><li><p>基本数据类型变量间运算规则</p><ol><li><p>涉及到的基本数据类型：除了boolean之外的其他7种</p></li><li><p>自动类型转换(只涉及7种基本数据类型）</p><p> 结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果<strong>自动提升为容量大</strong>的数据类型。</p><blockquote><p>byte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double </p><p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p><p><strong>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</strong></p></blockquote></li><li><p>强制类型转换(只涉及7种基本数据类型）：<strong>自动类型提升运算的逆运算</strong>。</p><ol><li>需要使用强转符：(类型)</li><li>注意点：强制类型转换，可能导致精度损失。</li></ol></li><li><p>String与8种基本数据类型间的运算</p><ol><li><p>String属于引用数据类型，翻译为：字符串</p></li><li><p>声明String类型变量时，使用一对””</p></li><li><p>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</p></li><li><p>运算的结果仍然是String类型</p><p>避免：</p><p>String s = 123;//编译错误</p><p>String s1 = “123”;</p><p>int i = (int)s1;//编译错误</p></li></ol></li></ol></li></ol><h3 id="1-5运算符"><a href="#1-5运算符" class="headerlink" title="1.5运算符"></a>1.5运算符</h3><ol><li><p>算数运算符： + - * / % (前)++ (后)++ (前)– (后)– </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="comment">//除号：/</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> result1 = num1 / num2;</span><br><span class="line">System.out.println(result1);<span class="comment">//2</span></span><br><span class="line"><span class="comment">// %:取余运算</span></span><br><span class="line"><span class="comment">//结果的符号与被模数的符号相同</span></span><br><span class="line"><span class="comment">//开发中，经常使用%来判断能否被除尽的情况。</span></span><br><span class="line"><span class="keyword">int</span> m1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m1 % n1 = "</span> + m1 % n1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m2 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m2 % n2 = "</span> + m2 % n2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m3 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n3 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m3 % n3 = "</span> + m3 % n3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m4 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n4 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m4 % n4 = "</span> + m4 % n4);</span><br><span class="line"><span class="comment">//(前)++ :先自增1，后运算</span></span><br><span class="line"><span class="comment">//(后)++ :先运算，后自增1</span></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = ++a1;</span><br><span class="line">System.out.println(<span class="string">"a1 = "</span> + a1 + <span class="string">",b1 = "</span> + b1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = a2++;</span><br><span class="line">System.out.println(<span class="string">"a2 = "</span> + a2 + <span class="string">",b2 = "</span> + b2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">++a3;<span class="comment">//a3++;</span></span><br><span class="line"><span class="keyword">int</span> b3 = a3;</span><br><span class="line"><span class="comment">//(前)-- :先自减1，后运算</span></span><br><span class="line"><span class="comment">//(后)-- :先运算，后自减1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b4 = a4--;<span class="comment">//int b4 = --a4;</span></span><br><span class="line">System.out.println(<span class="string">"a4 = "</span> + a4 + <span class="string">",b4 = "</span> + b4);</span><br><span class="line"></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>.<span class="comment">//(前)++ :先自增1，后运算</span></span><br><span class="line"> <span class="comment">//(后)++ :先运算，后自增1</span></span><br><span class="line"><span class="number">2</span>.<span class="comment">//(前)-- :先自减1，后运算</span></span><br><span class="line">  <span class="comment">//(后)-- :先运算，后自减1</span></span><br><span class="line"><span class="number">3</span>.连接符：+：只能使用在String与其他数据类型变量之间使用。</span><br></pre></td></tr></table></figure></li><li><p>赋值运算符：=  +=  -=  *=  /=  %= </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i2,j2;</span><br><span class="line"><span class="comment">//连续赋值</span></span><br><span class="line">i2 = j2 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//***************</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">10</span>,j3 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">num1 += <span class="number">2</span>;<span class="comment">//num1 = num1 + 2;</span></span><br><span class="line">System.out.println(num1);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">12</span>;</span><br><span class="line">num2 %= <span class="number">5</span>;<span class="comment">//num2 = num2 % 5;</span></span><br><span class="line">System.out.println(num2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//s1 = s1 + 2;//编译失败</span></span><br><span class="line">s1 += <span class="number">2</span>;<span class="comment">//结论：不会改变变量本身的数据类型</span></span><br><span class="line">System.out.println(s1);</span><br><span class="line"></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>.运算的结果不会改变变量本身的数据类型</span><br><span class="line"><span class="number">2</span>.</span><br><span class="line"><span class="comment">//开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 2;</span></span><br><span class="line"><span class="comment">//方式二：num += 2; (推荐)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 1;</span></span><br><span class="line"><span class="comment">//方式二：num += 1; </span></span><br><span class="line"><span class="comment">//方式三：num++; (推荐)</span></span><br></pre></td></tr></table></figure></li><li><p>比较运算符： == != &gt;  &lt;  &gt;=  &lt;=  instanceof</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line">System.out.println(i = j);<span class="comment">//20</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(b2 == b1);<span class="comment">//false</span></span><br><span class="line">System.out.println(b2 = b1);<span class="comment">//true</span></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>.比较运算符的结果是<span class="keyword">boolean</span>类型</span><br><span class="line"><span class="number">2</span>.&gt;  &lt;  &gt;=  &lt;= :只能使用在数值类型的数据之间。</span><br><span class="line"><span class="number">3</span>. == 和 !=: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</span><br><span class="line">Account acct1 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">Account acct2 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">boolean</span> b1 = (acct1 == acct2);<span class="comment">//比较两个Account是否是同一个账户。</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = (acct1 != acct2);<span class="comment">//</span></span><br></pre></td></tr></table></figure></li><li><p>逻辑运算符：&amp; &amp;&amp;  |  || !  ^</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="comment">//区分&amp; 与 &amp;&amp;</span></span><br><span class="line"><span class="comment">//相同点1：&amp; 与  &amp;&amp; 的运算结果相同</span></span><br><span class="line"><span class="comment">//相同点2：当符号左边是true时，二者都会执行符号右边的运算</span></span><br><span class="line"><span class="comment">//不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</span></span><br><span class="line"><span class="comment">//开发中，推荐使用&amp;&amp;</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">b1 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b1 &amp; (num1++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在北京"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在南京"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">true</span>;</span><br><span class="line">b2 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b2 &amp;&amp; (num2++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在北京"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在南京"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line"><span class="comment">// 区分：| 与 || </span></span><br><span class="line"><span class="comment">//相同点1：| 与  || 的运算结果相同</span></span><br><span class="line"><span class="comment">//相同点2：当符号左边是false时，二者都会执行符号右边的运算</span></span><br><span class="line"><span class="comment">//不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</span></span><br><span class="line"><span class="comment">//开发中，推荐使用||</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = <span class="keyword">false</span>;</span><br><span class="line">b3 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b3 | (num3++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在北京"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在南京"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"num3 = "</span> + num3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b4 = <span class="keyword">false</span>;</span><br><span class="line">b4 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num4 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b4 || (num4++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在北京"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在南京"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"num4 = "</span> + num4);</span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>.逻辑运算符操作的都是<span class="keyword">boolean</span>类型的变量。而且结果也是<span class="keyword">boolean</span>类型</span><br></pre></td></tr></table></figure></li><li><p>位运算符：&lt;&lt;  &gt;&gt; &gt;&gt;&gt; &amp;  |  ^  ~</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">21</span>;</span><br><span class="line">i = -<span class="number">21</span>;</span><br><span class="line">System.out.println(<span class="string">"i &lt;&lt; 2 :"</span> + (i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">"i &lt;&lt; 3 :"</span> + (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">"i &lt;&lt; 27 :"</span> + (i &lt;&lt; <span class="number">27</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m &amp; n :"</span> + (m &amp; n));</span><br><span class="line">System.out.println(<span class="string">"m | n :"</span> + (m | n));</span><br><span class="line">System.out.println(<span class="string">"m ^ n :"</span> + (m ^ n));</span><br><span class="line">【面试题】 你能否写出最高效的<span class="number">2</span> * <span class="number">8</span>的实现方式？ </span><br><span class="line">答案：<span class="number">2</span> &lt;&lt; <span class="number">3</span>  或  <span class="number">8</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>. 位运算符操作的都是整型的数据</span><br><span class="line"><span class="number">2</span>. &lt;&lt; ：在一定范围内，每向左移<span class="number">1</span>位，相当于 * <span class="number">2</span></span><br><span class="line">   &gt;&gt; :在一定范围内，每向右移<span class="number">1</span>位，相当于 / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">典型题目：</span><br><span class="line"><span class="number">1</span>.交换两个变量的值。</span><br><span class="line"><span class="number">2</span>.实现<span class="number">60</span>的二进制到十六进制的转换</span><br></pre></td></tr></table></figure></li><li><p>三元运算符：(条件表达式)? 表达式1 : 表达式2</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="number">1</span>.获取两个整数的较大值</span><br><span class="line"><span class="number">2</span>.获取三个数的最大值</span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>. 说明</span><br><span class="line">① 条件表达式的结果为<span class="keyword">boolean</span>类型</span><br><span class="line">② 根据条件表达式真或假，决定执行表达式<span class="number">1</span>，还是表达式<span class="number">2</span>.</span><br><span class="line">  如果表达式为<span class="keyword">true</span>，则执行表达式<span class="number">1</span>。</span><br><span class="line">  如果表达式为<span class="keyword">false</span>，则执行表达式<span class="number">2</span>。</span><br><span class="line">③ 表达式<span class="number">1</span> 和表达式<span class="number">2</span>要求是一致的。</span><br><span class="line">④ 三元运算符可以嵌套使用</span><br><span class="line"><span class="number">2</span>. 凡是可以使用三元运算符的地方，都可以改写为<span class="keyword">if</span>-<span class="keyword">else</span>，反之，不成立。</span><br><span class="line"><span class="number">3</span>. 如果程序既可以使用三元运算符，又可以使用<span class="keyword">if</span>-<span class="keyword">else</span>结构，那么优先选择三元运算符。原因：简洁、执行效率高。</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-6流程控制"><a href="#1-6流程控制" class="headerlink" title="1.6流程控制"></a>1.6流程控制</h3><ol><li><p>分支结构</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">if</span>-<span class="keyword">else</span>条件判断结构</span><br><span class="line"><span class="number">1.1</span>.</span><br><span class="line">结构一：</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构二：二选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构三：n选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span>.说明：</span><br><span class="line"><span class="number">1</span>. <span class="keyword">else</span> 结构是可选的。</span><br><span class="line"><span class="number">2</span>. 针对于条件表达式：</span><br><span class="line">   &gt; 如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。</span><br><span class="line">   &gt; 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。</span><br><span class="line">   &gt; 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。</span><br><span class="line"><span class="number">3</span>. <span class="keyword">if</span>-<span class="keyword">else</span>结构是可以相互嵌套的。</span><br><span class="line"><span class="number">4</span>. 如果<span class="keyword">if</span>-<span class="keyword">else</span>结构中的执行语句只有一行时，对应的一对&#123;&#125;可以省略的。但是，不建议大家省略。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.<span class="keyword">switch</span>-<span class="keyword">case</span>选择结构</span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">执行语句n;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>.说明：</span><br><span class="line">① 根据<span class="keyword">switch</span>表达式中的值，依次匹配各个<span class="keyword">case</span>中的常量。一旦匹配成功，则进入相应<span class="keyword">case</span>结构中，调用其执行语句。</span><br><span class="line">  当调用完执行语句以后，则仍然继续向下执行其他<span class="keyword">case</span>结构中的执行语句，直到遇到<span class="keyword">break</span>关键字或此<span class="keyword">switch</span>-<span class="keyword">case</span>结构</span><br><span class="line">  末尾结束为止。</span><br><span class="line">② <span class="keyword">break</span>,可以使用在<span class="keyword">switch</span>-<span class="keyword">case</span>结构中，表示一旦执行到此关键字，就跳出<span class="keyword">switch</span>-<span class="keyword">case</span>结构</span><br><span class="line">③ <span class="keyword">switch</span>结构中的表达式，只能是如下的<span class="number">6</span>种数据类型之一：</span><br><span class="line">   <span class="keyword">byte</span> 、<span class="keyword">short</span>、<span class="keyword">char</span>、<span class="keyword">int</span>、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)</span><br><span class="line">④ <span class="keyword">case</span> 之后只能声明常量。不能声明范围。</span><br><span class="line">⑤ <span class="keyword">break</span>关键字是可选的。</span><br><span class="line">⑥ <span class="keyword">default</span>:相当于<span class="keyword">if</span>-<span class="keyword">else</span>结构中的<span class="keyword">else</span>.  </span><br><span class="line">  <span class="keyword">default</span>结构是可选的，而且位置是灵活的。</span><br><span class="line"><span class="number">3</span>.如果<span class="keyword">switch</span>-<span class="keyword">case</span>结构中的多个<span class="keyword">case</span>的执行语句相同，则可以考虑进行合并。</span><br><span class="line"><span class="number">4</span>.<span class="keyword">break</span>在<span class="keyword">switch</span>-<span class="keyword">case</span>中是可选的</span><br></pre></td></tr></table></figure></li><li><p>循环结构</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.循环结构的四要素</span><br><span class="line">① 初始化条件</span><br><span class="line">② 循环条件  ---&gt;是<span class="keyword">boolean</span>类型</span><br><span class="line">③ 循环体</span><br><span class="line">④ 迭代条件</span><br><span class="line">说明：通常情况下，循环结束都是因为②中循环条件返回<span class="keyword">false</span>了。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.三种循环结构：</span><br><span class="line"><span class="number">2.1</span> <span class="keyword">for</span>循环结构</span><br><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">③</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"><span class="number">2.2</span> <span class="keyword">while</span>循环结构</span><br><span class="line">①</span><br><span class="line"><span class="keyword">while</span>(②)&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line">说明：</span><br><span class="line">写<span class="keyword">while</span>循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>和<span class="keyword">while</span>循环总结：</span><br><span class="line"><span class="number">1</span>. 开发中，基本上我们都会从<span class="keyword">for</span>、<span class="keyword">while</span>中进行选择，实现循环结构。</span><br><span class="line"><span class="number">2</span>. <span class="keyword">for</span>循环和<span class="keyword">while</span>循环是可以相互转换的！ </span><br><span class="line">  区别：<span class="keyword">for</span>循环和<span class="keyword">while</span>循环的初始化条件部分的作用范围不同。</span><br><span class="line"><span class="number">3</span>. 我们写程序，要避免出现死循环。</span><br><span class="line"><span class="number">2.3</span> <span class="keyword">do</span>-<span class="keyword">while</span>循环结构</span><br><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br><span class="line">执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>.<span class="keyword">do</span>-<span class="keyword">while</span>循环至少会执行一次循环体！</span><br><span class="line"><span class="number">2</span>.开发中，使用<span class="keyword">for</span>和<span class="keyword">while</span>更多一些。较少使用<span class="keyword">do</span>-<span class="keyword">while</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.“无限循环”结构: <span class="keyword">while</span>(<span class="keyword">true</span>) 或 <span class="keyword">for</span>(;;)</span><br><span class="line">总结：如何结束一个循环结构？</span><br><span class="line">方式一：当循环条件是<span class="keyword">false</span>时</span><br><span class="line">方式二：在循环体中，执行<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.嵌套循环</span><br><span class="line"><span class="number">1</span>.嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环</span><br><span class="line">  内层循环：循环结构A</span><br><span class="line">  外层循环：循环结构B</span><br><span class="line"><span class="number">2</span>.说明：</span><br><span class="line">① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</span><br><span class="line">② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次</span><br><span class="line">③ 外层循环控制行数，内层循环控制列数</span><br><span class="line">【典型练习】</span><br><span class="line"><span class="comment">//练习一：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">4</span>;j++ )&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">6</span>;i++)&#123;</span><br><span class="line">System.out.print(<span class="string">'*'</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//练习二：</span></span><br><span class="line"><span class="comment">/*i(行号)j(*的个数)</span></span><br><span class="line"><span class="comment">*11</span></span><br><span class="line"><span class="comment">**22</span></span><br><span class="line"><span class="comment">***33</span></span><br><span class="line"><span class="comment">****44</span></span><br><span class="line"><span class="comment">*****55</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;<span class="comment">//控制行数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)&#123;<span class="comment">//控制列数</span></span><br><span class="line">System.out.print(<span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//练习三：九九乘法表</span></span><br><span class="line"><span class="comment">//练习四：100以内的质数</span></span><br><span class="line"></span><br><span class="line">补充:衡量一个功能代码的优劣：</span><br><span class="line"><span class="number">1</span>.正确性</span><br><span class="line"><span class="number">2</span>.可读性</span><br><span class="line"><span class="number">3</span>.健壮性</span><br><span class="line"><span class="number">4</span>.高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</span><br><span class="line"></span><br><span class="line">如何理解流程控制的练习：</span><br><span class="line">流程控制结构的使用 + 算法逻辑</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>关键字：break和continue</p><table><thead><tr><th></th><th>使用范围</th><th>循环中使用的作用(不同点)</th><th>相同点</th></tr></thead><tbody><tr><td>break</td><td>switch-case循环结构中</td><td>结束当前循环</td><td>关键字后面不能声明执行语句</td></tr><tr><td>continue</td><td>循环结构中</td><td>结束当次循环</td><td>关键字后面不能声明执行语句</td></tr></tbody></table><p> 补充：带标签的break和continue的使用</p><p> ​            return在方法中使用。</p></li><li><p>补充：Scanner类的使用</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何从键盘获取不同类型的变量：需要使用Scanner类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">具体实现步骤：</span></span><br><span class="line"><span class="comment">1.导包：import java.util.Scanner;</span></span><br><span class="line"><span class="comment">2.Scanner的实例化:Scanner scan = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">3.调用Scanner类的相关方法（next() / nextXxx()），来获取指定类型的变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException</span></span><br><span class="line"><span class="comment">导致程序终止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.导包：import java.util.Scanner;</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//2.Scanner的实例化</span></span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.调用Scanner类的相关方法</span></span><br><span class="line">System.out.println(<span class="string">"请输入你的姓名："</span>);</span><br><span class="line">String name = scan.next();</span><br><span class="line">System.out.println(name);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入你的芳龄："</span>);</span><br><span class="line"><span class="keyword">int</span> age = scan.nextInt();</span><br><span class="line">System.out.println(age);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入你的体重："</span>);</span><br><span class="line"><span class="keyword">double</span> weight = scan.nextDouble();</span><br><span class="line">System.out.println(weight);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"你是否相中我了呢？(true/false)"</span>);</span><br><span class="line"><span class="keyword">boolean</span> isLove = scan.nextBoolean();</span><br><span class="line">System.out.println(isLove);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串</span></span><br><span class="line">System.out.println(<span class="string">"请输入你的性别：(男/女)"</span>);</span><br><span class="line">String gender = scan.next();<span class="comment">//"男"</span></span><br><span class="line"><span class="keyword">char</span> genderChar = gender.charAt(<span class="number">0</span>);<span class="comment">//获取索引为0位置上的字符</span></span><br><span class="line">System.out.println(genderChar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h3 id="2-1一维数组"><a href="#2-1一维数组" class="headerlink" title="2.1一维数组"></a>2.1一维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.一维数组的声明与初始化</span><br><span class="line">正确的方式：</span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//声明</span></span><br><span class="line">num = <span class="number">10</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">1001</span>;<span class="comment">//声明 + 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line"><span class="comment">//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line"><span class="comment">//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">错误的方式：</span><br><span class="line"><span class="comment">//int[] arr1 = new int[];</span></span><br><span class="line"><span class="comment">//int[5] arr2 = new int[5];</span></span><br><span class="line"><span class="comment">//int[] arr3 = new int[3]&#123;1,2,3&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.一维数组元素的引用：通过角标的方式调用。</span><br><span class="line"><span class="comment">//数组的角标（或索引从0开始的，到数组的长度-1结束。</span></span><br><span class="line">names[<span class="number">0</span>] = <span class="string">"王铭"</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">"王赫"</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">"张学良"</span>;</span><br><span class="line">names[<span class="number">3</span>] = <span class="string">"孙居龙"</span>;</span><br><span class="line">names[<span class="number">4</span>] = <span class="string">"王宏志"</span>;<span class="comment">//charAt(0)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.数组的属性：length</span><br><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br><span class="line">System.out.println(ids.length);</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">数组一旦初始化，其长度就是确定的。arr.length</span><br><span class="line">数组长度一旦确定，就不可修改。</span><br><span class="line"><span class="number">4</span>.一维数组的遍历</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; names.length;i++)&#123;</span><br><span class="line">System.out.println(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span>.一维数组元素的默认初始化值</span><br><span class="line">&gt; 数组元素是整型：<span class="number">0</span></span><br><span class="line"> * &gt; 数组元素是浮点型：<span class="number">0.0</span></span><br><span class="line"> * &gt; 数组元素是<span class="keyword">char</span>型：<span class="number">0</span>或<span class="string">'\u0000'</span>，而非<span class="string">'0'</span></span><br><span class="line"> * &gt; 数组元素是<span class="keyword">boolean</span>型：<span class="keyword">false</span></span><br><span class="line"> * </span><br><span class="line"> * &gt; 数组元素是引用数据类型：<span class="keyword">null</span></span><br><span class="line"><span class="number">6</span>.一维数组的内存解析</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130221.png" alt></p><h3 id="2-2二维数组"><a href="#2-2二维数组" class="headerlink" title="2.2二维数组"></a>2.2二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.如何理解二维数组？</span><br><span class="line">数组属于引用数据类型</span><br><span class="line">数组的元素也可以是引用数据类型</span><br><span class="line">一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.二维数组的声明与初始化</span><br><span class="line">正确的方式：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一维数组</span></span><br><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//动态初始化1</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//动态初始化2</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];</span><br><span class="line"><span class="comment">//也是正确的写法：</span></span><br><span class="line"><span class="keyword">int</span>[] arr4[] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;<span class="comment">//类型推断</span></span><br><span class="line">错误的方式：</span><br><span class="line"><span class="comment">//String[][] arr4 = new String[][4];</span></span><br><span class="line"><span class="comment">//String[4][3] arr5 = new String[][];</span></span><br><span class="line"><span class="comment">//int[][] arr6 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span></span><br><span class="line"><span class="number">3</span>.如何调用二维数组元素:</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>]);<span class="comment">//</span></span><br><span class="line"><span class="number">4</span>.二维数组的属性：</span><br><span class="line">System.out.println(arr4.length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">0</span>].length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">1</span>].length);<span class="comment">//4</span></span><br><span class="line"><span class="number">5</span>.遍历二维数组元素</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr4.length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr4[i].length;j++)&#123;</span><br><span class="line">System.out.print(arr4[i][j] + <span class="string">"  "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.二维数组元素的默认初始化值</span><br><span class="line"> * 规定：二维数组分为外层数组的元素，内层数组的元素</span><br><span class="line"> * <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"> * 外层元素：arr[<span class="number">0</span>],arr[<span class="number">1</span>]等</span><br><span class="line"> * 内层元素：arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">2</span>]等</span><br><span class="line"> * </span><br><span class="line"> *   ⑤ 数组元素的默认初始化值 </span><br><span class="line"> *   针对于初始化方式一：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"> *      外层元素的初始化值为：地址值</span><br><span class="line"> *      内层元素的初始化值为：与一维数组初始化情况相同</span><br><span class="line"> *      </span><br><span class="line"> *   针对于初始化方式二：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line"> *   外层元素的初始化值为：<span class="keyword">null</span></span><br><span class="line"> *      内层元素的初始化值为：不能调用，否则报错。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.二维数组的内存结构</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130249.png" alt></p><h3 id="2-3常见算法"><a href="#2-3常见算法" class="headerlink" title="2.3常见算法"></a>2.3常见算法</h3><ol><li><p>数组的创建与元素赋值：</p><p> 杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p></li><li><p>针对于数值型的数组：</p><p> 最大值、最小值、总和、平均数等</p></li><li><p>数组的赋值与复制</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1,array2;</span><br><span class="line">array1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p> 3.1 赋值：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2 = array1;</span><br></pre></td></tr></table></figure><p> 如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130448.png" alt><br> 3.2 复制：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2 = <span class="keyword">new</span> <span class="keyword">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array2.length;i++)&#123;</span><br><span class="line">array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130705.png" alt></p><p> 如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</p></li><li><p>数组元素的反转</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length / <span class="number">2</span>;i++)&#123;</span><br><span class="line">    String temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">    arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">    String temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组中指定元素的查找：搜索、检索</p><p> 5.1 线性查找： </p><p> 实现思路：通过遍历的方式，一个一个的数据进行比较、查找。</p><p> 适用性：具有普遍适用性。</p><p> 5.2 二分法查找：</p><p> 实现思路：每次比较中间值，折半的方式检索。</p><p> 适用性：（前提：数组必须有序）</p></li><li><p>数组的排序算法</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130852.png" alt></p><p> 理解：</p><p> 1）衡量排序算法的优劣：时间复杂度、空间复杂度、稳定性</p><p> 2）排序的分类：内部排序 与 外部排序（需要借助于磁盘）</p><p> 3）不同排序算法的时间复杂度</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130927.png" alt></p><p> 4）手写冒泡排序</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">43</span>,<span class="number">32</span>,<span class="number">76</span>,-<span class="number">98</span>,<span class="number">0</span>,<span class="number">64</span>,<span class="number">33</span>,-<span class="number">21</span>,<span class="number">32</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-4Arrays工具类"><a href="#2-4Arrays工具类" class="headerlink" title="2.4Arrays工具类"></a>2.4Arrays工具类</h3><ol><li><p>理解：</p><p> ① 定义在java.util包下。</p><p> ② Arrays:提供了很多操作数组的方法。</p></li><li><p>使用：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.boolean equals(int[] a,int[] b):判断两个数组是否相等。</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> isEquals = Arrays.equals(arr1, arr2);</span><br><span class="line">System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.String toString(int[] a):输出数组信息。</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.void fill(int[] a,int val):将指定值填充到数组之中。</span></span><br><span class="line">Arrays.fill(arr1,<span class="number">10</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.void sort(int[] a):对数组进行排序。</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.int binarySearch(int[] a,int key)</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(arr3, <span class="number">210</span>);</span><br><span class="line"><span class="keyword">if</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"未找到"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-5常见异常"><a href="#2-5常见异常" class="headerlink" title="2.5常见异常"></a>2.5常见异常</h3><ol><li><p>数组角标越界异常：ArrayIndexOutOfBoundsException</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(arr[-<span class="number">2</span>]);</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p>空指针异常：NullPointerException</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line"><span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">System.out.println(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况三：</span></span><br><span class="line">String[] arr3 = <span class="keyword">new</span> String[]&#123;<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"CC"</span>&#125;;</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>].toString());</span><br></pre></td></tr></table></figure><p> 小知识：一旦程序出现异常，未处理时，就终止执行。</p></li></ol><h2 id="3-面向对象（上）"><a href="#3-面向对象（上）" class="headerlink" title="3.面向对象（上）"></a>3.面向对象（上）</h2><h3 id="3-1类与对象"><a href="#3-1类与对象" class="headerlink" title="3.1类与对象"></a>3.1类与对象</h3><ol><li><p>面向对象学习的三条主线：</p><ol><li>Java类及类的成员：属性、方法、构造器；代码块、内部类</li><li>面向对象的大特征：封装性、继承性、多态性、(抽象性)</li><li>其它关键字：this、super、static、final、abstract、interface、package、import等</li></ol></li><li><p>面向对象与面向过程（理解）</p><ol><li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li><li>面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li></ol></li><li><p>完成一个项目（或功能）的思路：</p><ul><li>根据问题需要，选择问题所针对的现实世界中的实体</li><li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类</li><li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。</li><li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。</li></ul></li><li><p>面向对象中两个重要的概念：</p><p> 类：对一类事物的描述，是抽象的、概念上的定义</p><p> 对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)</p><p> ​            面向对象程序设计的重点是类的设计，设计类，就是设计类的成员。</p><p> 二者的关系：对象，是由类new出来的，派生出来的。</p></li><li><p>面向对象思想落地实现的规则一</p><ol><li><p>创建类，设计类的成员</p></li><li><p>创建类的对象</p></li><li><p>通过“对象.属性”或“对象.方法”调用对象的结构</p><p>补充：几个概念的使用说明</p></li><li><p>属性 = 成员变量 = field = 域、字段</p></li><li><p>方法 = 成员方法 = 函数 = method</p></li><li><p>创建类的对象 = 类的实例化 = 实例化类</p></li></ol></li><li><p>对象的创建与对象的内存解析</p><p> 典型代码：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p3 = p1;<span class="comment">//没有新创建一个对象，共用一个堆空间中的对象实体。</span></span><br></pre></td></tr></table></figure><p> 说明：</p><p> ​        如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）<br> 意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</p><p> 内存解析：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522151443.png" alt></p><p> <img src="E:%5CGitHubBlog%5Cfangchenyong.github.io%5CHexo%5Csource_posts%5C%E5%9F%BA%E7%A1%80.assets%5C1590131692254.png" alt="1590131692254"></p></li><li><p>匿名对象:我们创建的对象，没显式的赋给一个变量名。即为匿名对象</p><p> 特点：匿名对象只能调用一次。</p><p> 举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line"><span class="keyword">new</span> Phone().playGame();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">new</span> Phone().showPrice();<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure><p> 应用场景：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象的使用</span></span><br><span class="line">mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">其中，</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">phone.sendEmail();</span><br><span class="line">phone.playGame();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>理解”万事万物皆对象”</p><ol><li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构<ul><li>Scanner,String等</li><li>文件：File</li><li>网络资源：URL</li></ul></li><li>涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</li></ol></li><li><p>JVM内存结构简述</p><p> 编译完源程序以后，生成一个或多个字节码文件。</p><p> 我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节</p><p> 码文件对应的类加载到内存中，涉及到内存解析。</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522151721.png" alt></p><p> 虚拟机栈：即为平时提到的栈结构。</p><p> 我们将局部变量存储在栈结构中堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。</p><p> 补充：对象的属性（非static的）加载在堆空间中。</p><p> 方法区：类的加载信息、常量池、静态域</p></li></ol><h3 id="3-2类的结构之一：属性"><a href="#3-2类的结构之一：属性" class="headerlink" title="3.2类的结构之一：属性"></a>3.2类的结构之一：属性</h3><p>对比：属性  vs  局部变量</p><ul><li><p>相同点</p><ol><li>定义变量的格式：数据类型  变量名 = 变量值</li><li>先声明，后使用</li><li>变量都其对应的作用域</li></ol></li><li><p>不同点</p><ol><li><p>在类中声明的位置的不同</p><ul><li>属性：直接定义在类的一对{}内</li><li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li></ul></li><li><p>关于权限修饰符的不同</p><ul><li><p>属性：可以在声明属性时，指明其权限，使用权限修饰符。</p><p>  ​            常用的权限修饰符：private、public、缺省、protected  —&gt;封装性</p></li><li><p>局部变量：不可以使用权限修饰符。</p></li></ul></li><li><p>默认初始化值的情况：</p><ul><li><p>属性：类的属性，根据其类型，都默认初始化值。</p><ul><li>整型（byte、short、int、long：0）</li><li>浮点型（float、double：0.0）</li><li>字符型（char：0  （或’\u0000’））</li><li>布尔型（boolean：false）</li><li>引用数据类型（类、数组、接口：null）</li></ul></li><li><p>局部变量：没默认初始化值。</p><p>  ​                    意味着，我们在调用局部变量之前，一定要显式赋值。</p><p>  ​                    特别地：形参在调用时，我们赋值即可。</p></li></ul></li><li><p>在内存中加载的位置：</p><ul><li>属性：加载到堆空间中   （非static）</li><li>局部变量：加载到栈空间</li></ul></li></ol></li></ul><h3 id="3-3类的结构之二：方法"><a href="#3-3类的结构之二：方法" class="headerlink" title="3.3类的结构之二：方法"></a>3.3类的结构之二：方法</h3><ol><li><p>方法的声明：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法的声明：权限修饰符  返回值类型  方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关键字：return</p><ul><li>使用范围：使用在方法体中</li><li>作用：<ul><li>结束方法</li><li>针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</li></ul></li><li>注意点：return关键字后面不可以声明执行语句。</li></ul></li><li><p>方法的重载</p><ol><li><p>概念</p><p> 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p><p> <strong>总结：”两同一不同”:同一个类、相同方法名</strong></p><p> ​            <strong>参数列表不同：参数个数不同，参数类型不同</strong></p></li><li><p>构成重载的举例：</p><p> 举例一：Arrays类中重载的sort() / binarySearch()；PrintStream中的println()</p><p> 举例二：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如下的4个方法构成了重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">double</span> d1,<span class="keyword">double</span> d2)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(String s ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,String s)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"4"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何判断是否构成方法的重载？</p><p> 严格按照定义判断：两同一不同。</p><p> <strong>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</strong></p></li><li><p>如何确定类中某一个方法的调用：</p><p> 方法名 —&gt; 参数列表</p><p> 面试题：方法的重载与重写的区别？</p><blockquote><p>throws\throw<br>String\StringBuffer\StringBuilder<br>Collection\Collections<br>final\finally\finalize<br>…</p></blockquote><blockquote><p>抽象类、接口<br>sleep() / wait()</p></blockquote></li></ol></li><li><p>可变个数形参的方法</p><ol><li><p>使用说明：</p><ol><li>jdk 5.0新增的内容</li><li>具体使用：<ul><li>可变个数形参的格式：数据类型 … 变量名</li><li>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</li><li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li><li>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</li><li>可变个数形参在方法的形参中，必须声明在末尾</li><li>可变个数形参在方法的形参中,最多只能声明一个可变形参。</li></ul></li></ol></li><li><p>举例说明</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show(String)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String ... strs)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show(String ... strs)"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用时：</span></span><br><span class="line">test.show(<span class="string">"hello"</span>);</span><br><span class="line">test.show(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">test.show();</span><br><span class="line"></span><br><span class="line">test.show(<span class="keyword">new</span> String[]&#123;<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"CC"</span>&#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>java 的值传递机制</p><ol><li><p>针对于方法内变量的赋值举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"***********基本数据类型：****************"</span>);</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n = m;</span><br><span class="line">System.out.println(<span class="string">"m = "</span> + m + <span class="string">", n = "</span> + n);</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">"m = "</span> + m + <span class="string">", n = "</span> + n);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"***********引用数据类型：****************"</span>);</span><br><span class="line">Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">o1.orderId = <span class="number">1001</span>;</span><br><span class="line">Order o2 = o1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line">System.out.println(<span class="string">"o1.orderId = "</span> + o1.orderId + <span class="string">",o2.orderId = "</span> +o2.orderId);</span><br><span class="line"></span><br><span class="line">o2.orderId = <span class="number">1002</span>;</span><br><span class="line">System.out.println(<span class="string">"o1.orderId = "</span> + o1.orderId + <span class="string">",o2.orderId = "</span> +o2.orderId);</span><br></pre></td></tr></table></figure><p> 规则：</p><p> ​        如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</p><p> ​        如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p></li><li><p>针对于方法的参数概念</p><p> 形参：方法定义时，声明的小括号内的参数</p><p> 实参：方法调用时，实际传递给形参的数据</p></li><li><p>java中参数传递机制：值传递</p><p> 规则：</p><p> ​        如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</p><p> ​        如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</p></li><li><p>典型例题与内存解析：</p><ul><li><p>【例题1】</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522155534.png" alt></p></li><li><p>【例题2】</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522155539.png" alt></p></li></ul></li></ol></li><li><p>递归方法</p><ol><li><p>定义：递归方法：一个方法体内调用它自身。</p></li><li><p>如何理解递归方法？</p><ul><li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</li><li>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</li></ul></li><li><p>举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="3-4面向对象的特征一：封装性"><a href="#3-4面向对象的特征一：封装性" class="headerlink" title="3.4面向对象的特征一：封装性"></a>3.4面向对象的特征一：封装性</h3><ol><li><p>为什么要引入封装性？</p><p> 我们程序设计追求“高内聚，低耦合”。</p><ul><li><p>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</p></li><li><p>低耦合 ：仅对外暴露少量的方法用于使用。</p><p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p></li></ul></li><li><p>问题引入：</p><p> 当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).</p><p> 此时，针对于属性就体现了封装性。</p></li><li><p>封装性思想具体的代码体现：</p><ul><li><p>体现一：将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>体现二：不对外暴露的私有的方法</p></li><li><p>体现三：单例模式（将构造器私有化）</p></li><li><p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的。</p></li></ul></li><li><p>Java规定的四种权限修饰符</p><ol><li><p>权限从小到大顺序为：private &lt;  缺省 &lt; protected &lt; public</p></li><li><p>具体的修饰范围：</p><table><thead><tr><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr><tr><td>（缺省）</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table></li><li><p>权限修饰符可用来修饰的结构说明：</p><p> 4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p><p> 修饰类的话，只能使用：缺省、public</p></li></ol></li></ol><h3 id="3-5类的结构之三：构造器"><a href="#3-5类的结构之三：构造器" class="headerlink" title="3.5类的结构之三：构造器"></a>3.5类的结构之三：构造器</h3><ol><li><p>构造器（或构造方法）：Constructor</p><p> 构造器的作用：</p><ul><li>1.创建对象</li><li>2.初始化对象的信息</li></ul></li><li><p>使用说明：</p><ul><li>1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</li><li>2.定义构造器的格式：权限修饰符  类名(形参列表){}</li><li>3.一个类中定义的多个构造器，彼此构成重载</li><li>4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li><li>5.一个类中，至少会有一个构造器。</li></ul></li><li><p>举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Person()....."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性赋值顺序</p><ol><li><p>默认初始化</p></li><li><p>显式初始化</p></li><li><p>构造器中初始化</p></li><li><p>通过”对象.方法” 或 “对象.属性”的方式，赋值</p><p>以上操作的先后顺序：① - ② - ③ - ④ </p></li></ol></li><li><p>JavaBean的概念</p><p> 所谓JavaBean，是指符合如下标准的Java类：</p><ul><li>类是公共的</li><li>一个无参的公共的构造器</li><li>属性，且对应的get、set方法</li></ul></li></ol><h3 id="3-6关键词：this"><a href="#3-6关键词：this" class="headerlink" title="3.6关键词：this"></a>3.6关键词：this</h3><ol><li><p>可以调用的结构：属性、方法；构造器</p></li><li><p>this调用属性、方法：</p><p> this理解为：当前对象  或 当前正在创建的对象</p><ul><li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li><li>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li></ul></li><li><p>this调用构造器：</p><ol><li>我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器</li><li>构造器中不能通过”this(形参列表)”方式调用自己</li><li>如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</li><li>规定：”this(形参列表)”必须声明在当前构造器的首行</li><li>构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器</li></ol></li></ol><h3 id="3-7关键词：package-import"><a href="#3-7关键词：package-import" class="headerlink" title="3.7关键词：package/import"></a>3.7关键词：package/import</h3><p><strong>package</strong></p><ol><li><p>使用说明：</p><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用package声明类或接口所属的包，声明在源文件的首行</li><li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li><li>每”.”一次，就代表一层文件目录。</li></ol></li><li><p>举例：</p><ul><li><p>举例一：</p><p>  某航运软件系统包括：一组域对象、GUI和reports子系统</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161002.png" alt></p></li><li><p>举例二：MVC设计模式</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161017.png" alt></p></li></ul></li><li><p>JDK中的主要包介绍：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161042.png" alt></p></li></ol><p><strong>import</strong></p><h2 id="4-面向对象（中）"><a href="#4-面向对象（中）" class="headerlink" title="4.面向对象（中）"></a>4.面向对象（中）</h2><h3 id="4-1面向对象的特征二：继承性"><a href="#4-1面向对象的特征二：继承性" class="headerlink" title="4.1面向对象的特征二：继承性"></a>4.1面向对象的特征二：继承性</h3><ol><li><p>为什么要有类的继承性？(继承性的好处）</p><ol><li><p>减少了代码的冗余，提高了代码的复用性</p></li><li><p>便于功能的扩展</p></li><li><p>为之后多态性的使用，提供了前提</p><p>图示：</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161542.png" alt></p></li></ol></li><li><p>继承性的格式：</p><p> <code>class A extends B{}</code></p><p> A:子类、派生类、subclass</p><p> B:父类、超类、基类、superclass</p></li><li><p>子类继承父类以后有哪些不同？</p><ul><li><p>体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。</p><p>  特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。</p></li><li><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。</p><p>  子类和父类的关系，不同于子集和集合的关系。</p><p>  extends：延展、扩展</p></li></ul></li><li><p>Java中继承性的说明</p><ol><li><p>一个类可以被多个子类继承。</p></li><li><p>Java中类的单继承性：一个类只能有一个父类</p></li><li><p>子父类是相对的概念。</p></li><li><p>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</p></li><li><p>子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</p><p>图示：</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161347.png" alt></p></li></ol></li><li><p>java.lang.Object类的理解</p><ol><li>如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li><li>所有的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类</li><li>意味着，所的java类具有java.lang.Object类声明的功能。</li></ol></li></ol><h3 id="4-2方法的重写"><a href="#4-2方法的重写" class="headerlink" title="4.2方法的重写"></a>4.2方法的重写</h3><ol><li><p>什么是方法的重写(override 或 overwrite)？</p><p> 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。</p></li><li><p>应用：</p><p> 重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p></li><li><p>举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> <span class="keyword">extends</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求表面积</span></span><br><span class="line">&#125;</span><br><span class="line">***************</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckAccount</span> <span class="keyword">extends</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写的规则：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法的声明： 权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p><ol><li><p>① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</p></li><li><p>② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</p><p> 特殊情况：子类不能重写父类中声明为private权限的方法</p></li><li><p>返回值类型：</p><ul><li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li><li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li><li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</li></ul></li><li><p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p><p>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。</p></li></ol></li><li><p>面试题：</p><p> 区分方法的重写和重载？</p><p> 答：</p><ol><li><p>二者的概念：</p></li><li><p>重载和重写的具体规则</p></li><li><p>重载：不表现为多态性。</p><p> 重写：表现为多态性。</p><p>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p><p>所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</p><p>而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 </p><p>引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</p></li></ol></li></ol><h3 id="4-3关键字：super"><a href="#4-3关键字：super" class="headerlink" title="4.3关键字：super"></a>4.3关键字：super</h3><ol><li>super 关键字可以理解为：父类的</li><li>可以用来调用的结构：属性、方法、构造器</li><li>super调用属性、方法：<ol><li>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</li><li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li><li>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li></ol></li><li>super调用构造器：<ol><li>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li><li>“super(形参列表)”的使用，必须声明在子类构造器的首行！</li><li>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二一，不能同时出现</li><li>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</li><li>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</li></ol></li></ol><h3 id="4-4子类对象实例化全过程"><a href="#4-4子类对象实例化全过程" class="headerlink" title="4.4子类对象实例化全过程"></a>4.4子类对象实例化全过程</h3><ol><li><p>从结果上看：继承性</p><ul><li>子类继承父类以后，就获取了父类中声明的属性或方法。</li><li>创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</li></ul></li><li><p>从过程上看：</p><p> 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</p><p> 图示：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164236.png" alt></p></li><li><p>强调说明：</p><p> 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164256.png" alt></p></li></ol><h3 id="4-5面向对象的特征三：多态性"><a href="#4-5面向对象的特征三：多态性" class="headerlink" title="4.5面向对象的特征三：多态性"></a>4.5面向对象的特征三：多态性</h3><ol><li><p>多态性的理解：可以理解为一个事物的多种形态。</p></li><li><p>何为多态性：</p><p> 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p><p> 举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Man();</span><br><span class="line">Object obj = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure></li><li><p>多态性的使用：虚拟方法调用</p><p> 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p><p> <strong>总结：编译，看左边；运行，看右边。</strong></p></li><li><p>多态性的使用前提：</p><ol><li>类的继承关系</li><li>方法的重写</li></ol></li><li><p>多态性的应用举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例一：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal animal)</span></span>&#123;<span class="comment">//Animal animal = new Dog();</span></span><br><span class="line">animal.eat();</span><br><span class="line">animal.shout();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//举例二：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//举例三：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doData</span><span class="params">(Connection conn)</span></span>&#123;<span class="comment">//conn = new MySQlConnection(); / conn = new OracleConnection();</span></span><br><span class="line"><span class="comment">//规范的步骤去操作数据</span></span><br><span class="line"><span class="comment">//conn.method1();</span></span><br><span class="line"><span class="comment">//conn.method2();</span></span><br><span class="line"><span class="comment">//conn.method3();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多态性使用的注意点：</p><p> <strong>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</strong></p></li><li><p>关于向上转型与向下转型：</p><ol><li><p>向上转型：多态</p></li><li><p>向下转型：</p><ol><li><p>为什么使用向下转型：</p><p> 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。</p></li><li><p>如何实现向下转型：</p><p> 使用强制类型转换符：()</p></li><li><p>使用时的注意点：</p><ol><li>使用强转时，可能出现ClassCastException的异常。</li><li>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</li></ol></li><li><p>instanceof的使用：</p><ol><li>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</li><li>如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。</li><li>要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</li></ol></li><li><p>图示：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164521.png" alt></p></li></ol></li></ol></li><li><p>面试题：</p><ol><li><p>谈谈你对多态性的理解？</p><ul><li><p>实现代码的通用性。</p></li><li><p>Object类中定义的public boolean equals(Object obj){  }</p><p>  JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)</p></li><li><p>抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</p></li></ul></li><li><p>多态是编译时行为还是运行时行为？</p></li></ol></li></ol><h3 id="4-6Object类的使用"><a href="#4-6Object类的使用" class="headerlink" title="4.6Object类的使用"></a>4.6Object类的使用</h3><ol><li><p>java.lang.Object类的说明：</p><ol><li><p>Object类是所Java类的根父类</p></li><li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 </p></li><li><p>Object类中的功能(属性、方法)就具通用性。</p><p>属性：无</p><p>方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()</p><p>wait() 、 notify()、notifyAll()</p></li><li><p>Object类只声明了一个空参的构造器</p></li></ol></li><li><p>equals()方法</p><ol><li><p>equals()的使用：</p><ol><li><p>是一个方法，而非运算符</p></li><li><p>只能适用于引用数据类型</p></li><li><p>Object类中equals()的定义：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p></li><li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是</p><p> 两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p></li><li><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相</p><p> 同。那么，我们就需要对Object类中的equals()进行重写.</p><p> 重写的原则：比较两个对象的实体内容是否相同.</p></li></ol></li><li><p>如何重写equals()</p><p> 手动重写举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//重写其equals()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">this</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">User u = (User)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == u.age &amp;&amp; <span class="keyword">this</span>.name.equals(u.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回顾 == 运算符的使用：</p><p> == ：运算符</p><ul><li><p>可以使用在基本数据类型变量和引用数据类型变量中</p></li><li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p><p>  如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p><p>补充： == 符号使用时，必须保证符号左右两边的变量类型一致。</p></li></ul></li></ol></li><li><p>toString()方法</p><ol><li><p>toString()的使用：</p><ol><li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p></li><li><p>Object类中toString()的定义：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息</p></li><li><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p></li></ol></li><li><p>如何重写toString()</p><p> 举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Customer [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>面试题：</p><ul><li>final、finally、finalize的区别？</li><li>== 和 equals() 区别</li></ul></li></ol><h3 id="4-7单元测试方法"><a href="#4-7单元测试方法" class="headerlink" title="4.7单元测试方法"></a>4.7单元测试方法</h3><p>Java中的JUnit单元测试</p><p>步骤：</p><ol><li><p>选中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步</p></li><li><p>创建Java类，进行单元测试。</p><p> 此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p></li><li><p>此类中声明单元测试方法。</p><p> 此时的单元测试方法：方法的权限是public,没返回值，没形参</p></li><li><p>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p></li><li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p></li><li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p></li></ol><p>说明：</p><ol><li>如果执行结果没任何异常：绿条</li><li>如果执行结果出现异常：红条</li></ol><h3 id="4-8包装类的使用"><a href="#4-8包装类的使用" class="headerlink" title="4.8包装类的使用"></a>4.8包装类的使用</h3><ol><li><p>为什么要有包装类(或封装类）</p><p> 为了使基本数据类型的变量具有类的特征，引入包装类。</p></li><li><p>基本数据类型与对应的包装类：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522165706.png" alt></p></li><li><p>需要掌握的类型间的转换：（基本数据类型、包装类、String）</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522165718.png" alt></p><p> 简易版：</p><ul><li><p>基本数据类型&lt;—&gt;包装类：JDK 5.0 新特性：自动装箱 与自动拆箱</p></li><li><p>基本数据类型、包装类—&gt;String:调用String重载的valueOf(Xxx xxx)</p></li><li><p>String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)</p><p>   注意：转换时，可能会报NumberFormatException</p><p>应用场景举例：</p><p>​        Vector类中关于添加元素，只定义了形参为Object类型的方法：</p><p>v.addElement(Object obj);   //基本数据类型 —&gt;包装类 —&gt;使用多态</p></li></ul></li></ol><h2 id="5-面向对象（下）"><a href="#5-面向对象（下）" class="headerlink" title="5.面向对象（下）"></a>5.面向对象（下）</h2><h3 id="5-1关键字：static"><a href="#5-1关键字：static" class="headerlink" title="5.1关键字：static"></a>5.1关键字：static</h3><ol><li><p>可以用来修饰的结构：主要用来修饰类的内部结构</p><p> 属性、方法、代码块、内部类</p></li><li><p>static修饰属性：静态变量（或类变量）</p><ul><li><p>属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)</p><ul><li><p>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</p></li><li><p>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p></li></ul></li><li><p>static修饰属性的其他说明：</p><ol><li><p>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</p></li><li><p>静态变量的加载要早于对象的创建。</p></li><li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p><ol start="4"><li><table><thead><tr><th></th><th>类变量</th><th>实例变量</th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table></li></ol></li></ol></li><li><p>静态属性举例：System.out; Math.PI;</p></li></ul></li><li><p>静态变量内存解析：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200529173043.png" alt></p></li><li><p>static修饰方法：静态方法、类方法</p><ol><li><p>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</p></li><li><table><thead><tr><th></th><th>静态方法</th><th>非静态方法</th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table></li><li><p>静态方法中，只能调用静态的方法或属性</p><p> 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p></li></ol></li><li><p>static的注意点：</p><ol><li>在静态的方法内，不能使用this关键字、super关键字</li><li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</li></ol></li><li><p>如何判定属性和方法应该使用static关键字：</p><ol><li>关于属性<ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li><li>类中的常量也常常声明为static</li></ul></li><li>关于方法<ul><li>操作静态属性的方法，通常设置为static的</li><li>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li></ul></li></ol></li><li><p>使用举例：</p><ol><li><p>举例一：Arrays、Math、Collections等工具类</p></li><li><p>举例二：单例模式</p></li><li><p>举例三：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//自动赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = init++;</span><br><span class="line">        total++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="comment">//id = init++;</span></span><br><span class="line">        <span class="comment">//total++;</span></span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total;<span class="comment">//记录创建的圆的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> init = <span class="number">1001</span>;<span class="comment">//static声明的属性被所对象所共享</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>涉及设计模式–&gt;单例模式</p><ol><li><p>设计模式</p><ol><li><p>设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。</p></li><li><p>常用设计模式  — 23种经典的设计模式  GOF</p><blockquote><p>创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 </p></blockquote></li></ol></li><li><p>单例模式</p><ol><li><p>要解决的问题</p><p> 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p></li><li><p>具体代码的实现</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">饿汉式<span class="number">1</span>：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.内部创建类的对象</span></span><br><span class="line"><span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">饿汉式<span class="number">2</span>：使用了静态代码块</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Order();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">懒汉式：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">instance = <span class="keyword">new</span> Order();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两种方式的对比</p><ul><li>饿汉式：<ul><li>坏处：对象加载时间过长。</li><li>好处：饿汉式是线程安全的</li></ul></li><li>懒汉式：<ul><li>好处：延迟对象的创建。</li><li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li></ul></li></ul></li></ol></li></ol></li></ol><h3 id="5-2main-的使用说明"><a href="#5-2main-的使用说明" class="headerlink" title="5.2main()的使用说明"></a>5.2main()的使用说明</h3><blockquote><ul><li><ol><li>main()方法作为程序的入口</li></ol></li><li><ol start="2"><li>main()方法也是一个普通的静态方法</li></ol></li><li><ol start="3"><li>main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</li></ol></li></ul><p>如何将控制台获取的数据传给形参：String[] args?<br>  运行时：java 类名 “Tom” “Jerry” “123” “true”</p><p>sysout(args[0]);//“Tom”<br>sysout(args[3]);//“true”  –&gt;Boolean.parseBoolean(args[3]);<br>sysout(args[4]);//报异常</p></blockquote><h3 id="5-3类的结构：代码块"><a href="#5-3类的结构：代码块" class="headerlink" title="5.3类的结构：代码块"></a>5.3类的结构：代码块</h3><ol><li><p>代码块的作用：用来初始化类、对象的信息</p></li><li><p>分类：代码块要是使用修饰符，只能使用static</p><p> 分类：静态代码块  vs 非静态代码块</p></li><li><p>静态代码块：</p><blockquote><p>内部可以输出语句<br>随着类的加载而执行,而且只执行一次<br>作用：初始化类的信息<br>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>静态代码块的执行要优先于非静态代码块的执行<br>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p></blockquote><p> 非静态代码块：</p><blockquote><p>内部可以输出语句<br>随着对象的创建而执行<br>每创建一个对象，就执行一次非静态代码块<br>作用：可以在创建对象时，对对象的属性等进行初始化<br>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p></blockquote></li><li><p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：</p><p> 由父及子，静态先行。</p></li><li><p>属性的赋值顺序</p><blockquote><ul><li>①默认初始化<ul><li>②显式初始化/⑤在代码块中赋值</li><li>③构造器中初始化</li><li>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</li><li></li><li></li><li>执行的先后顺序：① - ② / ⑤ - ③ - ④</li></ul></li></ul></blockquote></li></ol><h3 id="5-4关键字：final"><a href="#5-4关键字：final" class="headerlink" title="5.4关键字：final"></a>5.4关键字：final</h3><ol><li><p>可以用来修饰：类、方法、变量</p></li><li><p>具体的：</p><ol><li><p>final 用来修饰一个类:此类不能被其他类所继承。</p><p> 比如：String类、System类、StringBuffer类</p></li><li><p>final 用来修饰方法：表明此方法不可以被重写</p><p> 比如：Object类中getClass();</p></li><li><p>final 用来修饰变量：此时的”变量”就称为是一个常量</p><ul><li>final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li></ul><p>static final 用来修饰属性：全局常量</p></li></ol></li></ol><h3 id="5-5关键字：abstract"><a href="#5-5关键字：abstract" class="headerlink" title="5.5关键字：abstract"></a>5.5关键字：abstract</h3><ol><li><p>可以用来修饰：类、方法</p></li><li><p>具体的：</p><ul><li>abstract修饰类：抽象类<ul><li>此类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</li></ul></li><li>abstract修饰方法：抽象方法<ul><li>抽象方法只方法的声明，没方法体</li><li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li><li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li><li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li></ul></li></ul></li><li><p>注意点：</p><ol><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract不能用来修饰私方法、静态方法、final的方法、final的类</li></ol></li><li><p>abstract的应用举例：</p><ol><li><p>举例一：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GeometricObject</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">GeometricObject</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>举例二：IO流中设计到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部定义了抽象的read()、write()方法。</p></li></ol></li><li><p>涉及设计模式–&gt;模板方法</p><ol><li><p>解决的问题</p><p> 在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变<br> 部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p></li><li><p>举例</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.code();<span class="comment">//不确定的部分、易变的部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"花费的时间为："</span> + (end - start));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">isFlag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用场景</p><p> 模板方法设计模式是编程中经常用的到的模式。各个框架、类库中都有用到，比如常见的有：</p><ul><li>数据库访问的封装</li><li>Junit单元测试</li><li>JavaWeb的Servlet中关于doGet/doPost方法调用</li><li>Hibernate中模板程序</li><li>Spring中的JDBCTemplate、HibernateTemplate等</li></ul></li></ol></li></ol><h3 id="5-6关键字：interface"><a href="#5-6关键字：interface" class="headerlink" title="5.6关键字：interface"></a>5.6关键字：interface</h3><ol><li><p>使用说明：</p><ol><li><p>接口使用interface来定义</p></li><li><p>Java中，接口和类是并列的两个结构</p></li><li><p>如何定义接口：定义接口中的成员</p><ol><li>JDK7及以前：只能定义全局常量和抽象方法<ul><li>全局常量：public static final的.但是书写时，可以省略不写</li><li>抽象方法：public abstract的</li></ul></li><li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略</li></ol></li><li><p>接口中不能定义构造器的！意味着接口不可以实例化</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p><p> 如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</p><p> 如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</p></li><li><p>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性</p><p> 格式：class AA extends BB implements CC,DD,EE</p></li><li><p>接口与接口之间可以继承，而且可以多继承</p></li><li><p>接口的具体使用，体现多态性</p></li><li><p>接口，实际上可以看做是一种规范</p></li></ol></li><li><p>举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span></span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">usb.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"具体传输数据的细节"</span>);</span><br><span class="line"></span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"U盘开启工作"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"U盘结束工作"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"打印机开启工作"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"打印机结束工作"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 体会：</p><ul><li>1.接口使用上也满足多态性</li><li>2.接口，实际上就是定义了一种规范</li><li>3.开发中，体会面向接口编程！</li></ul></li><li><p>体会面向接口编程的思想</p><p> 面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个<br> 数据库厂商的API。</p></li><li><p>Java8中关于接口的新规范</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//知识点1：接口中定义的静态方法，只能通过接口来调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class="line"><span class="comment">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class="line"><span class="comment">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class="line"><span class="comment">//那么在实现类没重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class="line"><span class="comment">//这就需要我们必须在实现类中重写此方法</span></span><br><span class="line"><span class="comment">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">    <span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">    CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>面试题：</p><p> 抽象类和接口的异同？</p><ul><li><p>相同点：不能实例化；都可以包含抽象方法的。</p></li><li><p>不同点：</p><ul><li>1）把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明</li><li>2）类：单继承性 ，接口：多继承，类与接口：多实现</li></ul></li></ul></li><li><p>涉及设计模式–&gt;代理模式、工厂模式</p><ol><li><p>代理模式</p><ol><li><p>解决的问题</p><p> 代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 </p></li><li><p>举例</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"真实的服务器访问网络"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.work = work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"联网之前的检查工作"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">check();</span><br><span class="line">work.browse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用场景</p><ul><li><p>应用场景：</p><ul><li>安全代理：屏蔽对真实角色的直接访问</li><li>远程代理：通过代理类处理远程方法调用（RMI）</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li></ul></li><li><p>分类</p><ul><li><p>静态代理（静态定义代理类）</p></li><li><p>动态代理（动态生成代理类）</p><p>  JDK自带的动态代理，需要反射等知识</p></li></ul></li></ul></li></ol></li><li><p>工厂模式</p><ol><li><p>解决的问题</p><p> 实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p></li><li><p>具体模式</p><ul><li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li><li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</li><li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</li></ul></li></ol></li></ol></li></ol><h3 id="5-7类的结构：内部类"><a href="#5-7类的结构：内部类" class="headerlink" title="5.7类的结构：内部类"></a>5.7类的结构：内部类</h3><ol><li><p>定义：Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.</p></li><li><p>内部类的分类：</p><p> 成员内部类（静态、非静态 ） vs 局部内部类(方法内、代码块内、构造器内)</p></li><li><p>成员内部类的理解：</p><p> 一方面，作为外部类的成员：</p><ul><li><p>调用外部类的结构</p></li><li><p>可以被static修饰</p></li><li><p>可以被4种不同的权限修饰</p><p>另一方面，作为一个类：</p></li><li><p>类内可以定义属性、方法、构造器等</p></li><li><p>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</p></li><li><p>可以被abstract修饰</p></li></ul></li><li><p>成员内部类：</p><ol><li><p>如何创建成员内部类的对象？(静态的，非静态的)</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">//Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Bird bird = p.new Bird();</span><br></pre></td></tr></table></figure></li><li><p>如何在成员内部类中调用外部类的结构？</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">String name = <span class="string">"小明"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">String name = <span class="string">"杜鹃"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line"><span class="comment">//Person.this.eat();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>局部内部类的使用：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//class MyComparable implements Comparable&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//return new MyComparable();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意点：</p><p> 在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。</p><ul><li><p><strong>jdk 7及之前版本：要求此局部变量显式的声明为final的</strong></p></li><li><p><strong>jdk 8及之后的版本：可以省略final的声明</strong></p><p>总结：</p><p>成员内部类和局部内部类，在编译以后，都会生成字节码文件。</p><p>格式：</p></li><li><p>成员内部类：外部类$内部类名.class    </p></li><li><p>局部内部类：外部类$数字 内部类名.class</p></li></ul></li></ol><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h2><h3 id="6-1异常"><a href="#6-1异常" class="headerlink" title="6.1异常"></a>6.1异常</h3><ol><li><p>异常的体系结构</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">|-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">|-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">|------编译时异常(checked)</span><br><span class="line">|-----IOException</span><br><span class="line">|-----FileNotFoundException</span><br><span class="line">|-----ClassNotFoundException</span><br><span class="line">|------运行时异常(unchecked,RuntimeException)</span><br><span class="line">|-----NullPointerException</span><br><span class="line">|-----ArrayIndexOutOfBoundsException</span><br><span class="line">|-----ClassCastException</span><br><span class="line">|-----NumberFormatException</span><br><span class="line">|-----InputMismatchException</span><br><span class="line">|-----ArithmeticException</span><br></pre></td></tr></table></figure><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522172127.png" alt></p></li><li><p>从程序执行过程，看编译时异常和运行时异常</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522171550.png" alt></p><p> 编译时异常：执行javac.exe命名时，可能出现的异常</p><p> 运行时异常：执行java.exe命名时，出现的异常</p></li><li><p>常见的异常类型，请举例说明：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> score = scanner.nextInt();</span><br><span class="line">    System.out.println(score);</span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">"123"</span>;</span><br><span class="line">    str = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">    String str = (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">    <span class="comment">//int[] arr = new int[10];</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[10]);</span></span><br><span class="line">    <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">    String str = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//int[] arr = null;</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[3]);</span></span><br><span class="line">    String str = <span class="string">"abc"</span>;</span><br><span class="line">    str = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//File file = new File("hello.txt");</span></span><br><span class="line">    <span class="comment">//FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//int data = fis.read();</span></span><br><span class="line">    <span class="comment">//while(data != -1)&#123;</span></span><br><span class="line">    <span class="comment">//System.out.print((char)data);</span></span><br><span class="line">    <span class="comment">//data = fis.read();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//fis.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-2异常的处理"><a href="#6-2异常的处理" class="headerlink" title="6.2异常的处理"></a>6.2异常的处理</h3><ol><li><p>异常处理的抓抛模型</p><ol><li><p>“抓”</p><p> 可以理解为异常的处理方式：</p><ul><li>try-catch-finally </li><li>throws</li></ul></li><li><p>”抛“</p><p> 程序在正常执行的过程中，一旦出现异常，就会中异常代码处生成一个异常对象，并将此对象抛出。</p><p> 异常对象的产生：</p><ul><li>系统自动生成的异常对象</li><li>手动生成的一个异常对象，并抛出（throw）</li></ul></li></ol></li><li><p>异常处理方式：try-catch-finally</p></li><li><p>方法重写的规则之一：</p><p> 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p></li></ol><h3 id="6-3手动抛出异常对象"><a href="#6-3手动抛出异常对象" class="headerlink" title="6.3手动抛出异常对象"></a>6.3手动抛出异常对象</h3><ol><li><p>使用说明</p><p> 在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。</p></li><li><p>面试题</p><p> throw 和  throws区别：</p><p> throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。</p><p> throws 属于异常处理的一种方式，声明在方法的声明处。</p></li><li><p>典型例题</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//手动抛出异常对象</span></span><br><span class="line"><span class="comment">//throw new RuntimeException("您输入的数据非法！");</span></span><br><span class="line"><span class="comment">//throw new Exception("您输入的数据非法！");</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"不能输入负数"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [id="</span> + id + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-4自定义异常类"><a href="#6-4自定义异常类" class="headerlink" title="6.4自定义异常类"></a>6.4自定义异常类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何自定义异常类？</span></span><br><span class="line"><span class="comment"> * 1. 继承于现的异常结构：RuntimeException 、Exception</span></span><br><span class="line"><span class="comment"> * 2. 提供全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment"> * 3. 提供重载的构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="/2019/07/18/Java%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/18/Java%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="java基础笔记"><a href="#java基础笔记" class="headerlink" title="java基础笔记"></a>java基础笔记</h2><ol><li><h4 id="基本数据类型和包装类型"><a href="#基本数据类型和包装类型" class="headerlink" title="基本数据类型和包装类型"></a>基本数据类型和包装类型</h4><blockquote><p>基本数据类型：short、int、long、double、float、char、string、boolean</p><p>包装类型：Short、Integer、Long、Double、Float、Char、String、Boolean</p><p>装箱：1. 手动装箱：Integer.valueOf(1) ;    2. 自动装箱：Integer i = 1;</p><p>拆箱：1. 手动拆箱：int j = i.intValue() ;    2. 自动拆箱：int j = i ;</p><p>JDK1.5开始为什么要引入包装类型：java是面向对象的语言，而基本的数据类型不具备面向对象的特性。</p><p>例：用Integer和int分别表示一个类的ID，进行非空判断的时候，Integer只要判断是否为null，int还要判断是否为0；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; Integer num1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; Integer num2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; System.out.println(<span class="string">"num1==num2 "</span> + (num1 == num2));</span><br><span class="line">&gt; </span><br><span class="line">&gt; Integer num3 = <span class="number">100</span>;</span><br><span class="line">&gt; Integer num4 = <span class="number">100</span>;</span><br><span class="line">&gt; System.out.println(<span class="string">"num3==num4 "</span> +(num3 == num4));</span><br><span class="line">&gt; </span><br><span class="line">&gt; Integer num5 = <span class="number">128</span>;</span><br><span class="line">&gt; Integer num6 = <span class="number">128</span>;</span><br><span class="line">&gt; System.out.println(<span class="string">"num5==num6 "</span> + (num5 == num6));</span><br><span class="line">&gt; </span><br><span class="line">&gt; Integer num7 = <span class="number">100</span>;</span><br><span class="line">&gt; Integer num8 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; System.out.println(<span class="string">"num7==num8 "</span> + (num7 == num8));</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">int</span> num9 = <span class="number">100</span>;</span><br><span class="line">&gt; Integer num10 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; Integer num11 = <span class="number">100</span>;</span><br><span class="line">&gt; System.out.println(<span class="string">"num9==num10 "</span> + (num9 == num10));</span><br><span class="line">&gt; System.out.println(<span class="string">"num9==num11 "</span> + (num9 == num11));</span><br><span class="line">&gt; </span><br><span class="line">&gt; 结果：num1==num2 <span class="keyword">false</span>  </span><br><span class="line">&gt;  num3==num4 <span class="keyword">true</span></span><br><span class="line">&gt;  num5==num6 <span class="keyword">false</span></span><br><span class="line">&gt;  num7==num8 <span class="keyword">false</span></span><br><span class="line">&gt;  num9==num10 <span class="keyword">true</span></span><br><span class="line">&gt;  num9==num11 <span class="keyword">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; 源码：</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">&gt;             <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     </span><br><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">static</span> &#123;</span><br><span class="line">&gt;             <span class="comment">// high value may be configured by property</span></span><br><span class="line">&gt;             <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">&gt;             String integerCacheHighPropValue =</span><br><span class="line">&gt;                 sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">&gt;             <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt;                 <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                     <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">&gt;                     i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">&gt;                     <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">&gt;                     h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">&gt;                 &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">&gt;                     <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;             high = h;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">&gt;             <span class="keyword">int</span> j = low;</span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">&gt;                 cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">&gt;             <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; 分析：</span><br><span class="line">&gt; <span class="number">1</span>.==对于对象来说比较的是对象的地址，两个新<span class="keyword">new</span>的对象地址不同，输出<span class="keyword">false</span>。</span><br><span class="line">&gt; <span class="number">2</span>.jvm在初始化的时候，会将低值（-<span class="number">128</span>）到高值（默认<span class="number">127</span>）之间的数字加载到内存中。低值是固定的，高值是可变的。在java程序执行的时候加上 -XX:AutoBoxCacheMax=&lt;size&gt; 的参数即可。缓如果初始化的数字是-<span class="number">128</span>~<span class="number">127</span>之间就会引用内存中的地址，输出<span class="keyword">true</span>。</span><br><span class="line">&gt; <span class="number">3</span>.同上。</span><br><span class="line">&gt; <span class="number">4</span>.num7是引用的本地内存地址，而num8是<span class="keyword">new</span>出来的，所以地址不同，输出<span class="keyword">false</span>。</span><br><span class="line">&gt; <span class="number">5</span>.包装类Integer和基本数据类型<span class="keyword">int</span>类型比较时，会自动拆箱为<span class="keyword">int</span>类型比较，实际上就变成两个基本的数据类型<span class="keyword">int</span>类型进行比较，而基本类型==比较的是值而不是地址，所以输出<span class="keyword">true</span>。</span><br><span class="line">&gt; <span class="number">6</span>.同上，即使是新<span class="keyword">new</span>出来的地址不同，但是最终拆箱为<span class="keyword">int</span>类型比较值是否相等，所以输出<span class="keyword">true</span>。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>“==”和“equals()” 方法区别</p><blockquote><p><strong>变量分为基本数据类型和引用数据类型</strong></p><p>1）对于==，比较的是值是否相等</p><p>​    如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p><p>　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p><p>2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象</p><p>　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p><p>　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p></blockquote></li><li><p>String、StringBuilder、StringBuffer区别</p><blockquote><p>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.String底层使用<span class="keyword">final</span>关键字修饰的数组，因此不可变</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="number">2</span>.StringBuilder继承AbstractStringBuilder抽象类使用的是普通数组所以可以改变。</span><br><span class="line">     <span class="comment">/** The value is used for character storage.*/</span></span><br><span class="line">     <span class="keyword">char</span>[] value;</span><br><span class="line"><span class="number">3</span>.StringBuffer继承AbstractStringBuilder抽象类使用的是普通数组所以可以改变。并且与StringBuilder重写的方法不同，方法添加了<span class="keyword">synchronized</span>关键字，线程安全但是效率低。</span><br></pre></td></tr></table></figure><blockquote><p>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</p><p>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p></blockquote></li><li><h4 id="java中的集合"><a href="#java中的集合" class="headerlink" title="java中的集合"></a>java中的集合</h4><blockquote><p>java中的集合分类存储value（继承Collection接口）和存储key-value（继承）形式。</p><p><strong>存储值：</strong>List、Set</p><blockquote><p>List是有序的，可以重复的。</p><p>Set是无序的，不可以重复的。根据equals和hascode判断，也就是如果一个对象要存储在Set中，必须重写equals和hasCode方法。</p></blockquote><p><strong>存储键值：</strong>Map</p></blockquote></li><li><h4 id="ArrayList和LinkedList的区别和使用场景"><a href="#ArrayList和LinkedList的区别和使用场景" class="headerlink" title="ArrayList和LinkedList的区别和使用场景"></a>ArrayList和LinkedList的区别和使用场景</h4><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1</span>.ArrayList底层使用的是数组。</span><br><span class="line">&gt; <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line">&gt; <span class="number">2</span>.LinkedList底层使用的是链表。</span><br><span class="line">&gt; <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">&gt; <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>区别：</strong></p><p>数组查询特定元素快，而插入、删除和修改比较慢，因为数组在内存中是一块连续的内存，如果是插入或删除需要移动内存。</p><p>链表在内存中是不连续的，在当前元素中存放的是下一个或者上一个元素的地址。查询时需要从头部开始查找至尾部，效率低。而插入时不需要移动内存，只需要改变节点指针即可。所以插入或删除效率高。</p><p><strong>使用场景：</strong></p><p>ArrayList使用在查询比较多，但是插入和删除比较少的情况，</p><p>LinkedList使用在查询比较少，但是插入和删除比较多的情况。</p></blockquote></li><li><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h4><blockquote><p><strong>相同点：</strong>都可以用来存储Key-Value类型数据</p><p><strong>不同点：</strong></p><ol><li><p>HashMap可以使用null值作为key或者value，而Hashtable不行。</p></li><li><p>HashMap是线程不安全的，效率高。而Hashtable是线程安全的，效率低。</p></li><li><p>HashMap继承了AbstractMap抽象类同时实现Map, Cloneable, Serializable接口，而Hashtable继承了Dictionary抽象类同时实现Map, Cloneable, Serializable接口。</p></li></ol><p><strong>线程安全又要效率高？ConcurrentHashMap</strong></p><p>通过把整个Map分为N个Segment（类似于Hashtable）,可以提供相关的线程安全，又可以提升效率，默认提升16倍。</p></blockquote></li><li><h4 id="实现一个拷贝文件的工具类使用字节流还是字符流"><a href="#实现一个拷贝文件的工具类使用字节流还是字符流" class="headerlink" title="实现一个拷贝文件的工具类使用字节流还是字符流"></a>实现一个拷贝文件的工具类使用字节流还是字符流</h4><blockquote><p>我们拷贝的文件不确定是只包含字符流，有可能有字节流（图片、声音、图像等），为考虑到通用性，要使用字节流。</p></blockquote></li><li><h4 id="线程的几种实现方式"><a href="#线程的几种实现方式" class="headerlink" title="线程的几种实现方式"></a>线程的几种实现方式</h4><blockquote><ol><li><p>通过继承Thread类实现一个线程</p></li><li><p>通过实现Runnable接口实现一个线程</p></li><li><p>通过实现callable接口，重写call函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;    <span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line">&gt;    <span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式一  开始 (Thread是一个类继承了Runnable接口) =======</span></span><br><span class="line">&gt;            Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法中写我们业务代码</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">&gt;                        <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                            Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1000毫秒(就是1秒)</span></span><br><span class="line">&gt;                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt;                            e.printStackTrace();</span><br><span class="line">&gt;                        &#125;</span><br><span class="line">&gt;                        <span class="comment">//打印当前线程名称</span></span><br><span class="line">&gt;                        System.out.println(<span class="string">"创建线程方式一,打印线程名称: "</span>+Thread.currentThread().getName());</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                        <span class="comment">//打印当前线程名称,这里采用this来获取,在某些时候这里并不适用,推荐使用上面一种方式</span></span><br><span class="line">&gt;                        System.out.println(<span class="string">"创建线程方式一,通过this调用getName方法,打印线程名称: "</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">&gt;                    &#125;</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            thread.start();<span class="comment">//启动线程</span></span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式一  结束  =======</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式二开始  (Runnable是一个接口)=======</span></span><br><span class="line">&gt;            Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法中写我们业务代码</span></span><br><span class="line">&gt;                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">&gt;                        <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                            Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1000毫秒(就是1秒)</span></span><br><span class="line">&gt;                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt;                            e.printStackTrace();</span><br><span class="line">&gt;                        &#125;</span><br><span class="line">&gt;                        <span class="comment">//打印当前线程名称</span></span><br><span class="line">&gt;                        System.out.println(<span class="string">"创建线程方式二,打印线程名称: "</span>+Thread.currentThread().getName());</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                        <span class="comment">//TODO 这种方式就不适合上面打印2的方式通过this来调用获取当前线程名称的方法</span></span><br><span class="line">&gt;                    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;);</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            thread2.start();<span class="comment">//启动线程</span></span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式二  结束  =======</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式三 开始  =======</span></span><br><span class="line">&gt;            FutureTask&lt;Integer&gt; thread3 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&gt;                    <span class="keyword">int</span> count =<span class="number">0</span>;  </span><br><span class="line">&gt;                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;  </span><br><span class="line">&gt;                        count=count+i;  </span><br><span class="line">&gt;                    &#125;  </span><br><span class="line">&gt;                    <span class="comment">//打印当前线程名称</span></span><br><span class="line">&gt;                    System.out.println(<span class="string">"创建线程方式三,打印线程名称: "</span>+Thread.currentThread().getName());</span><br><span class="line">&gt;                    <span class="keyword">return</span> count; <span class="comment">//返回值   </span></span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;);  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="keyword">new</span> Thread(thread3,<span class="string">"这是线程名称"</span>).start();<span class="comment">//启动线程</span></span><br><span class="line">&gt;            <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                System.out.println(<span class="string">"创建线程方式三,打印返回值:"</span>+ thread3.get());<span class="comment">//打印返回值</span></span><br><span class="line">&gt;            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&gt;                e.printStackTrace();</span><br><span class="line">&gt;            &#125; </span><br><span class="line">&gt;         <span class="comment">// =======  创建线程方式三 结束  =======</span></span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>   <strong>区别：</strong></p><ul><li><p>采用继承Thread类方式：</p><p>​    优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。</p><p>​    缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。</p></li><li><p>采用实现Runnable接口方式：</p><p>​    优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p><p>​    缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。</p></li></ul></blockquote></li><li><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><blockquote><ol><li><strong>newCachedThreadPool</strong></li></ol><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>这种类型的线程池特点是：</p><ul><li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li><li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li><li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&gt; <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; e.printStackTrace();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; System.out.println(index);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="2"><li><strong>newFixedThreadPool</strong></li></ol><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p><p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&gt; <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">&gt; fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; System.out.println(index);</span><br><span class="line">&gt; Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; e.printStackTrace();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置如Runtime.getRuntime().availableProcessors()</p><ol start="3"><li><strong>newSingleThreadExecutor</strong></li></ol><p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&gt; <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">&gt; singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; System.out.println(index);</span><br><span class="line">&gt; Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; e.printStackTrace();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="4"><li><strong>newScheduleThreadPool</strong></li></ol><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p><p>延迟3秒执行，延迟执行示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">&gt; scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; System.out.println(<span class="string">"delay 3 seconds"</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>表示延迟1秒后每3秒执行一次，定期执行示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">&gt; scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h4 id="使用线程池的风险，为什么使用线程池"><a href="#使用线程池的风险，为什么使用线程池" class="headerlink" title="使用线程池的风险，为什么使用线程池"></a>使用线程池的风险，为什么使用线程池</h4><blockquote><p><strong>风险：</strong></p><ol><li>死锁</li><li>资源不足</li><li>并发错误</li><li>线程泄漏</li><li>请求过载</li></ol><p><strong>作用：</strong>（连接池同理）</p><ol><li>限定线程的个数，不会由于线程过多而导致系统运行缓慢或崩溃</li><li>线程池不需要每次去创建或销毁，节约资源，响应速度快</li></ol></blockquote></li><li><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><blockquote><p><strong>常用的设计模式：</strong></p><ol><li><p>单例模式（饱汉模式、饿汉模式）：</p><p>（1）构造方法私有化，在除了自己类中其他地方都不能创建</p><p>（2）在自己的类中创建一个单实例（饱汉模式是一出来就创建单实例，而饿汉模式需要用到的时候才创建）</p><p>（3）提供一个方法或获取该实例对象（创建时需要进行方法同步）</p></li><li><p>工厂模式：SpringIOC使用的就是工厂模式，对象的创建交给一个工厂  创建。</p></li><li><p>代理模式：SpringAOP使用的就是动态代理。</p></li></ol></blockquote></li></ol><h2 id="javaWeb笔记"><a href="#javaWeb笔记" class="headerlink" title="javaWeb笔记"></a>javaWeb笔记</h2><ol><li><h4 id="Http-Get和Post请求的区别"><a href="#Http-Get和Post请求的区别" class="headerlink" title="Http Get和Post请求的区别"></a>Http Get和Post请求的区别</h4><blockquote><p><strong>相同点：</strong></p><p>Get和Post请求都是Http请求方式，用户通过不同的Http请求对资源实现不同的操作。GET，POST，PUT，DELETE对应着对资源的查，改，增，删4个操作，GET一般用于获取/查询资源信息，而POST用于更新资源信息。</p><p><strong>区别：</strong></p><ol><li>GET请求提交的数据会在地址栏显示出来，而POST请求地址栏不会改变，数据放置在HTTP包体中。</li><li>传输数据的大小不同，GET由于浏览器对地址长度的限制导致传输的数据有限制，而POST不会。</li><li>GET提交的数据会在地址中显示出来，安全性较低，而POST则不会。</li></ol></blockquote></li><li><h4 id="servlet的理解"><a href="#servlet的理解" class="headerlink" title="servlet的理解"></a>servlet的理解</h4><blockquote><p>Servlet 是用java编写的服务器端程序，而这些Servlet都要实现Servlet接口。主要用于交互式地浏览和修改数据，生成动态Web内容。Servlet运行于支持java的web容器中。</p><p>HttpServlet重写doGet和doPost方法或者service方法完成对get和post请求的响应。</p></blockquote></li><li><h4 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h4><blockquote><ol><li>加载Servlet的class</li><li>实例化Servlet</li><li>调用Servlet的init完成实例化</li><li>运行service方法，响应doGet或doPost请求</li><li>调用destory方法销毁实例</li></ol></blockquote></li><li><h4 id="Servlet-API中forward-和redirect-区别"><a href="#Servlet-API中forward-和redirect-区别" class="headerlink" title="Servlet API中forward() 和redirect()区别"></a>Servlet API中forward() 和redirect()区别</h4><blockquote><p>forward：转发，地址不变，服务端跳转</p><p>redirect：重定向，地址改变，客户端跳转</p></blockquote></li><li><h4 id="Session和Cookie区别"><a href="#Session和Cookie区别" class="headerlink" title="Session和Cookie区别"></a>Session和Cookie区别</h4><blockquote><p><strong>相同点：</strong></p><p>Session和cookie都是会话跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务端记录信息确定用户身份。但是Session是实现依赖于Cookie，sessionId（session的唯一标识需要存放在客户端）</p><p><strong>区别：</strong></p><ol><li><p>Cookie数据存放在客户端浏览器，Session存放在服务器上</p></li><li><p>Cookie安全性较Session差</p></li><li><p>Session运行时间久会占用较多服务器内存，影响服务器性能</p></li><li><p>单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie</p></li><li><p>登录信息等重要信息存放在Session中，安全性较高</p><p>其他信息如果需要保留，存在Cookie中（比如购物车的实现，但是Cookie在客户端是可以禁用的，所以可以采用cookie+数据库方式实现）</p></li></ol></blockquote></li><li><h4 id="MVC的各部分都有哪些技术来实现"><a href="#MVC的各部分都有哪些技术来实现" class="headerlink" title="MVC的各部分都有哪些技术来实现"></a>MVC的各部分都有哪些技术来实现</h4><blockquote><ul><li>M（Model） 模型     javabean……</li><li>V（View）     视图     html、jsp、freemarker、thymeleaf……</li><li>C（Control）控制器 Servlet、Action……</li></ul></blockquote></li></ol><h2 id="数据库笔记"><a href="#数据库笔记" class="headerlink" title="数据库笔记"></a>数据库笔记</h2><ol><li><h4 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h4><blockquote><ul><li><p>关系型数据库</p><blockquote><p> MySql、Oracle、SqlServer……</p></blockquote></li><li><p>非关系型数据库</p><blockquote><p>redis、memcache、mogodb、hadoop……</p></blockquote></li></ul></blockquote></li><li><h4 id="关系型数据库三范式"><a href="#关系型数据库三范式" class="headerlink" title="关系型数据库三范式"></a>关系型数据库三范式</h4><blockquote><ol><li><p>第一范式（1NF)所谓第一范式（1NF）是指<strong>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</strong>。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。理解注释：列不可分。</p></li><li><p>第二范式（2NF)第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求<strong>数据库表中的每个实例或行必须可以被惟一的区分</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。要求实体的属性完全依赖于主关键字。理解注释：不能部分依赖。即：一张表存在组合主键时，其他非主键字段不能部分依赖。</p></li><li><p>第三范式（3NF)满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求<strong>一个数据库表中不包含已在其它表中已包含的非主关键字信息</strong>。在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。理解注释：不能存在传递依赖。即：除主键外，其他字段必须依赖主键。</p></li></ol></blockquote></li><li><h4 id="事务四个基本特征ACID特性"><a href="#事务四个基本特征ACID特性" class="headerlink" title="事务四个基本特征ACID特性"></a>事务四个基本特征ACID特性</h4><blockquote><p>​    事务是并发控制的单位，使用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）.这是可靠数据库所应具备的几个特性.</p><ul><li><p>原子性</p><blockquote><p>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></blockquote></li><li><p>一致性</p><blockquote><p>在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p></blockquote></li><li><p>隔离性</p><blockquote><p>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p></blockquote></li><li><p>持久性</p><blockquote><p>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p></blockquote></li></ul></blockquote></li><li><h4 id="MySql数据库默认的最大连接数"><a href="#MySql数据库默认的最大连接数" class="headerlink" title="MySql数据库默认的最大连接数"></a>MySql数据库默认的最大连接数</h4><blockquote><p>特定服务器上的数据库只能支持一定数目同时连接，这时候需要我们设置最大连接数（最多同时服务多少连接），在my.ini中查看设置</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; # The maximum amount of concurrent sessions the MySQL server will</span><br><span class="line">&gt; # allow. One of these connections will be reserved for a user with</span><br><span class="line">&gt; # SUPER privileges to allow the administrator to login even if the</span><br><span class="line">&gt; # connection limit has been reached.</span><br><span class="line">&gt; max_connections=151</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h4 id="MySql分页、Oracle分页和SqlServer分页"><a href="#MySql分页、Oracle分页和SqlServer分页" class="headerlink" title="MySql分页、Oracle分页和SqlServer分页"></a><del>MySql分页、Oracle分页和SqlServer分页</del></h4><blockquote><p>MySql使用limit关键字来分页</p><p>Oracle使用rownum</p><p>SqlServer使用top</p></blockquote></li><li><h4 id="触发器使用场景"><a href="#触发器使用场景" class="headerlink" title="触发器使用场景"></a><strong>触发器使用场景</strong></h4><blockquote></blockquote></li></ol><h2 id="前端笔记"><a href="#前端笔记" class="headerlink" title="前端笔记"></a>前端笔记</h2><h2 id="框架笔记"><a href="#框架笔记" class="headerlink" title="框架笔记"></a>框架笔记</h2><ol><li><h4 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h4><blockquote><ol><li>用户向服务器发送请求，请求被Spring前端控制器DispatcherServlet拦截</li><li>DispatcherServlet对请求的URL进行解析，得到请求资源标识符（URL）。然后根据URI调用HandlerMapping获的该Handler配置的所有相关对象，最后以HandlerExecutionChain对象的形式返回</li><li>DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter适配器，提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller），Handler执行完成后，向DispatcherServlet返回一个ModelAndVIew对象</li><li>DispatcherServlet根据返回的ModelAndVIew，选择一个合适的ViewResolver视图解析器</li><li>通过ViewResolver结合Model和View。来渲染视图，DispatcherServlet将渲染结果返回给客户端</li></ol></blockquote></li><li><h4 id="Struts2和SpringMVC区别"><a href="#Struts2和SpringMVC区别" class="headerlink" title="Struts2和SpringMVC区别"></a>Struts2和SpringMVC区别</h4><blockquote><ol><li>Struts2的前端控制器是Filter，SpringMVC是Servlet</li><li>SpringMVC是基于方法设计，而Struts2是基于对象</li><li>SpringMVC属于Spring大家族中的一员，Spring对于SpringMVC的控制器管理更加方便，而Struts2采用XML配置参数来管理</li><li>Struts2中自身提供多种参数接收，其实都是通过ValueStack进行传递和赋值，而SpringMVC是通过方法的参数进行接收</li><li>Struts2拥有较多的技术点，比如拦截器、值栈和OGNL表达式，学习成本较高，而SpringMVC相对比较简单</li><li>Struts有自己的interceptor拦截机制，SpringMVC使用的是独立的AOP</li><li>SpringMVC处理Ajax请求，直接通过返回数据，方法中使用注解@ResponseBody直接转为JSON对象返回，而Struts2是通过插件的方式处理</li></ol></blockquote></li><li><h4 id="Spring中的两大核心"><a href="#Spring中的两大核心" class="headerlink" title="Spring中的两大核心"></a>Spring中的两大核心</h4><blockquote><ol><li><p>IOC（Inversion of Control）或DI（Dependency Injection）</p><blockquote><p><strong>IOC控制反转：</strong></p><p>在spring中BeanFactory是IOC容器的核心接口，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。XmlBeanFactory实现BeanFactory接口，通过获取xml配置文件数据，组成应用对象及对象间的依赖关系。</p><p>Spring中有三种注入方式：set注入、接口注入、构造方法注入</p><p>核心原理：配置文件+反射+容器</p></blockquote></li><li><p>AOP面向切面编程：</p><blockquote><p>使用动态代理的方式在执行前后或出现异常后执行相关逻辑</p><p>主要用于：事务、日志、权限校验</p></blockquote></li></ol></blockquote></li><li><h4 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h4><blockquote><p>为了解决面向对象与关系数据库存在的互不匹配的现象的框架</p></blockquote></li><li><h4 id="Mybatis和Hibernate区别"><a href="#Mybatis和Hibernate区别" class="headerlink" title="Mybatis和Hibernate区别"></a>Mybatis和Hibernate区别</h4><blockquote><p><strong>相同点：</strong></p><p>​    都是java中的ORM框架、屏蔽了jdbc api的底层访问细节。</p><p>​    mybatis：专注sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis也可以实现映射（输入映射，输出映射）</p><p>​    应用场景：适用需求变化较多的项目，比如：互联网项目。</p><p>​    hibernate:是一个标准的ORM框架（对象关系映射）。入门门槛较高，不需要写sql，sql语句自动生成，对sql语句进行优化、修改比较困难。</p><p>​    应用场景：适用需求变化不多的中小型项目，比如：后台管理系统，erp，orm，oa等</p></blockquote></li><li><h4 id="Hibernate映射对象的状态"><a href="#Hibernate映射对象的状态" class="headerlink" title="Hibernate映射对象的状态"></a>Hibernate映射对象的状态</h4><blockquote><ol><li>临时状态(transient)(瞬态)：刚用new 语句创建，还没有被持久化，并且不处于Sesssion 的缓存中。处于临时状态的Java 对象被称为临时对象。</li><li>持久化状态(persistent)：已经被持久化，并且加入到Session 的缓存中。处于持久化状态的Java 对象被称为持久化对象。</li><li>删除状态(removed)：不再处于Session 的缓存中，并且Session 已经计划将其从数据库中删除。处于删除状态的Java 对象被称为删除对象。</li><li>游离状态(detached)：已经被持久化，但不再处于Session 的缓存中。处于游离状态的Java 对象被称为游离对象。</li></ol><p>下面以具体的代码来说明这四种状态:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">&gt;   </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">&gt;         SessionFactory sessionFactory=HibernateUtil.getSessionFactory();  </span><br><span class="line">&gt;         Session session=sessionFactory.openSession(); <span class="comment">// 生成一个session  </span></span><br><span class="line">&gt;         session.beginTransaction(); <span class="comment">// 开启事务  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         Person p1=<span class="keyword">new</span> Person(<span class="string">"天天"</span>,<span class="string">"18"</span>,<span class="string">"3009"</span>); <span class="comment">// 临时对象1  </span></span><br><span class="line">&gt;         Person p2=<span class="keyword">new</span> Person(<span class="string">"小李"</span>,<span class="string">"23"</span>,<span class="string">"4009"</span>); <span class="comment">// 临时对象1   </span></span><br><span class="line">&gt;         session.save(p1); <span class="comment">// 持久化对象  </span></span><br><span class="line">&gt;         session.save(p2); <span class="comment">// 持久化对象  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         session.delete(p2); <span class="comment">// 删除对象  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         session.getTransaction().commit(); <span class="comment">// 提交事务  </span></span><br><span class="line">&gt;         session.close(); <span class="comment">// 关闭session  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         System.out.println(p1.getName()); <span class="comment">// 游离对象  </span></span><br><span class="line">&gt;         System.out.println(p2.getName()); <span class="comment">// 删除对象  </span></span><br><span class="line">&gt;     &#125;     </span><br><span class="line">&gt; &#125;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><h4 id="Hibernate缓存机制"><a href="#Hibernate缓存机制" class="headerlink" title="Hibernate缓存机制"></a>Hibernate缓存机制</h4><blockquote><p>​    使用缓存是为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能</p><p>​    Hibernate缓存分为一级缓存和二级缓存，一级缓存就是Session级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。</p><p>什么样的数据适合存放到第二级缓存中？ 　　</p><p>​    1) 很少被修改的数据 　帖子的最后回复时间　</p><p>​    2) 经常被查询的数据   电商的地点</p><p>​    3) 不是很重要的数据，允许出现偶尔并发的数据 　　</p><p>​    4) 不会被并发访问的数据 　　</p><p>​    5) 常量数据 </p><p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用memcahe,redis等中央缓存来代替二级缓存。</p></blockquote></li><li><h4 id="webservice使用场景"><a href="#webservice使用场景" class="headerlink" title="webservice使用场景"></a>webservice使用场景</h4><blockquote><p>​    webservice是一个SOA（面向服务的编程）的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过Internet进行基于Http协议的网络应用间的交互。</p><ol><li><p>异构系统(不同语言)的整合</p></li><li><p>不同客户端的整合，浏览器、手机端(android,ios.塞班)、微信端、PC端等终端来访问</p></li><li><p>实实在在的列子：</p><p>天气预报：可以通过实现webservice客户端调用远程天气服务实的。 </p><p>单点登录：一个服务是所有系统的登录</p></li></ol></blockquote></li></ol><h2 id="服务器及优化"><a href="#服务器及优化" class="headerlink" title="服务器及优化"></a>服务器及优化</h2><ol><li><h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><blockquote><p>常用：</p><p>​    Pwd 获取当前路径</p><p>​    Cd 跳转到目录</p><p>​    Su -u 切换到管理员</p><p>​    Ls ls 列举目录</p><p>文件操作命令：</p><p>​    文件</p><p>​           tail 查看</p><p>​           rm -rf </p><p>​           vi</p><p>​    文件夹</p><p>​           mkdir </p><p>​           rm -r</p></blockquote></li><li><h4 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h4><blockquote><p>做过mysql数据库的优化、其他数据库类似</p><p>定位：查找、定位慢查询</p><p>优化手段：</p><p>​    a) 创建索引：创建合适的索引，我们就可以现在索引中查询，查询到以后直接找对应的记录。</p><p>​    b) 分表：当一张表的数据比较多或者一张表的某些字段的值比较多并且很少使用时，采用水平分表和垂直分表来优化</p><p>​    c) 读写分离：当一台服务器不能满足需求时，采用读写分离的方式进行集群。</p><p>​    d) 缓存：使用redis来进行缓存</p><p>​    e) 一些常用优化技巧</p><p><a href="http://www.cnblogs.com/luyucheng/p/6323477.html" target="_blank" rel="noopener">优化</a></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>​        当一个数组中大部分元素为0，或者为同一值的数组时，可研使用稀疏数组来保存该数组。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h2><ol><li>记录数组一共有几行几列，有多少个不同的值。</li><li>把具有不同值的元素的行列及值记录在小规模的数组中，从而缩小程序的规模。</li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200709221603.png" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: SparseArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * 二维数组转稀疏数组思路</span></span><br><span class="line"><span class="comment"> * 1. 遍历原始的二维数组，得到有效数据的个数count</span></span><br><span class="line"><span class="comment"> * 2. 根据count就可以创建 稀疏数组 sparseArr   int[count + 1] [3]</span></span><br><span class="line"><span class="comment"> * 3. 将二维数组的有效数据数据存入到 稀疏数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 10136</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/9 22:20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个原始的二维数组11*11</span></span><br><span class="line">        <span class="comment">//0表示没有棋子，1表示黑子，2表示蓝子</span></span><br><span class="line">        <span class="keyword">int</span> chessOriginArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessOriginArr[<span class="number">1</span>][<span class="number">2</span>]= <span class="number">1</span>;</span><br><span class="line">        chessOriginArr[<span class="number">2</span>][<span class="number">3</span>]= <span class="number">2</span>;</span><br><span class="line">        chessOriginArr[<span class="number">5</span>][<span class="number">2</span>]= <span class="number">2</span>;</span><br><span class="line">        chessOriginArr[<span class="number">2</span>][<span class="number">4</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出原始数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessOriginArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1. 遍历原始的二维数组，得到有效数据的个数count</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessOriginArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data!=<span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(count);//2</span></span><br><span class="line">        <span class="comment">//2. 根据count就可以创建 稀疏数组 sparseArr   int[count + 1] [3]</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//3. 将二维数组的有效数据数据存入到 稀疏数组</span></span><br><span class="line">        <span class="comment">//第一行存储原始数组的行数，列数以及有效数字数量</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line">        <span class="keyword">int</span> rowNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(chessOriginArr[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    rowNum++;</span><br><span class="line">                    sparseArr[rowNum][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[rowNum][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[rowNum][<span class="number">2</span>] = chessOriginArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:sparseArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        <span class="comment">//稀疏数组还原为原始数组</span></span><br><span class="line">        <span class="keyword">int</span> chessOriginBackArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessOriginBackArr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessOriginBackArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00021000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00200000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">------------------------------------</span><br><span class="line">11114</span><br><span class="line">121</span><br><span class="line">232</span><br><span class="line">241</span><br><span class="line">522</span><br><span class="line">------------------------------------</span><br><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00021000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00200000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
          <category> 稀疏数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 稀疏数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组模拟环形队列</title>
      <link href="/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"/>
      <url>/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><ol><li>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li><li>遵循<strong>先进先出</strong>的原则。即：先进入队列的数据，要先取出。后进入的要后取出</li></ol><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h2><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200709225933.png" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 环形队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 环形队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组模拟环形队列</title>
      <link href="/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E9%98%9F%E5%88%97/"/>
      <url>/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><ol><li>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li><li>遵循<strong>先进先出</strong>的原则。即：先进入队列的数据，要先取出。后进入的要后取出</li></ol><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h2><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200709225933.png" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 环形队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 环形队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方兴商城笔记</title>
      <link href="/2019/06/29/FangXingMallNote/"/>
      <url>/2019/06/29/FangXingMallNote/</url>
      
        <content type="html"><![CDATA[<h1 id="方兴商城"><a href="#方兴商城" class="headerlink" title="方兴商城"></a>方兴商城</h1><h2 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h2><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="系统架构图"></p><h2 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h2><table><thead><tr><th><strong>表名称</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>tb_brand</td><td>品牌</td></tr><tr><td>tb_specification</td><td>规格</td></tr><tr><td>tb_specification_option</td><td>规格选项</td></tr><tr><td>tb_type_template</td><td>类型模板：用于关联品牌和规格</td></tr><tr><td>tb_item_cat</td><td>商品分类</td></tr><tr><td>tb_seller</td><td>商家</td></tr><tr><td>tb_goods</td><td>商品</td></tr><tr><td>tb_goods_desc</td><td>商品详情</td></tr><tr><td>tb_item</td><td>商品明细</td></tr><tr><td>tb_content</td><td>内容（广告）</td></tr><tr><td>tb_content_category</td><td>内容（广告）类型</td></tr><tr><td>tb_user</td><td>用户</td></tr><tr><td>tb_order</td><td>订单</td></tr><tr><td>tb_order_item</td><td>订单明细</td></tr><tr><td>tb_pay_log</td><td>支付日志</td></tr></tbody></table><h2 id="系统框架组合"><a href="#系统框架组合" class="headerlink" title="系统框架组合"></a>系统框架组合</h2><ul><li>前端<ul><li>AngularJS(基础指令学习)</li><li>BootStrap</li></ul></li><li>后端<ul><li>Spring</li><li>SpringMVC</li><li>SpringSecurity</li><li>Mybatis</li><li>Dubbox</li></ul></li></ul><h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h2><ol><li>创建父工程fangxingmall-parent（POM）</li><li>创建实体类模块fangxingmall-pojo</li><li>创建数据访问模块fangxingmall-dao</li><li>创建商家商品服务接口模块fangxingmall-sellergoods-interface</li><li>创建商家商品服务模块fangxingmall-sellergoods-service</li><li>创建运营商管理后台模块fangxingmall-manager-web</li><li>创建商家管理后台模块fangxingmall-shop-web</li></ol><h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><ol><li><p>服务器安装软件</p><ul><li><p>安装zookeeper</p><ol><li><p>服务器安装JDK</p></li><li><p>上传zookeeper压缩包到服务器</p></li><li><p>解压缩</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# tar -zxvf zookeeper-3.4.6.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>进入zookeeper-3.4.6目录创建data文件夹</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# mkdir data</span><br></pre></td></tr></table></figure></li><li><p>进入conf目录，重命名zoo_sample.cfg为zoo.cfg</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></li><li><p>打开zoo.cfg文件，修改data存储路径为你解压缩新建的data路径，pwd查看当前路径直接复制</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# vim zoo.cfg</span><br><span class="line"><span class="meta">#</span>dataDir=/usr/dubbo/zookeeper-3.4.6/data</span><br></pre></td></tr></table></figure></li><li><p>进入bin目录，启动服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# ./zkServer.sh start</span><br></pre></td></tr></table></figure></li><li><p>关闭服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# ./zkServer.sh stop</span><br></pre></td></tr></table></figure></li><li><p>查看服务状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# ./zkServer.sh status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /usr/dubbo/zookeeper-3.4.6/bin/../conf/zoo.cfg</span><br><span class="line">Mode: standalonexxxxxxxxxx [root@VM_90_242_centos bin]# ./zkServer.sh statusJMX enabled by defaultUsing config: /usr/dubbo/zookeeper-3.4.6/bin/../conf/zoo.cfgMode: standalone./zkServer.sh statusshell</span><br></pre></td></tr></table></figure></li></ol></li><li><p>安装Dubbox</p><ol><li><p>手动安装Dubbox的jar包到本地仓库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=d:\setup\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar</span><br></pre></td></tr></table></figure></li><li><p>配置离线约束</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190918105912.png" alt="配置离线约束"></p></li></ol></li><li><p><a href="https://fangchenyong.top/2019/07/23/install_ActiveMQ/">安装activemq</a></p></li></ul></li><li><p>修改</p><ol><li><p>数据库连接修改</p><blockquote><p>/fangxingmall-dao/src/main/resources/properties/db.properties</p></blockquote></li><li><p>redis配置修改</p><blockquote><p>/fangxingmall-common/src/main/resources/properties/redis-config.properties</p></blockquote></li><li><p>日志文件配置修改</p><blockquote><p>/fangxingmall-sellergoods-service/src/main/resources/log4j.properties</p></blockquote></li><li><p>dubbo连接修改</p><blockquote><p>/fangxingmall-sellergoods-service/src/main/resources/spring/applicationContext-service.xml</p><p>/fangxingmall-shop-web/src/main/resources/spring/springmvc.xml</p><p>/fangxingmall-shop-web/src/main/resources/spring/spring-security.xml</p><p>/fangxingmall-manager-web/src/main/resources/spring/springmvc.xml</p><p>/fangxingmall-content-service/src/main/resources/spring/applicationContext-service.xml</p><p>/fangxingmall-portal-web/src/main/resources/spring/springmvc.xml</p><p>/fangxingmall-search-web/src/main/resources/spring/springmvc.xml</p></blockquote></li><li><p>FastDFS配置</p></li><li><p>solr配置</p><blockquote><p>/fangxingmall-solr-util/src/main/resources/spring/applicationContext-solr.xml</p></blockquote></li><li></li></ol></li><li><p>启动模块（MavenBulid tomcat7:run）</p><ol><li>fangxingmall-sellergoods-service，端口9001</li><li>fangxingmall-manager-web，端口9101</li><li>fangxingmall-content-service，端口9002</li><li>fangxingmall-shop-web，端口9102</li><li>fangxingmall-portal-web，端口9103</li><li>fangxingmall-search-service，端口9004</li><li>fangxingmall-search-web，端口9104</li><li>fangxingmall-page-service，端口9005</li><li>fangxingmall-page-web，端口9105</li></ol></li><li><p>开发进度</p><ul><li><p>新增、修改、删除商品分类</p></li><li><p>安装Fast DFS服务器</p></li><li><p>TO DO 图片上传</p></li><li><p>按销量、评价排序</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 方兴商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
