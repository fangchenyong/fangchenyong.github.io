<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法</title>
      <link href="/2021/05/06/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/05/06/%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: InsertSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 10136</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/6 23:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 记录要插入的数据</span></span><br><span class="line">            <span class="keyword">int</span> arrTemp = arr[i];</span><br><span class="line">            <span class="comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">1</span> &amp;&amp; arrTemp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存在比其小的数，插入</span></span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                arr[j] = arrTemp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 插入排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2021/05/06/%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/05/06/%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: SelectSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 10136</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/6 22:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//记录用来对比的元素下标</span></span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="comment">//循环后面的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//如果有比对比的元素小，记录下标,反之则是倒序</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[k]) &#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换位置</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            arr[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 选择排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机</title>
      <link href="/2021/04/12/Java-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2021/04/12/Java-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="深入理解Java虚拟机"><a href="#深入理解Java虚拟机" class="headerlink" title="深入理解Java虚拟机"></a>深入理解Java虚拟机</h2> <iframe   height=1000 width=90%  src="https://www.processon.com/embed/606f199bf346fb575c7130c1"   frameborder=0   allowfullscreen> </iframe>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-并发编程</title>
      <link href="/2021/03/21/%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/03/21/%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="为什么要使用并发编程"><a href="#为什么要使用并发编程" class="headerlink" title="为什么要使用并发编程"></a>为什么要使用并发编程</h2><ul><li>提升多核CPU的利用率：一般来说一台主机上的会有多个CPU核心，我们可以创建多个线程，理论上讲操作系统可以将多个线程分配给不同的CPU去执行，每个CPU执行一个线程，这样就提高了CPU的使用效率，如果使用单线程就只能有一个CPU核心被使用。</li><li>比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</li><li>简单来说就是：<ul><li>充分利用多核CPU的计算能力；</li><li>方便进行业务拆分，提升应用性能</li></ul></li></ul><h2 id="多线程应用场景"><a href="#多线程应用场景" class="headerlink" title="多线程应用场景"></a>多线程应用场景</h2><ul><li>例如: 迅雷多线程下载、数据库连接池、分批发送短信等。</li></ul><h2 id="并发编程有什么缺点"><a href="#并发编程有什么缺点" class="headerlink" title="并发编程有什么缺点"></a>并发编程有什么缺点</h2><ul><li>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、线程安全、死锁等问题。</li></ul><h2 id="并发编程三个必要因素是什么？"><a href="#并发编程三个必要因素是什么？" class="headerlink" title="并发编程三个必要因素是什么？"></a>并发编程三个必要因素是什么？</h2><ul><li>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。</li><li>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</li></ul><h2 id="Java-程序中怎么保证多线程的运行安全？"><a href="#Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="Java 程序中怎么保证多线程的运行安全？"></a>Java 程序中怎么保证多线程的运行安全？</h2><ul><li>出现线程安全问题的原因一般都是三个原因：<ul><li>线程切换带来的原子性问题 解决办法：使用多线程之间同步synchronized或使用锁(lock)。</li><li>缓存导致的可见性问题 解决办法：synchronized、volatile、LOCK，可以解决可见性问题</li><li>编译优化带来的有序性问题 解决办法：Happens-Before 规则可以解决有序性问题</li></ul></li></ul><h2 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h2><ul><li><p>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p></li><li><p>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。<br>  串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</p><p>  <strong>做一个形象的比喻：</strong></p><ul><li>并发 = 俩个人用一台电脑。</li><li>并行 = 俩个人分配了俩台电脑。</li><li>串行 = 俩个人排队使用一台电脑。</li></ul></li></ul><h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><ul><li>多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。</li></ul><h2 id="多线程的优点和缺点"><a href="#多线程的优点和缺点" class="headerlink" title="多线程的优点和缺点"></a>多线程的优点和缺点</h2><p><strong>优点：</strong></p><ul><li>可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li></ul><p><strong>缺点：</strong></p><ul><li>线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；</li><li>多线程需要协调和管理，所以需要 CPU 时间跟踪线程；</li><li>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。</li></ul><h2 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h2><ul><li><p>什么是线程和进程?</p><ul><li><p>进程：一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程</p></li><li><p>线程：进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。</p><p>  <code>一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</code></p></li></ul></li><li><p>进程与线程的区别</p><ul><li>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</li><li>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的</li><li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。</li><li>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li></ul></li></ul><h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h2><ul><li>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</li><li>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</li><li>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU时间，事实上，可能是操作系统中时间消耗最大的操作。</li><li>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li></ul><h2 id="守护线程和用户线程有什么区别呢？"><a href="#守护线程和用户线程有什么区别呢？" class="headerlink" title="守护线程和用户线程有什么区别呢？"></a>守护线程和用户线程有什么区别呢？</h2><ul><li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li><li>守护 (Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li></ul><h2 id="如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？"><a href="#如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？" class="headerlink" title="如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？"></a>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</h2><ul><li>windows上面用任务管理器看，linux下可以用 top 这个工具看。<ul><li>找出cpu耗用厉害的进程pid， 终端执行top命令，然后按下shift+p (shift+m是找出消耗内存最高)查找出cpu利用最厉害的pid号</li><li>根据上面第一步拿到的pid号，top -H -p pid 。然后按下shift+p，查找出cpu利用率最厉害的线程号，比如top -H -p 1328<ul><li>将获取到的线程号转换成16进制，去百度转换一下就行</li></ul></li><li>使用jstack工具将进程信息打印输出，jstack pid号 &gt; /tmp/t.dat，比如jstack 31365 &gt;/tmp/t.dat<ul><li>编辑/tmp/t.dat文件，查找线程号对应的信息</li></ul></li><li>或者直接使用JDK自带的工具查看“jconsole” 、“visualVm”，这都是JDK自带的，可以直接在JDK的bin目录下找到直接使用</li></ul></li></ul><h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><ul><li>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</li><li>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</li><li>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</li></ul><h2 id="形成死锁的四个必要条件是什么"><a href="#形成死锁的四个必要条件是什么" class="headerlink" title="形成死锁的四个必要条件是什么"></a>形成死锁的四个必要条件是什么</h2><ul><li>互斥条件：在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，就只能等待，直至占有资源的进程用毕释放。</li><li>占有且等待条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不可抢占条件：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。（比如一个进程集合，A在等B，B在等C，C在等A）</li></ul><h2 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h2><ul><li>避免一个线程同时获得多个锁</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制</li></ul><h2 id="创建线程的四种方式"><a href="#创建线程的四种方式" class="headerlink" title="创建线程的四种方式"></a>创建线程的四种方式</h2><ul><li><p>继承 Thread 类；</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法正在执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 Runnable 接口；</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 Callable 接口；</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; call()方法执行中...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用匿名内部类方式</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建多线程创建开始</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="说一下-runnable-和-callable-有什么区别"><a href="#说一下-runnable-和-callable-有什么区别" class="headerlink" title="说一下 runnable 和 callable 有什么区别"></a>说一下 runnable 和 callable 有什么区别</h2><ul><li>相同点：<ul><li>都是接口</li><li>都可以编写多线程程序</li><li>都采用Thread.start()启动线程</li></ul></li><li>主要区别：<ul><li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息 注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</li></ul></li></ul><h2 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run()和 start()有什么区别？"></a>线程的 run()和 start()有什么区别？</h2><ul><li>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</li><li>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start()只能调用一次。</li><li>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</li><li>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</li></ul><h2 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？</h2><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><ul><li>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到 时间片 后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行run() 方法的内容，这是真正的多线程工作。</li><li>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li></ul><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><h2 id="什么是-Callable-和-Future"><a href="#什么是-Callable-和-Future" class="headerlink" title="什么是 Callable 和 Future?"></a>什么是 Callable 和 Future?</h2><ul><li>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</li><li>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 Callable用于产生结果，Future 用于获取结果。</li></ul><h2 id="什么是-FutureTask"><a href="#什么是-FutureTask" class="headerlink" title="什么是 FutureTask"></a>什么是 FutureTask</h2><ul><li>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</li></ul><h2 id="一个线程的生命周期有哪几种状态？它们之间如何流转的？"><a href="#一个线程的生命周期有哪几种状态？它们之间如何流转的？" class="headerlink" title="一个线程的生命周期有哪几种状态？它们之间如何流转的？"></a>一个线程的生命周期有哪几种状态？它们之间如何流转的？</h2><ul><li>NEW：毫无疑问表示的是刚创建的线程，还没有开始启动。</li><li>RUNNABLE: 表示线程已经触发 start()方式调用，线程正式启动，线程处于运行中状态。</li><li>BLOCKED：表示线程阻塞，等待获取锁，如碰到 synchronized、lock 等关键字等占用临界区的情况，一旦获取到锁就进行RUNNABLE 状态继续运行。</li><li>WAITING：表示线程处于无限制等待状态，等待一个特殊的事件来重新唤醒，如通过wait()方法进行等待的线程等待一个 notify()或者 notifyAll()方法，通过 join()方法进行等待的线程等待目标线程运行结束而唤醒，一旦通过相关事件唤醒线程，线程就进入了 RUNNABLE 状态继续运行。</li><li>TIMED_WAITING：表示线程进入了一个有时限的等待，如 sleep(3000)，等待 3 秒后线程重新进行 RUNNABLE 状态继续运行。</li><li>TERMINATED：表示线程执行完毕后，进行终止状态。需要注意的是，一旦线程通过 start 方法启动后就再也不能回到初始 NEW 状态，线程终止后也不能再回到RUNNABLE 状态</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20210321160949.png"></p><ul><li><p>新建(new)：新创建了一个线程对象。</p></li><li><p>就绪（可运行状态）(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</p></li><li><p>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</p><p>  注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p></li><li><p>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。</p><ul><li>阻塞的情况分三种：<ol><li>等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting<br> queue)中，使本线程进入到等待阻塞状态；</li><li> 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；</li><li>其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状<br> 态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。</li></ol></li></ul></li><li><p>死亡(dead)(结束)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ul><h2 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h2><ul><li>计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。（Java是由JVM中的线程计数器来实现线程调度）</li><li>有两种调度模型：分时调度模型和抢占式调度模型。<ul><li>分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU的时间片这个也比较好理解。</li><li>Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</li></ul></li></ul><h2 id="线程的调度策略"><a href="#线程的调度策略" class="headerlink" title="线程的调度策略"></a>线程的调度策略</h2><p>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p><ul><li>线程体中调用了 yield 方法让出了对 cpu 的占用权利</li><li>线程体中调用了 sleep 方法使线程进入睡眠状态</li><li>线程由于 IO 操作受到阻塞</li><li>另外一个更高优先级线程出现</li><li>在支持时间片的系统中，该线程的时间片用完</li></ul><h2 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</h2><ul><li>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。</li><li>时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。</li><li>线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</li></ul><h2 id="请说出与线程同步以及线程调度相关的方法。"><a href="#请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="请说出与线程同步以及线程调度相关的方法。"></a>请说出与线程同步以及线程调度相关的方法。</h2><ul><li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理<br>  InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一<br>  个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它<br>  们竞争，只有获得锁的线程才能进入就绪状态；</li></ul><h2 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h2><p>两者都可以暂停线程的执行</p><ul><li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li><li>是否释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li><li>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(longtimeout)超时后线程会自动苏醒。</li></ul><h2 id="你是如何调用-wait-方法的？使用-if-块还是循环？为什么？"><a href="#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？" class="headerlink" title="你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h2><ul><li><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p></li><li><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。</p><p>  下面是一段标准的使用 wait 和 notify 方法的代码：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">    <span class="comment">// 判断条件谓词是否得到满足</span></span><br><span class="line">    <span class="keyword">while</span>(!locked) &#123;</span><br><span class="line">        <span class="comment">// 等待唤醒</span></span><br><span class="line">        monitor.wait();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 处理其他的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h2><ul><li>因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</li><li>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</li></ul><h2 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h2><ul><li>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</li></ul><h2 id="Thread-类中的-yield-方法有什么作用？"><a href="#Thread-类中的-yield-方法有什么作用？" class="headerlink" title="Thread 类中的 yield 方法有什么作用？"></a>Thread 类中的 yield 方法有什么作用？</h2><ul><li>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</li><li>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</li></ul><h2 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h2><ul><li>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</li></ul><h2 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep()方法和 yield()方法有什么区别？"></a>线程的 sleep()方法和 yield()方法有什么区别？</h2><ul><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li><li>线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</li><li>sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</li><li>sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</li></ul><h2 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h2><ul><li>在java中有以下3种方法可以终止正在运行的线程：<ul><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li><li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li><li>使用interrupt方法中断线程。</li></ul></li></ul><h2 id="Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="Java 中 interrupted 和 isInterrupted 方法的区别？"></a>Java 中 interrupted 和 isInterrupted 方法的区别？</h2><ul><li>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br>  注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</li><li>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</li><li>isInterrupted：是可以返回当前中断信号是true还是false，与interrupt最大的差别</li></ul><h2 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h2><ul><li>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</li></ul><h2 id="Java-中你怎样唤醒一个阻塞的线程？"><a href="#Java-中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java 中你怎样唤醒一个阻塞的线程？"></a>Java 中你怎样唤醒一个阻塞的线程？</h2><ul><li>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</li><li>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</li></ul><h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify() 和 notifyAll() 有什么区别？"></a>notify() 和 notifyAll() 有什么区别？</h2><ul><li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</li><li>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</li></ul><h2 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h2><ul><li><p>在两个线程间共享变量即可实现共享。</p><p>  一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p></li></ul><h2 id="Java-如何实现多线程之间的通讯和协作？"><a href="#Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="Java 如何实现多线程之间的通讯和协作？"></a>Java 如何实现多线程之间的通讯和协作？</h2><ul><li><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p></li><li><p>比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p></li><li><p>Java中线程通信协作的最常见方式：</p><ul><li><p>一.syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()</p></li><li><p>二.ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()</p></li><li><p>三.通过管道进行线程间通信：字节流、字符流</p></li></ul></li></ul><h2 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h2><ul><li><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p></li><li><p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p><p>  请知道一条原则：同步的范围越小越好。</p></li></ul><h2 id="什么是线程同步和线程互斥，有哪几种实现方式？"><a href="#什么是线程同步和线程互斥，有哪几种实现方式？" class="headerlink" title="什么是线程同步和线程互斥，有哪几种实现方式？"></a>什么是线程同步和线程互斥，有哪几种实现方式？</h2><ul><li>当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。</li><li>在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。</li><li>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</li><li>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</li><li>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</li><li>实现线程同步的方法<ul><li>同步代码方法：sychronized 关键字修饰的方法</li><li>同步代码块：sychronized 关键字修饰的代码块</li><li>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</li><li>使用重入锁实现线程同步：reentrantlock类是可冲入、互斥、实现了lock接口的锁他与sychronized方法具有相同的基本行为和语义</li></ul></li></ul><h2 id="在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h2><ul><li>在 java 虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</li><li>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</li><li>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</li></ul><h2 id="如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么"></a>如果你提交任务时，线程池队列已满，这时会发生什么</h2><p>有俩种可能：</p><ul><li>如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务</li><li>如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue 满了，会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是 AbortPolicy</li></ul><h2 id="什么叫线程安全？servlet-是线程安全吗"><a href="#什么叫线程安全？servlet-是线程安全吗" class="headerlink" title="什么叫线程安全？servlet 是线程安全吗?"></a>什么叫线程安全？servlet 是线程安全吗?</h2><ul><li>线程安全是编程中的术语，指某个方法在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</li><li>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</li><li>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。</li><li>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</li><li>Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。</li></ul><h2 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h2><ul><li><p>方法一：使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger</p></li><li><p>方法二：使用自动锁 synchronized。</p></li><li><p>方法三：使用手动锁 Lock。</p><p>  手动锁 Java 示例代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System. out. println(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System. out. println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h2><ul><li>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。</li><li>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</li><li>当然，如果你真的想设置优先级可以通过setPriority()方法设置，但是设置了不一定会该变，这个是不准确的</li></ul><h2 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h2><ul><li>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</li><li>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了Thread1，main 函数中 new 了 Thread2，那么：<ul><li>Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的</li><li>Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的</li></ul></li></ul><h2 id="Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？"><a href="#Java-中怎么获取一份线程-dump-文件？你如何在-Java-中获取线程堆栈？" class="headerlink" title="Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？"></a>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</h2><ul><li>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump文件中。</li><li>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java应用的 dump 文件。</li><li>在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。</li></ul><h2 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h2><ul><li>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</li></ul><h2 id="Java-线程数过多会造成什么异常？"><a href="#Java-线程数过多会造成什么异常？" class="headerlink" title="Java 线程数过多会造成什么异常？"></a>Java 线程数过多会造成什么异常？</h2><ul><li><p>线程的生命周期开销非常高</p></li><li><p>消耗过多的 CPU</p><p>  资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。</p></li><li><p>降低稳定性JVM</p><p>  在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</p></li></ul><h2 id="多线程的常用方法"><a href="#多线程的常用方法" class="headerlink" title="多线程的常用方法"></a>多线程的常用方法</h2><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>sleep()</td><td>强迫一个线程睡眠Ｎ毫秒</td></tr><tr><td>isAlive()</td><td>判断一个线程是否存活。</td></tr><tr><td>join()</td><td>等待线程终止。</td></tr><tr><td>activeCount()</td><td>程序中活跃的线程数。</td></tr><tr><td>enumerate()</td><td>枚举程序中的线程。</td></tr><tr><td>currentThread()</td><td>得到当前线程。</td></tr><tr><td>isDaemon()</td><td>一个线程是否为守护线程。</td></tr><tr><td>setDaemon()</td><td>设置一个线程为守护线程。</td></tr><tr><td>setName()</td><td>为线程设置一个名称。</td></tr><tr><td>wait()</td><td>强迫一个线程等待。</td></tr><tr><td>notify()</td><td>通知一个线程继续运行。</td></tr><tr><td>setPriority()</td><td>设置一个线程的优先级。</td></tr></tbody></table><h1 id="并发理论"><a href="#并发理论" class="headerlink" title="并发理论"></a>并发理论</h1><h2 id="Java中垃圾回收有什么目的？什么时候进行垃圾回收？"><a href="#Java中垃圾回收有什么目的？什么时候进行垃圾回收？" class="headerlink" title="Java中垃圾回收有什么目的？什么时候进行垃圾回收？"></a>Java中垃圾回收有什么目的？什么时候进行垃圾回收？</h2><ul><li>垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行的。</li><li>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</li></ul><h2 id="线程之间如何通信及线程之间如何同步"><a href="#线程之间如何通信及线程之间如何同步" class="headerlink" title="线程之间如何通信及线程之间如何同步"></a>线程之间如何通信及线程之间如何同步</h2><ul><li>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。通信是指线程之间以如何来交换信息。一般线程之间的通信机制有两种：共享内存和消息传递。</li><li>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</li></ul><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><ul><li>共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入时,能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</li></ul><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20210321162645.png"></p><ul><li>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：<ul><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li><li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li></ul></li></ul><p><strong>下面通过示意图来说明线程之间的通信</strong></p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20210321162723.png"></p><ul><li>总结：什么是Java内存模型：java内存模型简称jmm，定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。</li></ul><h2 id="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h2><ul><li>不会，在下一个垃圾回调周期中，这个对象将是被可回收的。</li><li>也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。</li></ul><h2 id="finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h2><ul><li><p>垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；<br>  finalize是Object类的一个方法，该方法在Object类中的声明protected void finalize() throws Throwable { } 在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间</p></li><li><p>GC本来就是内存回收了，应用还需要在finalization做什么呢？ </p><p>  答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。<br>  Finalizetion主要用来释放被对象占用的资源（不是指内存，而是指其他资源，比如文件(File<br>  Handle)、端口(ports)、数据库连接(DB Connection)等）。然而，它不能真正有效地工作。</p></li></ul><h2 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h2><ul><li><p>程序执行的顺序按照代码的先后顺序执行。</p></li><li><p>一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，进行重新排序（重排序），它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">3</span>; <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">2</span>; <span class="comment">//语句3</span></span><br><span class="line">r = a*a; <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure></li><li><p>则因为重排序，他还可能执行顺序为（这里标注的是语句的执行顺序） 2-1-3-4，1-3-2-4 但绝不可能 2-1-4-3，因为这打破了依赖关系。</p></li><li><p>显然重排序对单线程运行是不会有任何问题，但是多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。</p></li></ul><h2 id="重排序实际执行的指令步骤"><a href="#重排序实际执行的指令步骤" class="headerlink" title="重排序实际执行的指令步骤"></a>重排序实际执行的指令步骤</h2><p>源代码 –&gt; 1.编译器优化重排序 –&gt; 2.指令级并行重排序 –&gt; 3.内存系统重排序 –&gt; 最终在执行指令排序</p><ul><li><p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p>指令级并行的重排序。现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>  这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。</p></li></ul><h2 id="重排序遵守的规则"><a href="#重排序遵守的规则" class="headerlink" title="重排序遵守的规则"></a>重排序遵守的规则</h2><ul><li>as-if-serial：<ul><li>不管怎么排序，结果不能改变</li><li>不存在数据依赖的可以被编译器和处理器重排序</li><li>一个操作依赖两个操作，这两个操作如果不存在依赖可以重排序</li><li>单线程根据此规则不会有问题，但是重排序后多线程会有问题</li></ul></li></ul><h2 id="as-if-serial规则和happens-before规则的区别"><a href="#as-if-serial规则和happens-before规则的区别" class="headerlink" title="as-if-serial规则和happens-before规则的区别"></a>as-if-serial规则和happens-before规则的区别</h2><ul><li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行<br>  的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li><li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li></ul><h2 id="并发关键字-synchronized-？"><a href="#并发关键字-synchronized-？" class="headerlink" title="并发关键字 synchronized ？"></a>并发关键字 synchronized ？</h2><ul><li>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制<br>  synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、变量。</li><li>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</li></ul><h2 id="说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h2><p><strong>synchronized关键字最主要的三种使用方式：</strong></p><ul><li>修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li>修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li><li>修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><p>总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p><h2 id="单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！"><a href="#单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！" class="headerlink" title="单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！"></a>单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！</h2><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><p>双锁机制的出现是为了解决前面同步问题和性能问题，看下面的代码，简单分析下确实是解决了多线程并行进来不会出现重复new对象，而且也实现了懒加载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton();<br>  这段代码其实是分为三步执行：<ul><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ul></li><li>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时uniqueInstance 还未被初始化。<br>  使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</li></ul><h2 id="说一下-synchronized-底层实现原理？"><a href="#说一下-synchronized-底层实现原理？" class="headerlink" title="说一下 synchronized 底层实现原理？"></a>说一下 synchronized 底层实现原理？</h2><ul><li><p>Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成，</p></li><li><p>每个对象有一个监视器锁(monitor)。每个Synchronized修饰过的代码当它的monitor被占用时会处于锁定状态并且尝试获取monitor的所有权 ，过程：</p><ul><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为<br>  monitor的所有者。</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li></ul><p>  synchronized是可以通过 反汇编指令 javap命令，查看相应的字节码文件。</p></li></ul><h2 id="synchronized可重入的原理，什么是重入锁？"><a href="#synchronized可重入的原理，什么是重入锁？" class="headerlink" title="synchronized可重入的原理，什么是重入锁？"></a>synchronized可重入的原理，什么是重入锁？</h2><ul><li>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</li></ul><h2 id="什么是自旋"><a href="#什么是自旋" class="headerlink" title="什么是自旋"></a>什么是自旋</h2><ul><li>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</li><li>忙循环：就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</li></ul><h2 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h2><ul><li><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p></li><li><p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p></li><li><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，轻量级锁就会升级为重量级锁；</p></li><li><p>重量级锁是synchronized ，是 Java 虚拟机中最为基础的锁实现。在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</p><p>  锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p></li></ul><h2 id="线程-B-怎么知道线程-A-修改了变量"><a href="#线程-B-怎么知道线程-A-修改了变量" class="headerlink" title="线程 B 怎么知道线程 A 修改了变量"></a>线程 B 怎么知道线程 A 修改了变量</h2><ul><li>volatile 修饰变量</li><li>synchronized 修饰修改变量的方法</li><li>wait/notify</li><li>while 轮询</li></ul><h2 id="当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><a href="#当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？" class="headerlink" title="当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？"></a>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</h2><ul><li>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</li></ul><h2 id="synchronized、volatile、CAS-比较"><a href="#synchronized、volatile、CAS-比较" class="headerlink" title="synchronized、volatile、CAS 比较"></a>synchronized、volatile、CAS 比较</h2><ul><li>synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。</li><li>volatile 提供多线程共享变量可见性和禁止指令重排序优化。</li><li>CAS 是基于冲突检测的乐观锁（非阻塞）</li></ul><h2 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h2><ul><li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</li><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h2 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h2><ul><li>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</li><li>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在Java 6 中对 synchronized 进行了非常多的改进。</li><li>相同点：两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</li><li>主要区别如下：<ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word</li></ul></li><li>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：<ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul></li></ul><h2 id="volatile-关键字的作用"><a href="#volatile-关键字的作用" class="headerlink" title="volatile 关键字的作用"></a>volatile 关键字的作用</h2><ul><li>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happensbefore 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值。</li><li>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见<br>  java.util.concurrent.atomic 包下的类，比如 AtomicInteger。</li><li>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</li></ul><h2 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h2><ul><li>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</li></ul><h2 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h2><ul><li>volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。</li><li>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li></ul><h2 id="volatile-能使得一个非原子操作变成原子操作吗？"><a href="#volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h2><ul><li><p>关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p></li><li><p>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。</p><p>  所以从Oracle Java Spec里面可以看到：</p><ul><li>对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。</li><li>如果使用volatile修饰long和double，那么其读写都是原子操作</li><li>对于64位的引用地址的读写，都是原子操作</li><li>在实现JVM时，可以自由选择是否把读写long和double作为原子操作</li><li>推荐JVM实现为原子操作</li></ul></li></ul><h2 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h2><ul><li>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</li><li>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</li></ul><p>区别：</p><ul><li>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li></ul><h2 id="final不可变对象，它对写并发应用有什么帮助？"><a href="#final不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="final不可变对象，它对写并发应用有什么帮助？"></a>final不可变对象，它对写并发应用有什么帮助？</h2><ul><li><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</p></li><li><p>不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger 和 BigDecimal 等。</p></li><li><p>只有满足如下状态，一个对象才是不可变的；</p><ul><li>它的状态不能在创建后再被修改；</li><li>所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。</li></ul><p>  不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p></li></ul><h2 id="Lock-接口和synchronized-对比同步它有什么优势？"><a href="#Lock-接口和synchronized-对比同步它有什么优势？" class="headerlink" title="Lock 接口和synchronized 对比同步它有什么优势？"></a>Lock 接口和synchronized 对比同步它有什么优势？</h2><ul><li>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</li><li>它的优势有：<ol><li>可以使锁更公平</li><li>可以使线程在等待锁的时候响应中断</li><li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li><li>可以在不同的范围，以不同的顺序获取和释放锁</li></ol></li><li>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</li></ul><h2 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h2><ul><li>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</li><li>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</li></ul><h2 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h2><ul><li><p>CAS 是 compare and swap 的缩写，即我们所说的比较交换。</p></li><li><p>cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。</p></li><li><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p><p>  java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的(AtomicInteger,AtomicBoolean,AtomicLong)</p></li></ul><h2 id="CAS-的会产生什么问题？"><a href="#CAS-的会产生什么问题？" class="headerlink" title="CAS 的会产生什么问题？"></a>CAS 的会产生什么问题？</h2><ul><li><p>ABA 问题：</p><p>  比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p></li><li><p>循环时间长开销大：</p><p>  对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p></li><li><p>只能保证一个共享变量的原子操作：</p><p>  当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p></li></ul><h2 id="什么是原子类"><a href="#什么是原子类" class="headerlink" title="什么是原子类"></a>什么是原子类</h2><ul><li>java.util.concurrent.atomic包：是原子类的小工具包，支持在单个变量上解除锁的线程安全编程原子变量类相当于一种泛化的 volatile 变量，能够支持原子的和有条件的读-改-写操作。</li><li>比如：AtomicInteger 表示一个int类型的值，并提供了 get 和 set 方法，这些 Volatile 类型的int变量在读取和写入上有着相同的内存语义。它还提供了一个原子的 compareAndSet 方法（如果该方法成功执行，那么将实现与读取/写入一个 volatile 变量相同的内存效果），以及原子的添加、递增和递减等方法。AtomicInteger 表面上非常像一个扩展的 Counter 类，但在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。</li></ul><h2 id="原子类的常用类"><a href="#原子类的常用类" class="headerlink" title="原子类的常用类"></a>原子类的常用类</h2><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicReference</li></ul><h2 id="说一下-Atomic的原理？"><a href="#说一下-Atomic的原理？" class="headerlink" title="说一下 Atomic的原理？"></a>说一下 Atomic的原理？</h2><ul><li>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</li></ul><h2 id="死锁与活锁的区别，死锁与饥饿的区别？"><a href="#死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别？"></a>死锁与活锁的区别，死锁与饥饿的区别？</h2><ul><li><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p></li><li><p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p></li><li><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p></li><li><p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><p>  Java 中导致饥饿的原因：</p><ol><li>高优先级线程吞噬所有的低优先级线程的 CPU 时间。</li><li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该<br> 同步块进行访问。</li><li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其<br> 他线程总是被持续地获得唤醒。</li></ol></li></ul><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h2><ul><li>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。<ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用</li></ul></li></ul><h2 id="线程池作用？"><a href="#线程池作用？" class="headerlink" title="线程池作用？"></a>线程池作用？</h2><ul><li>线程池是为突然大量爆发的线程设计的，通过有限的几个固定线程为大量的操作服务，减少了创建和销毁线程所需的时间，从而提高效率。</li><li>如果一个线程所需要执行的时间非常长的话，就没必要用线程池了(不是不能作长时间操作，而是不宜。本来降低线程创建和销毁，结果你那么久我还不好控制还不如直接创建线程)，况且我们还不能控制线程池中线程的开始、挂起、和中止。</li></ul><h2 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h2><ul><li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li><li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</li></ul><h2 id="什么是ThreadPoolExecutor？"><a href="#什么是ThreadPoolExecutor？" class="headerlink" title="什么是ThreadPoolExecutor？"></a>什么是ThreadPoolExecutor？</h2><ul><li><p>ThreadPoolExecutor就是线程池</p><p>  ThreadPoolExecutor其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）</p><p>  构造参数参数介绍：</p><ul><li>corePoolSize 核心线程数量</li><li>maximumPoolSize 最大线程数量</li><li>keepAliveTime 线程保持时间，N个时间单位</li><li>unit 时间单位（比如秒，分）</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂</li><li>handler 线程池拒绝策略</li></ul></li></ul><h2 id="什么是Executors？"><a href="#什么是Executors？" class="headerlink" title="什么是Executors？"></a>什么是Executors？</h2><ul><li><p>Executors框架实现的就是线程池的功能。</p><p>  Executors工厂类中提供的newCachedThreadPool、newFixedThreadPool 、newScheduledThreadPool 、newSingleThreadExecutor 等方法其实也只是ThreadPoolExecutor的构造函数参数不同而已。通过传入不同的参数，就可以构造出适用于不同应用场景下的线程池，</p></li></ul><h2 id="线程池四种创建方式？"><a href="#线程池四种创建方式？" class="headerlink" title="线程池四种创建方式？"></a>线程池四种创建方式？</h2><ul><li>Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：<ol><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol></li></ul><h2 id="在-Java-中-Executor-和-Executors-的区别？"><a href="#在-Java-中-Executor-和-Executors-的区别？" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别？"></a>在 Java 中 Executor 和 Executors 的区别？</h2><ul><li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li><li>Executor 接口对象能执行我们的线程任务。</li><li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li><li>使用 ThreadPoolExecutor 可以创建自定义线程池。</li></ul><h2 id="四种构建线程池的区别及特点？"><a href="#四种构建线程池的区别及特点？" class="headerlink" title="四种构建线程池的区别及特点？"></a>四种构建线程池的区别及特点？</h2><ul><li><p>newCachedThreadPool</p><ul><li><p>特点：newCachedThreadPool创建一个可缓存线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时， 它可以灵活的添加新的线程，而不会对池的长度作任何限制</p></li><li><p>缺点：他虽然可以无线的新建线程，但是容易造成堆外内存溢出，因为它的最大值是在初始化的时候设置为 Integer.MAX_VALUE，一般来说机器都没那么大内存给它不断使用。当然知道可能出问题的点，就可以去重写一个方法限制一下这个最大值</p></li><li><p>总结：线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p></li><li><p>代码示例：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNewCachedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建无限大小线程池，由jvm自动回收</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(</span><br><span class="line">                        Thread.currentThread().getName() +</span><br><span class="line">                                       <span class="string">&quot;,i==&quot;</span> + temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>newFixedThreadPool</p><ul><li><p>特点：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置。</p></li><li><p>缺点：线程数量是固定的，但是阻塞队列是无界队列。如果有很多请求积压，阻塞队列越来越长，容易导致OOM（超出内存空间）</p></li><li><p>总结：请求的挤压一定要和分配的线程池大小匹配，定线程池的大小最好根据系统资源进行设置。<br>  如Runtime.getRuntime().availableProcessors()方法是查看电脑CPU核心数量）</p></li><li><p>代码示例：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNewFixedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService newFixedThreadPool =</span><br><span class="line">            Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">                        newFixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                System.out.println(</span><br><span class="line"> Thread.currentThread().getName() +<span class="string">&quot;,i==&quot;</span> + temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>newScheduledThreadPool</p><ul><li><p>特点：创建一个固定长度的线程池，而且支持定时的以及周期性的任务执行，类似于Timer（Timer是Java的一个定时器类）</p></li><li><p>缺点：由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务（比如：一个任务出错，以后的任务都无法继续）。</p></li><li><p>代码示例：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNewScheduledThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义线程池大小为3</span></span><br><span class="line">        ScheduledExecutorService newScheduledThreadPool =</span><br><span class="line">            Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            newScheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;i:&quot;</span> + temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">3</span>, TimeUnit.SECONDS);<span class="comment">//这里表示延迟3秒执行。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>newSingleThreadExecutor</p><ul><li><p>特点：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，他必须保证前一项任务执行完毕才能执行后一项。保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p></li><li><p>缺点：缺点的话，很明显，他是单线程的，高并发业务下有点无力</p></li><li><p>总结：保证所有任务按照指定顺序执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它</p></li><li><p>代码示例：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNewSingleThreadExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService newSingleThreadExecutor =</span><br><span class="line">        Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            newSingleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(</span><br><span class="line">                        Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">&quot;index:&quot;</span> + index);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h2><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><h2 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit() 和 execute() 方法有什么区别？"></a>线程池中 submit() 和 execute() 方法有什么区别？</h2><ul><li>相同点：<ul><li>相同点就是都可以开启线程执行池中的任务。</li></ul></li><li>不同点：</li><li>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和Callable 类型的任务。</li><li>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</li><li>异常处理：submit()方便Exception处理</li></ul><h2 id="什么是线程组，为什么在-Java-中不推荐使用？"><a href="#什么是线程组，为什么在-Java-中不推荐使用？" class="headerlink" title="什么是线程组，为什么在 Java 中不推荐使用？"></a>什么是线程组，为什么在 Java 中不推荐使用？</h2><ul><li>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</li><li>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</li><li>为什么不推荐使用线程组？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。</li></ul><h2 id="ThreadPoolExecutor饱和策略有哪些？"><a href="#ThreadPoolExecutor饱和策略有哪些？" class="headerlink" title="ThreadPoolExecutor饱和策略有哪些？"></a>ThreadPoolExecutor饱和策略有哪些？</h2><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:</p><ul><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</li></ul><h2 id="如何自定义线程线程池"><a href="#如何自定义线程线程池" class="headerlink" title="如何自定义线程线程池?"></a>如何自定义线程线程池?</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">60L</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            TaskThred t1 = <span class="keyword">new</span> TaskThred(<span class="string">&quot;任务&quot;</span> + i);</span><br><span class="line">            <span class="comment">//executor.execute(t1);是执行线程方法</span></span><br><span class="line">            executor.execute(t1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//executor.shutdown()不再接受新的任务，并且等待之前提交的任务都执行完再关闭，阻塞队列中的任务不会再执行。</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TaskThred</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskThred</span><span class="params">(String taskName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + taskName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的执行原理？"><a href="#线程池的执行原理？" class="headerlink" title="线程池的执行原理？"></a>线程池的执行原理？</h2><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20210321172503.png"></p><ul><li>提交一个任务到线程池中，线程池的处理流程如下：<ol><li>判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没<br> 有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个<br> 流程。</li><li>线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队<br> 列里。如果工作队列满了，则进入下个流程。</li><li>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任<br> 务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol></li></ul><h2 id="如何合理分配线程池大小"><a href="#如何合理分配线程池大小" class="headerlink" title="如何合理分配线程池大小?"></a>如何合理分配线程池大小?</h2><ul><li>要合理的分配线程池的大小要根据实际情况来定，简单的来说的话就是根据CPU密集和IO密集来分配</li></ul><p><strong>什么是CPU密集</strong></p><ul><li>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。</li><li>CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程)，而在单核CPU上，无论你开几个模拟的多线程，该任务都不可能得到加速，因为CPU总的运算能力就那样。</li></ul><p><strong>什么是IO密集</strong></p><ul><li>IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行，即时在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</li></ul><p><strong>分配CPU和IO密集：</strong></p><ol><li>CPU密集型时，任务可以少配置线程数，大概和机器的cpu核数相当，这样可以使得每个线程都在执行任务</li><li>IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数</li></ol><p><strong>精确来说的话的话：</strong></p><ul><li>从以下几个角度分析任务的特性：<ul><li>任务的性质：CPU密集型任务、IO密集型任务、混合型任务。</li><li>任务的优先级：高、中、低。</li><li>任务的执行时间：长、中、短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接等。</li></ul></li></ul><p><strong>可以得出一个结论：</strong></p><ul><li>线程等待时间比CPU执行时间比例越高，需要越多线程。</li><li>线程CPU执行时间比等待时间比例越高，需要越少线程。</li></ul><h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="你经常使用什么并发容器，为什么？"><a href="#你经常使用什么并发容器，为什么？" class="headerlink" title="你经常使用什么并发容器，为什么？"></a>你经常使用什么并发容器，为什么？</h2><ul><li><p>Vector、ConcurrentHashMap、HasTable</p></li><li><p>一般软件开发中容器用的最多的就是HashMap、ArrayList，LinkedList ，等等</p><p>  但是在多线程开发中就不能乱用容器，如果使用了未加锁（非同步）的的集合，你的数据就会非常的混乱。由此在多线程开发中需要使用的容器必须是加锁（同步）的容器。</p></li></ul><h2 id="什么是Vector"><a href="#什么是Vector" class="headerlink" title="什么是Vector"></a>什么是Vector</h2><ul><li><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多</p><p>  （ ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。 ）</p></li></ul><h2 id="ArrayList和Vector有什么不同之处？"><a href="#ArrayList和Vector有什么不同之处？" class="headerlink" title="ArrayList和Vector有什么不同之处？"></a>ArrayList和Vector有什么不同之处？</h2><ul><li>Vector方法带上了synchronized关键字，是线程同步的</li></ul><h2 id="为什么HashTable是线程安全的？"><a href="#为什么HashTable是线程安全的？" class="headerlink" title="为什么HashTable是线程安全的？"></a>为什么HashTable是线程安全的？</h2><ul><li>因为HasTable的内部方法都被synchronized修饰了，所以是线程安全的。其他的都和HashMap一样</li></ul><h2 id="用过ConcurrentHashMap，讲一下他和HashTable的不同之处？"><a href="#用过ConcurrentHashMap，讲一下他和HashTable的不同之处？" class="headerlink" title="用过ConcurrentHashMap，讲一下他和HashTable的不同之处？"></a>用过ConcurrentHashMap，讲一下他和HashTable的不同之处？</h2><ul><li>ConcurrentHashMap是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</li><li>总结：<ol><li>HashTable就是实现了HashMap加上了synchronized，而ConcurrentHashMap底层采用分段的数组+链表实现，线程安全</li><li>ConcurrentHashMap通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li><li>并且读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。</li><li>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术</li><li>扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容</li></ol></li></ul><h2 id="Java-中-ConcurrentHashMap-的并发度是什么？"><a href="#Java-中-ConcurrentHashMap-的并发度是什么？" class="headerlink" title="Java 中 ConcurrentHashMap 的并发度是什么？"></a>Java 中 ConcurrentHashMap 的并发度是什么？</h2><ul><li>ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。</li><li>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现,利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</li></ul><h2 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h2><ul><li>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList 等方法返回的容器。可以通过查看 Vector，<br>  Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。</li><li>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。</li></ul><h2 id="Java-中的同步集合与并发集合有什么区别？"><a href="#Java-中的同步集合与并发集合有什么区别？" class="headerlink" title="Java 中的同步集合与并发集合有什么区别？"></a>Java 中的同步集合与并发集合有什么区别？</h2><ul><li>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</li></ul><h2 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h2><ul><li>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。</li><li>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。</li><li>ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。</li><li>这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。</li><li>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当iterator 被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时 new新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</li></ul><h2 id="CopyOnWriteArrayList-是什么？使用场景？"><a href="#CopyOnWriteArrayList-是什么？使用场景？" class="headerlink" title="CopyOnWriteArrayList 是什么？使用场景？"></a>CopyOnWriteArrayList 是什么？使用场景？</h2><ul><li><p>CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。</p></li><li><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p></li><li><p>合适读多写少的场景</p></li></ul><h2 id="CopyOnWriteArrayList-的缺点"><a href="#CopyOnWriteArrayList-的缺点" class="headerlink" title="CopyOnWriteArrayList 的缺点?"></a>CopyOnWriteArrayList 的缺点?</h2><ul><li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc 或者 full gc。</li><li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li><li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点<br>  多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li></ul><h2 id="CopyOnWriteArrayList-的设计思想"><a href="#CopyOnWriteArrayList-的设计思想" class="headerlink" title="CopyOnWriteArrayList 的设计思想?"></a>CopyOnWriteArrayList 的设计思想?</h2><ul><li>读写分离，读和写分开</li><li>最终一致性</li><li>使用另外开辟空间的思路，来解决并发冲突</li></ul><h1 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h1><h2 id="什么是并发队列："><a href="#什么是并发队列：" class="headerlink" title="什么是并发队列："></a>什么是并发队列：</h2><ul><li>消息队列很多人知道：消息队列是分布式系统中重要的组件，是系统与系统直接的通信</li><li>并发队列是什么：并发队列多个线程以有次序共享数据的重要组件</li></ul><h2 id="并发队列和并发集合的区别："><a href="#并发队列和并发集合的区别：" class="headerlink" title="并发队列和并发集合的区别："></a>并发队列和并发集合的区别：</h2><p>那就有可能要说了，我们并发集合不是也可以实现多线程之间的数据共享吗，其实也是有区别的：</p><ul><li>队列遵循“先进先出”的规则，可以想象成排队检票，队列一般用来解决大数据量采集处理和显示的。</li><li>并发集合就是在多个线程中共享数据的</li></ul><h2 id="怎么判断并发队列是阻塞队列还是非阻塞队列"><a href="#怎么判断并发队列是阻塞队列还是非阻塞队列" class="headerlink" title="怎么判断并发队列是阻塞队列还是非阻塞队列"></a>怎么判断并发队列是阻塞队列还是非阻塞队列</h2><ul><li>在并发队列上JDK提供了Queue接口，一个是以Queue接口下的BlockingQueue接口为代表的阻塞队列，另一个是高性能（无堵塞）队列。</li></ul><h2 id="阻塞队列和非阻塞队列区别"><a href="#阻塞队列和非阻塞队列区别" class="headerlink" title="阻塞队列和非阻塞队列区别"></a>阻塞队列和非阻塞队列区别</h2><ul><li>当队列阻塞队列为空的时，从队列中获取元素的操作将会被阻塞。</li><li>或者当阻塞队列是满时，往队列里添加元素的操作会被阻塞。</li><li>或者试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。</li><li>试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来</li></ul><h2 id="常用并发列队的介绍："><a href="#常用并发列队的介绍：" class="headerlink" title="常用并发列队的介绍："></a>常用并发列队的介绍：</h2><ul><li><p>非堵塞队列：</p><ol><li><p>ArrayDeque, （数组双端队列）</p><p> ArrayDeque （非堵塞队列）是JDK容器中的一个双端队列实现，内部使用数组进行元素存储，不允许存储null值，可以高效的进行元素查找和尾部插入取出，是用作队列、双端队列、栈的绝佳选择，性能比LinkedList还要好。</p></li><li><p>PriorityQueue, （优先级队列）</p><p> PriorityQueue （非堵塞队列） 一个基于优先级的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。该队列不允许使用 null 元素也不允许插入不可比较的对象</p></li><li><p>ConcurrentLinkedQueue, （基于链表的并发队列）</p><p> ConcurrentLinkedQueue （非堵塞队列）: 是一个适用于高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能。ConcurrentLinkedQueue的性能要好于BlockingQueue接口，它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。该队列不允许null元素。</p></li></ol></li><li><p>堵塞队列：</p><ol><li><p>DelayQueue, （基于时间优先级的队列，延期阻塞队列）</p><p> DelayQueue是一个没有边界BlockingQueue实现，加入其中的元素必需实现Delayed接口。当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间越晚。</p></li><li><p>ArrayBlockingQueue, （基于数组的并发阻塞队列）</p><p> ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。ArrayBlockingQueue是以先进先出的方式存储数据</p></li><li><p>LinkedBlockingQueue, （基于链表的FIFO阻塞队列）</p><p> LinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。</p></li><li><p>LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）</p><p> LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</p><p> 相比于其他阻塞队列，LinkedBlockingDeque多了addFirst、addLast、peekFirst、peekLast等方法，以first结尾的方法，表示插入、获取获移除双端队列的第一个元素。以last结尾的方法，表示插入、获取获移除双端队列的最后一个元素。 </p><p> LinkedBlockingDeque是可选容量的，在初始化时可以设置容量防止其过度膨胀，如果不设置，默认容量大小为Integer.MAX_VALUE。</p></li><li><p>PriorityBlockingQueue, （带优先级的无界阻塞队列）</p><p> priorityBlockingQueue是一个无界队列，它没有限制，在内存允许的情况下可以无限添加元素；它又是具有优先级的队列，是通过构造函数传入的对象来判断，传入的对象必须实现comparable接口。</p></li><li><p>SynchronousQueue （并发同步阻塞队列）</p><p> SynchronousQueue是一个内部只能包含一个元素的队列。插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。</p></li></ol></li></ul><h2 id="并发队列的常用方法"><a href="#并发队列的常用方法" class="headerlink" title="并发队列的常用方法"></a>并发队列的常用方法</h2><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>在不超出队列长度的情况下插入元素，可以立即执行，成功返回true，<br/>如果队列满了就抛出异常。</td></tr><tr><td>offer()</td><td>在不超出队列长度的情况下插入元素的时候则可以立即在队列的尾部插<br/>入指定元素,成功时返回true，如果此队列已满，则返回false。</td></tr><tr><td>put()</td><td>插入元素的时候，如果队列满了就进行等待，直到队列可用。</td></tr><tr><td>take()</td><td>从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有<br/>值，并且该方法取得了该值。</td></tr><tr><td>poll(long timeout,TimeUnit unit)</td><td>在给定的时间里，从队列中获取值，如果没有取到会抛出异常。</td></tr><tr><td>remainingCapacity()</td><td>获取队列中剩余的空间。</td></tr><tr><td>remove(Object o)</td><td>从队列中移除指定的值。</td></tr><tr><td>contains(Object o)</td><td>判断队列中是否拥有该值。</td></tr><tr><td>drainTo(Collectionc)</td><td>将队列中值，全部移除，并发设置到给定的集合中。</td></tr></tbody></table><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="常用的并发工具类有哪些？"><a href="#常用的并发工具类有哪些？" class="headerlink" title="常用的并发工具类有哪些？"></a>常用的并发工具类有哪些？</h2><ul><li><p>CountDownLatch</p><p>  CountDownLatch 类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他3个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p></li><li><p>CyclicBarrier (回环栅栏) CyclicBarrier它的作用就是会让所有线程都等待完成后才会继续下一步行动。</p><p>  CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。</p><p>  CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。</p></li><li><p>Semaphore (信号量) Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量（允许自定义多少线程同时访问）。就这一点而言，单纯的synchronized 关键字是实现不了的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-集合框架</title>
      <link href="/2021/03/20/%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/"/>
      <url>/2021/03/20/%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合容器概述"><a href="#Java集合容器概述" class="headerlink" title="Java集合容器概述"></a>Java集合容器概述</h1><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><ul><li>集合就是一个放数据的容器，准确的说是放数据对象引用的容器。</li><li>集合类存放的都是对象的引用，而不是对象的本身。</li><li>集合类型主要有3种：set(集）、list(列表）和map(映射)。</li></ul><h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><p>主要有如下两点：==存储对象，长度可变==</p><ul><li>集合用于存储对象的容器，对象是用来封装数据，对象多了也需要存储集中式管理。</li><li>和数组对比对象的大小不确定。因为集合是可变长度的。数组需要提前定义大小。</li></ul><h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul><li><p>数组是固定长度的；集合可变长度的。</p></li><li><p>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</p></li><li><p>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</p></li></ul><h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h2><ul><li>容量自增长。</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量。</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ul><h2 id="常见的集合类有哪些"><a href="#常见的集合类有哪些" class="headerlink" title="常见的集合类有哪些"></a>常见的集合类有哪些</h2><p>Map接口和Collection接口是所有集合框架的父接口：</p><ul><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ul><h2 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616168692363.png"></p><ul><li>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</li><li>Collection集合主要有List和Set两大接口<ul><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及TreeSet。</li></ul></li><li>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。<ul><li>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li></ul></li></ul><h2 id="框架底层数据结构"><a href="#框架底层数据结构" class="headerlink" title="框架底层数据结构"></a>框架底层数据结构</h2><ul><li>Collection<ol><li>List<ul><li>Arraylist： Object数组</li><li>Vector： Object数组</li><li>LinkedList： 双向循环链表</li></ul></li><li>Set<ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素。</li><li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)。</li></ul></li></ol></li><li>Map<ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul></li></ul><h2 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h2><ul><li>Vector：就比Arraylist多了个 synchronized （线程安全），因为效率较低，现在已经不太建议使用。</li><li>Hashtable：就比hashMap多了个synchronized (线程安全)，不建议使用。</li><li>ConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）</li></ul><h2 id="Java集合的快速失败机制-fail-fast"><a href="#Java集合的快速失败机制-fail-fast" class="headerlink" title="Java集合的快速失败机制(fail-fast)"></a>Java集合的快速失败机制(fail-fast)</h2><ul><li>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast 机制。</li><li>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li><li>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>解决办法：<ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol></li></ul><h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？"></a>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</h2><ul><li>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。</li></ul><h2 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h2><ul><li><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只 读 集 合 ， 这 样 改 变 集 合 的 任 何 操 作 都 会 抛 出 Java. lang.UnsupportedOperationException 异常。</p></li><li><p>示例代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);</span><br><span class="line">clist.add(<span class="string">&quot;y&quot;</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System.out.println(list. size());</span><br></pre></td></tr></table></figure></li></ul><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h3 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h3><ul><li>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</li></ul><h3 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h3><ul><li><p>Iterator 使用代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">String obj = it.next();</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p></li></ul><h3 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h3><ul><li><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    *<span class="comment">// do something*</span></span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一种最常见的错误代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p></li></ul><h3 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h3><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h3 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List遍历的最佳实践是什么？</h3><ul><li>遍历方式有以下几种：<ul><li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li><li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li><li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li></ul></li><li>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。<ul><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li><li>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或foreach 遍历。</li></ul></li></ul><h3 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h3><ul><li>ArrayList的优点如下：<ul><li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li><li>ArrayList 在顺序添加一个元素的时候非常方便。</li></ul></li><li>ArrayList 的缺点如下：<ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li><li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li></ul></li><li>ArrayList 比较适合顺序添加、随机访问的场景。</li></ul><h3 id="如何实现数组和-List-之间的转换？转换完还能继续增加元素吗？"><a href="#如何实现数组和-List-之间的转换？转换完还能继续增加元素吗？" class="headerlink" title="如何实现数组和 List 之间的转换？转换完还能继续增加元素吗？"></a>如何实现数组和 List 之间的转换？转换完还能继续增加元素吗？</h3><ul><li><p>数组转 List：使用 Arrays.asList(array) 进行转换。</p><p>  List 转数组：使用 List 自带的 toArray() 方法。</p><p>  代码示例：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list. add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">list. add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">list. toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure></li><li><p>不能增加元素，会报<code>Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</code></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList(E[] array) &#123;</span><br><span class="line">    a = Objects.requireNonNull(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于返回的ArrayList并不是java.util.ArrayList类，没有重写add()方法，所以不能新增</p></li></ul><h3 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h3><ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li><li>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</li></ul><h3 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h3><ul><li>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合<ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul></li><li>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</li><li>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</li></ul><h3 id="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList 的存储性能和特性？"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList 的存储性能和特性？</h3><ul><li>ArrayList和Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li><li>Vector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。</li><li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。</li></ul><h3 id="多线程场景下如何使用-ArrayList"><a href="#多线程场景下如何使用-ArrayList" class="headerlink" title="多线程场景下如何使用 ArrayList"></a>多线程场景下如何使用 ArrayList</h3><ul><li>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">synchronizedList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h3><ul><li><p>ArrayList 中的数组定义如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></li><li><p>再看一下 ArrayList 的定义：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></li><li><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">java.io.IOException</span>&#123;</span><br><span class="line">*<span class="comment">// Write out element count, and any hidden stuff*</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">s.defaultWriteObject();</span><br><span class="line">    *<span class="comment">// Write out array length*</span></span><br><span class="line">    s.writeInt(elementData.length);</span><br><span class="line">    *<span class="comment">// Write out all elements in the proper order.*</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    s.writeObject(elementData[i]);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p></li></ul><h3 id="ArrayList-默认大小是多少，是如何扩容的？"><a href="#ArrayList-默认大小是多少，是如何扩容的？" class="headerlink" title="ArrayList 默认大小是多少，是如何扩容的？"></a>ArrayList 默认大小是多少，是如何扩容的？</h3><ul><li>Jdk1.7 之前 ArrayList 默认大小是 10，JDK1.7 之后是 0，JDK 差异，每次约按 1.5 倍扩容。</li></ul><h3 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h3><ul><li>List , Set 都是继承自Collection 接口</li><li>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及<br>  TreeSet。</li><li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li><li>Set和List对比<ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li><li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起<br>  其他元素位置改变</li></ul></li></ul><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h3 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h3><ul><li>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</li></ul><h3 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h3><ul><li><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p></li><li><p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p></li><li><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p></li><li><p>以下是HashSet 部分源码</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>hashCode（）与equals（）的相关规定：</strong></p><ol><li><p>如果两个对象相等，则hashcode一定也是相同的，hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值</p></li><li><p>两个对象相等,对两个equals方法返回true</p></li><li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p></li><li><p>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</p></li><li><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p></li></ol><p>  <strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li></ol></li></ul><ol start="2"><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li></ol><h3 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h3><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现了Set接口</td></tr><tr><td>存储键值对</td><td>存储对象</td></tr><tr><td>调用put（）向map中添加元素</td><td>调用add（）方法向Set中添加元素</td></tr><tr><td>HashMap使用键Key计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h2 id="什么是Hash算法"><a href="#什么是Hash算法" class="headerlink" title="什么是Hash算法"></a>什么是Hash算法</h2><ul><li>哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</li></ul><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><ul><li>链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能。</li><li>链表大致分为单链表和双向链表<ol><li>单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针</li><li>双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针</li></ol></li><li>链表的优点<ul><li>插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加、删除元素）</li><li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）</li><li>大小没有固定，拓展很灵活。</li></ul></li><li>链表的缺点<ul><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ul></li></ul><h2 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h2><ul><li><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></li><li><p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。</p><p>  HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p></li><li><p>HashMap 基于 Hash 算法实现的</p><ol><li>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li><li>存储时，如果出现hash值相同的key，此时有两种情况。</li></ol><pre><code>(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</code></pre><ol start="3"><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li><li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li></ol><p>  ==需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过8个之后，并且数组长度超过64，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)==</p></li></ul><h2 id="HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h2><ul><li>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。</li></ul><p><strong>HashMap JDK1.8之前</strong></p><ul><li>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li></ul><p><strong>HashMap JDK1.8之后</strong></p><ul><li>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li></ul><p><strong>JDK1.7 VS JDK1.8 比较</strong></p><ul><li>JDK1.8主要解决或优化了一下问题：<ol><li>resize 扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li><li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol></li></ul><table><thead><tr><th>不同</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>初始化方式</td><td>单独函数： inflateTable()</td><td>直接集成到了扩容函数 resize() 中</td></tr><tr><td>hash值<br />计算方式</td><td>扰动处理 = <br />9次扰动 = 4次位运算 + 5次异或运算</td><td>扰动处理 = <br />2次扰动 = 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据的规则</td><td>无冲突时，存放数组；<br />冲突时，存放链表</td><td>无冲突时，存放数组；<br />冲突 &amp; 链表长度 &lt;8：存放单链表；<br />冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr><tr><td>插入数据方式</td><td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td><td>尾插法<br />（直接插入到链表尾部/红黑树）</td></tr><tr><td>扩容后存储位置的计算方式</td><td>全部按照原来方法进行计算<br/>（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>按照扩容后的规律计算<br />（即扩容后的位置=原位置 or 原位置 + 旧容量）</td></tr></tbody></table><h2 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h2><p><strong>说到红黑树先讲什么是二叉树</strong></p><p>​    二叉树简单来说就是 每一个节上可以关联俩个子节点</p><p><strong>红黑树</strong></p><ul><li>红黑树是一种特殊的二叉查找树。红黑树的每个结点上都有存储位表示结点的颜色，可以是红(Red)或黑(Black)。</li><li>红黑树的每个结点是黑色或者红色。当是不管怎么样他的根结点是黑色。每个叶子结点（叶子结点代表终结、结尾的节点）也是黑色 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]。</li><li>如果一个结点是红色的，则它的子结点必须是黑色的。</li><li>每个结点到叶子结点NIL所经过的黑色结点的个数一样的。[确保没有一条路径会比其他路径长出俩倍，所以红黑树是相对接近平衡的二叉树的！]</li><li>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的结点之后，红黑树的结构就发生了变化，可能不满足上面三条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转和变色，可以使这颗树重新成为红黑树。简单点说，旋转和变色的目的是让树保持红黑树的特性。</li></ul><h2 id="HashMap的put-方法的具体流程？"><a href="#HashMap的put-方法的具体流程？" class="headerlink" title="HashMap的put()方法的具体流程？"></a>HashMap的put()方法的具体流程？</h2><ul><li><p>当我们put的时候，首先计算 key 的 hash 值，这里调用了 hash 方法， hash 方法实际是让<br>  key.hashCode() 与 key.hashCode()&gt;&gt;&gt;16 进行异或操作，高16bit补0，一个数和0异或不变，<br>  所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标 index = (table.length - 1) &amp;<br>  hash ，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p></li><li><p>putVal()方法执行流程图如下</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616205167185.png"></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key 键经过扰动的哈希值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key 键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value the value to put 值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value 如果要放入的位置为空才放入，不进行替换</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//tab表示当前HashMap的table，p是table的旧的元素，n是散列表的长度，i是路由寻址结果</span></span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//如果table为空，调用resize()方法，初始化table，在第一次用到的时候初始化</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//1.如果要放入的位置刚好为null就直接放入，寻址算法：用与运算替代取模提升性能</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//e 存放table中需要修改的元素，k也是需要修改元素的key</span></span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//2.当前位置还是数组，放入的位置和你要存的值，键相同，需要进行覆盖操作，将旧值p临时存放到e中</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="comment">//3.如果当前位置已经树化了</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="comment">//4.当前位置成为链表</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//循环查找元素</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">//4.1 查到最后一个元素了也没有找到匹配的</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//最后一个元素再指向新的元素，尾插法，新元素成为末尾节点</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//循环值从0开始，所以判断值是否达到树化阈值（条件之一）</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//4.2 找到key一致的元素，需要进行覆盖，break结束循环，此时e等于需要替换的元素</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="comment">//4.3 查找过程中，没找到对应的也没循环结束。把下一个元素赋给p，继续查找</span></span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果找到了需要与插入的元素 key一致的，也就是位置一致的元素</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">           <span class="comment">//存放旧元素的值</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="comment">//先判断参数，不为空是否允许修改</span></span><br><span class="line">               <span class="comment">//如果不为空不允许修改，那么取反就是false，那就看后面的元素值是不是null，空的化就可以修改，妙啊~</span></span><br><span class="line">               <span class="comment">//如果不为空允许修改，那么取反就是true，那就不管空不空都会修改</span></span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               <span class="comment">//为LinkedHashMap预留</span></span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="comment">//返回旧值</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//table结构修改次数+1,不包括值替换</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">//如果元素大小超过阈值时调用resize()方法</span></span><br><span class="line">       <span class="comment">//threshold在第一次put的时候调用过resize()已经计算过</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="comment">//没有旧值返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h2><ol><li><p>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p></li><li><p>每次扩展的时候，都是扩展2倍；</p></li><li><p>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p><p> 在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p></li></ol><h2 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h2><ul><li><p><strong>什么是哈希？</strong></p><p>  Hash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</p></li><li><p><strong>什么是哈希冲突？</strong></p><p>  当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p></li><li><p><strong>HashMap的数据结构</strong></p><ul><li><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。</p><ul><li>数组的特点是：寻址容易，插入和删除困难；</li><li>链表的特点是：寻址困难，但插入和删除容易；</li></ul></li><li><p>所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用俩种方式：链地址法和开放地址法可以解决哈希冲突：</p></li><li><p>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；<br>  开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</p></li><li><p>但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 （即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</p></li></ul></li><li><p>hash()函数</p><ul><li><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p></li></ul></li><li><p>总结</p><ul><li>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：<ul><li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li><li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li></ul></li></ul></li></ul><h2 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h2><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h2 id="为什么HashMap中String、Integer这样的包装类适合作为Key？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为Key？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为Key？"></a>为什么HashMap中String、Integer这样的包装类适合作为Key？</h2><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减<br>少Hash碰撞的几率</p><ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了 equals() 、 hashCode() 等方法，遵守了HashMap内部的规范（不清楚可以<br>  去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ul><h2 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h2><p>重写 hashCode() 和 equals() 方法</p><ol><li>重写 hashCode() 是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中<br> 排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li>重写 equals() 方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用<br> 值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</li></ol><h2 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2><ul><li><p>hashCode() 方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过 hashCode() 计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p></li><li><p><strong>那怎么解决呢？</strong></p><ul><li>HashMap自己实现了自己的 hash() 方法，通过两次扰动使得它自己的哈希值高低位自行进<br>  行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li></ul><ol start="2"><li>在保证数组长度为2的幂次方的时候，使用 hash() 运算之后的值与运算（&amp;）（数组长度 -<br>1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol></li></ul><h2 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h2><ul><li>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</li><li>这个算法应该如何设计呢？<ul><li>我们首先可能会想到采用%取余的操作来实现。</li><li>但是，重点来了：取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。</li><li>并且采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li></ul></li><li>那为什么是两次扰动呢？<ul><li>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</li></ul></li></ul><h2 id="HashMap-与-HashTable-有什么区别？"><a href="#HashMap-与-HashTable-有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h2><ol><li>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li><li>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li><li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li><li>初始容量大小和每次扩充容量大小的不同 ：<ol><li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li></ol></li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ol><h2 id="什么是TreeMap"><a href="#什么是TreeMap" class="headerlink" title="什么是TreeMap"></a>什么是TreeMap</h2><ul><li>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。</li><li>TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li><li>TreeMap是线程非同步的。</li></ul><h2 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h2><ul><li>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</li></ul><h2 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h2><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h2 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h2><ul><li><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；<br>  实现线程安全的方式：<ol><li>在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ol></li></ul></li><li><p>两者的对比图：</p><ul><li><p>HashTable:</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212819917.png"></p></li><li><p>JDK1.7的ConcurrentHashMap：</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212846206.png"></p></li><li><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212860845.png"></p></li></ul></li><li><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题使用了synchronized 关键字，所以 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p></li></ul><h2 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h2><ul><li><p><strong>JDK1.7</strong></p><ul><li><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p></li><li><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p><p>  一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p></li></ul><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212945385.png"></p><ol><li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当<br>锁的角色；</li><li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元<br>素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol></li><li><p><strong>JDK1.8</strong></p><ul><li><p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。<br>  结构如下：</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212987126.png"></p></li><li><p>插入元素过程（==需要看源码，未完待续==）：</p></li><li><p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">    K ek;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">    ((ek = e.key) == key ||</span><br><span class="line">    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">    oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;K,V&gt; pred = e;</span><br><span class="line">    <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li><li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li></ol></li></ul></li></ul><h1 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h1><h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><ul><li><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</p></li><li><p>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p></li><li><p>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList有。</p><p>  <code>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</code></p></li></ul><h2 id="Comparable-和-Comparator-接口是干什么的？列出它们的区别。"><a href="#Comparable-和-Comparator-接口是干什么的？列出它们的区别。" class="headerlink" title="Comparable 和 Comparator 接口是干什么的？列出它们的区别。"></a><strong>Comparable 和 Comparator 接口是干什么的？列出它们的区别。</strong></h2><ul><li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li><li>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</li></ul><h2 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li><li>Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li><li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li><li>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</li></ul><h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8 HashMap源码</title>
      <link href="/2021/03/20/Java-%E6%BA%90%E7%A0%81-JDK8-HashMap/"/>
      <url>/2021/03/20/Java-%E6%BA%90%E7%A0%81-JDK8-HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><p>未完待续…</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InvalidObjectException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap继承了AbstractMap类，实现了Cloneable和Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     * 初始化默认容量为16，必须为2的次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     * 最大容量为2^30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     * 默认负载因子为0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     * 链表长度树化的阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     * 重新转为链表的阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     * 树化的条件之一，当最大容量超过64</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">     * Node节点用来存储数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//哈希值</span></span><br><span class="line">        <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">        V value;<span class="comment">//值</span></span><br><span class="line">        Node&lt;K,V&gt; next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写equals()方法，判断键值是否都相等</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Static utilities -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.key==null：如果键等于null，哈希值就等于0</span></span><br><span class="line"><span class="comment">         * 2.key!=null：key的hash值与它右移16位后的值按位异或</span></span><br><span class="line"><span class="comment">         * 例如：</span></span><br><span class="line"><span class="comment">         * h = key.hashCode()  1111 1111 1111 1111 1111 0000 1110 1010</span></span><br><span class="line"><span class="comment">         *    ^</span></span><br><span class="line"><span class="comment">         * h &gt;&gt;&gt; 16            0000 0000 0000 0000 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">         * 返回值               0000 0000 0000 0000 0000 1111 0001 0101</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns x&#x27;s Class if it is of the form &quot;class C implements</span></span><br><span class="line"><span class="comment">     * Comparable&lt;C&gt;&quot;, else null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                        ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                         Comparable.class) &amp;&amp;</span><br><span class="line">                        (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns k.compareTo(x) if x matches kc (k&#x27;s screened comparable</span></span><br><span class="line"><span class="comment">     * class), else 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 返回一个大于当前Cap的值，并且这个值要是2的次方</span></span><br><span class="line"><span class="comment">     * 通过按位或的操作将最高位后面的位全变成1，然后最后返回+1，就能得到2的整数次方</span></span><br><span class="line"><span class="comment">     * 那为什么一开始要减1？</span></span><br><span class="line"><span class="comment">     * 为了防止一开始就是2的次方，比如说cap = 8;</span></span><br><span class="line"><span class="comment">     * 1000 | 0100 = 1100</span></span><br><span class="line"><span class="comment">     * 1100 | 0011 = 1111</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     * n + 1  = 16，返回的值就变成了原来的两倍</span></span><br><span class="line"><span class="comment">     * -1之后</span></span><br><span class="line"><span class="comment">     * 0111 | 0011 = 0100</span></span><br><span class="line"><span class="comment">     * 0100 | 0001 = 0101</span></span><br><span class="line"><span class="comment">     * 0101 | 0000 = 0101</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     * 0101 = 7 ;返回 7+1 = 8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假如 cap = 10,那n = 9 = 0b1001</span></span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//1001 | 0100 = 1110</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//1101 | 0011 = 1111</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1111 | 0000 = 1111</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//1111 | 0000 = 1111</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        <span class="comment">//1111 | 0000 = 1111 = 15</span></span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="comment">//如果n小于0，那最小值就是1；</span></span><br><span class="line">        <span class="comment">//如果大于最大容量，那就等于最大容量</span></span><br><span class="line">        <span class="comment">//否则就等于 n + 1，返回2的整数次方</span></span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     * 存放数据的数组，第一次使用的时候进行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">     * for keySet() and values().</span></span><br><span class="line"><span class="comment">     * 键值对缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">     * table中元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     * 结构的修改次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">    <span class="comment">// 下一次扩容的阈值</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 负载因子</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Public operations -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     * 设置初始化容量，负载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果初始容量小于0，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line"><span class="comment">//如果初始容量大于最大容量，那就等于最大容量。</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//如果负载因子小于0，或者是非数，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">//负载因子赋值</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//默认阈值等于数组容量，调用tableSizeFor方法，传入初始容量，返回大于等于容量的最小2的次方</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     * 设置初始化容量，其余都为默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     * 无参构造函数，全部为默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">     * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.putAll and Map constructor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">     * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     * 返回map中键值对的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span></span><br><span class="line"><span class="comment">     * 判断是否为空，只需要判断size的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the</span></span><br><span class="line"><span class="comment">     * specified key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   The key whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified</span></span><br><span class="line"><span class="comment">     * key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key 键经过扰动的哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value 如果要放入的位置为空才放入，不进行替换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//tab表示当前HashMap的table，p是table的旧的元素，n是散列表的长度，i是路由寻址结果</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//如果table为空，调用resize()方法，初始化table，在第一次用到的时候初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">//1.如果要放入的位置刚好为null就直接放入，寻址算法：用与运算替代取模提升性能</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//e 存放table中需要修改的元素，k也是需要修改元素的key</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//2.当前位置还是数组，放入的位置和你要存的值，键相同，需要进行覆盖操作，将旧值p临时存放到e中</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//3.如果当前位置已经树化了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//4.当前位置成为链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//循环查找元素</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//4.1 查到最后一个元素了也没有找到匹配的</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//最后一个元素再指向新的元素，尾插法，新元素成为末尾节点</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//循环值从0开始，所以判断值是否达到树化阈值（条件之一）</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4.2 找到key一致的元素，需要进行覆盖，break结束循环，此时e等于需要替换的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//4.3 查找过程中，没找到对应的也没循环结束。把下一个元素赋给p，继续查找</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了需要与插入的元素 key一致的，也就是位置一致的元素</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//存放旧元素的值</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">//先判断参数，不为空是否允许修改</span></span><br><span class="line">                <span class="comment">//如果不为空不允许修改，那么取反就是false，那就看后面的元素值是不是null，空的化就可以修改，妙啊~</span></span><br><span class="line">                <span class="comment">//如果不为空允许修改，那么取反就是true，那就不管空不空都会修改</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">//为LinkedHashMap预留</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">//返回旧值</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//table结构修改次数+1,不包括值替换</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//如果元素大小超过阈值时调用resize()方法</span></span><br><span class="line">        <span class="comment">//threshold在第一次put的时候调用过resize()已经计算过</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="comment">//没有旧值返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//扩容前的哈希表</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">//扩容前的哈希表的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//树化阈值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">//newCap：扩容后的大小</span></span><br><span class="line">        <span class="comment">//newThe：下次触发扩容的阈值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1.已经初始化过了，如果扩容前容量&gt;0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果扩容前容量大于等于最大容量</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           <span class="comment">//阈值等于最大值，无法扩容返回扩容前的哈希表</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左移一位，新容量等于扩容前容量*2</span></span><br><span class="line">            <span class="comment">//新容量小于最大值 并且 大于等于默认值16 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">//新阈值也等于原来阈值*2</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.没有初始化过，但是容量传了参数，返回了大于容量的最小2的正式次方幂</span></span><br><span class="line">        <span class="comment">//这种情况出现在初始化哈希表的时候指定了容量，这个时候的阈值等于初始化的容量</span></span><br><span class="line">        <span class="comment">//即：this.threshold = tableSizeFor(initialCapacity);</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//3.没有初始化过，也没有传参，那就是默认长度16，负载因子0.75，阈值为16*0.75</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//即1中的else if条件不满足，旧容量就小于16的情况下，</span></span><br><span class="line">        <span class="comment">//比如最开始容量是4，新容量在else if中 newCap = oldCap &lt;&lt; 1 赋值变成8，</span></span><br><span class="line">        <span class="comment">//但是newThr还是0，那么阈值还是新容量*负载因子=8*0.75= 6</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="comment">//得到新的哈希表</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">//如果原先的哈希表不为空，那将数据进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//循环遍历哈希表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//如果当前位置不为空，可能是单节点、链表或者是红黑树，赋值给临时变量e</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将当前位置清空，方便JVM进行回收</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//1.如果下一个节点为空，那表示这个节点是单节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//在新的哈希表中寻址，将数据存入</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//2.如果是红黑树的树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//3.如果是链表</span></span><br><span class="line">                    <span class="comment">//例如：容量为16的哈希表，扩容后为32</span></span><br><span class="line">                    <span class="comment">//假如说存放在最后下标为15的链表，</span></span><br><span class="line">                    <span class="comment">//根据寻址算法hash &amp; (16-1) = 1111 = 15，所以存放在下标15的位置，</span></span><br><span class="line">                    <span class="comment">//但是扩容后算法变成了hash&amp;(32-1) = hash&amp; (0001 1111),</span></span><br><span class="line">                    <span class="comment">//你并不确定倒数第五位的hash值是0还是1，</span></span><br><span class="line">                    <span class="comment">//如果是0那就是0 1111 &amp; 1 1111 = 0 1111，放在下标15的位置</span></span><br><span class="line">                    <span class="comment">//如果是1那就是1 1111 &amp; 1 1111 = 1 1111，放在下标31的位置</span></span><br><span class="line">                        <span class="comment">//低位链表：存放扩容后还在原位置的，比如上面的下标15</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//高位链表：存放扩容后在下标位置+扩容长度的，比如上面的下标31</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; </span><br><span class="line">                        <span class="comment">//存放下一个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">//取到下一个节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//如果当前节点的hash &amp; 旧的容量等于0</span></span><br><span class="line">                            <span class="comment">//低位：...0 1111 &amp; 0001 0000 = ...0 0000</span></span><br><span class="line">                            <span class="comment">//高位：...1 1111 &amp; 0001 0000 = ...1 0000</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果低位链表为空，那头节点就为当前节点</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="comment">//如果不为空，那就拼接在尾部</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                         <span class="comment">//这个位置看的云里雾里，画个图豁然开朗</span></span><br><span class="line">                         <span class="comment">//第一次循环，loHead，loTail都为空，执行loHead = e;e = e.next;</span></span><br><span class="line">                         <span class="comment">//第二次循环，loTail还是为空，执行loTail = e;e = e.next;</span></span><br><span class="line">                         <span class="comment">//第三次循环，loTail不为空，此时的e已经是第三个节点了，//而loTail指向的还是第二个节点，所以loTail.next = e;</span></span><br><span class="line">                         <span class="comment">//第二个节点指向第三个节点，再执行loTail = e;将第三个结点 // 作为尾结点，也就是始终保持loTail指向的都是尾节点</span></span><br><span class="line">                         <span class="comment">//  妙啊~</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//如果没有下一个节点了，那扩容后低位链表存放在原位置</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位链表存放在原来长度+下标位置</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">     * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">//如果数字为空或者长度小于最小树化阈值64时，进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies all of the mappings from the specified map to this map.</span></span><br><span class="line"><span class="comment">     * These mappings will replace any mappings that this map had for</span></span><br><span class="line"><span class="comment">     * any of the keys currently in the specified map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m mappings to be stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the mappings from this map.</span></span><br><span class="line"><span class="comment">     * The map will be empty after this call returns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     * specified value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     *         specified value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                        (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</span></span><br><span class="line"><span class="comment">     * the iteration are undefined.  The set supports element removal,</span></span><br><span class="line"><span class="comment">     * which removes the corresponding mapping from the map, via the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the keys contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks;</span><br><span class="line">        <span class="keyword">return</span> (ks = keySet) == <span class="keyword">null</span> ? (keySet = <span class="keyword">new</span> KeySet()) : ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Collection&#125; view of the values contained in this map.</span></span><br><span class="line"><span class="comment">     * The collection is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the collection, and vice-versa.  If the map is</span></span><br><span class="line"><span class="comment">     * modified while an iteration over the collection is in progress</span></span><br><span class="line"><span class="comment">     * (except through the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation),</span></span><br><span class="line"><span class="comment">     * the results of the iteration are undefined.  The collection</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</span></span><br><span class="line"><span class="comment">     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a view of the values contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs;</span><br><span class="line">        <span class="keyword">return</span> (vs = values) == <span class="keyword">null</span> ? (values = <span class="keyword">new</span> Values()) : vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the mappings contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span></span><br><span class="line"><span class="comment">     * iterator) the results of the iteration are undefined.  The set</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                Object key = e.getKey();</span><br><span class="line">                Object value = e.getValue();</span><br><span class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overrides of JDK8 Map extension methods</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e; V v;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">            e.value = newValue;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V v = mappingFunction.apply(key);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (oldValue = e.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = v;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, v, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">                   BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">if</span> (old.value != <span class="keyword">null</span>)</span><br><span class="line">                v = remappingFunction.apply(old.value, value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v = value;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, value, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    e.value = function.apply(e.key, e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Cloning and serialization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and</span></span><br><span class="line"><span class="comment">     * values themselves are not cloned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a shallow copy of this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">        result.reinitialize();</span><br><span class="line">        result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (table != <span class="keyword">null</span>) ? table.length :</span><br><span class="line">            (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">            DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * serialize it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</span></span><br><span class="line"><span class="comment">     *             bucket array) is emitted (int), followed by the</span></span><br><span class="line"><span class="comment">     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</span></span><br><span class="line"><span class="comment">     *             mappings), followed by the key (Object) and value (Object)</span></span><br><span class="line"><span class="comment">     *             for each key-value mapping.  The key-value mappings are</span></span><br><span class="line"><span class="comment">     *             emitted in no particular order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">        <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(buckets);</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        internalWriteEntries(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitute the &#123;<span class="doctag">@code</span> HashMap&#125; instance from a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * deserialize it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                             mappings);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">            <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">            <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">            <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">            <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="keyword">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t;</span><br><span class="line">            Node&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            K key = p.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// spliterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;K,V&gt; map;</span><br><span class="line">        Node&lt;K,V&gt; current;          <span class="comment">// current node</span></span><br><span class="line">        <span class="keyword">int</span> index;                  <span class="comment">// current index, modified on advance/split</span></span><br><span class="line">        <span class="keyword">int</span> fence;                  <span class="comment">// one past last index</span></span><br><span class="line">        <span class="keyword">int</span> est;                    <span class="comment">// size estimate</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;       <span class="comment">// for comodification checks</span></span><br><span class="line"></span><br><span class="line">        HashMapSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin,</span><br><span class="line">                           <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                           <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.map = m;</span><br><span class="line">            <span class="keyword">this</span>.index = origin;</span><br><span class="line">            <span class="keyword">this</span>.fence = fence;</span><br><span class="line">            <span class="keyword">this</span>.est = est;</span><br><span class="line">            <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>&#123; <span class="comment">// initialize fence and size on first use</span></span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                HashMap&lt;K,V&gt; m = map;</span><br><span class="line">                est = m.size;</span><br><span class="line">                expectedModCount = m.modCount;</span><br><span class="line">                Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            getFence(); <span class="comment">// force init</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">long</span>) est;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        KeySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                       <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KeySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                        expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.key);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        K k = current.key;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(k);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        ValueSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ValueSpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.value);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        V v = current.value;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(v);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        EntrySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EntrySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Node&lt;K,V&gt; e = current;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// LinkedHashMap support</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The following package-protected methods are designed to be</span></span><br><span class="line"><span class="comment">     * overridden by LinkedHashMap, but not by any other subclass.</span></span><br><span class="line"><span class="comment">     * Nearly all other internal methods are also package-protected</span></span><br><span class="line"><span class="comment">     * but are declared final, so can be used by LinkedHashMap, view</span></span><br><span class="line"><span class="comment">     * classes, and HashSet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a regular (non-tree) node</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a tree bin node</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For treeifyBin</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reset to initial default state.  Called by clone and readObject.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = <span class="keyword">null</span>;</span><br><span class="line">        entrySet = <span class="keyword">null</span>;</span><br><span class="line">        keySet = <span class="keyword">null</span>;</span><br><span class="line">        values = <span class="keyword">null</span>;</span><br><span class="line">        modCount = <span class="number">0</span>;</span><br><span class="line">        threshold = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called only from writeObject, to ensure compatible ordering.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    s.writeObject(e.key);</span><br><span class="line">                    s.writeObject(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">     * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">     * linked node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Ensures that the given root is the first node of its bin.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">                <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; rn;</span><br><span class="line">                    tab[index] = root;</span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                    <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                    <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                        rp.next = rn;</span><br><span class="line">                    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                        first.prev = root;</span><br><span class="line">                    root.next = first;</span><br><span class="line">                    root.prev = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">         * The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">         * comparing keys.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Calls find for root node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment">         * hashCodes and non-comparable. We don&#x27;t require a total</span></span><br><span class="line"><span class="comment">         * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment">         * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment">         * necessary simplifies testing a bit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> d;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">                (d = a.getClass().getName().</span><br><span class="line">                 compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                     -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> root of tree</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = <span class="keyword">null</span>;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    root = x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    K k = x.key;</span><br><span class="line">                    <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                        <span class="keyword">int</span> dir, ph;</span><br><span class="line">                        K pk = p.key;</span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment">         * this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tl.next = p;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Tree version of putVal.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes the given node, that must be present before this call.</span></span><br><span class="line"><span class="comment">         * This is messier than typical red-black deletion code because we</span></span><br><span class="line"><span class="comment">         * cannot swap the contents of an interior node with a leaf</span></span><br><span class="line"><span class="comment">         * successor that is pinned by &quot;next&quot; pointers that are accessible</span></span><br><span class="line"><span class="comment">         * independently during traversal. So instead we swap the tree</span></span><br><span class="line"><span class="comment">         * linkages. If the current tree appears to have too few nodes,</span></span><br><span class="line"><span class="comment">         * the bin is converted back to a plain bin. (The test triggers</span></span><br><span class="line"><span class="comment">         * somewhere between 2 and 6 nodes, depending on tree structure).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment">         * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment">         * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">        <span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                    rl.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">                    lr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">                    pp.right = l;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.left = l;</span><br><span class="line">                l.right = p;</span><br><span class="line">                p.parent = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                            root = rotateLeft(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                        xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                            (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                            xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpr);</span><br><span class="line">                                xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.right;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateLeft(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                        xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                            (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                            xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpl);</span><br><span class="line">                                xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.left;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateRight(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Recursive invariant check</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">            <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 源码 </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Road To Bald Man!</title>
      <link href="/2021/03/13/The%20Road%20To%20Bald%20Man!/"/>
      <url>/2021/03/13/The%20Road%20To%20Bald%20Man!/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="The-Road-To-Bald-Man！"><a href="#The-Road-To-Bald-Man！" class="headerlink" title="The Road To Bald Man！"></a>The Road To Bald Man！</h1><h2 id="一、编程基础"><a href="#一、编程基础" class="headerlink" title="一、编程基础"></a>一、编程基础</h2><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ul><li>基础语法</li><li>面向对象</li><li>接口</li><li>容器</li><li>异常</li><li>泛型</li><li>反射</li><li>注解</li><li>I/O</li><li>图形化</li><li>集合框架（源码）<ul><li>List<ul><li>ArrayList</li><li>LInkedList</li></ul></li><li>Set<ul><li>HashSet</li><li>TreeSet</li></ul></li><li>Map<ul><li>HashMap （JDK 8 的实现与之前的版本不同）</li><li>TreeMap</li><li>ConcurrentHashMap</li></ul></li><li>Queue<ul><li>ConcurrentLinkedQueue</li></ul></li><li>Stack</li><li>Collections的SynchronizedXXX方法</li></ul></li><li>高级特性<ul><li>泛型</li><li>多态的实现原理</li><li>Lambda</li><li>并发编程<ul><li>Executor框架</li><li>Fork/join</li><li>数据结构<ul><li>ConcurrentHashMap</li><li>ConcurrentLinkedQueue</li></ul></li><li>线程池</li><li>线程状态</li><li>Lock/syschronized</li><li>原子操作类</li><li>并发工具类<ul><li>CountDownLatch</li><li>Semaphore</li><li>CyclicBarrier</li><li>Exchanger</li></ul></li></ul></li></ul></li><li>网络编程<ul><li>Socket</li></ul></li><li>IO<ul><li>BIO</li><li>NIO</li><li>AIO</li></ul></li><li>序列化<ul><li>JDK自带</li><li>Google protobuf</li></ul></li><li>RPC<ul><li>RMI</li><li>Thrift</li><li>Dubbo</li><li>gRpc</li></ul></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li>认识Java虚拟机（默认HotSpot实现）</li><li>类加载机制（知道双亲委派模型）</li><li>字节码执行机制</li><li>内存模型</li><li>GC<ul><li>回收算法</li><li>垃圾收集器</li></ul></li><li>jvm性能监控与故障定位</li><li>调优</li><li>工具<ul><li>jstack</li><li>jmap</li><li>jconsole</li></ul></li></ul><h3 id="并发、多线程"><a href="#并发、多线程" class="headerlink" title="并发、多线程"></a>并发、多线程</h3><ul><li>并发编程基础</li><li>线程池</li><li>锁</li><li>并发容器</li><li>原子类</li><li>juc并发工具类</li></ul><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p>字符串</p><ul><li>查找匹配（KMP）</li><li>正则</li></ul></li><li><p>数组</p></li><li><p>链表</p></li><li><p>栈</p></li><li><p>队列</p></li><li><p>树</p><ul><li>二叉树<ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li></ul></li><li><p>B Tree/B+Tree</p></li><li><p>红黑树</p></li><li><p>哈希</p><ul><li>哈希冲突</li><li>k-v</li></ul></li><li><p>图</p><ul><li>BFS</li><li>DFS</li></ul></li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul><li>查找</li><li>动态规划</li><li>分治</li><li>回溯</li><li>排序<ul><li>内部排序<ul><li>插入排序<ul><li>直接插入排序</li><li>希尔排序</li></ul></li></ul></li><li>选择排序<ul><li>简单选择排序</li><li>堆排序</li></ul></li></ul></li><li>交换排序<ul><li>冒泡排序</li><li>快速排序</li></ul></li><li>归并排序</li><li>基数排序</li><li>桶排序</li><li>外部排序</li><li>贪心</li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul><li>TCP、UDP</li><li>ARP</li><li>IP、ICMP</li><li>DNS、HTTP、HTTPS</li><li>OAuth2.0</li><li>REST</li><li>Session、Cookie</li></ul><h3 id="数据库-SQL"><a href="#数据库-SQL" class="headerlink" title="数据库/SQL"></a>数据库/SQL</h3><ul><li>关系型数据库<ul><li>MySql<ul><li>引擎<ul><li>InnoDB（支持事务）</li><li>MyISAM（支持全文索引）</li></ul></li></ul></li><li>分库分表<ul><li>Cobar</li><li>Mycat</li></ul></li></ul></li><li>SQL优化<ul><li>索引<ul><li>主键索引</li><li>组合索引</li></ul></li></ul></li><li>explain</li><li>存储过程</li><li>SQL注入<ul><li>使用#而不使用$</li></ul></li><li>事务隔离级别（ACID）<ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul></li><li>锁<ul><li>表锁</li><li>行锁</li><li>乐观锁</li><li>悲观锁</li></ul></li><li>Oracle</li><li>SQL sever</li><li>数据库设计<ul><li>范式<ul><li>第一范式</li><li>第二范式</li><li>第三范式</li></ul></li></ul></li><li>E-R图</li><li>NoSql<ul><li>Memcached<ul><li>文档模型</li><li>分片</li></ul></li></ul></li><li>Redis</li><li>MongoDB</li><li>HBase</li><li>JDBC</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>七大原则<ul><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特法则</li><li>合成复用原则</li></ul></li><li>23种设计模式<ul><li>创建型模式：<ol><li>单例模式</li><li>抽象工厂模式</li><li>原型模式</li><li>建造者模式</li><li>工厂模式</li></ol></li><li>结构性模式：<ol><li>适配器模式</li><li>桥接模式</li><li>装饰模式</li><li>组合模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ol></li><li>行为型模式：<ol><li>模板方法模式</li><li>命令模式</li><li>访问者模式</li><li>迭代器模式</li><li>观察者模式</li><li>中介者模式</li><li>备忘录模式</li><li>解释器模式</li><li>状态模式</li><li>策略模式</li><li>职责链模式</li></ol></li></ul></li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>线程、进程</li><li>并发、锁</li><li>内存管理和调度</li><li>I/O原理</li></ul><h2 id="二、开发工具"><a href="#二、开发工具" class="headerlink" title="二、开发工具"></a>二、开发工具</h2><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul><li>IDEA</li><li>Eclipse</li><li>VSCode</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="发行版（Server）"><a href="#发行版（Server）" class="headerlink" title="发行版（Server）"></a>发行版（Server）</h4><ul><li>Ubuntu</li><li>RedHat</li><li>CentOS</li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>1、查看正则执行的进程</li><li>2、查询指定的进程ID打开的文件</li><li>3、杀死指定PID的进程</li><li>4、计算文件的行数、字数或字符数</li><li>5、显示进程信息，并实时更新</li><li>6、调用top命令的&quot;-H&quot;选项，该选项会列出所有的Linux线程</li><li>7、查看用户username的进程所打开的文件</li><li>8、在ps命令中，&quot;-T&quot;选项可以开启线程查看，下面的命令列出了由进程号为进程创建的所有线程</li><li>9、比较两个文件</li><li>10、后台执行、通过在shell中输入exit来退出终端</li><li>11、查看正在执行的任务</li><li>12、多线程执行</li><li>13、查看进程和线程的树形结构关系</li><li>14、ps命令-L参数显示进程，并尽量显示其LWP（线程ID）和NLWP（线程的个数）</li><li>15、ps命令查看线程在哪个CPU上运行</li><li>16、取出文件的前面几行</li><li>17、动态查看文件变化</li><li>18、退出 tail -f</li><li>19、tail程序放到后台去等处理完其他事情，再用fg命令将tail命令转到前台来</li><li>20、查看文件夹和子目录的大小</li><li>21、设置定时任务</li><li>22、重命名文件和文件夹</li><li>23、复制、剪切、清空和删除</li><li>24、Linux通信</li></ul><h3 id="代码管理工具"><a href="#代码管理工具" class="headerlink" title="代码管理工具"></a>代码管理工具</h3><ul><li>Git</li><li>SVN</li></ul><h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><ul><li>Maven</li><li>Gradle</li></ul><h2 id="三、前端技术"><a href="#三、前端技术" class="headerlink" title="三、前端技术"></a>三、前端技术</h2><h3 id="HTML、CSS、JavaScript"><a href="#HTML、CSS、JavaScript" class="headerlink" title="HTML、CSS、JavaScript"></a>HTML、CSS、JavaScript</h3><h3 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h3><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h3 id="JSP、JSTL"><a href="#JSP、JSTL" class="headerlink" title="JSP、JSTL"></a>JSP、JSTL</h3><h3 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h3><h3 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h3><h3 id="VUE、React"><a href="#VUE、React" class="headerlink" title="VUE、React"></a>VUE、React</h3><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><h2 id="四、技术框架"><a href="#四、技术框架" class="headerlink" title="四、技术框架"></a>四、技术框架</h2><h3 id="Spring全家桶"><a href="#Spring全家桶" class="headerlink" title="Spring全家桶"></a>Spring全家桶</h3><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul><li>IOC</li><li>AOP</li><li>Transaction<ul><li>声明式事务底层原理</li><li>Spring事务处理机制</li><li>事务的传播与监控</li><li>基于Springjdbc手写Orm框架</li></ul></li><li>常用注解<ul><li>@Component：标识该类需要Spring初始化时自动装配，可以时一个普通的Bean</li><li>@Resource：被该注释修饰的字段或方法，Spring会通过by-name的方式自动注入</li><li>@Required：应用于bean属性的setter方法，它表明受影响的bean属性在配置时必须放在XML配置文件中，否则容器就会抛出一个BeanInitializationException异常</li><li>@Autowired：可以在setter方法中被用于自动连接bean</li><li>@Value：可以为普通方法和构造方法中的参数或者字段指定一个默认的值</li><li>@Qualifer：指定哪个真正的bean将会被装配，应用于一个接口有多个实现类的情况</li><li>@Service：标注一个业务逻辑处理类</li><li>@Repository：标注一个DAO组件类</li><li>＠RequestMapping：指定请求路径</li><li>＠Controller：标注一个控制器组件类</li><li>＠ResponseBody：返回json结果数据</li></ul></li><li>设计模式<ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>原型模式</li><li>代理模式<ul><li>jdk动态代理模式</li><li>cglib动态代理模式</li></ul></li></ul></li><li>组合模式</li></ul><h4 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h4><ul><li>MVC原理介绍</li><li>与IOC容器整合原理</li><li>Handlermapping实现原理</li><li>Handleradapter实现原理</li><li>Viewresolver实现原理</li><li>Controller调用原理</li><li>动态参数匹配原理</li><li>SpringMVC与Struts2对比分析</li><li>手写实现SpringMVC框架</li></ul><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><ul><li>自动配置、开箱即用</li><li>整合Web</li><li>整合数据库（事务问题）</li><li>整合权限<ul><li>Shiro</li><li>SpringSecurity</li></ul></li><li>整合各种中间件<ul><li>缓存</li><li>MQ</li><li>RPC框架</li><li>NIO框架</li><li>等。。。</li></ul></li></ul><h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><h3 id="服务器软件"><a href="#服务器软件" class="headerlink" title="服务器软件"></a>服务器软件</h3><h4 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h4><ul><li>Nginx</li></ul><h4 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h4><ul><li>Tomcat</li><li>Jetty</li><li>Undertow</li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>Redis<ul><li>5大数据类型</li><li>事务</li><li>消息通知</li><li>管道</li><li>持久化</li><li>集群</li></ul></li><li>Memcached</li></ul><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul><li>RocketMQ</li><li>RabbitMQ</li><li>Kafka</li></ul><h4 id="RPC架构"><a href="#RPC架构" class="headerlink" title="RPC架构"></a>RPC架构</h4><ul><li>Dubbo</li><li>GRPC</li><li>Thrift</li><li>Netty</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="ORM层框架"><a href="#ORM层框架" class="headerlink" title="ORM层框架"></a>ORM层框架</h4><ul><li>MyBatis<ul><li>逆向工程</li><li>一对多，多对多嵌套查询</li><li>一级缓存、二级缓存使用场景及选择策略</li><li>与Spring继承Spring-Mybatis.Jar分析</li><li>Spring继承下的Sqlsession与Mapper</li><li>Mybaits事务</li><li>分析Mybatis动态代理的真正实现</li><li>手写实现Mybatis<ul><li>实现配置文件加载流程</li><li>实现封装jdbc的执行流程</li></ul></li><li>设计模式<ul><li>构建者模式</li><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li></ul></li></ul></li><li>Hibernate</li><li>JPA</li></ul><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><ul><li>Druid</li><li>HikariCP</li><li>C3P0</li></ul><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><ul><li>MyCat</li><li>Sharding-JDBC</li><li>Sharding-Sphere</li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li>Solr</li><li>ElasticSearch</li></ul><h3 id="分布式微服务"><a href="#分布式微服务" class="headerlink" title="分布式微服务"></a>分布式微服务</h3><ul><li>服务发现/注册<ul><li>Eureka</li><li>Consul</li><li>Zookeeper</li><li>Nacos</li></ul></li><li>网关<ul><li>Zuul</li><li>Gateway</li></ul></li><li>服务调用（负载均衡）<ul><li>Ribbon</li><li>Feign</li></ul></li><li>熔断/降级<ul><li>Hystrix</li></ul></li><li>配置中心<ul><li>Config</li><li>Apollo</li><li>Nacos</li></ul></li><li>认证和鉴权<ul><li>Shiro</li><li>SpringSecurity</li><li>OAuth2</li><li>SSO</li></ul></li><li>分布式事务<ul><li>JTA接口<ul><li>Atomikos组件</li></ul></li></ul></li><li>2PC、3PC</li><li>XA模式</li><li>TCC模式<ul><li>tcc-transaction</li><li>ByteTCC</li><li>EasyTransaction</li><li>Seata</li></ul></li><li>SAGA模式<ul><li>ServiceComb</li><li>Seata</li></ul></li><li>LCN模式<ul><li>tx-lcn</li></ul></li><li>任务调度<ul><li>Quartz</li><li>Elastic-Job</li></ul></li><li>链路追踪与监控<ul><li>Zipkin</li><li>Sleuth</li><li>Skywalking</li></ul></li><li>日志分析与监控<ul><li>ELK<ul><li>ElasticSearch</li><li>Logstash</li><li>Kibana</li></ul></li></ul></li><li>虚拟化/容器化<ul><li>容器技术<ul><li>Docker</li></ul></li></ul></li><li>容器编排技术<ul><li>Kubernetes</li><li>Swarm</li></ul></li></ul><h2 id="五、运维"><a href="#五、运维" class="headerlink" title="五、运维"></a>五、运维</h2><h4 id="Web服务器-1"><a href="#Web服务器-1" class="headerlink" title="Web服务器"></a>Web服务器</h4><ul><li>Nginx</li></ul><h4 id="应用服务器-1"><a href="#应用服务器-1" class="headerlink" title="应用服务器"></a>应用服务器</h4><ul><li>Tomcat</li><li>Jetty</li><li>Undertow</li></ul><h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><h4 id="持续集成-持续发布"><a href="#持续集成-持续发布" class="headerlink" title="持续集成/持续发布"></a>持续集成/持续发布</h4><ul><li>Jenkins</li></ul><h4 id="代码质量检查"><a href="#代码质量检查" class="headerlink" title="代码质量检查"></a>代码质量检查</h4><ul><li>sonar</li></ul><h4 id="日志收集-分析"><a href="#日志收集-分析" class="headerlink" title="日志收集/分析"></a>日志收集/分析</h4><ul><li>ELK</li></ul><h2 id="六、安全加密"><a href="#六、安全加密" class="headerlink" title="六、安全加密"></a>六、安全加密</h2><h4 id="单项散列算法"><a href="#单项散列算法" class="headerlink" title="单项散列算法"></a>单项散列算法</h4><ul><li>MD5</li><li>SHA</li></ul><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ul><li>DES</li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul><li>RSA</li><li>HTTPS</li></ul><h2 id="七、业务解决方案"><a href="#七、业务解决方案" class="headerlink" title="七、业务解决方案"></a>七、业务解决方案</h2><h2 id="八、源码"><a href="#八、源码" class="headerlink" title="八、源码"></a>八、源码</h2><h2 id="九、植发"><a href="#九、植发" class="headerlink" title="九、植发"></a>九、植发</h2>]]></content>
      
      
      <categories>
          
          <category> My Java Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> My Java Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven配置标签详解</title>
      <link href="/2020/07/21/%E6%A1%86%E6%9E%B6-Maven-%E9%85%8D%E7%BD%AE%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/21/%E6%A1%86%E6%9E%B6-Maven-%E9%85%8D%E7%BD%AE%E6%A0%87%E7%AD%BE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven配置标签详解"><a href="#Maven配置标签详解" class="headerlink" title="Maven配置标签详解"></a>Maven配置标签详解</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 </span></span><br><span class="line"><span class="comment">        version。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 </span></span><br><span class="line"><span class="comment">            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asia.banseon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 </span></span><br><span class="line"><span class="comment">        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 </span></span><br><span class="line"><span class="comment">        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span>jira<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目持续集成信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--传送通知的途径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生错误时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建失败时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建成功时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生警告时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">address</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--扩展配置项 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--邮件的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">post</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http:/hi.baidu.com/banseon/demo/dev/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目开发者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的全名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的email --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.baidu.com/banseon<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dept</span>&gt;</span>No<span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>-5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--license用于法律上的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache 2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">comments</span>&gt;</span>A business-friendly OSS license<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class="line">        <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织的全名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织主页的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scriptSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testOutputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--描述使用到的构建扩展。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的groupId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的artifactId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 </span></span><br><span class="line"><span class="comment">                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--profile默认是否激活的标志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                    ......</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                ......</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    ......</span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencyManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见distributionManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见properties元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--true，则，网站不包括默认的报表。这包括&quot;项目信息&quot;菜单中的报表。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的group ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件的配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon maven2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Banseon-maven2 Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>business api website<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class="line">            <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的版本号 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 </span></span><br><span class="line"><span class="comment">            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">status</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型模式-单例模式</title>
      <link href="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-创建型模式-单例模式"><a href="#设计模式-创建型模式-单例模式" class="headerlink" title="设计模式-创建型模式-单例模式"></a>设计模式-创建型模式-单例模式</h1><h2 id="1）、饿汉式（静态常量）"><a href="#1）、饿汉式（静态常量）" class="headerlink" title="1）、饿汉式（静态常量）"></a>1）、饿汉式（静态常量）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">Singleton instance2 = Singleton.getInstance();</span><br><span class="line">System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ol><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</li><li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</li><li>这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果</li><li>结论：这种单例模式可用，可能造成内存浪费。</li></ol><h2 id="2）、饿汉式（静态代码块）"><a href="#2）、饿汉式（静态代码块）" class="headerlink" title="2）、饿汉式（静态代码块）"></a>2）、饿汉式（静态代码块）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">Singleton instance2 = Singleton.getInstance();</span><br><span class="line">System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123; <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ol><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li><li>结论：这种单例模式可用，但是可能造成内存浪费。</li></ol><h2 id="3）、懒汉式（线程不安全）"><a href="#3）、懒汉式（线程不安全）" class="headerlink" title="3）、懒汉式（线程不安全）"></a>3）、懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;懒汉式1 ， 线程不安全~&quot;</span>);</span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">Singleton instance2 = Singleton.getInstance();</span><br><span class="line">System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line"><span class="comment">//即懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ol><li>起到了 Lazy Loading 的效果，但是只能在单线程下使用。</li><li>如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li><li>结论：在实际开发中，不要使用这种方式. </li></ol><h2 id="4）、懒汉式（线程安全，同步方法）"><a href="#4）、懒汉式（线程安全，同步方法）" class="headerlink" title="4）、懒汉式（线程安全，同步方法）"></a>4）、懒汉式（线程安全，同步方法）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;懒汉式2 ， 线程安全~&quot;</span>);</span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">Singleton instance2 = Singleton.getInstance();</span><br><span class="line">System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line"><span class="comment">//即懒汉式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ol><li>解决了线程安全问题</li><li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低</li><li>结论：在实际开发中，不推荐使用这种方式</li></ol><h2 id="5）、懒汉式（线程安全，同步代码块）"><a href="#5）、懒汉式（线程安全，同步代码块）" class="headerlink" title="5）、懒汉式（线程安全，同步代码块）"></a>5）、懒汉式（线程安全，同步代码块）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>开发中不能使用</strong></p><h2 id="6）、双重检查"><a href="#6）、双重检查" class="headerlink" title="6）、双重检查"></a>6）、双重检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;双重检查&quot;</span>);</span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">Singleton instance2 = Singleton.getInstance();</span><br><span class="line">System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重检查</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line"><span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ol><li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步. </li><li>线程安全；延迟加载；效率较高</li><li>结论：在实际开发中，推荐使用这种单例设计模式</li></ol><h2 id="7）、静态内部类"><a href="#7）、静态内部类" class="headerlink" title="7）、静态内部类"></a>7）、静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest07</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用静态内部类完成单例模式&quot;</span>);</span><br><span class="line">Singleton instance = Singleton.getInstance();</span><br><span class="line">Singleton instance2 = Singleton.getInstance();</span><br><span class="line">System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ol><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li><li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高。</li><li>结论：推荐使用。</li></ol><h2 id="8）、枚举"><a href="#8）、枚举" class="headerlink" title="8）、枚举"></a>8）、枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest08</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Singleton instance = Singleton.INSTANCE;</span><br><span class="line">Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">System.out.println(instance == instance2);</span><br><span class="line"></span><br><span class="line">System.out.println(instance.hashCode());</span><br><span class="line">System.out.println(instance2.hashCode());</span><br><span class="line"></span><br><span class="line">instance.sayOK();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">INSTANCE; <span class="comment">//属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ok~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ol><li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li><li>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式</li><li>结论：推荐使用</li></ol><h2 id="9）、单例模式在JDK应用的源码分析"><a href="#9）、单例模式在JDK应用的源码分析" class="headerlink" title="9）、单例模式在JDK应用的源码分析"></a>9）、单例模式在JDK应用的源码分析</h2><p>例如：在JDK 中，<strong>java.lang.Runtime</strong> 就是经典的单例模式(饿汉式)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Runtime &#123;</span><br><span class="line">&#x2F;&#x2F;类加载直接生成对象</span><br><span class="line">    private static Runtime currentRuntime &#x3D; new Runtime();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the runtime object associated with the current Java application.</span><br><span class="line">     * Most of the methods of class &lt;code&gt;Runtime&lt;&#x2F;code&gt; are instance</span><br><span class="line">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="line">     *</span><br><span class="line">     * @return  the &lt;code&gt;Runtime&lt;&#x2F;code&gt; object associated with the current</span><br><span class="line">     *          Java application.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Runtime getRuntime() &#123;</span><br><span class="line">        return currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Don&#39;t let anyone else instantiate this class *&#x2F;</span><br><span class="line">    private Runtime() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10）、单例模式注意事项和细节说明"><a href="#10）、单例模式注意事项和细节说明" class="headerlink" title="10）、单例模式注意事项和细节说明"></a>10）、单例模式注意事项和细节说明</h2><ol><li><strong>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使</strong><br> <strong>用单例模式可以提高系统性能</strong></li><li> <strong>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</strong></li><li><strong>单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级</strong><br> <strong>对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建型模式 </category>
          
          <category> 单例模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-七大设计原则</title>
      <link href="/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2020/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-七大设计原则"><a href="#设计模式-七大设计原则" class="headerlink" title="设计模式-七大设计原则"></a>设计模式-七大设计原则</h1><p>==<strong>三种类型</strong>==</p><ol><li><strong>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</strong></li><li><strong>结构性模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</strong></li><li><strong>行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式</strong></li></ol><p>==<strong>核心思想</strong>==</p><ol><li><strong>代码重用性（即：相同功能的代码，不用多次编写）</strong></li><li><strong>可读性（即：编程规范性，便于其他程序员的阅读和理解）</strong></li><li><strong>可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）</strong></li><li><strong>可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</strong></li><li><strong>使程序呈现高内聚，低耦合的特性</strong></li></ol><h2 id="1）、单一职责原则（Single-Responsibility）"><a href="#1）、单一职责原则（Single-Responsibility）" class="headerlink" title="1）、单一职责原则（Single Responsibility）"></a>1）、单一职责原则（Single Responsibility）</h2><p><strong>目的：</strong>降低代码复杂度、系统解耦合、提高可读性</p><p>​        对类来说，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。</p><ol><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性。</li><li>降低变更引起的风险。</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责；只有类中方法数量足够少，可以在方法级别保持单一职责原则。</li></ol><p><strong>==快速记忆：各司其职，降低耦合==</strong></p><h2 id="2）、接口隔离原则（Interface-Segregation）"><a href="#2）、接口隔离原则（Interface-Segregation）" class="headerlink" title="2）、接口隔离原则（Interface Segregation）"></a>2）、接口隔离原则（Interface Segregation）</h2><p><strong>目的：</strong>避免接口过于臃肿</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类A通过Interface1会依赖（使用）类B</span></span><br><span class="line"><span class="comment">//但是A只会用到接口的fun1(),fun2(),fun3()三个方法</span></span><br><span class="line"><span class="comment">//类C通过Interface1会依赖（使用）类D</span></span><br><span class="line"><span class="comment">//但是C只会用到接口的fun1(),fun4(),fun5()三个方法</span></span><br></pre></td></tr></table></figure><ol><li><p>类A通过Interface1会依赖（使用）类B（<strong>比如：在control层调用service层实现方法时</strong>），类C通过Interface1会依赖（使用）类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。</p></li><li><p>将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p></li><li><p>接口Interface1中出现的方法，根据实际情况拆分为三个接口</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface3</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>==快速记忆：利用接口的多实现，拆分粒度尽量小，避免实现类重写不需要的方法==</strong></p></li></ol><h2 id="3）、依赖倒转原则（Dependence-Inversion）"><a href="#3）、依赖倒转原则（Dependence-Inversion）" class="headerlink" title="3）、依赖倒转原则（Dependence Inversion）"></a>3）、依赖倒转原则（Dependence Inversion）</h2><p><strong>目的：</strong>避免需求变化导致过多的维护工作</p><ol><li><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象，低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。</p></li><li><p>抽象不应该依赖细节，细节应该依赖抽象。</p></li><li><p>依赖倒转（倒置）的中心思想是面向接口编程。</p></li><li><p>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。</p></li><li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展示细节的任务交给他们的实现类去完成。</p></li><li><p>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。</p></li><li><p>继承时遵循里氏替换原则。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependenceInversion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">        person.receive(<span class="keyword">new</span> WeChat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Receive Email&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeChat</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Receive WeChat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person 接受信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Info info)</span> </span>&#123;</span><br><span class="line">        System.out.println(info.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>依赖关系的传递方式：</strong></p><ul><li>接口传递</li><li>构造方法传递</li><li>setter方式传递</li></ul><p> <strong>==快速记忆：面向接口编程，这就是为什么service 要多写个接口，然后才是实现类==</strong></p></li></ol><h2 id="4）、里氏替换原则（Liskov-Substitution）"><a href="#4）、里氏替换原则（Liskov-Substitution）" class="headerlink" title="4）、里氏替换原则（Liskov Substitution）"></a>4）、里氏替换原则（Liskov Substitution）</h2><p><strong>目的：</strong>避免系统继承体系被破坏</p><ol><li><p>里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院一位姓里的女士提出。</p></li><li><p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p></li><li><p>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p></li><li><p>继承实际上让两个类耦合性增强了，给程序带来侵入性。在适当的情况下，可以通过聚合，组合，依赖来解决问题。</p></li><li><p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiskovSubstitution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">&quot;2-1=&quot;</span> + a.func1(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">&quot;2+1=&quot;</span> + b.func1(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;2+1+9=&quot;</span> + b.func2(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;B类使用A类方法：2-1=&quot;</span> + b.func3(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把基础方法和成员抽取成基类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public int func1(int num1, int num2) &#123;</span></span><br><span class="line"><span class="comment">//        return num1 - num2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// TODO 类 B `无意` 重写了父类 A 方法，造成原有方法发生改变。</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int func1(int num1, int num2) &#123;</span></span><br><span class="line"><span class="comment">//        return num1 + num2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(num1, num2) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();<span class="comment">//组合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 A 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>==快速记忆：子类可以扩展父类的功能，但不能改变父类原有的功能==</strong></p></li></ol><h2 id="5）、开闭原则（Open-Closed）"><a href="#5）、开闭原则（Open-Closed）" class="headerlink" title="5）、开闭原则（Open Closed）"></a>5）、开闭原则（Open Closed）</h2><p><strong>目的：</strong>提高扩展性、便于维护</p><ol><li><p>开闭原则(Open Closed Principle) 是编程中最基础、最重要的设计原则。</p></li><li><p>一个软件实体，比如类，模块和函数应该对==提供方扩展开放==，对==使用方修改关闭==。用抽象构建框架，用实现扩展细节。</p></li><li><p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p></li><li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenClosed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Use use = <span class="keyword">new</span> Use();</span><br><span class="line">        use.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">        use.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        use.drawShape(<span class="keyword">new</span> OtherGraphics());<span class="comment">//只需要让 此类继承 抽象类，子类实现具体方法  OCP原则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Use</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现具体功能：三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现具体功能：圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphics</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类实现具体功能：任何形状&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>==快速记忆：比如你作为开发可以修改程序，但用户无法修改。即 类，模块和函数提供方开放修改，调用方关闭修改==</strong></p></li></ol><h2 id="6）、迪米特法则（Demeter）"><a href="#6）、迪米特法则（Demeter）" class="headerlink" title="6）、迪米特法则（Demeter）"></a>6）、迪米特法则（Demeter）</h2><p><strong>目的：</strong>降低类与类之间的耦合</p><ol><li><p>一个对象应该对其他对象保持最少的了解（最少知道原则 LKP）。</p></li><li><p>类与类关系越密切，耦合度越大。要求降低类之间耦合，而不是完全解耦。</p></li><li><p>迪米特法则(Demeter Principle)，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息。</p></li><li><p>迪米特法则更简单的定义：只与直接的朋友通信。</p></li><li><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    B b;<span class="comment">//全局变量 - 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">m1</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//方法返回值 - 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(B b)</span></span>&#123;&#125;<span class="comment">//方法入参 - 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B b1 = <span class="keyword">new</span> B();<span class="comment">// 局部变量 非直接朋友</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工 //TODO CollegeEmployee 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10 个员工到list ，</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCollegeEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;---学院员工----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//TODO 直接朋友 Employee CollegeManager</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SchoolEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SchoolEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SchoolEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到list</span></span><br><span class="line">            SchoolEmployee emp = <span class="keyword">new</span> SchoolEmployee();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        <span class="comment">//TODO 非直接朋友 CollegeEmployee  应该提取到  CollegeManager</span></span><br><span class="line"><span class="comment">//        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;---学院员工----&quot;);</span></span><br><span class="line"><span class="comment">//        for (CollegeEmployee e : list1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e.getId());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        sub.printCollegeEmployee();<span class="comment">//只提供方法，不把具体实现放在其他类里面。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;SchoolEmployee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------学校总部员工------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SchoolEmployee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>==快速记忆：只与直接的朋友通信。校长管老师，老师管学生。校长找学生不会直接去找，而是通过老师去找。==</strong></p></li></ol><h2 id="7）、合成复用原则（Composite-Reuse）"><a href="#7）、合成复用原则（Composite-Reuse）" class="headerlink" title="7）、合成复用原则（Composite Reuse）"></a>7）、合成复用原则（Composite Reuse）</h2><p><strong>目的：</strong>防止类的体系庞大</p><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeReuse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------依赖------&quot;</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.Operation1(<span class="keyword">new</span> A());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------聚合------&quot;</span>);</span><br><span class="line">        b.setA(<span class="keyword">new</span> A());</span><br><span class="line">        b.Operation2();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------组合------&quot;</span>);</span><br><span class="line">        b.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A Operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A Operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A Operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只是需要用到 A类的方法，尽量不要使用继承。而是使用，依赖，聚合，组合的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">(A a)</span> </span>&#123;<span class="comment">//TODO 依赖</span></span><br><span class="line">        a.Operation1();</span><br><span class="line">        a.Operation2();</span><br><span class="line">        a.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================================================</span></span><br><span class="line">    A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;<span class="comment">//TODO 聚合</span></span><br><span class="line">        a.Operation1();</span><br><span class="line">        a.Operation2();</span><br><span class="line">        a.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================================================</span></span><br><span class="line">    A a1 = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span> </span>&#123;<span class="comment">//TODO 组合</span></span><br><span class="line">        a1.Operation1();</span><br><span class="line">        a1.Operation2();</span><br><span class="line">        a1.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>==快速记忆：当类与类之间的关系是”Is-A”时，用继承；当类与类之间的关系是”Has-A”时，用组合。==</strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 设计原则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级</title>
      <link href="/2020/04/19/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-MySQL%E9%AB%98%E7%BA%A7/"/>
      <url>/2020/04/19/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-MySQL%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL的结构介绍"><a href="#1-MySQL的结构介绍" class="headerlink" title="1.MySQL的结构介绍"></a>1.MySQL的结构介绍</h1><h2 id="1-1MySQL简介"><a href="#1-1MySQL简介" class="headerlink" title="1.1MySQL简介"></a>1.1MySQL简介</h2><h3 id="1-1-1-概述"><a href="#1-1-1-概述" class="headerlink" title="1.1.1 概述"></a>1.1.1 概述</h3><h3 id="1-1-2-高级MYSQL"><a href="#1-1-2-高级MYSQL" class="headerlink" title="1.1.2 高级MYSQL"></a>1.1.2 高级MYSQL</h3><ul><li>mysql内核</li><li>sql优化工程师</li><li>mysql服务器的优化</li><li>查询语句优化</li><li>主重复制</li><li>软硬件升级</li><li>容灾备份</li><li>sql编程</li></ul><h2 id="1-2MySQL-Linux版安装"><a href="#1-2MySQL-Linux版安装" class="headerlink" title="1.2MySQL-Linux版安装"></a>1.2MySQL-Linux版安装</h2><p><a href="https://fangchenyong.top/2019/07/23/install_MySql5.7/">CentOS 7.2 安装MySql 5.7</a></p><h2 id="1-3MySQL主要配置文件"><a href="#1-3MySQL主要配置文件" class="headerlink" title="1.3MySQL主要配置文件"></a>1.3MySQL主要配置文件</h2><h3 id="1-3-1-二进制日志log-bin"><a href="#1-3-1-二进制日志log-bin" class="headerlink" title="1.3.1 二进制日志log-bin"></a>1.3.1 二进制日志log-bin</h3><ul><li>主从复制</li></ul><h3 id="1-3-2-错误日志log-error"><a href="#1-3-2-错误日志log-error" class="headerlink" title="1.3.2 错误日志log-error"></a>1.3.2 错误日志log-error</h3><ul><li>默认是关闭的,记录严重的警告和错误信息,每次启动和关闭的详细信息等.</li></ul><h3 id="1-3-3-查询日志log"><a href="#1-3-3-查询日志log" class="headerlink" title="1.3.3 查询日志log"></a>1.3.3 查询日志log</h3><ul><li>默认关闭,记录查询的sql语句，如果开启会减低mysql的整体性能，因为记录日志也是需要消耗系统资源的</li></ul><h3 id="1-3-4-数据文件"><a href="#1-3-4-数据文件" class="headerlink" title="1.3.4  数据文件"></a>1.3.4  数据文件</h3><ul><li>两个系统<ul><li>windows<ul><li>D:\ProgramFiles\MySQL\MySQLServer5.5\data目录下可以挑选很多库</li></ul></li><li>linux<ul><li>看看当前系统中的全部库后再进去</li><li>默认路径：/var/lib/mysql</li></ul></li></ul></li><li>frm文件<ul><li>存放表结构</li></ul></li><li>myd文件<ul><li>存放表数据</li></ul></li><li>myi文件<ul><li>存放表索引</li></ul></li></ul><h3 id="1-3-5-如何配置"><a href="#1-3-5-如何配置" class="headerlink" title="1.3.5 如何配置"></a>1.3.5 如何配置</h3><ul><li>windows<ul><li>my.ini文件</li></ul></li><li>Linux<ul><li>/etc/my.cnf文件</li></ul></li></ul><h2 id="1-4Mysql逻辑架构介绍"><a href="#1-4Mysql逻辑架构介绍" class="headerlink" title="1.4Mysql逻辑架构介绍"></a>1.4Mysql逻辑架构介绍</h2><ul><li><p>总体概览</p><blockquote><p>1.Connectors<br>指的是不同语言中与SQL的交互<br>2 Management Serveices &amp; Utilities： <br>系统管理和控制工具<br>3 Connection Pool: 连接池<br>管理缓冲用户连接，线程处理等需要缓存的需求。<br>负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，<br>接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。<br>4 SQL Interface: SQL接口。…</p></blockquote></li><li><p>查询说明</p></li></ul><h2 id="1-5Mysql存储引擎"><a href="#1-5Mysql存储引擎" class="headerlink" title="1.5Mysql存储引擎"></a>1.5Mysql存储引擎</h2><ul><li>查看命令</li><li>MyISAM和InnoDB</li><li>阿里巴巴，淘宝用哪个</li></ul><h1 id="2-索引优化分析"><a href="#2-索引优化分析" class="headerlink" title="2.索引优化分析"></a>2.索引优化分析</h1><h2 id="2-1-性能下降SQL慢-执行时间长-等待时间长"><a href="#2-1-性能下降SQL慢-执行时间长-等待时间长" class="headerlink" title="2.1 性能下降SQL慢 执行时间长 等待时间长"></a>2.1 性能下降SQL慢 执行时间长 等待时间长</h2><h3 id="2-1-1查询语句写的烂"><a href="#2-1-1查询语句写的烂" class="headerlink" title="2.1.1查询语句写的烂"></a>2.1.1查询语句写的烂</h3><h3 id="2-1-2索引失效"><a href="#2-1-2索引失效" class="headerlink" title="2.1.2索引失效"></a>2.1.2索引失效</h3><ul><li>单值</li><li>复合</li></ul><h3 id="2-1-3关联查询太多join-设计缺陷或不得已的需求"><a href="#2-1-3关联查询太多join-设计缺陷或不得已的需求" class="headerlink" title="2.1.3关联查询太多join(设计缺陷或不得已的需求)"></a>2.1.3关联查询太多join(设计缺陷或不得已的需求)</h3><h3 id="2-1-4服务器调优及各个参数设置-缓冲-线程数等"><a href="#2-1-4服务器调优及各个参数设置-缓冲-线程数等" class="headerlink" title="2.1.4服务器调优及各个参数设置(缓冲\线程数等)"></a>2.1.4服务器调优及各个参数设置(缓冲\线程数等)</h3><h2 id="2-2-常见通用的join查询"><a href="#2-2-常见通用的join查询" class="headerlink" title="2.2 常见通用的join查询"></a>2.2 常见通用的join查询</h2><h3 id="2-2-1-SQL执行顺序"><a href="#2-2-1-SQL执行顺序" class="headerlink" title="2.2.1 SQL执行顺序"></a>2.2.1 SQL执行顺序</h3><ul><li>手写</li><li>机读</li><li>总结</li></ul><h3 id="2-2-2-Join图"><a href="#2-2-2-Join图" class="headerlink" title="2.2.2 Join图"></a>2.2.2 Join图</h3><h3 id="2-2-3-建表SQL"><a href="#2-2-3-建表SQL" class="headerlink" title="2.2.3 建表SQL"></a>2.2.3 建表SQL</h3><h3 id="2-2-4-7种Join"><a href="#2-2-4-7种Join" class="headerlink" title="2.2.4 7种Join"></a>2.2.4 7种Join</h3><h2 id="2-3-索引简介"><a href="#2-3-索引简介" class="headerlink" title="2.3 索引简介"></a>2.3 索引简介</h2><p>2.3.1 是什么</p><ul><li>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高校获取数据的数据结构。<br>  可以得到索引的本质：索引是数据结构</li><li>你可以简单理解为”排好序的快速查找数据结构”。</li><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上</li><li>我们平时所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引，次要索引，覆盖索引，<br>  复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然,除了B+树这种类型的索引之外，还有哈希索引(hash index)等。</li></ul><p>2.3.2 优势</p><ul><li>类似大学图书馆建书目索引，提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗</li></ul><p>2.3.3 劣势</p><ul><li>实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录,所以索引列也是要占用空间的</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度,如果对表INSERT,UPDATE和DELETE。<br>  因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，<br>  都会调整因为更新所带来的键值变化后的索引信息</li><li>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句</li></ul><p>2.3.4 mysql索引分类</p><ul><li><p>单值索引</p><ul><li><p>即一个索引只包含单个列，一个表可以有多个单列索引</p><blockquote><p>建议一张表索引不要超过5个<br>优先考虑复合索引</p></blockquote></li></ul></li><li><p>唯一索引</p><ul><li>索引列的值必须唯一，但允许有空值</li></ul></li><li><p>复合索引</p><ul><li>即一个索引包含多个列</li></ul></li><li><p>基本语法</p><ul><li>创建<ul><li>CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));</li><li>ALTER mytable ADD [UNIQUE] INDEX [indexName] ON(columnname(length));</li></ul></li><li>删除<ul><li>DROP INDEX [indexName] ON mytable;</li></ul></li><li>查看<ul><li>SHOW INDEX FROM table_name\G</li></ul></li><li>使用ALTER命令</li></ul></li></ul><p>2.3.5 mysql索引结构</p><ul><li><p>BTree索引</p><blockquote><p>Btree索引(或Balanced Tree)，是一种很普遍的数据库索引结构，oracle默认的索引类型（本文也主要依据oracle来讲）。其特点是定位高效、利用率高、自我平衡，特别适用于高基数字段，定位单条或小范围数据非常高效。理论上，使用Btree在亿条数据与100条数据中定位记录的花销相同。<br> <br>数据结构利用率高、定位高效<br>Btree索引的数据结构如下：<br><br>结构看起来Btree索引与Binary Tree相似，但在细节上有所不同，上图中用不同颜色的标示出了Btree索引的几个主要特点：<br> <br>树形结构：由根节(root)、分支(branches)、叶(leaves)三级节点组成，其中分支节点可以有多层。…</p></blockquote></li><li><p>Hash索引</p><blockquote><p>了解</p></blockquote></li><li><p>full-text全文索引</p><blockquote><p>了解</p></blockquote></li><li><p>R-Tree索引</p><blockquote><p>了解</p></blockquote></li></ul><p>2.3.6 哪些情况需要创建索引</p><ul><li><p>1.主键自动建立唯一索引</p></li><li><p>2.频繁作为查询的条件的字段应该创建索引</p></li><li><p>3.查询中与其他表关联的字段，外键关系建立索引</p></li><li><p>4.频繁更新的字段不适合创建索引</p><blockquote><p>因为每次更新不单单是更新了记录还会更新索引，加重IO负担</p></blockquote></li><li><p>5.Where条件里用不到的字段不创建索引</p></li><li><p>6.单间/组合索引的选择问题，who？（在高并发下倾向创建组合索引）</p></li><li><p>7.查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度</p></li><li><p>8.查询中统计或者分组字段</p></li></ul><p>2.3.7 哪些情况不要创建索引</p><ul><li>1.表记录太少</li><li>2.经常增删改的表</li><li>3.数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。<br>  注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li></ul><h2 id="2-4-性能分析"><a href="#2-4-性能分析" class="headerlink" title="2.4 性能分析"></a>2.4 性能分析</h2><h2 id="2-5-索引优化"><a href="#2-5-索引优化" class="headerlink" title="2.5 索引优化"></a>2.5 索引优化</h2><h1 id="3-查询截取分析"><a href="#3-查询截取分析" class="headerlink" title="3.查询截取分析"></a>3.查询截取分析</h1><h1 id="4-MySQL锁机制"><a href="#4-MySQL锁机制" class="headerlink" title="4.MySQL锁机制"></a>4.MySQL锁机制</h1><h1 id="5-主从复制"><a href="#5-主从复制" class="headerlink" title="5.主从复制"></a>5.主从复制</h1><div class="row">    <embed src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/pdf/%E5%B0%9A%E7%A1%85%E8%B0%B7MySQL%E9%AB%98%E7%BA%A7_JAVA%E7%89%88.pdf" width="100%" height="550" type="application/pdf"></div> ]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis命令</title>
      <link href="/2020/04/01/%E4%B8%AD%E9%97%B4%E4%BB%B6-Redis/"/>
      <url>/2020/04/01/%E4%B8%AD%E9%97%B4%E4%BB%B6-Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-redis入门"><a href="#1-redis入门" class="headerlink" title="1.redis入门"></a>1.redis入门</h1><h2 id="1-1-redis简介"><a href="#1-1-redis简介" class="headerlink" title="1.1 redis简介"></a>1.1 redis简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id="1-1-1-Redis-优势"><a href="#1-1-1-Redis-优势" class="headerlink" title="1.1.1 Redis 优势"></a>1.1.1 Redis 优势</h3><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h3 id="1-1-2-Redis与其他key-value存储有什么不同？"><a href="#1-1-2-Redis与其他key-value存储有什么不同？" class="headerlink" title="1.1.2 Redis与其他key-value存储有什么不同？"></a>1.1.2 Redis与其他key-value存储有什么不同？</h3><ul><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li></ul><h3 id="1-1-3-应用"><a href="#1-1-3-应用" class="headerlink" title="1.1.3 应用"></a>1.1.3 应用</h3><ul><li>Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 </li><li>Tips 2：redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 </li><li>Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速 </li><li>Tips 4：redis 应用于购物车数据存储设计 </li><li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 </li><li>Tips 6：redis 应用于具有操作先后顺序的数据控制 </li><li>Tips 7：redis 应用于最新消息展示 </li><li>Tips 8：redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等 </li><li>Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 </li><li>Tips 10：redis 应用于同类型不重复数据的合并、取交集操作 </li><li>Tips 11：redis 应用于同类型数据的快速去重 </li><li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制 </li><li>Tips 13：redis 应用于计数器组合排序功能对应的排名 </li><li>Tips 14：redis 应用于定时任务执行顺序管理或任务过期管理 </li><li>Tips 15：redis 应用于及时任务/消息队列执行管理 </li><li>Tips 16：redis 应用于按次结算的服务控制 </li><li>Tips 17：redis 应用于基于时间顺序的数据操作，而不关注具体时间</li></ul><h2 id="1-2-redis的下载与安装"><a href="#1-2-redis的下载与安装" class="headerlink" title="1.2 redis的下载与安装"></a>1.2 redis的下载与安装</h2><p><strong>参考链接：</strong><a href="https://fangchenyong.top/2019/07/23/install_Redis5.0.3/#9-SpringBoot%E8%BF%9E%E6%8E%A5redis">Centos 7.2 安装目前最新版Redis5.0.3</a></p><h2 id="1-3-redis配置"><a href="#1-3-redis配置" class="headerlink" title="1.3 redis配置"></a>1.3 redis配置</h2><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。</p><h3 id="1-3-1-查看配置"><a href="#1-3-1-查看配置" class="headerlink" title="1.3.1 查看配置"></a>1.3.1 查看配置</h3><p>你可以通过 <strong>CONFIG</strong> 命令查看或设置配置项。</p><p><strong>语法</strong></p><p>Redis CONFIG 命令格式如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET loglevel</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;loglevel&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;notice&quot;</span></span><br></pre></td></tr></table></figure><p>使用 ***** 号获取所有配置项：</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET *</span><br><span class="line"> </span><br><span class="line">  <span class="number">1</span>) <span class="string">&quot;dbfilename&quot;</span></span><br><span class="line">  <span class="number">2</span>) <span class="string">&quot;dump.rdb&quot;</span></span><br><span class="line">  <span class="number">3</span>) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">  <span class="number">4</span>) <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="number">5</span>) <span class="string">&quot;masterauth&quot;</span></span><br><span class="line">  <span class="number">6</span>) <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="number">7</span>) <span class="string">&quot;unixsocket&quot;</span></span><br><span class="line">  <span class="number">8</span>) <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="number">9</span>) <span class="string">&quot;logfile&quot;</span></span><br><span class="line"> <span class="number">10</span>) <span class="string">&quot;&quot;</span></span><br><span class="line"> <span class="number">11</span>) <span class="string">&quot;pidfile&quot;</span></span><br><span class="line"> <span class="number">12</span>) <span class="string">&quot;/var/run/redis.pid&quot;</span></span><br><span class="line"> <span class="number">13</span>) <span class="string">&quot;maxmemory&quot;</span></span><br><span class="line"> <span class="number">14</span>) <span class="string">&quot;0&quot;</span></span><br><span class="line"> <span class="number">15</span>) <span class="string">&quot;maxmemory-samples&quot;</span></span><br><span class="line"> <span class="number">16</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"> <span class="number">17</span>) <span class="string">&quot;timeout&quot;</span></span><br><span class="line"> <span class="number">18</span>) <span class="string">&quot;0&quot;</span></span><br><span class="line"> <span class="number">19</span>) <span class="string">&quot;tcp-keepalive&quot;</span></span><br><span class="line"> <span class="number">20</span>) <span class="string">&quot;0&quot;</span></span><br><span class="line"> <span class="number">21</span>) <span class="string">&quot;auto-aof-rewrite-percentage&quot;</span></span><br><span class="line"> <span class="number">22</span>) <span class="string">&quot;100&quot;</span></span><br><span class="line"> <span class="number">23</span>) <span class="string">&quot;auto-aof-rewrite-min-size&quot;</span></span><br><span class="line"> <span class="number">24</span>) <span class="string">&quot;67108864&quot;</span></span><br><span class="line"> <span class="number">25</span>) <span class="string">&quot;hash-max-ziplist-entries&quot;</span></span><br><span class="line"> <span class="number">26</span>) <span class="string">&quot;512&quot;</span></span><br><span class="line"> <span class="number">27</span>) <span class="string">&quot;hash-max-ziplist-value&quot;</span></span><br><span class="line"> <span class="number">28</span>) <span class="string">&quot;64&quot;</span></span><br><span class="line"> <span class="number">29</span>) <span class="string">&quot;list-max-ziplist-entries&quot;</span></span><br><span class="line"> <span class="number">30</span>) <span class="string">&quot;512&quot;</span></span><br><span class="line"> <span class="number">31</span>) <span class="string">&quot;list-max-ziplist-value&quot;</span></span><br><span class="line"> <span class="number">32</span>) <span class="string">&quot;64&quot;</span></span><br><span class="line"> <span class="number">33</span>) <span class="string">&quot;set-max-intset-entries&quot;</span></span><br><span class="line"> <span class="number">34</span>) <span class="string">&quot;512&quot;</span></span><br><span class="line"> <span class="number">35</span>) <span class="string">&quot;zset-max-ziplist-entries&quot;</span></span><br><span class="line"> <span class="number">36</span>) <span class="string">&quot;128&quot;</span></span><br><span class="line"> <span class="number">37</span>) <span class="string">&quot;zset-max-ziplist-value&quot;</span></span><br><span class="line"> <span class="number">38</span>) <span class="string">&quot;64&quot;</span></span><br><span class="line"> <span class="number">39</span>) <span class="string">&quot;hll-sparse-max-bytes&quot;</span></span><br><span class="line"> <span class="number">40</span>) <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="number">41</span>) <span class="string">&quot;lua-time-limit&quot;</span></span><br><span class="line"> <span class="number">42</span>) <span class="string">&quot;5000&quot;</span></span><br><span class="line"> <span class="number">43</span>) <span class="string">&quot;slowlog-log-slower-than&quot;</span></span><br><span class="line"> <span class="number">44</span>) <span class="string">&quot;10000&quot;</span></span><br><span class="line"> <span class="number">45</span>) <span class="string">&quot;latency-monitor-threshold&quot;</span></span><br><span class="line"> <span class="number">46</span>) <span class="string">&quot;0&quot;</span></span><br><span class="line"> <span class="number">47</span>) <span class="string">&quot;slowlog-max-len&quot;</span></span><br><span class="line"> <span class="number">48</span>) <span class="string">&quot;128&quot;</span></span><br><span class="line"> <span class="number">49</span>) <span class="string">&quot;port&quot;</span></span><br><span class="line"> <span class="number">50</span>) <span class="string">&quot;6379&quot;</span></span><br><span class="line"> <span class="number">51</span>) <span class="string">&quot;tcp-backlog&quot;</span></span><br><span class="line"> <span class="number">52</span>) <span class="string">&quot;511&quot;</span></span><br><span class="line"> <span class="number">53</span>) <span class="string">&quot;databases&quot;</span></span><br><span class="line"> <span class="number">54</span>) <span class="string">&quot;16&quot;</span></span><br><span class="line"> <span class="number">55</span>) <span class="string">&quot;repl-ping-slave-period&quot;</span></span><br><span class="line"> <span class="number">56</span>) <span class="string">&quot;10&quot;</span></span><br><span class="line"> <span class="number">57</span>) <span class="string">&quot;repl-timeout&quot;</span></span><br><span class="line"> <span class="number">58</span>) <span class="string">&quot;60&quot;</span></span><br><span class="line"> <span class="number">59</span>) <span class="string">&quot;repl-backlog-size&quot;</span></span><br><span class="line"> <span class="number">60</span>) <span class="string">&quot;1048576&quot;</span></span><br><span class="line"> <span class="number">61</span>) <span class="string">&quot;repl-backlog-ttl&quot;</span></span><br><span class="line"> <span class="number">62</span>) <span class="string">&quot;3600&quot;</span></span><br><span class="line"> <span class="number">63</span>) <span class="string">&quot;maxclients&quot;</span></span><br><span class="line"> <span class="number">64</span>) <span class="string">&quot;4064&quot;</span></span><br><span class="line"> <span class="number">65</span>) <span class="string">&quot;watchdog-period&quot;</span></span><br><span class="line"> <span class="number">66</span>) <span class="string">&quot;0&quot;</span></span><br><span class="line"> <span class="number">67</span>) <span class="string">&quot;slave-priority&quot;</span></span><br><span class="line"> <span class="number">68</span>) <span class="string">&quot;100&quot;</span></span><br><span class="line"> <span class="number">69</span>) <span class="string">&quot;min-slaves-to-write&quot;</span></span><br><span class="line"> <span class="number">70</span>) <span class="string">&quot;0&quot;</span></span><br><span class="line"> <span class="number">71</span>) <span class="string">&quot;min-slaves-max-lag&quot;</span></span><br><span class="line"> <span class="number">72</span>) <span class="string">&quot;10&quot;</span></span><br><span class="line"> <span class="number">73</span>) <span class="string">&quot;hz&quot;</span></span><br><span class="line"> <span class="number">74</span>) <span class="string">&quot;10&quot;</span></span><br><span class="line"> <span class="number">75</span>) <span class="string">&quot;no-appendfsync-on-rewrite&quot;</span></span><br><span class="line"> <span class="number">76</span>) <span class="string">&quot;no&quot;</span></span><br><span class="line"> <span class="number">77</span>) <span class="string">&quot;slave-serve-stale-data&quot;</span></span><br><span class="line"> <span class="number">78</span>) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> <span class="number">79</span>) <span class="string">&quot;slave-read-only&quot;</span></span><br><span class="line"> <span class="number">80</span>) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> <span class="number">81</span>) <span class="string">&quot;stop-writes-on-bgsave-error&quot;</span></span><br><span class="line"> <span class="number">82</span>) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> <span class="number">83</span>) <span class="string">&quot;daemonize&quot;</span></span><br><span class="line"> <span class="number">84</span>) <span class="string">&quot;no&quot;</span></span><br><span class="line"> <span class="number">85</span>) <span class="string">&quot;rdbcompression&quot;</span></span><br><span class="line"> <span class="number">86</span>) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> <span class="number">87</span>) <span class="string">&quot;rdbchecksum&quot;</span></span><br><span class="line"> <span class="number">88</span>) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> <span class="number">89</span>) <span class="string">&quot;activerehashing&quot;</span></span><br><span class="line"> <span class="number">90</span>) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> <span class="number">91</span>) <span class="string">&quot;repl-disable-tcp-nodelay&quot;</span></span><br><span class="line"> <span class="number">92</span>) <span class="string">&quot;no&quot;</span></span><br><span class="line"> <span class="number">93</span>) <span class="string">&quot;aof-rewrite-incremental-fsync&quot;</span></span><br><span class="line"> <span class="number">94</span>) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> <span class="number">95</span>) <span class="string">&quot;appendonly&quot;</span></span><br><span class="line"> <span class="number">96</span>) <span class="string">&quot;no&quot;</span></span><br><span class="line"> <span class="number">97</span>) <span class="string">&quot;dir&quot;</span></span><br><span class="line"> <span class="number">98</span>) <span class="string">&quot;/home/deepak/Downloads/redis-2.8.13/src&quot;</span></span><br><span class="line"> <span class="number">99</span>) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line"><span class="number">100</span>) <span class="string">&quot;volatile-lru&quot;</span></span><br><span class="line"><span class="number">101</span>) <span class="string">&quot;appendfsync&quot;</span></span><br><span class="line"><span class="number">102</span>) <span class="string">&quot;everysec&quot;</span></span><br><span class="line"><span class="number">103</span>) <span class="string">&quot;save&quot;</span></span><br><span class="line"><span class="number">104</span>) <span class="string">&quot;3600 1 300 100 60 10000&quot;</span></span><br><span class="line"><span class="number">105</span>) <span class="string">&quot;loglevel&quot;</span></span><br><span class="line"><span class="number">106</span>) <span class="string">&quot;notice&quot;</span></span><br><span class="line"><span class="number">107</span>) <span class="string">&quot;client-output-buffer-limit&quot;</span></span><br><span class="line"><span class="number">108</span>) <span class="string">&quot;normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60&quot;</span></span><br><span class="line"><span class="number">109</span>) <span class="string">&quot;unixsocketperm&quot;</span></span><br><span class="line"><span class="number">110</span>) <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="number">111</span>) <span class="string">&quot;slaveof&quot;</span></span><br><span class="line"><span class="number">112</span>) <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">113</span>) <span class="string">&quot;notify-keyspace-events&quot;</span></span><br><span class="line"><span class="number">114</span>) <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">115</span>) <span class="string">&quot;bind&quot;</span></span><br><span class="line"><span class="number">116</span>) <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-编辑配置"><a href="#1-3-2-编辑配置" class="headerlink" title="1.3.2 编辑配置"></a>1.3.2 编辑配置</h3><p>你可以通过修改 redis.conf 文件或使用 <strong>CONFIG set</strong> 命令来修改配置。</p><p><strong>语法</strong></p><p><strong>CONFIG SET</strong> 命令基本语法：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG <span class="built_in">SET</span> CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG <span class="built_in">SET</span> loglevel <span class="string">&quot;notice&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET loglevel</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;loglevel&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;notice&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3-参数说明"><a href="#1-3-3-参数说明" class="headerlink" title="1.3.3 参数说明"></a>1.3.3 参数说明</h3><p>redis.conf 配置项说明如下：</p><ol><li><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">daemonize</span> <span class="string">no</span></span><br></pre></td></tr></table></figure></li><li><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">pidfile</span> <span class="string">/var/run/redis.pid</span></span><br></pre></td></tr></table></figure></li><li><p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br></pre></td></tr></table></figure></li><li><p>绑定的主机地址</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">bind</span> <span class="string">127.0.0.1</span></span><br></pre></td></tr></table></figure></li><li><p>当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">timeout</span> <span class="string">300</span></span><br></pre></td></tr></table></figure></li><li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">loglevel</span> <span class="string">verbose</span></span><br></pre></td></tr></table></figure></li><li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logfile</span> <span class="string">stdout</span></span><br></pre></td></tr></table></figure></li><li><p>设置数据库的数量，默认数据库为0，可以使用SELECT <code>&lt;dbid&gt;</code>命令在连接上指定数据库id</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">databases</span> <span class="string">16</span></span><br></pre></td></tr></table></figure></li><li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">save</span> <span class="string">&lt;seconds&gt; &lt;changes&gt;</span></span><br></pre></td></tr></table></figure><p>Redis默认配置文件中提供了三个条件：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">save</span> <span class="string">900 1  #900秒（15分钟）内有1个更改</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10     #300秒（5分钟）内有10个更改</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000#60秒内有10000个更改</span></span><br></pre></td></tr></table></figure></li><li><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure></li><li><p>指定本地数据库文件名，默认值为dump.rdb</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br></pre></td></tr></table></figure></li><li><p>指定本地数据库存放目录</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dir</span> <span class="string">./</span></span><br></pre></td></tr></table></figure></li><li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">slaveof</span> <span class="string">&lt;masterip&gt; &lt;masterport&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>当master服务设置了密码保护时，slav服务连接master的密码</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">masterauth</span> <span class="string">&lt;master-password&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <code>&lt;password&gt;</code>命令提供密码，默认关闭</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">requirepass</span> <span class="string">foobared</span></span><br></pre></td></tr></table></figure></li><li><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxclients</span> <span class="string">128</span></span><br></pre></td></tr></table></figure></li><li><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxmemory</span> <span class="string">&lt;bytes&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">appendonly</span> <span class="string">no</span></span><br></pre></td></tr></table></figure></li><li><p>指定更新日志文件名，默认为appendonly.aof</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">appendfilename</span> <span class="string">appendonly.aof</span></span><br></pre></td></tr></table></figure></li><li><p>指定更新日志条件，共有3个可选值：     <strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）     <strong>always</strong>：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）     <strong>everysec</strong>：表示每秒同步一次（折衷，默认值）</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec</span></span><br></pre></td></tr></table></figure></li><li><p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">vm-enabled</span> <span class="string">no</span></span><br></pre></td></tr></table></figure></li><li><p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">vm-swap-file</span> <span class="string">/tmp/redis.swap</span></span><br></pre></td></tr></table></figure></li><li><p>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p> <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">vm-max-memory</span> <span class="string">0</span></span><br></pre></td></tr></table></figure></li><li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">vm-page-size</span> <span class="string">32</span></span><br></pre></td></tr></table></figure></li><li><p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">vm-pages</span> <span class="string">134217728</span></span><br></pre></td></tr></table></figure></li><li><p>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">vm-max-threads</span> <span class="string">4</span></span><br></pre></td></tr></table></figure></li><li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">glueoutputbuf</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure></li><li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">hash-max-zipmap-entries</span> <span class="string">64</span></span><br><span class="line"><span class="meta">hash-max-zipmap-value</span> <span class="string">512</span></span><br></pre></td></tr></table></figure></li><li><p>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">activerehashing</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure></li><li><p>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">include</span> <span class="string">/path/to/local.conf</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="1-4-redis数据类型"><a href="#1-4-redis数据类型" class="headerlink" title="1.4 redis数据类型"></a>1.4 redis数据类型</h2><h3 id="1-4-1-String（字符串）"><a href="#1-4-1-String（字符串）" class="headerlink" title="1.4.1 String（字符串）"></a>1.4.1 String（字符串）</h3><p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p><p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p><p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">SET</span> name <span class="string">&quot;redis.net.cn&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET name</span><br><span class="line"><span class="string">&quot;redis.net.cn&quot;</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们使用了 Redis 的 <strong>SET</strong> 和 <strong>GET</strong> 命令。键为 name，对应的值为redis.net.cn。</p><p><strong>注意：</strong>一个键最大能存储512MB。</p><h3 id="1-4-2-Hash（哈希）"><a href="#1-4-2-Hash（哈希）" class="headerlink" title="1.4.2 Hash（哈希）"></a>1.4.2 Hash（哈希）</h3><p>Redis hash 是一个键值对集合。</p><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HMSET user:<span class="number">1</span> username redis.net.cn password redis.net.cn points <span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGETALL user:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;username&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;redis.net.cn&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;password&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;redis.net.cn&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;points&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;200&quot;</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><p>以上实例中 hash 数据类型存储了包含用户脚本信息的用户对象。 实例中我们使用了 Redis <strong>HMSET, HEGTALL</strong> 命令，<strong>user:1</strong> 为键值。</p><p>每个 hash 可以存储 2^(32 - 1)键值对（40多亿）。</p><h3 id="1-4-3-List（列表）"><a href="#1-4-3-List（列表）" class="headerlink" title="1.4.3 List（列表）"></a>1.4.3 List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush redis.net.cn redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush redis.net.cn mongodb</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush redis.net.cn rabitmq</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange redis.net.cn <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;redis&quot;</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h3 id="1-4-4-Set（集合）"><a href="#1-4-4-Set（集合）" class="headerlink" title="1.4.4 Set（集合）"></a>1.4.4 Set（集合）</h3><p>Redis的Set是string类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p><strong>sadd 命令</strong></p><p>添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0,key对应的set不存在返回错误。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sadd key member</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn rabitmq</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn rabitmq</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers redis.net.cn</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;rabitmq&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-5-zset-sorted-set：有序集合"><a href="#1-4-5-zset-sorted-set：有序集合" class="headerlink" title="1.4.5 zset(sorted set：有序集合)"></a>1.4.5 zset(sorted set：有序集合)</h3><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><p><strong>zadd 命令</strong></p><p>添加元素到集合，元素在集合中存在则更新对应score</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">zadd key score member </span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> rabitmq</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> rabitmq</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGEBYSCORE redis.net.cn <span class="number">0</span> <span class="number">1000</span></span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;rabitmq&quot;</span></span><br></pre></td></tr></table></figure><h1 id="2-redis命令"><a href="#2-redis命令" class="headerlink" title="2.redis命令"></a>2.<a href="http://doc.redisfans.com/">redis命令</a></h1><h2 id="2-1-如何执行命令"><a href="#2-1-如何执行命令" class="headerlink" title="2.1 如何执行命令"></a>2.1 如何执行命令</h2><h3 id="2-1-1-在本地连接执行命令"><a href="#2-1-1-在本地连接执行命令" class="headerlink" title="2.1.1 在本地连接执行命令"></a>2.1.1 在本地连接执行命令</h3><p>Redis 命令用于在 redis 服务上执行操作。</p><p>要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</p><p><strong>语法</strong></p><p>Redis 客户端的基本语法为：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> redis<span class="literal">-cli</span></span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>以下实例讲解了如何启动 redis 客户端：</p><p>启动 redis 客户端，打开终端并输入命令 <strong>redis-cli</strong>。该命令会连接本地的 redis 服务。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$redis</span><span class="literal">-cliredis</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PING PONG</span><br></pre></td></tr></table></figure><p>在以上实例中我们连接到本地的 redis 服务并执行 <strong>PING</strong> 命令，该命令用于检测 redis 服务是否启动。</p><hr><h3 id="2-2-2-在远程服务上执行命令"><a href="#2-2-2-在远程服务上执行命令" class="headerlink" title="2.2.2 在远程服务上执行命令"></a>2.2.2 在远程服务上执行命令</h3><p>如果需要在远程 redis 服务上执行命令，同样我们使用的也是 <strong>redis-cli</strong> 命令。</p><p><strong>语法</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> redis<span class="literal">-cli</span> <span class="literal">-h</span> host <span class="literal">-p</span> port <span class="literal">-a</span> password</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$redis</span><span class="literal">-cli</span> <span class="literal">-h</span> <span class="number">127.0</span>.<span class="number">0.1</span> <span class="literal">-p</span> <span class="number">6379</span> <span class="literal">-a</span> <span class="string">&quot;mypass&quot;</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PING</span><br><span class="line"> </span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h2 id="2-2-key（键）"><a href="#2-2-key（键）" class="headerlink" title="2.2 key（键）"></a>2.2 key（键）</h2><p>Redis 键命令用于管理 redis 的键。</p><p><strong>语法</strong></p><p>Redis 键命令的基本语法如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">SET</span> mykey redis</span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">DEL</span> mykey</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在以上实例中 <strong>DEL</strong> 是一个命令， <strong>mykey</strong> 是一个键。 如果键被删除成功，命令执行后输出 <strong>(integer) 1</strong>，否则将输出 <strong>(integer) 0</strong></p><p><strong>下表给出了与 Redis 键相关常用的基本命令：</strong></p><table><thead><tr><th><strong>命令</strong></th><th><strong>语法(可用版本)</strong></th><th><strong>返回值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>DEL</strong></td><td><strong><font size=2 color='red'>DEL KEY_NAME（&gt;= 1.0.0）</font></strong></td><td><strong><font size=2>被删除 <code>key</code> 的数量。</font></strong></td><td><strong><font size=2>删除存在的<code>key</code>，不存在就忽略。</font></strong></td></tr><tr><td><strong>DUMP</strong></td><td><font size=2 color='red'><strong>DUMP KEY_NAME（&gt;= 2.6.0）</strong></font></td><td><strong><font size=2><code>key</code>不存在，返回 <code>nil</code> 。否则，返回序列化之后的值。</font></strong></td><td><strong><font size=2>序列化给定 <code>key</code> 并返回值</font></strong></td></tr><tr><td><strong>EXISTS</strong></td><td><font size=2 color='red'><strong>EXISTS KEY_NAME（&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>存在返回 <code>1 </code>，否则返回 <code>0 </code>。</font></strong></td><td><strong><font size=2>检查给定<code>key</code>是否存在。</font></strong></td></tr><tr><td><strong>EXPIRE</strong></td><td><font size=2 color='red'><strong>EXPIRE KEY_NAME         TIME_IN_SECONDS         （&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>设置成功返回 <code>1</code> 。 不存在或者不能设置过期时间时(低于 2.1.3 版本)返回 <code>0 </code>。</font></strong></td><td><strong><font size=2>设置<code>key</code>的过期时间，<code>key</code> 过期后将不再可用。</font></strong></td></tr><tr><td><strong>EXPIREAT</strong></td><td><font size=2 color='red'><strong>EXPIREAT KEY_NAME TIME_IN_UNIX_TIMESTAMP（&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>设置成功返回<code>1</code>。 不存在或者不能设置过期时间时(低于 2.1.3 版本)返回<code>0</code>。</font></strong></td><td><strong><font size=2>以 UNIX 时间戳(unix timestamp)格式设置<code>key</code>的过期时间。过期后将不再可用。</font></strong></td></tr><tr><td><strong>KEYS</strong></td><td><font size=2 color='red'><strong>KEYS PATTERN（&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>符合给定模式的 <code>key </code>列表 (Array)。</font></strong></td><td><strong><font size=2>用于查找所有符合给定模式 <code>pattern</code> 的 <code>key</code></font></strong></td></tr><tr><td><strong>MIGRATE</strong></td><td><font size=2 color='red'><strong>MIGRATE HOST PORT KEY_NAME DESTINATION-DB TIMEOUT [COPY] [REPLACE]（&gt;= 2.6.0）</strong></font></td><td><strong><font size=2>迁移成功时返回 <code>OK</code>，否则返回相应的错误。</font></strong></td><td><strong><font size=2>将 <code>key</code>原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， <code>key</code> 保证会出现在目标实例上，而当前实例上的 <code>key</code>会被删除。</font></strong></td></tr><tr><td><strong>MOVE</strong></td><td><font size=2 color='red'><strong>MOVE KEY_NAME DESTINATION_DATABASE （&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>移动成功返回 <code>1 </code>，失败则返回<code>0</code>。</font></strong></td><td><strong><font size=2>将当前数据库的<code> key</code> 移动到给定的数据库<code>db</code>当中。</font></strong></td></tr><tr><td><strong>PERSIST</strong></td><td><font size=2 color='red'><strong>PERSIST KEY_NAME（&gt;= 2.2.0）</strong></font></td><td><strong><font size=2>当过期时间移除成功时，返回 <code>1 </code>。 如果<code>key</code>不存在或 <code>key</code> 没有设置过期时间，返回<code>0</code>。</font></strong></td><td><strong><font size=2>移除给定 <code>key</code> 的过期时间，使得 key 永不过期。</font></strong></td></tr><tr><td><strong>PEXPIRE</strong></td><td><font size=2 color='red'><strong>PEXPIREAT KEY_NAME TIME_IN_MILLISECONDS_IN_UNIX_TIMESTAMP （&gt;= 2.6.0）</strong></font></td><td><strong><font size=2>设置成功返回<code>1</code>。 当<code>key</code>不存在或者不能为 <code>key </code>设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 <code>key</code> 的过期时间)返回 <code>0</code> 。</font></strong></td><td><strong><font size=2>用于设置 <code>key</code> 的过期时间，以毫秒记。<code>key </code>过期后将不再可用。</font></strong></td></tr><tr><td><strong>PEXPIREAT</strong></td><td><font size=2 color='red'><strong>PEXPIREAT KEY_NAME TIME_IN_MILLISECONDS_IN_UNIX_TIMESTAMP （&gt;= 2.6.0）</strong></font></td><td><strong><font size=2>设置成功返回 <code>1</code> 。 当 <code>key</code> 不存在或者不能为<code> key</code> 设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 <code>key </code>的过期时间)返回 <code>0 </code>。</font></strong></td><td><strong><font size=2>用于设置<code> key</code> 的过期时间，以毫秒记。<code>key </code>过期后将不再可用。</font></strong></td></tr><tr><td><strong>PTTL</strong></td><td><font size=2 color='red'><strong>PTTL KEY_NAME（&gt;= 2.6.0）</strong></font></td><td><strong><font size=2>当 <code>key </code>不存在时，返回 <code>-2 </code>。 当 <code>key </code>存在但没有设置剩余生存时间时，返回 <code>-1 </code>。 否则，以毫秒为单位，返回的剩余生存时间。</font></strong></td><td><strong><font size=2>以毫秒为单位返回 <code>key</code> 的剩余过期时间。<br />注意：在 Redis 2.8 以前，当 <code>key</code> 不存在，或者 <code>key</code> 没有设置剩余生存时间时，命令都返回<code>-1</code>。</font></strong></td></tr><tr><td><strong>RANDOMKEY</strong></td><td><font size=2 color='red'><strong>RANDOMKEY（&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>当数据库不为空时，返回一个<code> key</code> 。 当数据库为空时，返回<code>nil</code>。</font></strong></td><td><strong><font size=2>从当前数据库中随机返回一个 <code>key </code>。</font></strong></td></tr><tr><td><strong>RENAME</strong></td><td><font size=2 color='red'><strong>RENAME OLD_KEY_NAME NEW_KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>改名成功时返回<code>OK </code>，失败时候返回一个错误。当 <code>OLD_KEY_NAME </code>和 <code>NEW_KEY_NAME</code> 相同，或者 <code>OLD_KEY_NAME </code>不存在时，返回一个错误。 当 <code>NEW_KEY_NAME</code> 已经存在时， <code>RENAME</code> 命令将覆盖旧值。</font></strong></td><td><strong><font size=2>用于修改<code>key</code>的名称 </font></strong></td></tr><tr><td><strong>RENAMENX</strong></td><td><font size=2 color='red'><strong>RENAMENX OLD_KEY_NAME NEW_KEY_NAME（&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>修改成功时，返回 <code>1</code> 。 如果 <code>NEW_KEY_NAME </code>已经存在，返回<code>0</code>。</font></strong></td><td><strong><font size=2>用于在新的 <code>key </code>不存在时修改<code>key</code>的名称 。</font></strong></td></tr><tr><td><strong>SORT</strong></td><td><font size=2 color='red'><strong>SORT KEY [BY PATTERN] [LIMIT OFFSET COUNT] [GET PATTERN [GET PATTERN …]] [ASC|DESC] [ALPHA] [STORE DESTINATION]</strong></font></td><td><strong><a href="http://doc.redisfans.com/key/sort.html">较为复杂见文档</a></strong></td><td><strong><a href="http://doc.redisfans.com/key/sort.html">较为复杂见文档</a></strong></td></tr><tr><td><strong>TTL</strong></td><td><font size=2 color='red'><strong>TTL KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>当 <code>key </code>不存在时，返回<code> -2</code> 。 当 <code>key </code>存在但没有设置剩余生存时间时，返回 <code>-1 </code>。 否则，以秒为单位，返回剩余生存时间。</font></strong></td><td><strong><font size=2>以秒为单位返回 <code>key </code>的剩余过期时间。<br />注意：在 Redis 2.8 以前，当 <code>key </code>不存在，或者<code>key</code>没有设置剩余生存时间时，命令都返回 <code>-1 </code>。</font></strong></td></tr><tr><td><strong>TYPE</strong></td><td><font size=2 color='red'><strong>TYPE KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><strong><font size=2>返回数据类型有：<code>none</code> (key不存在) <code>string </code>(字符串)       <code>list </code>(列表)                 <code>set </code>(集合)             <code>zset</code> (有序集)          <code>hash </code>(哈希表)</font></strong></td><td><font size=2><strong>返回<code>key</code>所储存的值的类型</strong>。</font></td></tr></tbody></table><h2 id="2-3-String（字符串）"><a href="#2-3-String（字符串）" class="headerlink" title="2.3 String（字符串）"></a>2.3 String（字符串）</h2><p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：</p><p><strong>语法</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">SET</span> mykey redis </span><br><span class="line">OK </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET mykey </span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们使用了 <strong>SET</strong> 和 <strong>GET</strong> 命令，键为 mykey。</p><p><strong>下表给出了与 Redis字符串相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>APPEND</strong></td><td><font size=2 color='red'><strong>APPEND KEY_NAME NEW_VALUE（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>追加指定值之后，<code> key</code> 中字符串的长度。</strong></font></td><td><font size=2><strong>如果 <code>key </code>已经存在并且是一个字符串， <code>APPEND </code>命令将<code>value</code>追加到 <code>key </code>原来的值的末尾。                                        如果 <code>key </code>不存在， <code>APPEND</code> 就简单地将给定 <code>key</code> 设为 <code>value </code>，就像执行 <code>SET key value </code>一样。</strong></font></td></tr><tr><td><strong>BITCOUNT</strong></td><td><font size=2 color='red'><strong>BITCOUNT key [start] [end]（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>被设置为 <code>1</code> 的位的数量。</strong></font></td><td><font size=2><strong>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行。不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 <code>0</code> 。</strong></font></td></tr><tr><td><strong>BITOP</strong></td><td><font size=2 color='red'><strong>BITOP operation destkey key [key …]（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>保存到 <code>destkey</code> 的字符串的长度，和输入 <code>key</code> 中最长的字符串长度相等。</strong></font></td><td><font size=2><strong>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。</strong></font></td></tr><tr><td><strong>DECR</strong></td><td><font size=2 color='red'><strong>DECR KEY_NAME（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>执行命令之后 <code>key</code> 的值。</strong></font></td><td><font size=2><strong>将 <code>key </code>中储存的数字值减一。             如果 <code>key</code> 不存在，<code>key</code> 的值会先被初始化为<code> 0</code> ，然后再执行 <code>DECR </code>操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>DECRBY</strong></td><td><font size=2 color='red'><strong>DECRBY KEY_NAME DECREMENT_AMOUNT （&gt;=1.0.0）</strong></font></td><td><font size=2><strong>减去指定减量值之后，<code>key</code>的值。</strong></font></td><td><font size=2><strong>将 <code>key</code>所储存的值减去指定的减量值。如果 <code>key</code>不存在，<code>key</code>的值会先被初始化为 <code>0</code> ，然后再执行 <code>DECRBY</code> 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>GET</strong></td><td><font size=2 color='red'><strong>GET KEY_NAME（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>返回<code> key</code> 的值，如果 <code>key</code> 不存在时，返回 <code>nil</code>。 如果 <code>key</code> 不是字符串类型，那么返回一个错误。</strong></font></td><td><font size=2><strong>获取指定 <code>key</code> 的值。 如果 <code>key</code> 不存在，返回 <code>nil </code>。 如果<code>key </code>储存的值不是字符串类型，返回一个错误。</strong></font></td></tr><tr><td><strong>GETBIT</strong></td><td><font size=2 color='red'><strong>GETBIT KEY_NAME OFFSET（&gt;=2.4.0）</strong></font></td><td><font size=2><strong>字符串值指定偏移量上的位(bit)。当偏移量 <code>OFFSET</code> 比字符串值的长度大，或者 <code>key </code>不存在时，返回 <code>0 </code>。</strong></font></td><td><font size=2><strong>对 <code>key </code>所储存的字符串值，获取指定偏移量上的位(bit)。</strong></font></td></tr><tr><td><strong>GETRANGE</strong></td><td><font size=2 color='red'><strong>GETRANGE KEY_NAME START END（&gt;=2.4.0）</strong></font></td><td><font size=2><strong>截取得到的子字符串。</strong></font></td><td><font size=2><strong>获取存储在指定 <code>key </code>中字符串的子字符串。字符串的截取范围由 <code>start </code>和<code>end</code>两个偏移量决定(包括 <code>start </code>和 <code>end</code> 在内)。</strong></font></td></tr><tr><td><strong>GETSET</strong></td><td><font size=2 color='red'><strong>GETSET KEY_NAME VALUE（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>返回给定 <code>key </code>的旧值。 当 <code>key</code> 没有旧值时，即<code>key</code>不存在时，返回 <code>nil</code> 。当 <code>key </code>存在但不是字符串类型时，返回一个错误。</strong></font></td><td><font size=2><strong>设置指定<code> key</code> 的值，并返回 <code>key </code>旧的值。</strong></font></td></tr><tr><td><strong>INCR</strong></td><td><font size=2 color='red'><strong>INCR KEY_NAME（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>执行 <code>INCR</code> 命令之后 <code>key </code>的值。</strong></font></td><td><font size=2><strong>将 <code>key </code>中储存的数字值增一。如果 <code>key</code> 不存在，那么 <code>key </code>的值会先被初始化为 <code>0</code> ，然后再执行 <code>INCR</code> 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>INCRBY</strong></td><td><font size=2 color='red'><strong>INCRBY KEY_NAME INCR_AMOUNT（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>加上指定的增量值之后，<code>key</code>的值。</strong></font></td><td><font size=2><strong>将 <code>key </code>中储存的数字加上指定的增量值。如果 <code>key</code> 不存在，那么 <code>key</code> 的值会先被初始化为 <code>0 </code>，然后再执行 <code>INCRBY</code> 命令。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>INCRBYFLOAT</strong></td><td><font size=2 color='red'><strong>INCRBYFLOAT KEY_NAME INCR_AMOUNT（&gt;=2.6.0）</strong></font></td><td><font size=2><strong>执行命令之后 <code>key </code>的值。</strong></font></td><td><font size=2><strong>为 <code>key</code> 中所储存的值加上指定的浮点数增量值。如果 <code>key </code>不存在，那么 <code>INCRBYFLOAT</code> 会先将 <code>key</code> 的值设为 <code>0 </code>，再执行加法操作。</strong></font></td></tr><tr><td><strong>MGET</strong></td><td><font size=2 color='red'><strong>MGET KEY1 KEY2 .. KEYN（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>一个包含所有给定 <code>key</code> 的值的列表。</strong></font></td><td><font size=2><strong>如果给定的 <code>key </code>里面，有某个<code> key</code> 不存在，那么这个<code> key</code> 返回特殊值 <code>nil</code> 。</strong></font></td></tr><tr><td><strong>MSET</strong></td><td><font size=2 color='red'><strong>MSET key1 value1 key2 value2 .. keyN valueN（&gt;=1.0.1）</strong></font></td><td><font size=2><strong>总是返回 <code>OK</code> 。</strong></font></td><td><font size=2><strong>同时设置一个或多个 <code>key</code>-<code>value</code> 对。</strong></font></td></tr><tr><td><strong>MSETNX</strong></td><td><font size=2 color='red'><strong>MSETNX key1 value1 key2 value2 .. keyN valueN（&gt;=1.0.1）</strong></font></td><td><font size=2><strong>当所有<code>key</code>都成功设置，返回 <code>1</code> 。 如果所有给定 <code>key </code>都设置失败(至少有一个<code> key</code> 已经存在)，那么返回 <code>0 </code>。</strong></font></td><td><font size=2><strong>所有给定 <code>key </code>都不存在时，同时设置一个或多个 <code>key</code>-<code>value</code> 对。</strong></font></td></tr><tr><td><strong>PSETEX</strong></td><td><font size=2 color='red'><strong>PSETEX key1 EXPIRY_IN_MILLISECONDS value1 （&gt;=2.6.0）</strong></font></td><td><font size=2><strong>总是返回 <code>OK</code> 。</strong></font></td><td><font size=2><strong>以毫秒为单位设置<code> key</code> 的生存时间。</strong></font></td></tr><tr><td><strong>SET</strong></td><td><font size=2 color='red'><strong>SET KEY_NAME VALUE（&gt;=1.0.0）</strong></font></td><td><strong><font size=2>在 2.6.12 以前版本， <code>SET </code>命令总是返回 <code>OK</code> 。从 Redis 2.6.12 版本开始， <code>SET</code> 在设置操作成功完成时，才返回 <code>OK</code> </font></strong></td><td><font size=2><strong>用于设置给定<code> key</code> 的值。如果 <code>key </code>已经存储其他值， <code>SET </code>就覆写旧值，且无视类型。</strong></font></td></tr><tr><td><strong>SETBIT</strong></td><td><font size=2 color='red'><strong>Setbit KEY_NAME OFFSET（&gt;=2.2.0）</strong></font></td><td><font size=2><strong>指定偏移量原来储存的位。</strong></font></td><td><font size=2><strong>对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</strong></font></td></tr><tr><td><strong>SETEX</strong></td><td><font size=2 color='red'><strong>SETEX KEY_NAME TIMEOUT VALUE（&gt;=2.0.0）</strong></font></td><td><font size=2><strong>成功返回 <code>OK</code> 。</strong></font></td><td><font size=2><strong>为指定的 <code>key </code>设置值及其过期时间。如果 <code>key</code> 已经存在， <code>SETEX</code> 命令将会替换旧的值。</strong></font></td></tr><tr><td><strong>SETNX</strong></td><td><font size=2 color='red'><strong>SETNX KEY_NAME VALUE（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>成功返回 <code>1</code> 。  失败返回<code> 0</code> 。</strong></font></td><td><font size=2><strong><code>Setnx</code>（SET if Not eXists） 命令在指定的<code>key</code>不存在时，为 <code>key</code> 设置指定的值。</strong></font></td></tr><tr><td><strong>SETRANGE</strong></td><td><font size=2 color='red'><strong>SETRANGE KEY_NAME OFFSET VALUE（&gt;=2.2.0）</strong></font></td><td><font size=2><strong>被修改后的字符串长度。</strong></font></td><td><font size=2><strong>用指定的字符串覆盖给定 <code>key</code> 所储存的字符串值，覆盖的位置从偏移量 <code>offset</code> 开始。</strong></font></td></tr><tr><td><strong>STRLEN</strong></td><td><font size=2 color='red'><strong>STRLEN KEY_NAME（&gt;=2.2.0）</strong></font></td><td><font size=2><strong>字符串值的长度。 当<code>key</code> 不存在时，返回 <code>0</code>。</strong></font></td><td><font size=2><strong>用于获取指定 <code>key</code> 所储存的字符串值的长度。当 <code>key</code> 储存的不是字符串值时，返回一个错误。</strong></font></td></tr></tbody></table><h2 id="2-4-Hash（哈希）"><a href="#2-4-Hash（哈希）" class="headerlink" title="2.4 Hash（哈希）"></a>2.4 Hash（哈希）</h2><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>Redis 中每个 hash 可以存储 2^(32 - 1 )键值对（40多亿）。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HMSET mykey name <span class="string">&quot;redis tutorial&quot;</span> description <span class="string">&quot;redis basic commands for caching&quot;</span> likes <span class="number">20</span> visitors <span class="number">23000</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGETALL mykey</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;redis tutorial&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;description&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;redis basic commands for caching&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;likes&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">7</span>) <span class="string">&quot;visitors&quot;</span></span><br><span class="line"><span class="number">8</span>) <span class="string">&quot;23000&quot;</span></span><br></pre></td></tr></table></figure><p>在以上实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 mykey 中。</p><p><strong>下表给出了与 Redis哈希相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>HDEL</strong></td><td><font size=2 color='red'><strong>HDEL KEY_NAME FIELD1.. FIELDN      （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>被成功删除字段的数量，不包括被忽略的字段。</strong></font></td><td><font size=2><strong>用于删除哈希表<code>key</code>中的一个或多个指定字段，不存在的字段将被忽略。</strong></td></tr><tr><td><strong>HEXISTS</strong></td><td><font size=2 color='red'><strong>HEXISTS KEY_NAME FIELD_NAME   （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>如果哈希表含有给定字段，返回 <code>1 </code>。 如果哈希表不含有给定字段，或 key 不存在，返回 <code>0 </code>。</strong></font></td><td><font size=2><strong>查看哈希表的指定字段是否存在。</strong></font></td></tr><tr><td><strong>HGET</strong></td><td><font size=2 color='red'><strong>HGET KEY_NAME FIELD_NAME    （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>返回给定字段的值。如果给定的字段或 <code>key </code>不存在时，返回 <code>nil</code> 。</strong></font></td><td><font size=2><strong>返回哈希表中指定字段的值。</strong></font></td></tr><tr><td><strong>HGETALL</strong></td><td><font size=2 color='red'><strong>HGETALL KEY_NAME        （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>以列表形式返回哈希表的字段及字段值。 若 <code>key </code>不存在，返回空列表。</strong></font></td><td><font size=2><strong>返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。</strong></font></td></tr><tr><td><strong>HINCRBY</strong></td><td><font size=2 color='red'><strong>HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER  （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>执行 <code>HINCRBY</code> 命令之后，哈希表中字段的值。</strong></font></td><td><font size=2><strong>用于为哈希表中的字段值加上指定增量值。增量也可以为负数，相当于对指定字段进行减法操作。如果哈希表的 <code>key</code> 不存在，一个新的哈希表被创建并执行 <code>HINCRBY</code> 命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 <code>0 </code>。对一个储存字符串值的字段执行 <code>HINCRBY</code> 命令将造成一个错误。本操作的值被限制在 64 位(bit)有符号数字表示之内。</strong></font></td></tr><tr><td><strong>HINCRBYFLOAT</strong></td><td><font size=2 color='red'><strong>HINCRBYFLOAT KEY_NAME FIELD_NAME INCR_BY_NUMBER （&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>执行 <code>Hincrbyfloat </code>命令之后，哈希表中字段的值。</strong></font></td><td><font size=2><strong>为哈希表中的字段值加上指定浮点数增量值。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 <code>0</code> 。</strong></font></td></tr><tr><td><strong>HKEYS</strong></td><td><font size=2 color='red'><strong>HKEYS KEY_NAME FIELD_NAME INCR_BY_NUMBER （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>包含哈希表中所有字段的列表。  <code>key</code> 不存在时，返回空列表。</strong></font></td><td><font size=2><strong>获取哈希表中的所有字段名。</strong></font></td></tr><tr><td><strong>HLEN</strong></td><td><font size=2 color='red'><strong>HLEN KEY_NAME （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>哈希表中字段的数量。 <code>key</code>不存在时，返回 0 。</strong></font></td><td><font size=2><strong>获取哈希表中字段的数量。</strong></font></td></tr><tr><td><strong>HMGET</strong></td><td><font size=2 color='red'><strong>HMGET KEY_NAME FIELD1…FIELDN （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。</strong></font></td><td><font size=2><strong>返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 <code>nil </code>值。</strong></font></td></tr><tr><td><strong>HMSET</strong></td><td><font size=2 color='red'><strong>HMSET KEY_NAME FIELD1 VALUE1 …FIELDN VALUEN （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>如果命令执行成功，返回 <code>OK</code> 。</strong></font></td><td><font size=2><strong>同时将多个 <code>field</code>-<code>value</code> (字段-值)对设置到哈希表中。此命令会覆盖哈希表中已存在的字段。如果哈希表不存在，会创建一个空哈希表，并执行 <code>HMSET</code> 操作。</strong></font></td></tr><tr><td><strong>HSET</strong></td><td><font size=2 color='red'><strong>HSET KEY_NAME FIELD VALUE     （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>如果字段是哈希表中的一个新建字段，并且值设置成功，返回 <code>1</code> 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 <code>0</code> 。</strong></font></td><td><font size=2><strong>为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 <code>HSET </code>操作。如果字段已经存在于哈希表中，旧值将被覆盖。</strong></font></td></tr><tr><td><strong>HSETNX</strong></td><td><font size=2 color='red'><strong>HSETNX KEY_NAME FIELD VALUE                  （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>设置成功返回 <code>1</code> 。 如果给定字段已经存在且没有操作被执行，返回 <code>0 </code>。</strong></font></td><td><font size=2><strong>为哈希表中不存在的的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 <code>HSET </code>操作。如果字段已经存在于哈希表中，操作无效。如果 <code>key</code> 不存在，一个新哈希表被创建并执行 <code>HSETNX</code> 命令。</strong></font></td></tr><tr><td><strong>HVALS</strong></td><td><font size=2 color='red'><strong>HVALS KEY_NAME FIELD VALUE      （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>一个包含哈希表中所有值的表。 当 <code>key</code> 不存在时，返回一个空表。</strong></font></td><td><font size=2><strong>返回哈希表所有字段的值。</strong></font></td></tr></tbody></table><h2 id="2-5-List（列表）"><a href="#2-5-List（列表）" class="headerlink" title="2.5 List（列表）"></a>2.5 List（列表）</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 2^(32 - 1) 个元素 (4294967295, 每个列表超过40亿个元素)。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH mykey redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH mykey mongodb</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH mykey mysql</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE mykey <span class="number">0</span> <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;mysql&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们使用了 <strong>LPUSH</strong> 将三个值插入了名为 mykey 的列表当中。</p><p><strong>下表给出了与 Redis列表相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>BLPOP</strong></td><td><font size=2 color='red'><strong>BLPOP LIST1 LIST2 .. LISTN TIMEOUT（&gt;=2.0.0）</strong></font></td><td><font size=2><strong>假如在指定时间内没有任何元素被弹出，则返回一个 <code>nil</code> 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <code>key</code> ，第二个元素是被弹出元素的值。</strong></font></td><td><font size=2><strong>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></font></td></tr><tr><td><strong>BRPOP</strong></td><td><font size=2 color='red'><strong>BRPOP LIST1 LIST2 .. LISTN TIMEOUT（&gt;=2.0.0）</strong></font></td><td><font size=2><strong>假如在指定时间内没有任何元素被弹出，则返回一个 <code>nil</code> 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <code>key</code> ，第二个元素是被弹出元素的值。</strong></font></td><td><font size=2><strong>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></font></td></tr><tr><td><strong>BRPOPLPUSH</strong></td><td><font size=2 color='red'><strong>BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT（&gt;=2.0.0）</strong></font></td><td><font size=2><strong>假如在指定时间内没有任何元素被弹出，则返回一个<code>nil</code>和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</strong></font></td><td><font size=2><strong>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></font></td></tr><tr><td><strong>LINDEX</strong></td><td><font size=2 color='red'><strong>LINDEX KEY_NAME INDEX_POSITION         （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>列表中下标为指定索引值的元素。 如果指定索引值不在列表的区间范围内，返回<code>nil </code>。</strong></font></td><td><font size=2><strong>通过索引获取列表中的元素。你也可以使用负数下标，以 <code>-1</code> 表示列表的最后一个元素，<code> -2</code> 表示列表的倒数第二个元素，以此类推。</strong></font></td></tr><tr><td><strong>LINSERT</strong></td><td><font size=2 color='red'><strong>LINSERT KEY_NAME BEFORE EXISTING_VALUE NEW_VALUE                 （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 <code>-1 </code>。 如果 key 不存在或为空列表，返回 <code>0 </code>。</strong></font></td><td><font size=2><strong>在列表的元素前或者后插入元素。 当指定元素不存在于列表中时，不执行任何操作。 当列表不存在时，被视为空列表，不执行任何操作。 如果<code> key</code> 不是列表类型，返回一个错误。</strong></font></td></tr><tr><td><strong>LLEN</strong></td><td><font size=2 color='red'><strong>LLEN KEY_NAME           （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>列表的长度。</strong></font></td><td><font size=2><strong>返回列表的长度。 如果列表 <code>key </code>不存在，则<code>key</code>被解释为一个空列表，返回 <code>0</code> 。 如果 <code>key</code> 不是列表类型，返回一个错误。</strong></font></td></tr><tr><td><strong>LPOP</strong></td><td><font size=2 color='red'><strong>LLEN KEY_NAME             （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>列表的第一个元素。 当列表 <code>key</code> 不存在时，返回<code>nil</code>。</strong></font></td><td><font size=2><strong>移除并返回列表的第一个元素。</strong></font></td></tr><tr><td><strong>LPUSH</strong></td><td><font size=2 color='red'><strong>LPUSH KEY_NAME VALUE1.. VALUEN              （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>执行 <code>LPUSH</code> 命令后，列表的长度。</strong></font></td><td><font size=2><strong>将一个或多个值插入到列表头部。 如果 <code>key </code>不存在，一个空列表会被创建并执行 <code>LPUSH</code> 操作。 当 <code>key </code>存在但不是列表类型时，返回一个错误。注意：在Redis 2.4版本以前的 <code>LPUSH </code>命令，都只接受单个 <code>value </code>值。</strong></font></td></tr><tr><td><strong>LPUSHX</strong></td><td><font size=2 color='red'><strong>LPUSHX KEY_NAME VALUE1.. VALUEN         （&gt;= 2.2.0）</strong></font></td><td><font size=2><strong><code>LPUSHX </code>命令执行之后，列表的长度。</strong></font></td><td><font size=2><strong>将一个或多个值插入到已存在的列表头部，列表不存在时操作无效。</strong></font></td></tr><tr><td><strong>LRANGE</strong></td><td><font size=2 color='red'><strong>LRANGE KEY_NAME START END                   （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>一个列表，包含指定区间内的元素。</strong></font></td><td><font size=2><strong>返回列表中指定区间内的元素，区间以偏移量<code> START</code> 和<code> END</code> 指定。 其中 <code>0 </code>表示列表的第一个元素， <code>1</code> 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 <code>-1 </code>表示列表的最后一个元素， <code>-2</code> 表示列表的倒数第二个元素，以此类推。</strong></font></td></tr><tr><td><strong>LREM</strong></td><td><font size=2 color='red'><strong>LREM KEY_NAME COUNT VALUE （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>被移除元素的数量。 列表不存在返回 <code>0 </code>。</strong></font></td><td><font size=2>**根据参数 <code>COUNT</code> 的值，移除列表中与参数 <code>VALUE </code>相等的元素。<code>COUNT</code> 的值可以是以下几种：count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 <code>COUNT</code> 。 count &lt; 0 : 从表尾开始向表头搜索，移除与 <code>VALUE</code> 相等的元素，数量为 <code>COUNT</code> 的绝对值。count = 0 : 移除表中所有与<code>VALUE</code>相等的值。**</font></td></tr><tr><td><strong>LSET</strong></td><td><font size=2 color='red'><strong>LSET KEY_NAME INDEX VALUE（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>操作成功返回 <code>ok </code>，否则返回错误信息。</strong></font></td><td><font size=2><strong>通过索引来设置元素的值。当索引参数超出范围，或对一个空列表进行 <code>LSET</code> 时，返回一个错误。</strong></font></td></tr><tr><td><strong>LTRIM</strong></td><td><font size=2 color='red'><strong>LTRIM KEY_NAME START STOP （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>命令执行成功时，返回 <code>ok </code>。</strong></font></td><td><font size=2><strong>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标 <code>0 </code>表示列表的第一个元素，以 <code>1</code> 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以<code> -1</code> 表示列表的最后一个元素，<code>-2</code>表示列表的倒数第二个元素，以此类推。</strong></font></td></tr><tr><td><strong>RPOP</strong></td><td><font size=2 color='red'><strong>RPOP KEY_NAME           （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>列表的最后一个元素。 当列表不存在时，返回 <code>nil </code>。</strong></font></td><td><font size=2><strong>用于移除并返回列表的最后一个元素。</strong></font></td></tr><tr><td><strong>RPOPLPUSH</strong></td><td><font size=2 color='red'><strong>RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>被弹出的元素。</strong></font></td><td><font size=2><strong>用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</strong></font></td></tr><tr><td><strong>RPUSH</strong></td><td><font size=2 color='red'><strong>RPUSH KEY_NAME VALUE1..VALUEN        （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>执行 <code>RPUSH </code>操作后，列表的长度。</strong></font></td><td><font size=2><strong>用于将一个或多个值插入到列表的尾部(最右边)。如果列表不存在，一个空列表会被创建并执行 <code>RPUSH</code> 操作。 当列表存在但不是列表类型时，返回一个错误。<br />注意：在 Redis 2.4 版本以前的 <code>RPUSH </code>命令，都只接受单个<code>value</code>值。</strong></font></td></tr><tr><td><strong>RPUSHX</strong></td><td><font size=2 color='red'><strong>RPUSHX KEY_NAME VALUE1..VALUEN              （&gt;= 2.2.0）</strong></font></td><td><font size=2><strong>执行 <code>RPUSHX </code>操作后，列表的长度。</strong></font></td><td><font size=2><strong>将一个或多个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效。</strong></font></td></tr></tbody></table><h2 id="2-6-Set（集合）"><a href="#2-6-Set（集合）" class="headerlink" title="2.6 Set（集合）"></a>2.6 Set（集合）</h2><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey mysql</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey mysql</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS mykey</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;mysql&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们通过 <strong>SADD</strong> 命令向名为 mykey 的集合插入的三个元素。</p><p><strong>下表给出了与 Redis集合相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>SADD</strong></td><td><font size=2 color='red'><strong>SADD KEY_NAME VALUE1..VALUEN（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>被添加到集合中的新元素的数量，不包括被忽略的元素。</strong></font></td><td><font size=2><strong>将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。假如集合 <code>key </code>不存在，则创建一个只包含添加的元素作成员的集合。当集合 <code>key </code>不是集合类型时，返回一个错误。注意：在Redis2.4版本以前，<code> SADD</code> 只接受单个成员值。</strong></font></td></tr><tr><td><strong>SCARD</strong></td><td><font size=2 color='red'><strong>SCARD KEY_NAME （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>集合的数量。 当集合 <code>key </code>不存在时，返回 0 。</strong></font></td><td><font size=2><strong>返回集合中元素的数量。</strong></font></td></tr><tr><td><strong>SDIFF</strong></td><td><font size=2 color='red'><strong>SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>包含差集成员的列表。</strong></font></td><td><font size=2><strong>返回给定集合之间的差集。不存在的集合 <code>key </code>将视为空集。</strong></font></td></tr><tr><td><strong>SDIFFSTORE</strong></td><td><font size=2 color='red'><strong>SDIFFSTORE DESTINATION_KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>结果集中的元素数量。</strong></font></td><td><font size=2><strong>将给定集合之间的差集存储在指定的集合中。如果指定的集合 <code>key </code>已存在，则会被覆盖。</strong></font></td></tr><tr><td><strong>SINTER</strong></td><td><font size=2 color='red'><strong>SINTER KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>交集成员的列表。</strong></font></td><td><font size=2><strong>返回给定所有给定集合的交集。 不存在的集合 <code>key</code> 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</strong></font></td></tr><tr><td><strong>SINTERSTORE</strong></td><td><font size=2 color='red'><strong>SINTERSTORE DESTINATION_KEY KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>交集成员的列表。</strong></font></td><td><font size=2><strong>将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖。</strong></font></td></tr><tr><td><strong>SISMEMBER</strong></td><td><font size=2 color='red'><strong>SISMEMBER KEY VALUE（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>如果成员元素是集合的成员，返回 <code>1</code> 。 如果成员元素不是集合的成员，或 <code>key</code> 不存在，返回 <code>0 </code>。</strong></font></td><td><font size=2><strong>判断成员元素是否是集合的成员。</strong></font></td></tr><tr><td><strong>SMEMBERS</strong></td><td><font size=2 color='red'><strong>SMEMBERS KEY VALUE （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>集合中的所有成员。</strong></font></td><td><font size=2><strong>返回集合中的所有的成员。 不存在的集合 <code>key</code> 被视为空集合。</strong></font></td></tr><tr><td><strong>SMOVE</strong></td><td><font size=2 color='red'><strong>SMOVE SOURCE DESTINATION MEMBER（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>如果成员元素被成功移除，返回 <code>1</code> 。 如果成员元素不是 <code>source </code>集合的成员，并且没有任何操作对 <code>destination</code> 集合执行，那么返回 <code>0 </code>。</strong></font></td><td><font size=2><strong>将指定成员 <code>member </code>元素从 <code>source </code>集合移动到 <code>destination</code> 集合。<code>SMOVE </code>是原子性操作。如果 <code>source</code> 集合不存在或不包含指定的 <code>member</code> 元素，则 <code>SMOVE </code>命令不执行任何操作，仅返回<code>0</code>。否则， <code>member</code> 元素从 <code>source</code> 集合中被移除，并添加到 <code>destination</code> 集合中去。当 <code>destination</code> 集合已经包含 <code>member</code> 元素时， <code>SMOVE</code> 命令只是简单地将 <code>source</code> 集合中的 <code>member</code> 元素删除。当 <code>source</code> 或 <code>destination</code> 不是集合类型时，返回一个错误。</strong></font></td></tr><tr><td><strong>SPOP</strong></td><td><font size=2 color='red'><strong>SPOP KEY（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>被移除的随机元素。 当集合不存在或是空集时，返回 <code>nil</code> 。</strong></font></td><td><font size=2><strong>移除并返回集合中的一个随机元素。</strong></font></td></tr><tr><td><strong>SRANDMEMBER</strong></td><td><font size=2 color='red'><strong>SRANDMEMBER KEY [count]（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>只提供集合 <code>key</code> 参数时，返回一个元素；如果集合为空，返回 <code>nil </code>。 如果提供了 <code>count </code>参数，那么返回一个数组；如果集合为空，返回空数组。</strong></font></td><td><font size=2><strong>返回集合中的一个随机元素。从 Redis 2.6 版本开始， <code>Srandmember</code> 命令接受可选的<code>count</code>参数：如果 <code>count </code>为正数，且小于集合基数，那么命令返回一个包含 <code>count </code>个元素的数组，数组中的元素各不相同。如果 <code>count </code>大于等于集合基数，那么返回整个集合。如果<code> count</code> 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 <code>count</code> 的绝对值。该操作和 <code>SPOP</code> 相似，但 <code>SPOP</code> 将随机元素从集合中移除并返回，而 <code>Srandmember</code> 则仅仅返回随机元素，而不对集合进行任何改动。</strong></font></td></tr><tr><td><strong>SREM</strong></td><td><font size=2 color='red'><strong>SREM KEY MEMBER1..MEMBERN            （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>被成功移除的元素的数量，不包括被忽略的元素。</strong></font></td><td><font size=2><strong>移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。当 <code>key </code>不是集合类型，返回一个错误。在 Redis 2.4 版本以前， <code>SREM</code> 只接受单个成员值。</strong></font></td></tr><tr><td><strong>SUNION</strong></td><td><font size=2 color='red'><strong>SUNION KEY KEY1..KEYN           （&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>并集成员的列表。</strong></font></td><td><font size=2><strong>返回给定集合的并集。不存在的集合 <code>key</code> 被视为空集。</strong></font></td></tr><tr><td><strong>SUNIONSTORE</strong></td><td><font size=2 color='red'><strong>SUNIONSTORE DESTINATION KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>结果集中的元素数量。</strong></font></td><td><font size=2><strong>将给定集合的并集存储在指定的集合<code>destination</code>中。</strong></font></td></tr><tr><td><strong>SSCAN</strong></td><td><font size=2 color='red'><strong>SSCAN KEY [MATCH pattern] [COUNT count]（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>数组列表。</strong></font></td><td><font size=2><strong>迭代集合键中的元素。</strong></font></td></tr></tbody></table><h2 id="2-7-zset-sorted-set：有序集合"><a href="#2-7-zset-sorted-set：有序集合" class="headerlink" title="2.7 zset(sorted set：有序集合)"></a>2.7 zset(sorted set：有序集合)</h2><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">1</span> redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">2</span> mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">3</span> mysql</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">3</span> mysql</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">4</span> mysql</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE mykey <span class="number">0</span> <span class="number">10</span> WITHSCORES</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;redis&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;mongodb&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;mysql&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure><p>在以上实例中我们通过命令 <strong>ZADD</strong> 向 redis 的有序集合中添加了三个值并关联上分数。</p><p><strong>下表给出了与 Redis有序集合相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>ZADD</strong></td><td><font size=2 color='red'><strong>ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN    （&gt;= 1.2.0）</strong></font></td><td><font size=2><strong>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</strong></font></td><td><font size=2><strong>将一个或多个成员元素及其分数值加入到有序集当中。如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。如果有序集合 <code>key</code> 不存在，则创建一个空的有序集并执行 <code>ZADD</code> 操作。当<code> key</code> 存在但不是有序集类型时，返回一个错误。<br />注意： 在 Redis 2.4 版本以前， <code>ZADD </code>每次只能添加一个元素。</strong></font></td></tr><tr><td><strong>ZCARD</strong></td><td><font size=2 color='red'><strong>ZCARD KEY_NAME     （&gt;= 1.2.0）</strong></font></td><td><font size=2><strong>当 <code>key </code>存在且是有序集类型时，返回有序集的基数。 当 <code>key</code> 不存在时，返回 <code>0 </code>。</strong></font></td><td><font size=2><strong>计算集合中元素的数量。</strong></font></td></tr><tr><td><strong>ZCOUNT</strong></td><td><font size=2 color='red'><strong>ZCOUNT key min max（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>分数值在 <code>min </code>和 <code>max</code> 之间的成员的数量。</strong></font></td><td><font size=2><strong>计算有序集合中指定分数区间的成员数量。</strong></font></td></tr><tr><td><strong>ZINCRBY</strong></td><td><font size=2 color='red'><strong>ZINCRBY key increment member（&gt;= 1.2.0）</strong></font></td><td><font size=2><strong><code>member</code> 成员的新分数值，以字符串形式表示。</strong></font></td><td><font size=2><strong>对有序集合中指定成员的分数加上增量<code>increment</code>可以通过传递一个负数值 <code>increment</code> ，让分数减去相应的值，比如 <code>ZINCRBY key -5 member </code>，就是让 <code>member </code>的 <code>score</code> 值减去 <code>5</code>。当 <code>key </code>不存在，或分数不是 key 的成员时， <code>ZINCRBY key increment member</code> 等同于 <code>ZADD key increment member </code>。当 <code>key</code> 不是有序集类型时，返回一个错误。分数值可以是整数值或双精度浮点数。</strong></font></td></tr><tr><td><strong>ZINTERSTORE</strong></td><td><font size=2 color='red'><strong>ZINTERSTORE DESTINATION NUMKEYS KEY [KEY …] [WEIGHTS WEIGHT [WEIGHT …]] [AGGREGATE SUM|MIN|MAX]    （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>保存到目标结果集的的成员数量。</strong></font></td><td><font size=2><strong>计算给定的一个或多个有序集的交集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code> 参数指定，并将该交集(结果集)储存到 <code>destination </code>。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。</strong></font></td></tr><tr><td><strong>ZLEXCOUNT</strong></td><td><font size=2 color='red'><strong>ZLEXCOUNT KEY MIN MAX（&gt;= 2.8.9）</strong></font></td><td><font size=2><strong>指定区间内的成员数量。</strong></font></td><td><font size=2><strong>计算有序集合中指定字典区间内成员数量。</strong></font></td></tr><tr><td><strong>ZRANGE</strong></td><td><font size=2 color='red'><strong>ZRANGE key start stop [WITHSCORES]（&gt;= 1.2.0）</strong></font></td><td><font size=2><strong>指定区间内，带有分数值(可选)的有序集成员的列表。</strong></font></td><td><font size=2><strong>返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order )来排列。如果你需要成员按值递减(从大到小)来排列，请使用 ZREVRANGE 命令。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</strong></font></td></tr><tr><td><strong>ZRANGEBYLEX</strong></td><td><font size=2 color='red'><strong>ZRANGEBYLEX KEY MIN MAX [LIMIT OFFSET COUNT]    （&gt;= 2.8.9）</strong></font></td><td><font size=2><strong>指定区间内的元素列表。</strong></font></td><td><font size=2><strong>通过字典区间返回有序集合的成员。</strong></font></td></tr><tr><td><strong>ZRANGEBYSCORE</strong></td><td><font size=2 color='red'><strong>ZRANGEBYSCORE KEY MIN MAX [WITHSCORES] [LIMIT OFFSET COUNT]     （&gt;= 1.0.5）</strong></font></td><td><font size=2><strong>指定区间内，带有分数值(可选)的有序集成员的列表。</strong></font></td><td><font size=2><strong>返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</strong></font></td></tr><tr><td><strong>ZRANK</strong></td><td><font size=2 color='red'><strong>ZRANK KEY MEMBER（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>如果成员是有序集<code> key</code> 的成员，返回 <code>member</code> 的排名。 如果成员不是有序集<code>key</code>的成员，返回 <code>nil</code> 。</strong></font></td><td><font size=2><strong>返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。</strong></font></td></tr><tr><td><strong>ZREM</strong></td><td><font size=2 color='red'><strong>ZREM KEY MEMBER [MEMBER …]          （&gt;= 1.2.0）</strong></font></td><td><font size=2><strong>被成功移除的成员的数量，不包括被忽略的成员。</strong></font></td><td><font size=2><strong>移除有序集中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。<br />注意： 在 Redis 2.4 版本以前， <code>ZREM </code>每次只能删除一个元素。</strong></font></td></tr><tr><td><strong>ZREMRANGEBYLEX</strong></td><td><font size=2 color='red'><strong>ZREMRANGEBYLEX KEY MIN MAX       （&gt;= 2.8.9）</strong></font></td><td><font size=2><strong>被成功移除的成员的数量，不包括被忽略的成员。</strong></font></td><td><font size=2><strong>移除有序集合中给定的字典区间的所有成员。</strong></font></td></tr><tr><td><strong>ZREMRANGEBYRANK</strong></td><td><font size=2 color='red'><strong>ZREMRANGEBYRANK KEY START STOP      （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>被移除成员的数量。</strong></font></td><td><font size=2><strong>用于移除有序集中，指定排名(rank)区间内的所有成员。</strong></font></td></tr><tr><td><strong>ZREMRANGEBYSCORE</strong></td><td><font size=2 color='red'><strong>ZREMRANGEBYSCORE KEY MIN MAX        （&gt;= 1.2.0）</strong></font></td><td><font size=2><strong>被移除成员的数量。</strong></font></td><td><font size=2><strong>移除有序集中，指定分数（score）区间内的所有成员。</strong></font></td></tr><tr><td><strong>ZREVRANGE</strong></td><td><font size=2 color='red'><strong>ZREVRANGE KEY START STOP [WITHSCORES]                （&gt;= 1.2.0）</strong></font></td><td><font size=2><strong>指定区间内，带有分数值(可选)的有序集成员的列表。</strong></font></td><td><font size=2><strong>返回有序集中，指定区间内的成员。其中成员的位置按分数值递减(从大到小)来排列。具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按分数值递减的次序排列这一点外， <code>ZREVRANGE</code> 命令的其他方面和 <code>ZRANGE</code> 命令一样。</strong></font></td></tr><tr><td><strong>ZREVRANK</strong></td><td><font size=2 color='red'><strong>ZREVRANK KEY MEMBER（&gt;= 2.2.0）</strong></font></td><td><font size=2><strong>如果成员是有序集 <code>key</code> 的成员，返回成员的排名。 如果成员不是有序集 <code>key</code> 的成员，返回 <code>nil </code>。</strong></font></td><td><font size=2><strong>返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。排名以 <code>0 </code>为底，也就是说， 分数值最大的成员排名为<code> 0</code> 。使用 <code>ZRANK</code> 命令可以获得成员按分数值递增(从小到大)排列的排名。</strong></font></td></tr><tr><td><strong>ZSCAN</strong></td><td><font size=2 color='red'><strong>ZSCAN KEY CURSOR [MATCH PATTERN] [COUNT COUNT]        （&gt;= 2.8.0）</strong></font></td><td><font size=2><strong>返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</strong></font></td><td><font size=2><strong>迭代有序集合中的元素（包括元素成员和元素分值）</strong></font></td></tr><tr><td><strong>ZSCORE</strong></td><td><font size=2 color='red'><strong>ZSCORE KEY MEMBER（&gt;= 1.2.0）</strong></font></td><td><font size=2><strong>成员的分数值，以字符串形式表示。</strong></font></td><td><font size=2><strong>返回有序集中，成员的分数值。 如果成员元素不是有序集 <code>key </code>的成员，或 <code>key </code>不存在，返回 <code>nil</code> 。</strong></font></td></tr><tr><td><strong>ZUNIONSTORE</strong></td><td><font size=2 color='red'><strong>ZUNIONSTORE DESTINATION NUMKEYS KEY [KEY …] [WEIGHTS WEIGHT [WEIGHT …]] [AGGREGATE SUM|MIN|MAX]（&gt;=2.0.0）</strong></font></td><td><font size=2><strong>保存到 <code>destination </code>的结果集的成员数量。</strong></font></td><td><font size=2><strong>计算给定的一个或多个有序集的并集，其中给定 <code>key</code> 的数量必须以 <code>numkeys </code>参数指定，并将该并集(结果集)储存到 <code>destination </code>。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和 。</strong></font></td></tr></tbody></table><h2 id="2-8-HyperLogLog"><a href="#2-8-HyperLogLog" class="headerlink" title="2.8 HyperLogLog"></a>2.8 HyperLogLog</h2><p>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据。</p><p>核心是基数估算算法，最终数值存在一定误差。</p><p>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值。</p><p>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数。</p><p>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大。</p><p>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少 。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFADD  databases  <span class="string">&quot;Redis&quot;</span>  <span class="string">&quot;MongoDB&quot;</span>  <span class="string">&quot;MySQL&quot;</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFCOUNT  databases</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFADD  databases  <span class="string">&quot;Redis&quot;</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFADD  databases  <span class="string">&quot;PostgreSQL&quot;</span>    <span class="comment"># 添加一个不存在的元素</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>下表给出了与 Redis HyperLogLog相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>PFADD</strong></td><td><font size=2 color='red'><strong>PFADD key element [element …]（&gt;= 2.8.9）</strong></font></td><td><font size=2><strong>整型，如果至少有个元素被添加返回<code> 1</code>， 否则返回<code> 0</code>。</strong></font></td><td><font size=2><strong>将所有元素参数添加到 <code>HyperLogLog</code> 数据结构中</strong></font></td></tr><tr><td><strong>PFCOUNT</strong></td><td><font size=2 color='red'><strong>PFCOUNT key [key …]        （&gt;= 2.8.9）</strong></font></td><td><font size=2><strong>整数，返回给定 <code>HyperLogLog </code>的基数值，如果多个 <code>HyperLogLog</code> 则返回基数估值之和。</strong></font></td><td><font size=2><strong>返回给定 HyperLogLog 的基数估算值。</strong></font></td></tr><tr><td><strong>PFMERGE</strong></td><td><font size=2 color='red'><strong>PFMERGE destkey sourcekey [sourcekey …]（&gt;= 2.8.9）</strong></font></td><td><font size=2><strong>返回<code> OK</code>。</strong></font></td><td><font size=2><strong>将多个 <code>HyperLogLog </code>合并为一个 <code>HyperLogLog</code> ，合并后的 <code>HyperLogLog</code> 的基数估算值是通过对所有 给定 <code>HyperLogLog </code>进行并集计算得出的。</strong></font></td></tr></tbody></table><h2 id="2-9-GEO（地理位置）"><a href="#2-9-GEO（地理位置）" class="headerlink" title="2.9 GEO（地理位置）"></a>2.9 GEO（地理位置）</h2><p>支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> <span class="string">&quot;Palermo&quot;</span> <span class="number">15.087269</span> <span class="number">37.502669</span> <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">&quot;166274.15156960039&quot;</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GEORADIUS Sicily <span class="number">15</span> <span class="number">37</span> <span class="number">100</span> km</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Catania&quot;</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily <span class="number">15</span> <span class="number">37</span> <span class="number">200</span> km</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Catania&quot;</span></span><br></pre></td></tr></table></figure><p><strong>下表给出了与 Redis GEO相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>GEOADD</strong></td><td><font size=2 color='red'><strong>GEOADD key longitude latitude member [longitude latitude member …]（&gt;= 3.2.0）</strong></font></td><td><font size=2><strong>新添加到键里面的空间元素数量， 不包括那些已经存在但是被更新的元素。</strong></font></td><td><font size=2><strong>将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 <code>GEORADIUS</code> 和 <code>GEORADIUSBYMEMBER</code> 这样的命令可以在之后通过位置查询取得这些元素。</strong></font></td></tr><tr><td><strong>GEOPOS</strong></td><td><font size=2 color='red'><strong>GEOPOS key member [member …]             （&gt;= 3.2.0）</strong></font></td><td><font size=2><strong><code>GEOPOS</code> 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。 当给定的位置元素不存在时， 对应的数组项为空值。</strong></font></td><td><font size=2><strong>从键里面返回所有给定位置元素的位置（经度和纬度）。因为 <code>GEOPOS</code> 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复。</strong></font></td></tr><tr><td><strong>GEODIST</strong></td><td><font size=2 color='red'><strong>GEODIST key member1 member2 [unit]          （&gt;= 3.2.0）</strong></font></td><td><font size=2><strong>计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值。</strong></font></td><td><font size=2><strong>返回两个给定位置之间的距离。如果两个位置之间的其中一个不存在， 那么命令返回空值。</strong></font></td></tr><tr><td><strong>GEORADIUS</strong></td><td><font size=2 color='red'><strong>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]（&gt;= 3.2.0）</strong></font></td><td><font size=2><strong><a href="http://redisdoc.com/geo/georadius.html">复杂见文档</a></strong></font></td><td><font size=2><strong><a href="http://redisdoc.com/geo/georadius.html">复杂见文档</a></strong></font></td></tr><tr><td><strong>GEORADIUSBYMEMBER</strong></td><td><font size=2 color='red'><strong>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]（&gt;= 3.2.0）</strong></font></td><td><font size=2><strong>一个数组， 数组中的每个项表示一个范围之内的位置元素。</strong></font></td><td><font size=2><strong>这个命令和 <code>GEORADIUS</code> 命令一样， 都可以找出位于指定范围内的元素， 但是 <code>GEORADIUSBYMEMBER</code> 的中心点是由给定的位置元素决定的， 而不是像 <code>GEORADIUS</code> 那样， 使用输入的经度和纬度来决定中心点。</strong></font></td></tr><tr><td><strong>GEOHASH</strong></td><td><font size=2 color='red'><strong>GEOHASH key member [member …]                （&gt;= 3.2.0）</strong></font></td><td><font size=2><strong>一个数组， 数组的每个项都是一个<code>geohash </code>。 命令返回的 <code>geohash </code>的位置与用户给定的位置元素的位置一一对应。</strong></font></td><td><font size=2><strong>返回一个或多个位置元素的 <code>Geohash</code> 表示。</strong></font></td></tr></tbody></table><h2 id="2-10-BitMap（位图）"><a href="#2-10-BitMap（位图）" class="headerlink" title="2.10 BitMap（位图）"></a>2.10 BitMap（位图）</h2><p>BitMap，即位图，其实也就是 byte 数组，用二进制表示，只有 0 和 1 两个数字。可以用于实现用户上线次数统计。</p><p><strong>实例</strong></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SETBIT bit <span class="number">10086</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GETBIT bit <span class="number">10086</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GETBIT bit <span class="number">100</span>   <span class="comment"># bit 默认被初始化为 0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>下表给出了与 Redis BitMap相关常用的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>SETBIT</strong></td><td><font size=2 color='red'><strong>SETBIT key offset value（&gt;=2.2.0）</strong></font></td><td><font size=2><strong>指定偏移量原来储存的位。</strong></font></td><td><font size=2><strong>对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。位的设置或清除取决于 <code>value</code> 参数，可以是 <code>0</code> 也可以是 <code>1</code> 。当 <code>key</code> 不存在时，自动生成一个新的字符串值。字符串会进行伸展(grown)以确保它可以将 <code>value</code> 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 <code>0</code> 填充。<code>offset</code> 参数必须大于或等于 <code>0</code> ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</strong></font></td></tr><tr><td><strong>GETBIT</strong></td><td><font size=2 color='red'><strong>GETBIT key offset（&gt;=2.2.0）</strong></font></td><td><font size=2><strong>字符串值指定偏移量上的位(bit)。</strong></font></td><td><font size=2><strong>对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。当 <code>offset</code> 比字符串值的长度大，或者 <code>key</code> 不存在时，返回 <code>0</code> 。</strong></font></td></tr><tr><td><strong>BITCOUNT</strong></td><td><font size=2 color='red'><strong>BITCOUNT key [start] [end]（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>被设置为 <code>1</code> 的位的数量。</strong></font></td><td><font size=2><strong>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行。<code>start</code> 和 <code>end</code> 参数的设置都可以使用负数值： 比如 <code>-1</code> 表示最后一个字节， <code>-2</code> 表示倒数第二个字节，以此类推。不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 <code>0</code> 。</strong></font></td></tr><tr><td><strong>BITPOS</strong></td><td><font size=2 color='red'><strong>BITPOS key bit [start] [end]（&gt;= 2.8.7）</strong></font></td><td><font size=2><strong>整数回复。</strong></font></td><td><font size=2><strong>返回位图中第一个值为 <code>bit</code> 的二进制位的位置。在默认情况下， 命令将检测整个位图， 但用户也可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。</strong></font></td></tr><tr><td><strong>BITOP</strong></td><td><font size=2 color='red'><strong>BITOP operation destkey key [key …]（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>保存到 <code>destkey</code> 的字符串的长度，和输入 <code>key</code> 中最长的字符串长度相等。</strong></font></td><td><font size=2><strong>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。<code>operation</code> 可以是 <code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 、 <code>XOR</code> 这四种操作中的任意一种：<br /><code>BITOP AND destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑并，并将结果保存到 <code>destkey</code> 。<br /><code>BITOP OR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑或，并将结果保存到 <code>destkey</code> 。<br /><code>BITOP XOR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑异或，并将结果保存到 <code>destkey</code> 。<br /><code>BITOP NOT destkey key</code> ，对给定 <code>key</code> 求逻辑非，并将结果保存到 <code>destkey</code> 。<br />除了 <code>NOT</code> 操作之外，其他操作都可以接受一个或多个 <code>key</code> 作为输入。<br />当 <code>BITOP</code>处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</strong></font></td></tr><tr><td><strong>BITFIELD</strong></td><td><font size=2 color='red'><strong>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]（&gt;= 3.2.0）</strong></font></td><td><font size=2><strong><a href="http://redisdoc.com/bitmap/bitfield.html">复杂见文档</a></strong></font></td><td><font size=2><strong><a href="http://redisdoc.com/bitmap/bitfield.html">复杂见文档</a></strong></font></td></tr></tbody></table><h2 id="2-11-Pub-Sub（发布-订阅）"><a href="#2-11-Pub-Sub（发布-订阅）" class="headerlink" title="2.11 Pub/Sub（发布/订阅）"></a>2.11 Pub/Sub（发布/订阅）</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p><strong>实例</strong></p><p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 <strong>redisChat</strong>:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUBSCRIBE redisChat</span><br><span class="line"></span><br><span class="line">Reading messages... (press Ctrl<span class="literal">-C</span> to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH redisChat <span class="string">&quot;Redis is a great caching technique&quot;</span></span><br><span class="line"> </span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH redisChat <span class="string">&quot;Learn redis by w3cschool.cc&quot;</span></span><br><span class="line"> </span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 订阅者的客户端会显示如下消息</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;Redis is a great caching technique&quot;</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;redisChat&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;Learn redis by w3cschool.cc&quot;</span></span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 发布订阅常用命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>PSUBSCRIBE</strong></td><td><font size=2 color='red'><strong>PSUBSCRIBE pattern [pattern …]（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>接收到的信息。</strong></font></td><td><font size=2><em><em>订阅一个或多个符合给定模式的频道。每个模式以 * 作为匹配符，比如 it</em> 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)。 news.</em> 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类。**</font></td></tr><tr><td><strong>PUBSUB</strong></td><td><font size=2 color='red'> <strong>PUBSUB <subcommand> [argument [argument …]]（&gt;= 2.8.0）</strong></font></td><td><font size=2><strong>由活跃频道组成的列表。</strong></font></td><td><font size=2><strong>用于查看订阅与发布系统状态，它由数个不同格式的子命令组成。</strong></font></td></tr><tr><td><strong>PUBLISH</strong></td><td><font size=2 color='red'><strong>PUBLISH channel message（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>接收到信息的订阅者数量。</strong></font></td><td><font size=2><strong>用于将信息发送到指定的频道。</strong></font></td></tr><tr><td><strong>PUNSUBSCRIBE</strong></td><td><font size=2 color='red'><strong>PUNSUBSCRIBE [pattern [pattern …]]（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>这个命令在不同的客户端中有不同的表现。</strong></font></td><td><font size=2><strong>用于退订所有给定模式的频道。</strong></font></td></tr><tr><td><strong>SUBSCRIBE</strong></td><td><font size=2 color='red'><strong>SUBSCRIBE channel [channel …]（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>接收到的信息。</strong></font></td><td><font size=2><strong>用于订阅给定的一个或多个频道的信息。</strong></font></td></tr><tr><td><strong>UNSUBSCRIBE</strong></td><td><font size=2 color='red'><strong>UNSUBSCRIBE channel [channel …]（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>这个命令在不同的客户端中有不同的表现。</strong></font></td><td><font size=2><strong>用于退订给定的一个或多个频道的信息。</strong></font></td></tr></tbody></table><h2 id="2-12-Transaction（事务）"><a href="#2-12-Transaction（事务）" class="headerlink" title="2.12 Transaction（事务）"></a>2.12 Transaction（事务）</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p><strong>实例</strong></p><p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; <span class="built_in">SET</span> book<span class="literal">-name</span> <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET book<span class="literal">-name</span></span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD tag <span class="string">&quot;C++&quot;</span> <span class="string">&quot;Programming&quot;</span> <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">3</span></span><br><span class="line"><span class="number">4</span>) <span class="number">1</span>) <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">&quot;C++&quot;</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">&quot;Programming&quot;</span></span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 事务的相关命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>DISCARD</strong></td><td><font size=2 color='red'><strong>DISCARD（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于取消事务，放弃执行事务块内的所有命令。</strong></font></td></tr><tr><td><strong>EXEC</strong></td><td><font size=2 color='red'><strong>EXEC（&gt;= 1.2.0）</strong></font></td><td><font size=2><strong>事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</strong></font></td><td><font size=2><strong>用于执行所有事务块内的命令。</strong></font></td></tr><tr><td><strong>MULTI</strong></td><td><font size=2 color='red'><strong>MULTI（&gt;= 1.2.0）</strong></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 <code>EXEC </code>命令原子性(atomic)地执行。</strong></font></td></tr><tr><td><strong>UNWATCH</strong></td><td><font size=2 color='red'><strong>UNWATCH（&gt;= 2.2.0）</strong> </font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于取消 <code>WATCH</code> 命令对所有 key 的监视。</strong></font></td></tr><tr><td><strong>WATCH</strong></td><td><font size=2 color='red'><strong>WATCH（&gt;= 2.2.0）</strong></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于监视一个(或多个)<code>key</code> ，如果在事务执行之前这个(或这些)<code>key</code>被其他命令所改动，那么事务将被打断。</strong></font></td></tr></tbody></table><h2 id="2-13-Script（脚本）"><a href="#2-13-Script（脚本）" class="headerlink" title="2.13 Script（脚本）"></a>2.13 Script（脚本）</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Reids 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong>。</p><p><strong>实例</strong></p><p>以下实例演示了 redis 脚本工作过程：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EVAL <span class="string">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> <span class="number">2</span> key1 key2 first second</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;key1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;key2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;first&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;second&quot;</span></span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 脚本的相关命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>EVAL</strong></td><td><font size=2 color='red'><strong>EVAL script numkeys key [key …] arg [arg …]（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>无</strong></font></td><td><font size=2><strong>使用 Lua 解释器执行脚本。<br />参数说明：<br />script： 参数是一段 Lua 5.1 脚本程序。脚本不必(也不应该)定义为一个 Lua 函数。 numkeys： 用于指定键名参数的个数。 key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。 arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</strong></font></td></tr><tr><td><strong>EVALSHA</strong></td><td><font size=2 color='red'><strong>EVALSHA sha1 numkeys key [key …] arg [arg …]（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>无</strong></font></td><td><font size=2><strong>根据给定的 sha1 校验码，执行缓存在服务器中的脚本。参数说明同上</strong></font></td></tr><tr><td><strong>SCRIPT EXISTS</strong></td><td><font size=2 color='red'><strong>SCRIPT EXISTS scripts（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>一个列表，包含 <code>0 </code>和<code>1</code>，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。列表中的元素和给定的 <code>SHA1 </code>校验和保持对应关系，比如列表的第三个元素的值就表示第三个 <code>SHA1 </code>校验和所指定的脚本在缓存中的状态。</strong></font></td><td><font size=2><strong>用于校验指定的脚本是否已经被保存在缓存当中。</strong></font></td></tr><tr><td><strong>SCRIPT FLUSH</strong></td><td><font size=2 color='red'><strong>SCRIPT FLUSH（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>总是返回 OK。</strong></font></td><td><font size=2><strong>用于清除所有 Lua 脚本缓存。</strong></font></td></tr><tr><td><strong>SCRIPT KILL</strong></td><td><font size=2 color='red'><strong>SCRIPT KILL（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>总是返回 OK</strong></font></td><td><font size=2><strong>用于杀死当前正在运行的 <code>Lua </code>脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限循环的脚本。<code>SCRIPT KILL</code> 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 EVAL 命令的阻塞当中退出，并收到一个错误作为返回值。</strong></font></td></tr><tr><td><strong>SCRIPT LOAD</strong></td><td><font size=2 color='red'><strong>SCRIPT LOAD script（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>给定脚本的 <code>SHA1 </code>校验和</strong></font></td><td><font size=2><strong>用于将脚本 <code>script </code>添加到脚本缓存中，但并不立即执行这个脚本。<code>EVAL</code>命令也会将脚本添加到脚本缓存中，但是它会立即对输入的脚本进行求值。如果给定的脚本已经在缓存里面了，那么不执行任何操作。在脚本被加入到缓存之后，通过 <code>EVALSHA</code>命令，可以使用脚本的 SHA1 校验和来调用这个脚本。脚本可以在缓存中保留无限长的时间，直到执行 <code>SCRIPT FLUSH</code> 为止。</strong></font></td></tr></tbody></table><h2 id="2-14-Connection（连接）"><a href="#2-14-Connection（连接）" class="headerlink" title="2.14 Connection（连接）"></a>2.14 Connection（连接）</h2><p>Redis 连接命令主要是用于连接 redis 服务。</p><p><strong>实例</strong></p><p>以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; AUTH <span class="string">&quot;password&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 连接的基本命令：</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>AUTH</strong></td><td><font size=2 color='red'><strong>AUTH PASSWORD（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>密码匹配时返回 OK ，否则返回一个错误。</strong></font></td><td><font size=2><strong>用于检测给定的密码和配置文件中的密码是否相符。</strong></font></td></tr><tr><td><strong>ECHO</strong></td><td><font size=2 color='red'><strong>ECHO message（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>返回字符串本身。</strong></font></td><td><font size=2><strong>用于打印给定的字符串。</strong></font></td></tr><tr><td><strong>PING</strong></td><td><font size=2 color='red'><strong>PING （&gt;=1.0.0）</strong></font></td><td><font size=2><strong>如果连接正常就返回一个 PONG ，否则返回一个连接错误。</strong></font></td><td><font size=2><strong>使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。</strong></font></td></tr><tr><td><strong>QUIT</strong></td><td><font size=2 color='red'><strong>QUIT（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于关闭与当前客户端与redis服务的连接。一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</strong></font></td></tr><tr><td><strong>SELECT</strong></td><td><font size=2 color='red'><strong>SELECT index（&gt;=1.0.0）</strong></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。</strong></font></td></tr></tbody></table><h2 id="2-15-Server（服务器）"><a href="#2-15-Server（服务器）" class="headerlink" title="2.15 Server（服务器）"></a>2.15 Server（服务器）</h2><p>Redis 服务器命令主要是用于管理 redis 服务。</p><p><strong>实例</strong></p><p>以下实例演示了如何获取 redis 服务器的统计信息：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; INFO</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line"><span class="comment"># Redis 服务器版本</span></span><br><span class="line">redis_version:<span class="number">2.8</span>.<span class="number">13</span></span><br><span class="line"><span class="comment"># Git SHA1</span></span><br><span class="line">redis_git_sha1:<span class="number">00000000</span></span><br><span class="line"><span class="comment"># Git dirty flag</span></span><br><span class="line">redis_git_dirty:<span class="number">0</span></span><br><span class="line">redis_build_id:c2238b38b1edb0e2</span><br><span class="line">redis_mode:standalone</span><br><span class="line"><span class="comment"># Redis 服务器的宿主操作系统</span></span><br><span class="line">os:Linux <span class="number">3.5</span>.<span class="number">0</span><span class="literal">-48</span><span class="literal">-generic</span> x86_64</span><br><span class="line"><span class="comment"># 架构（32 或 64 位）</span></span><br><span class="line">arch_bits:<span class="number">64</span></span><br><span class="line"><span class="comment"># Redis 所使用的事件处理机制</span></span><br><span class="line">multiplexing_api:epoll</span><br><span class="line"><span class="comment"># 编译 Redis 时所使用的 GCC 版本</span></span><br><span class="line">gcc_version:<span class="number">4.7</span>.<span class="number">2</span></span><br><span class="line"><span class="comment"># 服务器进程的 PID</span></span><br><span class="line">process_id:<span class="number">3856</span></span><br><span class="line"><span class="comment"># Redis 服务器的随机标识符（用于 Sentinel 和集群）</span></span><br><span class="line">run_id:<span class="number">0</span>e61abd297771de3fe812a3c21027732ac9f41fe</span><br><span class="line"><span class="comment"># TCP/IP 监听端口</span></span><br><span class="line">tcp_port:<span class="number">6379</span></span><br><span class="line"><span class="comment"># 自 Redis 服务器启动以来，经过的秒数</span></span><br><span class="line">uptime_in_seconds:<span class="number">11554</span></span><br><span class="line"><span class="comment"># 自 Redis 服务器启动以来，经过的天数</span></span><br><span class="line">uptime_in_days:<span class="number">0</span></span><br><span class="line">hz:<span class="number">10</span></span><br><span class="line"><span class="comment"># 以分钟为单位进行自增的时钟，用于 LRU 管理</span></span><br><span class="line">lru_clock:<span class="number">16651447</span></span><br><span class="line">config_file:</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line"><span class="comment"># 已连接客户端的数量（不包括通过从属服务器连接的客户端）</span></span><br><span class="line">connected_clients:<span class="number">1</span></span><br><span class="line"><span class="comment"># 当前连接的客户端当中，最长的输出列表</span></span><br><span class="line">client<span class="literal">-longest_output_list</span>:<span class="number">0</span></span><br><span class="line"><span class="comment"># 当前连接的客户端当中，最大输入缓存</span></span><br><span class="line">client<span class="literal">-biggest_input_buf</span>:<span class="number">0</span></span><br><span class="line"><span class="comment"># 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</span></span><br><span class="line">blocked_clients:<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line"><span class="comment"># 由 Redis 分配器分配的内存总量，以字节（byte）为单位</span></span><br><span class="line">used_memory:<span class="number">589016</span></span><br><span class="line"><span class="comment"># 以人类可读的格式返回 Redis 分配的内存总量</span></span><br><span class="line">used_memory_human:<span class="number">575.21</span>K</span><br><span class="line"><span class="comment"># 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</span></span><br><span class="line">used_memory_rss:<span class="number">2461696</span></span><br><span class="line"><span class="comment"># Redis 的内存消耗峰值（以字节为单位）</span></span><br><span class="line">used_memory_peak:<span class="number">667312</span></span><br><span class="line"><span class="comment"># 以人类可读的格式返回 Redis 的内存消耗峰值</span></span><br><span class="line">used_memory_peak_human:<span class="number">651.67</span>K</span><br><span class="line"><span class="comment"># Lua 引擎所使用的内存大小（以字节为单位）</span></span><br><span class="line">used_memory_lua:<span class="number">33792</span></span><br><span class="line"><span class="comment"># used_memory_rss 和 used_memory 之间的比率</span></span><br><span class="line">mem_fragmentation_ratio:<span class="number">4.18</span></span><br><span class="line"><span class="comment"># 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。</span></span><br><span class="line">mem_allocator:jemalloc<span class="literal">-3</span>.<span class="number">6.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Persistence RDB 和 AOF 的相关信息</span></span><br><span class="line">loading:<span class="number">0</span></span><br><span class="line">rdb_changes_since_last_save:<span class="number">3</span></span><br><span class="line">rdb_bgsave_in_progress:<span class="number">0</span></span><br><span class="line">rdb_last_save_time:<span class="number">1409158561</span></span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:<span class="number">0</span></span><br><span class="line">rdb_current_bgsave_time_sec:<span class="literal">-1</span></span><br><span class="line">aof_enabled:<span class="number">0</span></span><br><span class="line">aof_rewrite_in_progress:<span class="number">0</span></span><br><span class="line">aof_rewrite_scheduled:<span class="number">0</span></span><br><span class="line">aof_last_rewrite_time_sec:<span class="literal">-1</span></span><br><span class="line">aof_current_rewrite_time_sec:<span class="literal">-1</span></span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Stats 一般统计信息</span></span><br><span class="line">total_connections_received:<span class="number">24</span></span><br><span class="line">total_commands_processed:<span class="number">294</span></span><br><span class="line">instantaneous_ops_per_sec:<span class="number">0</span></span><br><span class="line">rejected_connections:<span class="number">0</span></span><br><span class="line">sync_full:<span class="number">0</span></span><br><span class="line">sync_partial_ok:<span class="number">0</span></span><br><span class="line">sync_partial_err:<span class="number">0</span></span><br><span class="line">expired_keys:<span class="number">0</span></span><br><span class="line">evicted_keys:<span class="number">0</span></span><br><span class="line">keyspace_hits:<span class="number">41</span></span><br><span class="line">keyspace_misses:<span class="number">82</span></span><br><span class="line">pubsub_channels:<span class="number">0</span></span><br><span class="line">pubsub_patterns:<span class="number">0</span></span><br><span class="line">latest_fork_usec:<span class="number">264</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Replication 主/从复制信息</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_repl_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_active:<span class="number">0</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_histlen:<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># CPU CPU计算量统计信息</span></span><br><span class="line">used_cpu_sys:<span class="number">10.49</span></span><br><span class="line">used_cpu_user:<span class="number">4.96</span></span><br><span class="line">used_cpu_sys_children:<span class="number">0.00</span></span><br><span class="line">used_cpu_user_children:<span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#commandstats : Redis 命令统计信息</span></span><br><span class="line"><span class="comment">#cluster : Redis 集群信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace 数据库相关的统计信息</span></span><br><span class="line">db0:keys=<span class="number">94</span>,expires=<span class="number">1</span>,avg_ttl=<span class="number">41638810</span></span><br><span class="line">db1:keys=<span class="number">1</span>,expires=<span class="number">0</span>,avg_ttl=<span class="number">0</span></span><br><span class="line">db3:keys=<span class="number">1</span>,expires=<span class="number">0</span>,avg_ttl=<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>下表列出了 redis 服务器的相关命令:</strong></p><table><thead><tr><th>命令</th><th>语法(可用版本)</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><strong>BGREWRITEAOF</strong></td><td><font size=2 color='red'><strong>BGREWRITEAOF（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>反馈信息。</strong></font></td><td><font size=2><strong>用于异步执行一个 AOF（AppendOnly File） 文件重写操作。重写会创建一个当前 AOF 文件的体积优化版本。即使 Bgrewriteaof 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 Bgrewriteaof 成功之前不会被修改。<br />注意：<br />从 Redis 2.4 开始， AOF 重写由 Redis 自行触发， BGREWRITEAOF 仅仅用于手动触发重写操作。</strong></font></td></tr><tr><td><strong>BGSAVE</strong></td><td><font size=2 color='red'><strong>BGSAVE（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>反馈信息。</strong></font></td><td><font size=2><strong>用于在后台异步保存当前数据库的数据到磁盘。BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</strong></font></td></tr><tr><td><strong>CLIENT KILL</strong></td><td><font size=2 color='red'><strong>CLIENT KILL ip:port（&gt;= 2.4.0）</strong></font></td><td><font size=2><strong>成功关闭时，返回 OK 。</strong></font></td><td><font size=2><strong>用于关闭客户端连接。</strong></font></td></tr><tr><td><strong>CLIENT LIST</strong></td><td><font size=2 color='red'><strong>CLIENT LIST（&gt;= 2.4.0）</strong></font></td><td><font size=2><strong>命令返回多行字符串，这些字符串按以下形式被格式化：每个已连接客户端对应一行（以 LF 分割） 每行字符串由一系列 属性=值 形式的域组成，每个域之间以空格分开</strong></font></td><td><font size=2><strong>用于返回所有连接到服务器的客户端信息和统计数据。</strong></font></td></tr><tr><td><strong>CLIENT GETNAME</strong></td><td><font size=2 color='red'><strong>CLIENT GETNAME（&gt;= 2.6.9）</strong></font></td><td><font size=2><strong>如果连接没有设置名字，那么返回空白回复； 如果有设置名字，那么返回名字。</strong></font></td><td><font size=2><strong>用于返回 CLIENT SETNAME 命令为连接设置的名字。 因为新创建的连接默认是没有名字的， 对于没有名字的连接， CLIENT GETNAME 返回空白回复。</strong></font></td></tr><tr><td><strong>CLIENT PAUSE</strong></td><td><font size=2 color='red'><strong>CLIENT PAUSE timeout（&gt;= 2.9.50）</strong></font></td><td><font size=2><strong>返回 OK。如果 timeout 参数是非法的返回错误。</strong></font></td><td><font size=2><strong>用于阻塞客户端命令一段时间（以毫秒计）。</strong></font></td></tr><tr><td><strong>CLIENT SETNAME</strong></td><td><font size=2 color='red'><strong>CLIENT SETNAME connection-name（&gt;= 2.6.9）</strong></font></td><td><font size=2><strong>设置成功时返回 OK 。</strong></font></td><td><font size=2><strong>用于指定当前连接的名称。这个名字会显示在 CLIENT LIST命令的结果中， 用于识别当前正在与服务器进行连接的客户端。</strong></font></td></tr><tr><td><strong>CLUSTER SLOTS</strong></td><td><font size=2 color='red'><strong>CLUSTER SLOTS（&gt;= 3.0.0）</strong></font></td><td><font size=2><strong>IP/端口嵌套的列表数组。</strong></font></td><td><font size=2><strong>用于当前的集群状态，以数组形式展示。</strong></font></td></tr><tr><td><strong>COMMAND</strong></td><td><font size=2 color='red'><strong>COMMAND（&gt;= 2.8.13）</strong></font></td><td><font size=2><strong>嵌套的Redis命令的详细信息列表。列表顺序是随机的。</strong></font></td><td><font size=2><strong>用于返回所有的Redis命令的详细信息，以数组形式展示。</strong></font></td></tr><tr><td><strong>COMMAND COUNT</strong></td><td><font size=2 color='red'><strong>COMMAND COUNT（&gt;= 2.8.13）</strong></font></td><td><font size=2><strong>redis 命令数。</strong></font></td><td><font size=2><strong>用于统计 redis 命令的个数。</strong></font></td></tr><tr><td><strong>COMMAND GETKEYS</strong></td><td><font size=2 color='red'><strong>COMMAND GETKEYS（&gt;= 2.8.13）</strong></font></td><td><font size=2><strong>key 的列表。</strong></font></td><td><font size=2><strong>用于获取所有 key。</strong></font></td></tr><tr><td><strong>TIME</strong></td><td><font size=2 color='red'><strong>TIME（&gt;= 2.6.0）</strong></font></td><td><font size=2><strong>一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒</strong></font></td><td><font size=2><strong>用于返回当前服务器时间。</strong></font></td></tr><tr><td><strong>COMMAND INFO</strong></td><td><font size=2 color='red'><strong>COMMAND INFO command-name [command-name …]（&gt;= 2.8.13）</strong></font></td><td><font size=2><strong>命令描述信息的嵌套列表。</strong></font></td><td><font size=2><strong>用于获取 redis 命令的描述信息。</strong></font></td></tr><tr><td><strong>CONFIG GET</strong></td><td><font size=2 color='red'><strong>CONFIG GET parameter（&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>给定配置参数的值。</strong></font></td><td><font size=2><strong>用于获取 redis 服务的配置参数。在 Redis 2.4 版本中， 有部分参数没有办法用 CONFIG GET 访问，但是在最新的 Redis 2.6 版本中，所有配置参数都已经可以用 CONFIG GET 访问了。</strong></font></td></tr><tr><td><strong>CONFIG REWRITE</strong></td><td><font size=2 color='red'><strong>CONFIG REWRITE parameter（&gt;= 2.8.0）</strong></font></td><td><font size=2><strong>一个状态值：如果配置重写成功则返回 OK ，失败则返回一个错误。</strong></font></td><td><font size=2><strong>对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写。对服务器的当前配置进行修改， 而修改后的配置可能和 redis.conf 文件中所描述的配置不一样， CONFIG REWRITE 的作用就是通过尽可能少的修改， 将服务器当前所使用的配置记录到 redis.conf 文件中。</strong></font></td></tr><tr><td><strong>CONFIG SET</strong></td><td><font size=2 color='red'> <strong>CONFIG SET parameter value （&gt;= 2.0.0）</strong></font></td><td><font size=2><strong>当设置成功时返回 OK ，否则返回一个错误。</strong></font></td><td><font size=2><strong>可以动态地调整 Redis 服务器的配置(configuration)而无须重启。可以使用它修改配置参数，或者改变 Redis 的持久化(Persistence)方式。</strong></font></td></tr><tr><td><strong>CONFIG RESETSTAT</strong></td><td><font size=2 color='red'><strong>CONFIG RESETSTAT（&gt;= 2.0.0）</strong></font></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于重置 INFO命令中的某些统计数据，包括：Keyspace hits (键空间命中次数)、Keyspace misses (键空间不命中次数)、Number of commands processed (执行命令的次数)、Number of connections received (连接服务器的次数)、Number of expired keys (过期key的数量)、Number of rejected connections (被拒绝的连接数量)、Latest fork(2) time(最后执行 fork(2) 的时间)、The <code>aof_delayed_fsync</code> counter(<code>aof_delayed_fsync</code> 计数器的值)</strong></font></td></tr><tr><td><strong>DBSIZE</strong></td><td><font size=2 color='red'><strong>DBSIZE（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>当前数据库的 key 的数量。</strong></font></td><td><font size=2><strong>用于返回当前数据库的 key 的数量。</strong></font></td></tr><tr><td><strong>DEBUG OBJECT</strong></td><td><font size=2 color='red'><strong>DEBUG OBJECT key（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>当 key 存在时，返回有关信息。 当 key 不存在时，返回一个错误。</strong></font></td><td><font size=2><strong>是一个调试命令，它不应被客户端所使用。</strong></font></td></tr><tr><td><strong>DEBUG SEGFAULT</strong></td><td><font size=2 color='red'><strong>DEBUG SEGFAULT（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>无</strong></font></td><td><font size=2><strong>执行一个非法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 调试。</strong></font></td></tr><tr><td><strong>FLUSHALL</strong></td><td><font size=2 color='red'><strong>FLUSHALL（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。</strong></font></td></tr><tr><td><strong>FLUSHDB</strong></td><td><font size=2 color='red'><strong>FLUSHDB（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于清空当前数据库中的所有 key。</strong></font></td></tr><tr><td><strong>INFO</strong></td><td><font size=2 color='red'><strong>INFO [section]（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>字符串，文本行的集合。</strong></font></td><td><font size=2><strong>以一种易于理解和阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。通过给定可选的参数 section ，可以让命令只返回某一部分的信息。</strong></font></td></tr><tr><td><strong>LASTSAVE</strong></td><td><font size=2 color='red'><strong>LASTSAVE（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>字符串，文本行的集合。</strong></font></td><td><font size=2><strong>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。</strong></font></td></tr><tr><td><strong>MONITOR</strong></td><td><font size=2 color='red'><strong>MONITOR（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>用于实时打印出 Redis 服务器接收到的命令，调试用。</strong></font></td></tr><tr><td><strong>ROLE</strong></td><td><font size=2 color='red'><strong>ROLE（&gt;= 2.8.12）</strong></font></td><td><font size=2><strong>返回一个数组：第一个参数是 master, slave, sentinel 三个中的一个。</strong></font></td><td><font size=2><strong>查看主从实例所属的角色，角色有master, slave, sentinel。</strong></font></td></tr><tr><td><strong>SAVE</strong></td><td><font size=2 color='red'><strong>SAVE（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>保存成功时返回 OK 。</strong></font></td><td><font size=2><strong>执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。</strong></font></td></tr><tr><td><strong>SHUTDOWN</strong></td><td><font size=2 color='red'><strong>SHUTDOWN [NOSAVE] [SAVE]（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>执行失败时返回错误。 执行成功时不返回任何信息，服务器和客户端的连接断开，客户端自动退出。</strong></font></td><td><font size=2><strong>停止所有客户端。如果有至少一个保存点在等待，执行 SAVE 命令。如果 AOF 选项被打开，更新 AOF 文件。关闭 redis 服务器(server)。</strong></font></td></tr><tr><td><strong>SLAVEOF</strong></td><td><font size=2 color='red'><strong>SLAVEOF host port（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>总是返回 OK 。</strong></font></td><td><font size=2><strong>可以将当前服务器转变为指定服务器的从属服务器(slave server)。如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行 SLAVEOF host port 将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。另外，对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。利用『 SLAVEOF NO ONE 不会丢弃同步所得数据集』这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</strong></font></td></tr><tr><td><strong>SLOWLOG</strong></td><td><font size=2 color='red'><strong>SLOWLOG subcommand [argument]（&gt;= 2.2.12）</strong></font></td><td><font size=2><strong>取决于不同命令，返回不同的值。</strong></font></td><td><font size=2><strong>用来记录查询执行时间的日志系统。查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</strong></font></td></tr><tr><td><strong>SYNC</strong></td><td><font size=2 color='red'><strong>SYNC（&gt;= 1.0.0）</strong></font></td><td><font size=2><strong>不明确。</strong></font></td><td><font size=2><strong>用于同步主从服务器。</strong></font></td></tr></tbody></table><h1 id="3-文档"><a href="#3-文档" class="headerlink" title="3.文档"></a>3.文档</h1><h2 id="3-1-KeySpace-Notification（键空间通知）"><a href="#3-1-KeySpace-Notification（键空间通知）" class="headerlink" title="3.1 KeySpace Notification（键空间通知）"></a>3.1 KeySpace Notification（键空间通知）</h2><h2 id="3-2-Transation（-事务）"><a href="#3-2-Transation（-事务）" class="headerlink" title="3.2 Transation（ 事务）"></a>3.2 Transation（ 事务）</h2><p><code>MULTI</code> 、 <code>EXEC</code>、 <code>DISCARD</code> 和 <code>WATCH</code>是 Redis 事务的基础。</p><p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p><code>EXEC</code> 命令负责触发并执行事务中的所有命令：</p><ul><li>如果客户端在使用 <code>MULTI</code>  开启了一个事务之后，却因为断线而没有成功执行 <code>EXEC</code> ，那么事务中的所有命令都不会被执行。</li><li>另一方面，如果客户端成功在开启事务之后执行 <code>EXEC</code> ，那么事务中的所有命令都会被执行。</li></ul></li></ul><h2 id="3-3-Pub-Sub（发布与订阅）"><a href="#3-3-Pub-Sub（发布与订阅）" class="headerlink" title="3.3 Pub/Sub（发布与订阅）"></a>3.3 Pub/Sub（发布与订阅）</h2><h2 id="3-4-Replication（主从复制）"><a href="#3-4-Replication（主从复制）" class="headerlink" title="3.4  Replication（主从复制）"></a>3.4  Replication（主从复制）</h2><h2 id="3-5-Protocol（通信协议）"><a href="#3-5-Protocol（通信协议）" class="headerlink" title="3.5 Protocol（通信协议）"></a>3.5 Protocol（通信协议）</h2><h2 id="3-6-Persistence（持久化）"><a href="#3-6-Persistence（持久化）" class="headerlink" title="3.6 Persistence（持久化）"></a>3.6 Persistence（持久化）</h2><h2 id="3-7-Sentinel（哨兵）"><a href="#3-7-Sentinel（哨兵）" class="headerlink" title="3.7 Sentinel（哨兵）"></a>3.7 Sentinel（哨兵）</h2><h2 id="3-8-Cluster（集群）"><a href="#3-8-Cluster（集群）" class="headerlink" title="3.8 Cluster（集群）"></a>3.8 Cluster（集群）</h2><h2 id="3-9-集群规范"><a href="#3-9-集群规范" class="headerlink" title="3.9 集群规范"></a>3.9 集群规范</h2><h1 id="4-jedis"><a href="#4-jedis" class="headerlink" title="4.jedis"></a>4.jedis</h1><h2 id="4-1-Jedis简介"><a href="#4-1-Jedis简介" class="headerlink" title="4.1 Jedis简介"></a>4.1 Jedis简介</h2><h2 id="4-2-HelloWordl-Jedis版"><a href="#4-2-HelloWordl-Jedis版" class="headerlink" title="4.2 HelloWordl(Jedis版)"></a>4.2 HelloWordl(Jedis版)</h2><ol><li><p>jar包导入</p><blockquote><p>下载地址：<a href="https://mvnrepository.com/artifact/redis.clients/jedis">https://mvnrepository.com/artifact/redis.clients/jedis</a> </p></blockquote></li><li><p>基于maven</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;dependency&gt;</span> <span class="string"></span></span><br><span class="line">    <span class="meta">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span> <span class="string"></span></span><br><span class="line">    <span class="meta">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span> <span class="string"></span></span><br><span class="line">    <span class="meta">&lt;version&gt;2.9.0&lt;/version&gt;</span> <span class="string"></span></span><br><span class="line"><span class="meta">&lt;/dependency&gt;</span> <span class="string"></span></span><br></pre></td></tr></table></figure></li><li><p>连接redis</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>); </span><br></pre></td></tr></table></figure></li><li><p>操作redis</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;itheima&quot;</span>); jedis.get(<span class="string">&quot;name&quot;</span>); </span><br></pre></td></tr></table></figure></li><li><p>关闭redis连接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.close(); </span><br></pre></td></tr></table></figure></li><li><p>API文档</p><p><a href="http://xetorthio.github.io/jedis/">http://xetorthio.github.io/jedis/</a> </p></li></ol><h2 id="4-3-Jedis读写redis数据"><a href="#4-3-Jedis读写redis数据" class="headerlink" title="4.3 Jedis读写redis数据"></a>4.3 Jedis读写redis数据</h2><h2 id="4-4-Jedis简易工具类开发"><a href="#4-4-Jedis简易工具类开发" class="headerlink" title="4.4 Jedis简易工具类开发"></a>4.4 Jedis简易工具类开发</h2><h2 id="4-5-可视化客户端"><a href="#4-5-可视化客户端" class="headerlink" title="4.5 可视化客户端"></a>4.5 可视化客户端</h2><h1 id="5-删除策略"><a href="#5-删除策略" class="headerlink" title="5. 删除策略"></a>5. 删除策略</h1><p><strong>数据删除策略</strong></p><ol><li><p>定时删除</p><blockquote><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 </p><p>优点：</p><p>​        节约内存，到时就删除，快速释放掉不必要的内存占用 </p><p>缺点：</p><p>​        CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 </p><p>总结：</p><p>​        用处理器性能换取存储空间 （拿时间换空间） </p></blockquote></li><li><p>惰性删除</p><blockquote><p>数据到达过期时间，不做处理。等下次访问该数据时 </p><ul><li>如果未过期，返回数据 </li><li>发现已过期，删除，返回不存在 </li></ul><p>优点：</p><p>​        节约CPU性能，发现必须删除的时候才删除 </p><p>缺点：</p><p>​        内存压力很大，出现长期占用内存的数据 </p><p>总结：</p><p>​        用存储空间换取处理器性能 （拿时间换空间） </p></blockquote></li><li><p>定期删除</p><blockquote><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 </p><p>特点1：</p><p>​        CPU性能占用设置有峰值，检测频度可自定义设置 </p><p>特点2：</p><p>​        内存压力不是很大，长期占用内存的冷数据会被持续清理 </p><p>总结：</p><p>​        周期性抽查存储空间 （随机抽查，重点抽查） </p></blockquote></li></ol><p><strong>三种策略对比</strong></p><table><thead><tr><th>策略</th><th>内存</th><th>CPU</th><th>总结</th></tr></thead><tbody><tr><td>定时删除</td><td>节约内存，无占用</td><td>不分时段占用CPU资源，频度高</td><td>时间换空间</td></tr><tr><td>惰性删除</td><td>内存占用严重</td><td>延时执行，CPU利用率高</td><td>空间换时间</td></tr><tr><td>定期删除</td><td>内存定期随机清理</td><td>每秒花费固定的COU资源维护内存</td><td>随机抽查，重点抽查</td></tr></tbody></table><h1 id="6-redis高可用"><a href="#6-redis高可用" class="headerlink" title="6. redis高可用"></a>6. redis高可用</h1><h2 id="6-1-主从模式"><a href="#6-1-主从模式" class="headerlink" title="6.1 主从模式"></a>6.1 主从模式</h2><h3 id="6-1-1-作用"><a href="#6-1-1-作用" class="headerlink" title="6.1.1 作用"></a>6.1.1 作用</h3><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数 量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 </li></ul><h3 id="6-1-2主从复制工作流程"><a href="#6-1-2主从复制工作流程" class="headerlink" title="6.1.2主从复制工作流程"></a>6.1.2主从复制工作流程</h3><ol><li><p>建立连接阶段（即准备阶段）</p><blockquote><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号 </p></blockquote><ul><li>步骤1：设置master的地址和端口，保存master信息</li><li>步骤2：建立socket连接 </li><li>步骤3：发送ping命令（定时器任务） </li><li>步骤4：身份验证 </li><li>步骤5：发送slave端口信息</li></ul><table><thead><tr><th>master</th><th>slave</th></tr></thead><tbody><tr><td></td><td>①发送指令：slaveof  ip  port</td></tr><tr><td>②接收到指令，响应对方</td><td></td></tr><tr><td></td><td>③保存master的IP与端口     masterhost     masterport</td></tr><tr><td></td><td>④根据保存的信息创建连接master的socket</td></tr><tr><td></td><td>⑤周期性发送命令：ping</td></tr><tr><td>⑥响应pong</td><td></td></tr><tr><td></td><td>⑦发送指令：auth  password</td></tr><tr><td>⑧验证授权</td><td></td></tr><tr><td></td><td>⑨发送指令：replconf listening-port <port-number></td></tr><tr><td>⑩保存slave的端口号</td><td></td></tr></tbody></table><ol><li><p>主从连接（slave连接master）</p><ul><li><p>方式一：客户端发送命令</p><blockquote><p><code>slaveof &lt;masterip&gt; &lt;masterport&gt; </code></p></blockquote></li><li><p>方式二：启动服务器参数 </p><blockquote><p><code>redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></blockquote></li><li><p>方式三：服务器配置 </p><blockquote><p><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></blockquote></li><li><p>slave系统信息 </p><ol><li>master_link_down_since_seconds </li><li>masterhost </li><li>masterport </li></ol></li><li><p>master系统信息</p><ol><li>slave_listening_port(多个) </li></ol></li></ul></li><li><p>主从断开连接</p><ul><li> 客户端发送命令 </li></ul><blockquote><p> <code>slaveof no one </code></p></blockquote><ul><li><p>说明</p><blockquote><p>slave断开连接后，不会删除已有数据，只是不再接受master发送的数据 </p></blockquote></li></ul></li><li><p>授权访问</p><ul><li><p>master客户端发送命令设置密码 </p><blockquote><p><code>requirepass &lt;password&gt; </code></p></blockquote></li><li><p>master配置文件设置密码 </p><blockquote><p><code>config set requirepass &lt;password&gt;</code></p><p><code>config get requirepass </code></p></blockquote></li><li><p>slave客户端发送命令设置密码 </p><blockquote><p><code>auth &lt;password&gt; </code></p></blockquote></li><li><p>slave配置文件设置密码 </p><blockquote><p><code>masterauth &lt;password&gt;</code></p></blockquote></li><li><p>slave启动服务器设置密码 </p><blockquote><p><code>redis-server –a &lt;password&gt;</code></p></blockquote></li></ul></li></ol></li><li><p>数据同步阶段</p><blockquote><p>在slave初次连接master后，复制master中的所有数据到slave</p><p>将slave的数据库状态更新成master当前的数据库状态 </p></blockquote><ul><li>步骤1：请求同步数据 </li><li>步骤2：创建RDB同步数据 </li><li>步骤3：恢复RDB同步数据 </li><li>步骤4：请求部分同步数据 </li><li>步骤5：恢复部分同步数据</li></ul><table><thead><tr><th>master</th><th>slave</th></tr></thead><tbody><tr><td></td><td>①发送指令：psync2</td></tr><tr><td>②执行bgsave</td><td></td></tr><tr><td>③第一个slave连接时， 创建命令缓冲区</td><td></td></tr><tr><td>④生成RDB文件，通过 socket发送给slave</td><td></td></tr><tr><td></td><td>⑤接收RDB，清空数据，执行RDB文件恢复过程</td></tr><tr><td></td><td>⑥发送命令告知RDB恢复已经完成完成</td></tr><tr><td>⑦发送复制缓冲区信息</td><td></td></tr><tr><td></td><td>⑧接收信息，执行bgrewriteaof，恢复数据</td></tr><tr><td></td><td>⑨发送指令：？？？</td></tr><tr><td>⑩接收到指令，响应对方</td><td></td></tr><tr><td>1-5:全量复制</td><td>6-8部分复制</td></tr></tbody></table><ol><li><p>数据同步阶段master说明 </p><ol><li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行 </p></li><li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已 经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。 </p><blockquote><p> repl-backlog-size 1mb</p></blockquote></li><li><p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区 </p></li></ol></li><li><p>数据同步阶段slave说明 </p><ol><li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务 </p><blockquote><p>slave-serve-stale-data yes|no </p></blockquote></li><li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送 命令</p></li><li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果 master带宽不足，因此数据同步需要根据业务需求，适量错峰</p></li><li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择 </p></li></ol></li></ol></li><li><p>命名传播阶段</p><blockquote><p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的 状态，同步的动作称为命令传播 </p><p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令 </p></blockquote><ol><li><p>命令传播阶段的部分复制 </p><ul><li>命令传播阶段出现了断网现象 <ul><li>网络闪断闪连        忽略 </li><li>短时间网络中断    部分复制 </li><li>长时间网络中断    全量复制 </li></ul></li><li>部分复制的三个核心要素 <ul><li>服务器的运行 id（run id） </li><li>主服务器的复制积压缓冲区 </li><li>主从服务器的复制偏移量 </li></ul></li></ul></li><li><p>服务器运行ID（runid） </p><ol><li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id </li><li>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce </li><li>作用：运行id被用于在服务器间进行传输，识别身份 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 </li><li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发 送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid </li></ol></li><li><p>复制缓冲区 </p><ol><li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区<ul><li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队 列长度时，最先入队的元素会被弹出，而新元素会被放入队列 </li></ul></li><li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 </li><li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） </li><li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中 </li></ol></li><li><p>复制缓冲区内部工作原理 </p><ol><li>组成 <ul><li>偏移量 </li><li>字节值 </li></ul></li><li>工作原理 <ul><li>通过offset区分不同的slave当前数据传播的差异 </li><li>master记录已发送的信息对应的offset</li><li>slave记录已接收的信息对应的offset </li></ul></li></ol></li><li><p>主从服务器复制偏移量（offset）</p><ol><li>概念：一个数字，描述复制缓冲区中的指令字节位置 </li><li> 分类： </li></ol><ul><li> master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）  </li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个） </li></ul><ol start="3"><li> 数据来源： </li></ol><ul><li>master端：发送一次记录一次 </li><li>slave端：接收一次记录一次</li></ul><ol start="4"><li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用 </li></ol></li><li><p>数据同步+命令传播阶段工作流程 </p><table><thead><tr><th>master</th><th>slave</th></tr></thead><tbody><tr><td>②执行bgsave生成RDB文件，记录当前的复制偏移量offset</td><td>①发送指令： psync2  ？-1   psync2  <runid> <offset></td></tr><tr><td>③发送 +FULLRESYNC runid offset   通过socket发送RDB文件给slave<br />期间接收客户端命令，offset发生了变化</td><td>④收到 +FULLRESYNC  保存master的runid和offset 清空当前全部数据，通过socket接收RDB文件，恢复RDB数据</td></tr><tr><td>⑥接收命令，判定runid是否匹配，判定offset是否在复制缓冲区中</td><td>⑤发送命令：psync2  runid offset</td></tr><tr><td>⑦如果runid或offset有一个不满足，执行全量复制<br />⑦如果runid或offset校验通过，offset与offset相同，忽略<br />⑦如果runid或offset校验通过，offset与offset不相同   发送 +CONTINUE offset   通过socket发送复制缓冲区中offset到offset的数据</td><td>⑧收到 +CONTINUE  保存master的offset 接收信息后，执行bgrewriteaof，恢复数据</td></tr><tr><td>1-4全量复制</td><td>5-8部分复制</td></tr></tbody></table></li><li><p>心跳机制</p><ul><li>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 </li><li>master心跳： <ul><li>指令：PING </li><li>周期：由repl-ping-slave-period决定，默认10秒 </li><li>作用：判断slave是否在线 </li><li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常 </li></ul></li><li>slave心跳任务 <ul><li> 指令：REPLCONF ACK {offset} </li><li>周期：1秒 </li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li> 作用2：判断master是否在线 </li></ul></li></ul></li><li><p>心跳阶段注意事项 </p><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 </p><blockquote><p>min-slaves-to-write 2<br>min-slaves-max-lag 8 </p></blockquote><p>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 </p></li><li><p>slave数量由slave发送REPLCONF ACK命令做确认 </p></li><li><p>slave延迟由slave发送REPLCONF ACK命令做确认 </p></li></ul></li><li><p>主从复制工作流程（完整） </p></li></ol></li></ol><h3 id="6-1-3-主从复制常见问题"><a href="#6-1-3-主从复制常见问题" class="headerlink" title="6.1.3 主从复制常见问题"></a>6.1.3 主从复制常见问题</h3><ol><li><p>频繁的全量复制（1） </p><blockquote><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的 全量复制操作 </p><p>内部优化调整方案： </p><ol><li> master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave </li><li> 在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中 </li></ol><ul><li>repl-id repl-offset   </li><li>通过redis-check-rdb命令可以查看该信息 </li></ul><ol start="3"><li> master重启后加载RDB文件，恢复数据 重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中 </li></ol><ul><li>master_repl_id = repl    master_repl_offset = repl-offset</li><li>通过info命令可以查看该信息</li></ul><p>作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master </p></blockquote></li><li><p>频繁的全量复制（2） </p><blockquote><ul><li> 问题现象 </li><li>网络环境不佳，出现网络中断，slave不提供服务</li><li>问题原因 <ul><li>复制缓冲区过小，断网后slave的offset越界，触发全量复制 </li></ul></li><li>最终结果 <ul><li>slave反复进行全量复制 </li></ul></li><li>解决方案 <ul><li>修改复制缓冲区大小 </li></ul></li><li>建议设置如下： <ol><li>测算从master到slave的重连平均时长second </li><li>获取master平均每秒产生写命令数据总量write_size_per_second </li><li>最优复制缓冲区空间 = 2 * second * write_size_per_second </li></ol></li></ul></blockquote></li><li><p>频繁的网络中断（1） </p><ul><li><p>问题现象 </p><ul><li>master的CPU占用过高 或 slave频繁断开连接 </li></ul></li><li><p>问题原因 </p><ul><li>slave每1秒发送REPLCONF ACK命令到master </li><li>当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能 </li><li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应 </li></ul></li><li><p>最终结果 </p><ul><li>master各种资源（输出缓冲区、带宽、连接等）被严重占用 </li></ul></li><li><p>解决方案 </p><ul><li><p>通过设置合理的超时时间，确认是否释放slave </p><blockquote><p>repl-timeout </p></blockquote></li></ul></li></ul></li></ol><pre><code> 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave </code></pre><ol start="4"><li><p>频繁的网络中断（2） </p><ul><li><p>问题现象 </p><ul><li>slave与master连接断开</li></ul></li><li><p>问题原因 </p><ul><li>master发送ping指令频度较低</li><li>master设定超时时间较短 </li><li>ping指令在网络中存在丢包 </li></ul></li><li><p>解决方案 </p><ul><li><p>提高ping指令发送的频度 </p><blockquote><p> repl-ping-slave-period  </p></blockquote></li></ul></li></ul></li></ol><pre><code>  超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时 </code></pre><ol start="5"><li><p>数据不一致 </p><ul><li><p>问题现象 </p><ul><li>多个slave获取相同数据不同步</li></ul></li><li><p>问题原因 </p><ul><li>网络信息不同步，数据发送有延迟</li></ul></li><li><p>解决方案</p><ul><li><p>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p></li><li><p>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问 </p><blockquote><p> slave-serve-stale-data  yes|no </p></blockquote></li></ul></li></ul></li></ol><pre><code> 开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高） </code></pre><h2 id="6-2-哨兵模式"><a href="#6-2-哨兵模式" class="headerlink" title="6.2 哨兵模式"></a>6.2 哨兵模式</h2><h3 id="6-2-1-作用"><a href="#6-2-1-作用" class="headerlink" title="6.2.1 作用"></a>6.2.1 作用</h3><ul><li>监控 <ul><li>不断的检查master和slave是否正常运行。 </li><li>master存活检测、master与slave运行情况检测 </li></ul></li><li> 通知（提醒） </li><li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。 </li><li>自动故障转移 <ul><li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服 务器地址 </li></ul></li></ul><p>注意：</p><p>​        哨兵也是一台redis服务器，只是不提供数据服务 </p><p>​        通常哨兵配置数量为单数 </p><h3 id="6-2-2-启用哨兵模式"><a href="#6-2-2-启用哨兵模式" class="headerlink" title="6.2.2 启用哨兵模式"></a>6.2.2 启用哨兵模式</h3><ol><li><p>配置一拖二的主从结构 </p></li><li><p>配置三个哨兵（配置相同，端口不同） </p><blockquote><p>参看sentinel.conf </p></blockquote></li><li><p>启动哨兵 </p><blockquote><p>redis-sentinel sentinel端口号 .conf </p></blockquote></li></ol><table><thead><tr><th>配置项</th><th>范例</th><th>说明</th></tr></thead><tbody><tr><td>sentinel auth-pass  &lt;服务器名称&gt; <password></td><td>&lt;服务器名称&gt; <password> <br/>sentinel auth-pass mymaster joey</td><td>设置哨兵监听的主服务器信息，最后的参数决定了最终参与选举的服务器（-1）</td></tr><tr><td>sentinel down-after-milliseconds &lt;自定义服 务名称&gt;&lt;主机地址&gt;&lt;端口&gt;&lt;主从服务器总量&gt;</td><td>sentinel monitor mymaster 192.168.194.131 6381 1</td><td>指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒（30000），也是主从切换条件之一</td></tr><tr><td>sentinel down-after-milliseconds  &lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>sentinel down-aftermilliseconds mymaster 3000</td><td>指定同时进行主从的slave数量，数值越大，要求的网络资源越高，要求月洗，同步时间越长</td></tr><tr><td>sentinel parallel-syncs   &lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td>sentinel parallel-syncs mymaster</td><td>指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟</td></tr><tr><td>sentinel failover-timeout   &lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>sentinel failover-timeout mymaster 9000</td><td>服务器无法正常联通时，设定的执行脚本，通常调试使用</td></tr><tr><td>sentinel notification-script   &lt;服务名称&gt;&lt;脚本路径&gt;</td><td></td><td></td></tr></tbody></table><h3 id="6-2-3-哨兵工作原理"><a href="#6-2-3-哨兵工作原理" class="headerlink" title="6.2.3 哨兵工作原理"></a>6.2.3 哨兵工作原理</h3><h2 id="6-3-redis集群"><a href="#6-3-redis集群" class="headerlink" title="6.3 redis集群"></a>6.3 redis集群</h2><h1 id="7-企业级解决方案"><a href="#7-企业级解决方案" class="headerlink" title="7.企业级解决方案"></a>7.企业级解决方案</h1>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2020/02/10/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/02/10/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL-MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL服务"><a href="#1-MySQL服务" class="headerlink" title="1.MySQL服务"></a>1.MySQL服务</h1><h2 id="1-1-MySQL服务的启动和停止"><a href="#1-1-MySQL服务的启动和停止" class="headerlink" title="1.1 MySQL服务的启动和停止"></a>1.1 MySQL服务的启动和停止</h2><p>方式一：计算机——右击管理——服务</p><p>方式二：通过管理员身份运行</p><ul><li><code>net start 服务名（启动服务）</code></li><li><code>net stop 服务名（停止服务）</code></li></ul><h2 id="1-2-MySQL服务的登录和退出"><a href="#1-2-MySQL服务的登录和退出" class="headerlink" title="1.2 MySQL服务的登录和退出"></a>1.2 MySQL服务的登录和退出</h2><p>登录：<strong>mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码</strong></p><p>退出：<strong>exit或ctrl+C</strong></p><h1 id="2-DQL-Data-Query-Language-数据查询语言"><a href="#2-DQL-Data-Query-Language-数据查询语言" class="headerlink" title="2.DQL(Data Query Language)数据查询语言"></a>2.DQL(Data Query Language)数据查询语言</h1><h2 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>通过select查询完的结果 ，是一个虚拟的表格，不是真实存在</li><li>要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</li></ol><h2 id="2-2-条件查询"><a href="#2-2-条件查询" class="headerlink" title="2.2 条件查询"></a>2.2 条件查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 WHERE 筛选条件;</span><br></pre></td></tr></table></figure><p><strong>分类：</strong></p><ol><li><p>条件表达式<br>示例：salary&gt;10000<br>条件运算符：&gt;、&lt; 、&gt;=、 &lt;=、 = 、!=、 &lt;&gt;</p></li><li><p>逻辑表达式</p><p>示例：salary&gt;10000 &amp;&amp; salary&lt;20000</p><p>逻辑运算符：</p><ul><li>and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</li><li>or(||)：两个条件只要有一个成立，结果为true，否则为false</li><li>not(!)：如果条件成立，则not后为false，否则为true</li></ul></li><li><p>模糊查询<br>示例：last_name like ‘a%’</p></li></ol><h2 id="2-3-排序查询"><a href="#2-3-排序查询" class="headerlink" title="2.3 排序查询"></a>2.3 排序查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 ORDER BY 排序列表 【asc||desc】;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li><p>asc ：升序，如果不写默认升序</p><p>desc：降序</p></li><li><p>排序列表 支持 单个字段、多个字段、函数、表达式、别名</p></li><li><p>order by的位置一般放在查询语句的最后（除limit语句之外）</p></li></ol><h2 id="2-4-常见函数"><a href="#2-4-常见函数" class="headerlink" title="2.4 常见函数"></a>2.4 常见函数</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(实参列表);</span><br></pre></td></tr></table></figure><p><strong>分类：</strong></p><ol><li><p>单行函数</p><ol><li><p>字符函数</p><ul><li><p>concat：连接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(&#39;Hello&#39;,&#39;_&#39;,&#39;World&#39;);</span><br><span class="line">#结果：Hello_World</span><br></pre></td></tr></table></figure></li><li><p>substr：截取子串</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#注意：索引从1开始</span><br><span class="line">#截取从指定索引处后面所有字符</span><br><span class="line">SELECT SUBSTR(&#39;Hello World&#39;,7);</span><br><span class="line">#结果：World</span><br><span class="line">#截取从指定索引处指定字符长度的字符</span><br><span class="line">SELECT SUBSTR(&#39;Hello World&#39;,1,3);</span><br><span class="line">#结果：Hel</span><br></pre></td></tr></table></figure></li><li><p>upper：变大写</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT UPPER(&#39;john&#39;);</span><br><span class="line">#结果：JOHN</span><br></pre></td></tr></table></figure></li><li><p>lower：变小写</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   SELECT LOWER(&#39;joHn&#39;);</span><br><span class="line">#结果：john</span><br></pre></td></tr></table></figure></li><li><p>replace：替换</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT REPLACE(&#39;Hello World&#39;,&#39;l&#39;,&#39;i&#39;);</span><br><span class="line">#结果：Heiio Worid</span><br></pre></td></tr></table></figure></li><li><p>length：获取字节长度</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(&#39;john&#39;);</span><br><span class="line">#结果：4</span><br></pre></td></tr></table></figure></li><li><p>trim：去前后空格</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(TRIM(&#39;    Hello    &#39;));</span><br><span class="line">#结果：5</span><br></pre></td></tr></table></figure></li><li><p>lpad：左填充</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRIM(&#39;l&#39; FROM &#39;llllllllHellolllll&#39;);</span><br><span class="line">#结果：Hello</span><br></pre></td></tr></table></figure></li><li><p>rpad：右填充</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LPAD(&#39;john&#39;,6,&#39;*&#39;);</span><br><span class="line">#结果：**john</span><br></pre></td></tr></table></figure></li><li><p>instr：获取子串第一次出现的索引</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT INSTR(&#39;Hello World&#39;,&#39;o&#39;);</span><br><span class="line">#结果：5</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数学函数</p><ul><li><p>ceil：向上取整</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CEIL(-1.02);</span><br><span class="line">#结果：-1</span><br></pre></td></tr></table></figure></li><li><p>round：四舍五入</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ROUND(-1.55);</span><br><span class="line">#结果：-2</span><br><span class="line">SELECT ROUND(1.567,2);</span><br><span class="line">#结果：1.57</span><br></pre></td></tr></table></figure></li><li><p>mod：取模</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MOD(10,-3);</span><br><span class="line">#结果：1</span><br><span class="line">SELECT 10%3;</span><br><span class="line">#结果：1</span><br></pre></td></tr></table></figure></li><li><p>floor：向下取整</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT FLOOR(-9.99);</span><br><span class="line">#结果：-10</span><br></pre></td></tr></table></figure></li><li><p>truncate：截断</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRUNCATE(1.69999,1);</span><br><span class="line">#结果：1.6</span><br></pre></td></tr></table></figure></li><li><p>rand：获取随机数，返回0-1之间的小数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT RAND();</span><br><span class="line">#结果：0.2870596892079894</span><br></pre></td></tr></table></figure></li></ul></li><li><p>日期函数</p><ul><li><p>now：返回当前日期+时间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW();</span><br><span class="line">#结果：2020-02-10 16:05:07</span><br></pre></td></tr></table></figure></li><li><p>curdate：返回当前日期</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURDATE();</span><br><span class="line">#结果：2020-02-10</span><br></pre></td></tr></table></figure></li><li><p>curtime：返回当前时间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURTIME();</span><br><span class="line">#结果：16:05:07</span><br></pre></td></tr></table></figure></li><li><p>year：返回年</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT YEAR(NOW()) 年;</span><br><span class="line">#结果：2020</span><br><span class="line">SELECT YEAR(&#39;1998-1-1&#39;) 年;</span><br><span class="line">#结果：1998</span><br></pre></td></tr></table></figure></li><li><p>month：返回月</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MONTH(NOW()) 月;</span><br><span class="line">#结果：2</span><br></pre></td></tr></table></figure></li><li><p>monthname：以英文形式返回月</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MONTHNAME(NOW()) 月;</span><br><span class="line">#结果：February</span><br></pre></td></tr></table></figure></li><li><p>day：返回日</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DAY(NOW()) 日;</span><br><span class="line">#结果：10</span><br></pre></td></tr></table></figure></li><li><p>hour：小时</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT HOUR(NOW()) 小时;</span><br><span class="line">#结果：16</span><br></pre></td></tr></table></figure></li><li><p>minute：分钟</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MINUTE(NOW()) 分钟;</span><br><span class="line">#结果：6</span><br></pre></td></tr></table></figure></li><li><p>second：秒</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SECOND(NOW()) 秒;</span><br><span class="line">#结果：50</span><br></pre></td></tr></table></figure></li><li><p>date_format：将日期转换成字符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(),&#39;%y年%m月%d日&#39;);</span><br><span class="line">#结果：20年02月10日</span><br></pre></td></tr></table></figure></li><li><p>str_to_date：将字符转换成日期</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&#39;1998-3-2&#39;,&#39;%Y-%c-%d&#39;);</span><br><span class="line">#结果：1998-03-02</span><br></pre></td></tr></table></figure></li><li><p>datediff：返回两个日期相差的天数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATEDIFF(&#39;2020-12-30&#39;,&#39;2020-12-29&#39;);</span><br><span class="line">#结果：1</span><br></pre></td></tr></table></figure></li></ul></li><li><p>流程控制函数</p><ul><li><p><strong>if</strong>(条件表达式，表达式1，表达式2)：</p><p> 如果条件表达式成立，返回表达式1，否则返回表达式2</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT IF(10&lt;5,&#39;大&#39;,&#39;小&#39;);</span><br><span class="line">#结果：小 </span><br></pre></td></tr></table></figure></li><li><p><strong>case情况1</strong></p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 变量或表达式或字段</span><br><span class="line">when 常量1 then 值1</span><br><span class="line">when 常量2 then 值2</span><br><span class="line">...</span><br><span class="line">else 值n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#示例</span><br><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></li><li><p><strong>case情况2</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 值1</span><br><span class="line">when 条件2 then 值2</span><br><span class="line">...</span><br><span class="line">else 值n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#示例</span><br><span class="line">SELECT salary,</span><br><span class="line">CASE </span><br><span class="line">WHEN salary&gt;20000 THEN &#39;A&#39;</span><br><span class="line">    WHEN salary&gt;15000 THEN &#39;B&#39;</span><br><span class="line">WHEN salary&gt;10000 THEN &#39;C&#39;</span><br><span class="line">    ELSE &#39;D&#39;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他函数</p><ul><li><p>version：当前数据库服务器的版本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br><span class="line">#结果：5.7.18-log</span><br></pre></td></tr></table></figure></li><li><p>database：当前打开的数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br><span class="line">#结果：joeychat</span><br></pre></td></tr></table></figure></li><li><p>user：当前用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT USER();</span><br><span class="line">#结果：root@localhost</span><br></pre></td></tr></table></figure></li><li><p>password(‘字符’)：返回该字符的密码形式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT PASSWORD(&#39;Hello&#39;);</span><br><span class="line">#结果：*FCA02337EEB51C3EE398B473FD9A9AFD093F9E64</span><br></pre></td></tr></table></figure></li><li><p>md5(‘字符’)：返回该字符的md5加密形式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MD5(&#39;Hello&#39;);</span><br><span class="line">#结果：8b1a9953c4611296a827abf8c47804d7    </span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>分组函数</p><ol><li><p>函数</p><ul><li><p>sum：求和</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(salary) FROM employees;</span><br></pre></td></tr></table></figure></li><li><p>max：最大值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary) FROM employees;</span><br></pre></td></tr></table></figure></li><li><p>min：最小值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary) FROM employees;</span><br></pre></td></tr></table></figure></li><li><p>avg：平均值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary) FROM employees;</span><br></pre></td></tr></table></figure></li><li><p>count：计数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(salary) FROM employees;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特点</p><ol><li>以上五个分组函数都忽略<code>null</code>值，除了count(*)</li><li>sum和avg一般用于处理数值型，max、min、count可以处理任何数据类型</li><li>可以搭配distinct使用，用于统计去重后的结果</li><li>count的参数可以支持：字段、*、常量值，一般放1</li><li>效率：<ul><li>MYISAM存储引擎下 ，COUNT(*)的效率高</li><li>INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些</li></ul></li></ol></li></ol></li></ol><h2 id="2-5-分组查询"><a href="#2-5-分组查询" class="headerlink" title="2.5 分组查询"></a>2.5 分组查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 GROUP BY 分组的字段 HAVING 分组后的筛选 ORDER BY 排序列表;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li><p>可以按单个字段分组</p></li><li><p>和分组函数一同查询的字段最好是分组后的字段</p></li><li><table><thead><tr><th>分组筛选</th><th>针对的表</th><th>位置</th><th>关键字</th></tr></thead><tbody><tr><td>分组前筛选</td><td>原始表</td><td>group by的前面</td><td>where</td></tr><tr><td>分组后筛选</td><td>分组后的结果集</td><td>group by的后面</td><td>having</td></tr></tbody></table></li><li><p>可以按多个字段分组，字段之间用逗号隔开</p></li><li><p>可以支持排序</p></li><li><p>having后可以支持别名</p></li></ol><h2 id="2-6-连接查询"><a href="#2-6-连接查询" class="headerlink" title="2.6 连接查询"></a>2.6 连接查询</h2><p><strong>sql99语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段，...</span><br><span class="line">FROM 表1</span><br><span class="line">INNER|LEFT OUTER|RIGHT OUTER|CROSS JOIN 表2 ON 连接条件</span><br><span class="line">INNER|LEFT OUTER|RIGHT OUTER|CROSS JOIN 表3 ON 连接条件</span><br><span class="line">WHERE 筛选条件</span><br><span class="line">GROUP BY 分组字段</span><br><span class="line">HAVING 分组后的筛选条件</span><br><span class="line">ORDER BY 排序的字段或表达式</span><br></pre></td></tr></table></figure><h2 id="2-7-子查询"><a href="#2-7-子查询" class="headerlink" title="2.7 子查询"></a>2.7 子查询</h2><p><strong>含义：</strong></p><p>​        一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询。<br>​        在外面的查询语句，称为主查询或外查询。</p><p><strong>特点：</strong></p><ol><li><p>子查询都放在小括号内</p></li><li><p>子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧</p></li><li><p>子查询优先于主查询执行，主查询使用了子查询的执行结果</p></li><li><p>子查询根据查询结果的行数不同分为以下两类：</p><ul><li><p>单行子查询</p><p>结果集只有一行，一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= </p><p>非法使用子查询的情况：</p><ul><li>子查询的结果为一组值</li><li>子查询的结果为空</li></ul></li><li><p>多行子查询</p><p>结果集有多行，一般搭配多行操作符使用：any、all、in、not in</p><p>in： 属于子查询结果中的任意一个就行</p><p>any和all往往可以用其他查询代替</p></li></ul></li></ol><h2 id="2-8-分页查询"><a href="#2-8-分页查询" class="headerlink" title="2.8 分页查询"></a>2.8 分页查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表</span><br><span class="line">LIMIT offset,size;</span><br><span class="line">#offset代表的是起始的条目索引，默认从0开始,可省略</span><br><span class="line">#size代表的是显示的条目数</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li><p>起始条目索引从0开始</p></li><li><p>limit子句放在查询语句的最后</p></li><li><p>公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage，</p><p>说明：</p><p>​        sizePerPage：每页显示条目数</p><p>​        page：要显示的页数 </p></li></ol><h2 id="2-9-联合查询"><a href="#2-9-联合查询" class="headerlink" title="2.9 联合查询"></a>2.9 联合查询</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件 UNION all</span><br><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件 UNION all</span><br><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件 UNION all</span><br><span class="line">.....</span><br><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>多条查询语句的查询的列数必须是一致的</li><li>多条查询语句的查询的列的类型几乎相同</li><li><strong>union代表去重，union all代表不去重</strong></li></ol><h1 id="3-DML-Data-Manipulate-Language-数据操作语言"><a href="#3-DML-Data-Manipulate-Language-数据操作语言" class="headerlink" title="3. DML(Data Manipulate Language)数据操作语言"></a>3. DML(Data Manipulate Language)数据操作语言</h1><h2 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一</span><br><span class="line">INSERT INTO 表名(字段名，...)VALUES(值1，...);</span><br><span class="line">#方式二</span><br><span class="line">INSERT INTO 表名 SET 字段&#x3D;值,字段&#x3D;值,...;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>字段类型和值类型一致或兼容，而且一一对应</li><li>可以为空的字段，可以不用插入值，或用null填充</li><li>不可以为空的字段，必须插入值</li><li>字段个数和值的个数必须一致</li><li>字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</li></ol><h2 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#单表更新</span><br><span class="line">UPDATE 表名 SET 字段&#x3D;值,字段&#x3D;值 WHERE 筛选条件;</span><br><span class="line">#多表更新</span><br><span class="line">UPDATE 表1 别名 </span><br><span class="line">LEFT|RIGHT|INNER JOIN 表2 别名 </span><br><span class="line">ON 连接条件  </span><br><span class="line">SET 字段&#x3D;值,字段&#x3D;值 </span><br><span class="line">WHERE 筛选条件;</span><br></pre></td></tr></table></figure><h2 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h2><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用DELETE</span><br><span class="line"> #一、删除单表的记录</span><br><span class="line"> DELETE FROM 表名 WHERE 筛选条件;</span><br><span class="line"> #二、级联删除</span><br><span class="line"> DELETE 别名1,别名2 FROM 表1 别名 </span><br><span class="line"> LEFT|RIGHT|INNER JOIN 表2 别名 </span><br><span class="line"> ON 连接条件</span><br><span class="line"> WHERE 筛选条件;</span><br><span class="line">#使用TRUNCATE</span><br><span class="line">TRUNCATE TABLE 表名;</span><br><span class="line">#区别：</span><br><span class="line">#1.truncate删除后，如果再插入，标识列从1开</span><br><span class="line">#  delete删除后，如果再插入，标识列从断点开始</span><br><span class="line">#2.delete可以添加筛选条件</span><br><span class="line">#     truncate不可以添加筛选条件</span><br><span class="line">#3.truncate效率较高</span><br><span class="line">#4.truncate没有返回值</span><br><span class="line">#  delete可以返回受影响的行数</span><br><span class="line">#5.truncate不可以回滚</span><br><span class="line">#  delete可以回滚</span><br></pre></td></tr></table></figure><h1 id="4-DDL-Data-Define-Language-数据定义语言"><a href="#4-DDL-Data-Define-Language-数据定义语言" class="headerlink" title="4.DDL(Data Define Language)数据定义语言"></a>4.DDL(Data Define Language)数据定义语言</h1><h2 id="4-1-库的管理"><a href="#4-1-库的管理" class="headerlink" title="4.1 库的管理"></a>4.1 库的管理</h2><ol><li><p>创建库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 【IF NOT EXISTS】 库名【 CHARACTER SET 字符集名】</span><br></pre></td></tr></table></figure></li><li><p>修改库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 库名 CHARACTER SET 字符集名;</span><br></pre></td></tr></table></figure></li><li><p>删除库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 【IF EXISTS】 库名;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-2-表的管理"><a href="#4-2-表的管理" class="headerlink" title="4.2 表的管理"></a>4.2 表的管理</h2><ol><li><p>创建表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">stuId INT,</span><br><span class="line">stuName VARCHAR(20),</span><br><span class="line">gender CHAR,</span><br><span class="line">bornDate DATETIME</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>修改表</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</span><br></pre></td></tr></table></figure><ol><li><p>添加字段</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD COLUMN 列名 类型 【First|After 字段名】;</span><br></pre></td></tr></table></figure></li><li><p>修改字段名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 类型;</span><br></pre></td></tr></table></figure></li><li><p>修改字段的类型或约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 列名 新类型 【新约束】;</span><br></pre></td></tr></table></figure></li><li><p>删除列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP COLUMN 列名;</span><br></pre></td></tr></table></figure></li><li><p>修改表名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME 【to】 新表名;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>删除表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] studentinfo;</span><br></pre></td></tr></table></figure></li><li><p>复制表</p><ol><li><p>复制表结构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 LIKE 旧表;</span><br></pre></td></tr></table></figure></li><li><p>复制表结构+数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名</span><br><span class="line">SELECT 查询列表 FROM 旧表 【WHERE筛选】;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h2><ol><li><p>整型</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 byte</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table></li><li><p>浮点型</p><table><thead><tr><th>类型</th><th>DECIMAL(M,D)</th><th>FLOAT</th><th>DOUBLE</th></tr></thead><tbody><tr><td>长度</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>4</td><td>8</td></tr></tbody></table></li><li><p>字符型</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255 bytes</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 bytes</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255 bytes</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255 bytes</td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65 535 bytes</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65 535 bytes</td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16 777 215 bytes</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16 777 215 bytes</td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294 967 295 bytes</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294 967 295 bytes</td><td align="left">极大文本数据</td></tr></tbody></table></li><li><p>日期型</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYYMMDD HHMMSS</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table></li></ol><h2 id="4-4-常见的约束"><a href="#4-4-常见的约束" class="headerlink" title="4.4 常见的约束"></a>4.4 常见的约束</h2><ol><li><p>常见约束</p><ol><li>NOT NULL：非空，该字段的值必填</li><li>UNIQUE：唯一，该字段的值不可重复</li><li>DEFAULT：默认，该字段的值不用手动插入有默认值</li><li>CHECK：检查，MYSQL不支持</li><li>PRIMARY KEY：主键，该字段的值不可重复并且非空  NIQUE+NOT NULL</li><li>FOREIGN KEY：外键，该字段的值引用了另外的表的字段</li></ol><p><strong>其中，主键和唯一</strong></p><ol><li>区别：<ul><li>一个表至多有一个主键，但可以有多个唯一</li><li>主键不允许为空，唯一可以为空</li></ul></li><li>相同点<ul><li>都具有唯一性</li><li>都支持组合键，但不推荐</li></ul></li></ol><p><strong>外键</strong></p><ol><li><p>用于限制两个表的关系，从表的字段值引用了主表的某字段值</p></li><li><p>外键列和主表的被引用列要求类型一致，意义一样，名称无要求</p></li><li><p>主表的被引用列要求是一个KEY（一般就是主键）</p></li><li><p>插入数据，先插入主表</p></li><li><p>当设置有外键的时候，可以通过一下两种方式实现删除主表的记录：</p><ul><li><p><strong>方式一：级联删除</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table stuinfo add CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) on DELETE CASCADE;</span><br></pre></td></tr></table></figure><p>说明：这样删除主表中的数据的时候，引用他外键的表的数据也都会进行删除，当然这种做法有点残忍，但是在实际的业务中，进行数据维护的时候，确实也有这么干的</p></li><li><p><strong>方式二：级联置空</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table stuinfo add CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) on DELETE set null;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>这样删除主表中的数据的时候，引用他外键的表的数据不会进行删除，对应的引用外键的那一列会置为空，这种方法比较好。<br><strong>综上所述，要结合具体的业务场景进行选择。</strong></p></li></ul></li></ol></li><li><p>创建表时添加约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段名 字段类型 NOT NULL,#非空</span><br><span class="line">字段名 字段类型 PRIMARY KEY,#主键</span><br><span class="line">字段名 字段类型 UNIQUE,#唯一</span><br><span class="line">字段名 字段类型 DEFAULT 值,#默认</span><br><span class="line">CONSTRAINT 约束名 FOREIGN KEY(字段名) REFERENCES 主表（被引用列）</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p><p><strong>对比：</strong></p><table><thead><tr><th></th><th>支持类型</th><th>可以起约束名</th></tr></thead><tbody><tr><td>列级约束</td><td>除了外键</td><td>不可以</td></tr><tr><td>表级约束</td><td>除了非空和默认</td><td>可以，但对主键无效</td></tr></tbody></table></li><li><p>修改表时添加或删除约束</p><ol><li><p>非空</p><ol><li><p>添加非空</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 NOT NULL;</span><br></pre></td></tr></table></figure></li><li><p>删除非空</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 ;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>默认</p><ol><li><p>添加默认</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 DEFAULT 值;</span><br></pre></td></tr></table></figure></li><li><p>删除默认</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 ;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>主键</p><ol><li><p>添加主键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD【 CONSTRAINT 约束名】 PRIMARY KEY(字段名);</span><br></pre></td></tr></table></figure></li><li><p>删除主键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>唯一</p><ol><li><p>添加唯一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD【 CONSTRAINT 约束名】 UNIQUE(字段名);</span><br></pre></td></tr></table></figure></li><li><p>删除唯一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP INDEX 索引名;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>外键</p><ol><li><p>添加外键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD【 CONSTRAINT 约束名】 FOREIGN KEY(字段名) REFERENCES 主表（被引用列）;</span><br></pre></td></tr></table></figure></li><li><p>删除外键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 约束名;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>自增长列</p><ol><li><p>特点：</p><ol><li><p>不用手动插入值，可以自动提供序列值，默认从1开始，步长为1</p><p>AUTO_INCREMENT_INCREMENT</p><p>如果要更改起始值：手动插入值</p><p>如果要更改步长：更改系统变量 SET AUTO_INCREMENT_INCREMENT=值;</p></li><li><p>一个表至多有一个自增长列</p></li><li><p>自增长列只能支持数值型</p></li><li><p>自增长列必须为一个KEY</p></li></ol></li><li><p>创建表时设置自增长列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表(</span><br><span class="line">字段名 字段类型 约束 AUTO_INCREMENT</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>修改表时设置自增长列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表 MODIFY COLUMN 字段名 字段类型 约束 AUTO_INCREMENT</span><br></pre></td></tr></table></figure></li><li><p>删除自增长列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表 MODIFY COLUMN 字段名 字段类型 约束 </span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="5-TCL-Transaction-Control-Language-事务控制语言"><a href="#5-TCL-Transaction-Control-Language-事务控制语言" class="headerlink" title="5.TCL(Transaction Control Language)事务控制语言"></a>5.TCL(Transaction Control Language)事务控制语言</h1><h2 id="5-1含义"><a href="#5-1含义" class="headerlink" title="5.1含义"></a>5.1含义</h2><p><strong>事务：</strong></p><p>​        一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行</p><h2 id="5-2-特点（ACID）"><a href="#5-2-特点（ACID）" class="headerlink" title="5.2 特点（ACID）"></a>5.2 特点（ACID）</h2><ul><li>A 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行</li><li>C 一致性：一个事务可以使数据从一个一致状态切换到另外一个一致的状态</li><li>I 隔离性：一个事务不受其他事务的干扰，多个事务互相隔离的</li><li>D 持久性：一个事务一旦提交了，则永久的持久化到本地</li></ul><h2 id="5-3-使用步骤"><a href="#5-3-使用步骤" class="headerlink" title="5.3 使用步骤"></a>5.3 使用步骤</h2><p><strong>了解：</strong><br>隐式（自动）事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete<br>显式事务：具有明显的开启和结束</p><p><strong>使用显式事务：</strong></p><p>①开启事务<br>set autocommit=0;<br>start transaction;#可以省略</p><p>②编写一组逻辑sql语句<br>注意：sql语句支持的是insert、update、delete</p><p>设置回滚点：<br>savepoint 回滚点名;</p><p>③结束事务<br>提交：commit;<br>回滚：rollback;<br>回滚到指定的地方：rollback to 回滚点名;</p><h2 id="5-4-并发事务"><a href="#5-4-并发事务" class="headerlink" title="5.4 并发事务"></a>5.4 并发事务</h2><ol><li><p>事务的并发问题是如何发生的？<br>多个事务同时操作 同一个数据库的相同数据时</p></li><li><p>并发问题都有哪些？<br>脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据<br>不可重复读：一个事务多次读取，结果不一样<br>幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的数据</p></li><li><p>如何解决并发问题<br>通过设置隔离级别来解决并发问题</p></li><li><p>隔离级别</p><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED:读未提交</td><td>×</td><td>×</td><td>×</td></tr><tr><td>READ COMMITTED：读已提交</td><td>√</td><td>×</td><td>×</td></tr><tr><td>REPEATABLE READ：可重复读</td><td>√</td><td>√</td><td>×</td></tr><tr><td>SERIALIZABLE：串行化</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></li><li><p>设置和查看隔离级别</p><ol><li><p>设置隔离级别</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set session|global  transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure></li><li><p>查看隔离级别</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h1><h2 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h2><ol><li><p>含义：</p><p>​        mysql5.1版本出现的新特性，本身是一个虚拟表，它的数据来自于表，通过执行时动态生成。</p></li><li><p>好处：</p><ol><li>简化sql语句</li><li>提高了sql的重用性</li><li>保护基表的数据，提高了安全性</li></ol></li><li><p>语法</p><ol><li><p>创建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li><li><p>修改</p><ol><li><p>方式一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view 视图1，视图2,...;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc 视图名;</span><br><span class="line">show create view 视图名;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.插入</span><br><span class="line">insert</span><br><span class="line">2.修改</span><br><span class="line">update</span><br><span class="line">3.删除</span><br><span class="line">delete</span><br><span class="line">4.查看</span><br><span class="line">select</span><br></pre></td></tr></table></figure></li><li><p>注意</p><p>视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新<br>①包含分组函数、group by、distinct、having、union、<br>②join<br>③常量视图<br>④where后的子查询用到了from中的表<br>⑤用到了不可更新的视图</p></li><li><p>视图和表的对比</p><table><thead><tr><th></th><th>关键字</th><th>是否占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td>视图</td><td>view</td><td>占用较小，只保存sql逻辑</td><td>一般用于查询</td></tr><tr><td>表</td><td>table</td><td>保存实际的数据</td><td>增删改查</td></tr></tbody></table></li></ol></li></ol><h2 id="6-2-变量"><a href="#6-2-变量" class="headerlink" title="6.2 变量"></a>6.2 变量</h2><ol><li><p>系统变量</p><p><strong>说明：</strong>变量由系统提供的，不用自定义。</p><ol><li><p>全局变量</p><p>服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效</p></li><li><p>会话变量</p><p>服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p></li></ol><p><strong>语法：</strong></p><ul><li><p>查看系统变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有显式声明global还是session，则默认是session</span><br><span class="line">show 【global|session 】variables like &#39;&#39;; </span><br></pre></td></tr></table></figure></li><li><p>查看指定的系统变量的值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有显式声明global还是session，则默认是session</span><br><span class="line">select @@【global|session】.变量名; </span><br></pre></td></tr></table></figure></li><li><p>为系统变量赋值</p><ul><li><p>方式一</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有显式声明global还是session，则默认是session</span><br><span class="line">set 【global|session 】 变量名&#x3D;值; </span><br></pre></td></tr></table></figure></li><li><p>方式二</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @@global.变量名&#x3D;值;</span><br><span class="line">set @@变量名&#x3D;值；</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>自定义变量</p><ol><li><p>用户变量</p><p>作用域：针对于当前连接（会话）生效</p><p>位置：begin end里面，也可以放在外面</p><p>使用：</p><ol><li><p>声明并赋值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @变量名&#x3D;值;或</span><br><span class="line">set @变量名:&#x3D;值;或</span><br><span class="line">select @变量名:&#x3D;值;</span><br></pre></td></tr></table></figure></li><li><p>更新值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @变量名&#x3D;值;或</span><br><span class="line">set @变量名:&#x3D;值;或</span><br><span class="line">select @变量名:&#x3D;值;</span><br><span class="line">select xx into @变量名 from 表;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @变量名;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>局部变量</p><p>作用域：仅仅在定义它的begin end中有效</p><p>位置：只能放在begin end中，而且只能放在第一句</p><p>使用：</p><ol><li><p>声明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare 变量名 类型 【default 值】;</span><br></pre></td></tr></table></figure></li><li><p>赋值或更新</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set 变量名&#x3D;值;或</span><br><span class="line">set 变量名:&#x3D;值;或</span><br><span class="line">select @变量名:&#x3D;值;</span><br><span class="line">select xx into 变量名 from 表;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 变量名;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="6-3-存储过程"><a href="#6-3-存储过程" class="headerlink" title="6.3 存储过程"></a>6.3 存储过程</h2><ol><li><p>创建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程名(参数模式 参数名 参数类型)</span><br><span class="line">begin</span><br><span class="line">存储过程体</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>1.参数模式：in、out、inout，其中in可以省略</strong></p><p><strong>2.存储过程体的每一条sql语句都需要用分号结尾</strong></p></li><li><p>调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call 存储过程名(实参列表)</span><br><span class="line">#举例：</span><br><span class="line">#调用in模式的参数：call sp1（‘值’）;</span><br><span class="line">#调用out模式的参数：set @name; call sp1(@name);select @name;</span><br><span class="line">#调用inout模式的参数：set @name&#x3D;值; call sp1(@name); select @name;</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create procedure 存储过程名;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop procedure 存储过程名;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-4-函数"><a href="#6-4-函数" class="headerlink" title="6.4 函数"></a>6.4 函数</h2><ol><li><p>创建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create function 函数名(参数名 参数类型) returns  返回类型</span><br><span class="line">begin</span><br><span class="line">函数体</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>注意：函数体中肯定需要有return语句</strong></p></li><li><p>调用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 函数名(实参列表);</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create function 函数名;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop function 函数名;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-5-流程控制结构"><a href="#6-5-流程控制结构" class="headerlink" title="6.5 流程控制结构"></a>6.5 流程控制结构</h2><h3 id="6-5-1-分支结构"><a href="#6-5-1-分支结构" class="headerlink" title="6.5.1 分支结构"></a>6.5.1 分支结构</h3><ol><li><p>IF函数</p><p>功能：实现简单双分支</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件，值1，值2)</span><br></pre></td></tr></table></figure><p>位置：可以作为表达式放在任何位置</p></li><li><p>CASE结构</p><p>功能：实现多分支</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一种</span><br><span class="line">case 表达式或字段</span><br><span class="line">when 值1 then 语句1;</span><br><span class="line">when 值2 then 语句2；</span><br><span class="line">..</span><br><span class="line">else 语句n;</span><br><span class="line">end [case];</span><br><span class="line">#第二种</span><br><span class="line">case </span><br><span class="line">when 条件1 then 语句1;</span><br><span class="line">when 条件2 then 语句2；</span><br><span class="line">..</span><br><span class="line">else 语句n;</span><br><span class="line">end [case];</span><br></pre></td></tr></table></figure></li><li><p>IF结构</p><p>功能：实现多分支</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件1 then 语句1;</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure><p>位置：只能放在begin end中</p></li></ol><h3 id="6-5-2-循环结构"><a href="#6-5-2-循环结构" class="headerlink" title="6.5.2 循环结构"></a>6.5.2 循环结构</h3><ol><li><p>WHILE</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【名称:】while 循环条件 do</span><br><span class="line">循环体</span><br><span class="line">end while 【名称】;</span><br></pre></td></tr></table></figure></li><li><p>LOOP</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【名称：】loop</span><br><span class="line">循环体</span><br><span class="line">end loop 【名称】;</span><br></pre></td></tr></table></figure></li><li><p>REPEAT</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【名称:】repeat</span><br><span class="line">循环体</span><br><span class="line">until 结束条件 </span><br><span class="line">end repeat 【名称】;</span><br></pre></td></tr></table></figure></li><li><p>对比</p><ol><li><p>这三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称</p><ul><li>leave：类似于break，用于跳出所在的循环</li><li>iterate：类似于continue，用于结束本次循环，继续下一次</li></ul></li><li><p>loop 一般用于实现简单的死循环</p><p>while 先判断后执行</p><p>repeat 先执行后判断，无条件至少执行一次</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高德地图绘制矢量图</title>
      <link href="/2019/12/19/%E5%9C%B0%E5%9B%BE-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E7%94%BB%E7%82%B9%E3%80%81%E6%8A%98%E7%BA%BF%E3%80%81%E5%A4%9A%E8%BE%B9%E5%BD%A2%E3%80%81%E9%95%BF%E6%96%B9%E5%BD%A2%E3%80%81%E5%9C%86/"/>
      <url>/2019/12/19/%E5%9C%B0%E5%9B%BE-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E7%94%BB%E7%82%B9%E3%80%81%E6%8A%98%E7%BA%BF%E3%80%81%E5%A4%9A%E8%BE%B9%E5%BD%A2%E3%80%81%E9%95%BF%E6%96%B9%E5%BD%A2%E3%80%81%E5%9C%86/</url>
      
        <content type="html"><![CDATA[<h1 id="高德地图绘制矢量图"><a href="#高德地图绘制矢量图" class="headerlink" title="高德地图绘制矢量图"></a>高德地图绘制矢量图</h1><h1 id="地图坐标选取器"><a href="#地图坐标选取器" class="headerlink" title="地图坐标选取器"></a>地图坐标选取器</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;chrome=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1.0, user-scalable=no, width=device-width&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="string">&quot;Segoe UI&quot;</span>, Roboto, <span class="string">&quot;Helvetica Neue&quot;</span>, Arial, sans-serif, <span class="string">&quot;Apple Color Emoji&quot;</span>, <span class="string">&quot;Segoe UI Emoji&quot;</span>, <span class="string">&quot;Segoe UI Symbol&quot;</span>, <span class="string">&quot;Noto Color Emoji&quot;</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-weight</span>: <span class="number">300</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: <span class="number">#111213</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        * &#123;</span><br><span class="line"><span class="css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .input-item &#123;</span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: -ms-flexbox;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            -ms-<span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="css">            -ms-<span class="attribute">flex</span>-align: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">2.2rem</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .info &#123;</span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: .<span class="number">75rem</span> <span class="number">1.25rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: .<span class="number">25rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">            <span class="attribute">top</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">min-width</span>: <span class="number">22rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">right</span>: auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">6px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">114</span>, <span class="number">124</span>, <span class="number">245</span>, .<span class="number">5</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .input-card &#123;</span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="css">            <span class="attribute">min-width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">word-wrap</span>: break-word;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-clip</span>: border-box;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: .<span class="number">25rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">22rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">6px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">114</span>, <span class="number">124</span>, <span class="number">245</span>, .<span class="number">5</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">            <span class="attribute">bottom</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">right</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">            -ms-<span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0.75rem</span> <span class="number">1.25rem</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .btn &#123;</span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">6rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">1rem</span> <span class="number">0</span> <span class="number">2rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-weight</span>: <span class="number">400</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">            <span class="attribute">white-space</span>: nowrap;</span></span><br><span class="line"><span class="css">            <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">            -webkit-user-select: none;</span></span><br><span class="line"><span class="css">            -moz-user-select: none;</span></span><br><span class="line"><span class="css">            -ms-user-select: none;</span></span><br><span class="line"><span class="css">            user-select: none;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">transition</span>: color .<span class="number">15s</span> ease-in-out, background-color .<span class="number">15s</span> ease-in-out, border-color .<span class="number">15s</span> ease-in-out, box-shadow .<span class="number">15s</span> ease-in-out;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: transparent;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-image</span>: none;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: <span class="number">#25A5F7</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-color</span>: <span class="number">#25A5F7</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: .<span class="number">25rem</span> .<span class="number">5rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">            -webkit-appearance: button;</span></span><br><span class="line"><span class="css">            <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-class">.btn</span><span class="selector-pseudo">:focus</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-class">.btn</span><span class="selector-pseudo">:active</span><span class="selector-pseudo">:focus</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-class">.btn</span><span class="selector-class">.active</span><span class="selector-pseudo">:focus</span>,</span></span><br><span class="line">            .btn.focus,</span><br><span class="line"><span class="css">            <span class="selector-class">.btn</span><span class="selector-pseudo">:active</span><span class="selector-class">.focus</span>,</span></span><br><span class="line">            .btn.active.focus &#123;</span><br><span class="line"><span class="css">                <span class="attribute">outline</span>: none;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        .input-text &#123;</span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">4rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: <span class="number">1rem</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>鼠标工具绘制<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;info&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>操作说明：圆和矩形通过拖拽来绘制，其他覆盖物通过单击来绘制，双击结束绘制<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>当前类型：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;type&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>坐标信息：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;lnglat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;location&quot;</span>&gt;</span>位置信息： <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-card&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;width: 24rem;&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-item&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;func&#x27;</span> <span class="attr">checked</span> <span class="attr">value</span>=<span class="string">&#x27;marker&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input-text&quot;</span>&gt;</span>画点<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;func&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;polyline&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input-text&quot;</span>&gt;</span>画折线<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;func&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;polygon&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input-text&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;width:5rem;&#x27;</span>&gt;</span>画多边形<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-item&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;func&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;rectangle&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input-text&quot;</span>&gt;</span>画矩形<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;func&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;circle&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input-text&quot;</span>&gt;</span>画圆<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-item&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;clear&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清除&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;confirm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确定&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://webapi.amap.com/maps?v=1.4.15&amp;key=你的key&amp;plugin=AMap.MouseTool&amp;plugin=AMap.PolyEditor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> map = <span class="keyword">new</span> AMap.Map(<span class="string">&#x27;container&#x27;</span>, &#123;</span></span><br><span class="line">            zoom: 13,</span><br><span class="line">            center: [110.255414, 20.009835],</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//自定义控件</span></span></span><br><span class="line"><span class="javascript">        AMap.plugin([<span class="string">&#x27;AMap.ToolBar&#x27;</span>, <span class="string">&#x27;AMap.Scale&#x27;</span>, <span class="string">&#x27;AMap.OverView&#x27;</span>, <span class="string">&#x27;AMap.MapType&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//map.addControl(new AMap.ToolBar());</span></span></span><br><span class="line"><span class="javascript">            map.addControl(<span class="keyword">new</span> AMap.Scale());</span></span><br><span class="line"><span class="javascript">            <span class="comment">//map.addControl(new AMap.OverView(&#123; isOpen: true &#125;));</span></span></span><br><span class="line"><span class="javascript">            map.addControl(<span class="keyword">new</span> AMap.MapType(&#123; <span class="attr">defaultType</span>: <span class="number">0</span> &#125;));</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> mouseTool = <span class="keyword">new</span> AMap.MouseTool(map);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//监听draw事件可获取画好的覆盖物</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> overlays = [];</span></span><br><span class="line"><span class="javascript">        <span class="comment">//结果集</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> result = &#123;</span></span><br><span class="line"><span class="javascript">            type: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                location: &#123; <span class="attr">lng</span>: <span class="string">&quot;&quot;</span>, <span class="attr">lat</span>: <span class="string">&quot;&quot;</span> &#125;, <span class="attr">path</span>: [],</span></span><br><span class="line"><span class="javascript">                bounds: &#123; <span class="attr">southwest</span>: &#123; <span class="attr">lng</span>: <span class="string">&quot;&quot;</span>, <span class="attr">lat</span>: <span class="string">&quot;&quot;</span> &#125;, <span class="attr">northeast</span>: &#123; <span class="attr">lng</span>: <span class="string">&quot;&quot;</span>, <span class="attr">lat</span>: <span class="string">&quot;&quot;</span> &#125;, &#125;,</span></span><br><span class="line"><span class="javascript">                circle: &#123; <span class="attr">center</span>: <span class="string">&quot;&quot;</span>, <span class="attr">radius</span>: <span class="string">&quot;&quot;</span> &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        mouseTool.on(<span class="string">&#x27;draw&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//清空覆盖物</span></span></span><br><span class="line">            map.remove(overlays);</span><br><span class="line">            overlays = [];</span><br><span class="line"><span class="javascript">            <span class="comment">//根据类型处理地图覆盖物</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> lnglat = [];<span class="comment">//单项目点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span> (e.obj.getExtData().type) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;marker&#x27;</span>: &#123;</span></span><br><span class="line">                    lnglat.push(e.obj.getPosition().lng);</span><br><span class="line">                    lnglat.push(e.obj.getPosition().lat);</span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;type&quot;</span>).innerHTML = <span class="string">&quot;marker&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;lnglat&quot;</span>).innerHTML = lnglat;</span></span><br><span class="line">                    Geocoder(lnglat, e.obj.getExtData().type);</span><br><span class="line">                    overlays.push(e.obj);</span><br><span class="line"><span class="javascript">                    result.type = <span class="string">&#x27;marker&#x27;</span>;</span></span><br><span class="line">                    result.data.location.lng = e.obj.getPosition().lng;</span><br><span class="line">                    result.data.location.lat = e.obj.getPosition().lat;</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;polyline&#x27;</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = e.obj.getPath();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> tmp = [];</span></span><br><span class="line">                        tmp.push(data[i].lng);</span><br><span class="line">                        tmp.push(data[i].lat);</span><br><span class="line">                        lnglat.push(tmp);</span><br><span class="line">                        result.data.path.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    result.type = <span class="string">&#x27;polyline&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;type&quot;</span>).innerHTML = <span class="string">&quot;polyline&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;lnglat&quot;</span>).innerHTML = lnglat;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> polyline = <span class="keyword">new</span> AMap.Polyline(&#123;</span></span><br><span class="line">                        path: data,</span><br><span class="line"><span class="javascript">                        isOutline: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                        outlineColor: <span class="string">&#x27;#ffeeff&#x27;</span>,</span></span><br><span class="line">                        borderWeight: 3,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">&quot;#3366FF&quot;</span>,</span></span><br><span class="line">                        strokeOpacity: 1,</span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line"><span class="javascript">                        <span class="comment">// 折线样式还支持 &#x27;dashed&#x27;</span></span></span><br><span class="line"><span class="javascript">                        strokeStyle: <span class="string">&quot;solid&quot;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// strokeStyle是dashed时有效</span></span></span><br><span class="line">                        strokeDasharray: [10, 5],</span><br><span class="line"><span class="javascript">                        lineJoin: <span class="string">&#x27;round&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        lineCap: <span class="string">&#x27;round&#x27;</span>,</span></span><br><span class="line">                        zIndex: 50,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">&#x27;polyline&#x27;</span> &#125;,</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    overlays.push(polyline);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    polyline.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">&quot;AMap.PolyEditor&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> PolylineEditor = <span class="keyword">new</span> AMap.PolyEditor(map, polyline);</span></span><br><span class="line">                        overlays.push(PolylineEditor);</span><br><span class="line">                        PolylineEditor.open();</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定增加节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolylineEditor.on(<span class="string">&#x27;addnode&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定调整节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolylineEditor.on(<span class="string">&#x27;adjust&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定删除节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolylineEditor.on(<span class="string">&#x27;removenode&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;polygon&#x27;</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = e.obj.getPath();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> tmp = [];</span></span><br><span class="line">                        tmp.push(data[i].lng);</span><br><span class="line">                        tmp.push(data[i].lat);</span><br><span class="line">                        lnglat.push(tmp);</span><br><span class="line">                        result.data.path.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    result.type = <span class="string">&#x27;polygon&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;type&quot;</span>).innerHTML = <span class="string">&quot;polygon&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;lnglat&quot;</span>).innerHTML = lnglat;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> polygon = <span class="keyword">new</span> AMap.Polygon(&#123;</span></span><br><span class="line">                        path: data,</span><br><span class="line"><span class="javascript">                        isOutline: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                        outlineColor: <span class="string">&#x27;#ffeeff&#x27;</span>,</span></span><br><span class="line">                        borderWeight: 3,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">&quot;#3366FF&quot;</span>,</span></span><br><span class="line">                        strokeOpacity: 1,</span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line"><span class="javascript">                        <span class="comment">// 折线样式还支持 &#x27;dashed&#x27;</span></span></span><br><span class="line"><span class="javascript">                        strokeStyle: <span class="string">&quot;solid&quot;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// strokeStyle是dashed时有效</span></span></span><br><span class="line">                        strokeDasharray: [10, 5],</span><br><span class="line"><span class="javascript">                        lineJoin: <span class="string">&#x27;round&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        lineCap: <span class="string">&#x27;round&#x27;</span>,</span></span><br><span class="line">                        zIndex: 50,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">&#x27;polygon&#x27;</span> &#125;,</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    overlays.push(polygon);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    polygon.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">&quot;AMap.PolyEditor&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> PolygonEditor = <span class="keyword">new</span> AMap.PolyEditor(map, polygon);</span></span><br><span class="line">                        overlays.push(PolygonEditor);</span><br><span class="line">                        PolygonEditor.open();</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定增加节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolygonEditor.on(<span class="string">&#x27;addnode&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定调整节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolygonEditor.on(<span class="string">&#x27;adjust&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定删除节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolygonEditor.on(<span class="string">&#x27;removenode&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;rectangle&#x27;</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = e.obj.getBounds();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> southwestlng = data.southwest.lng;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> southwestlat = data.southwest.lat;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> northeastlng = data.northeast.lng;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> northeastlat = data.northeast.lat;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;type&quot;</span>).innerHTML = <span class="string">&quot;rectangle&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;lnglat&quot;</span>).innerHTML = <span class="string">&quot;southwest:[&quot;</span> + southwestlng + <span class="string">&quot;,&quot;</span> + southwestlat + <span class="string">&quot;],northeast:[&quot;</span> + northeastlng + <span class="string">&quot;,&quot;</span> + northeastlat + <span class="string">&quot;]&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    result.type = <span class="string">&#x27;polygon&#x27;</span>;</span></span><br><span class="line">                    result.data.bounds.southwest.lng = southwestlng;</span><br><span class="line">                    result.data.bounds.southwest.lat = southwestlat;</span><br><span class="line">                    result.data.bounds.northeast.lng = northeastlng;</span><br><span class="line">                    result.data.bounds.northeast.lat = northeastlat;</span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//重新声明矩形对象</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> rectangle = <span class="keyword">new</span> AMap.Rectangle(&#123;</span></span><br><span class="line">                        bounds: data,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">&#x27;red&#x27;</span>,</span></span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line">                        strokeOpacity: 0.5,</span><br><span class="line">                        strokeDasharray: [30, 10],</span><br><span class="line"><span class="javascript">                        <span class="comment">// strokeStyle还支持 solid</span></span></span><br><span class="line"><span class="javascript">                        strokeStyle: <span class="string">&#x27;dashed&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">&#x27;blue&#x27;</span>,</span></span><br><span class="line">                        fillOpacity: 0.5,</span><br><span class="line"><span class="javascript">                        cursor: <span class="string">&#x27;pointer&#x27;</span>,</span></span><br><span class="line">                        zIndex: 50,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">&#x27;rectangle&#x27;</span> &#125;,</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    overlays.push(rectangle);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    rectangle.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">&quot;AMap.RectangleEditor&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> RectangleEditor = <span class="keyword">new</span> AMap.RectangleEditor(map, rectangle);</span></span><br><span class="line">                        overlays.push(RectangleEditor);</span><br><span class="line">                        RectangleEditor.open();</span><br><span class="line"><span class="javascript">                        RectangleEditor.on(<span class="string">&#x27;adjust&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;circle&#x27;</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> radius = e.obj.getRadius();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> center = e.obj.getCenter();</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;type&quot;</span>).innerHTML = <span class="string">&quot;circle&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;lnglat&quot;</span>).innerHTML = <span class="string">&quot;圆心：&quot;</span> + center + <span class="string">&quot;半径：&quot;</span> + radius;</span></span><br><span class="line"><span class="javascript">                    result.type = <span class="string">&#x27;circle&#x27;</span>;</span></span><br><span class="line">                    result.data.circle.center = center;</span><br><span class="line">                    result.data.circle.radius = radius;</span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> circle = <span class="keyword">new</span> AMap.Circle(&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">//map: mapObj,</span></span></span><br><span class="line">                        center: center,</span><br><span class="line">                        radius: radius,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">&quot;#F33&quot;</span>,</span></span><br><span class="line">                        strokeOpacity: 1,</span><br><span class="line">                        strokeWeight: 3,</span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">&quot;ee2200&quot;</span>,</span></span><br><span class="line">                        fillOpacity: 0.35,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">&#x27;circle&#x27;</span> &#125;,</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    overlays.push(circle);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    circle.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">&quot;AMap.CircleEditor&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> CircleEditor = <span class="keyword">new</span> AMap.CircleEditor(map, circle);</span></span><br><span class="line">                        overlays.push(CircleEditor);</span><br><span class="line">                        CircleEditor.open();</span><br><span class="line"><span class="javascript">                        CircleEditor.on(<span class="string">&#x27;move&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        CircleEditor.on(<span class="string">&#x27;adjust&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//绘制图形</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">type</span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">//清空上一次覆盖物</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//不是点需要先通过编辑工具关闭</span></span></span><br><span class="line">            if (overlays.length &gt; 0) &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type != <span class="string">&#x27;marker&#x27;</span>) &#123;</span></span><br><span class="line">                    overlays[1].close();</span><br><span class="line">                &#125;</span><br><span class="line">                map.remove(overlays[0]);</span><br><span class="line">                overlays = [];</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;type&quot;</span>).innerHTML = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;lnglat&quot;</span>).innerHTML = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;address&quot;</span>).innerHTML = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (type == <span class="string">&#x27;marker&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;location&quot;</span>).style.display = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;location&quot;</span>).style.display = <span class="string">&quot;none&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span> (type) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;marker&#x27;</span>: &#123;</span></span><br><span class="line">                    mouseTool.marker(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Marker的Option设置</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">//draggable: true,</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">//类型参数，用作区分</span></span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">&#x27;marker&#x27;</span> &#125;,</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;polyline&#x27;</span>: &#123;</span></span><br><span class="line">                    mouseTool.polyline(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Polyline的Option设置</span></span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">&#x27;#80d8ff&#x27;</span>,</span></span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">&#x27;polyline&#x27;</span> &#125;,</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;polygon&#x27;</span>: &#123;</span></span><br><span class="line">                    mouseTool.polygon(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Polygon的Option设置</span></span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">&#x27;#00b0ff&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">&#x27;#80d8ff&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">&#x27;polygon&#x27;</span> &#125;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;rectangle&#x27;</span>: &#123;</span></span><br><span class="line">                    mouseTool.rectangle(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Polygon的Option设置</span></span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">&#x27;#00b0ff&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">&#x27;#80d8ff&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">&#x27;rectangle&#x27;</span> &#125;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">&#x27;circle&#x27;</span>: &#123;</span></span><br><span class="line">                    mouseTool.circle(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Circle的Option设置</span></span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">&#x27;#00b0ff&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">&#x27;#80d8ff&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">&#x27;circle&#x27;</span> &#125;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> radios = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;func&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; radios.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            radios[i].onchange = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line">                draw(e.target.value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">//默认画点</span></span></span><br><span class="line"><span class="javascript">        draw(<span class="string">&#x27;marker&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//逆地理编码</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Geocoder</span>(<span class="params">lnglat, type</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            AMap.plugin(<span class="string">&#x27;AMap.Geocoder&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> geocoder = <span class="keyword">new</span> AMap.Geocoder(&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// city 指定进行编码查询的城市，支持传入城市名、adcode 和 citycode</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// city: &#x27;010&#x27;</span></span></span><br><span class="line">                    radius: 1000,</span><br><span class="line"><span class="javascript">                    extensions: <span class="string">&quot;all&quot;</span></span></span><br><span class="line">                &#125;)</span><br><span class="line"><span class="javascript">                geocoder.getAddress(lnglat, <span class="function"><span class="keyword">function</span> (<span class="params">status, result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (status === <span class="string">&#x27;complete&#x27;</span> &amp;&amp; result.info === <span class="string">&#x27;OK&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// result为对应的地理位置详细信息</span></span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">&quot;address&quot;</span>).innerHTML = result.regeocode.formattedAddress;</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//编辑事件绑定方法，实时更新左上角数据</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">updateData</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type == <span class="string">&quot;polyline&quot;</span> || overlays[<span class="number">0</span>].getExtData().type == <span class="string">&quot;polygon&quot;</span>) &#123;</span></span><br><span class="line">                data = overlays[0].getPath();</span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> lnglat = [];</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> tmp = [];</span></span><br><span class="line">                    tmp.push(data[i].lng);</span><br><span class="line">                    tmp.push(data[i].lat);</span><br><span class="line">                    lnglat.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;type&quot;</span>).innerHTML = <span class="string">&quot;polygon&quot;</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;lnglat&quot;</span>).innerHTML = lnglat;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type == <span class="string">&quot;rectangle&quot;</span>) &#123;</span></span><br><span class="line">                data = overlays[0].getBounds();</span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;lnglat&quot;</span>).innerHTML = <span class="string">&quot;southwest:[&quot;</span> + data.southwest.lng + <span class="string">&quot;,&quot;</span> + data.southwest.lat</span></span><br><span class="line"><span class="javascript">                    + <span class="string">&quot;],northeast:[&quot;</span> + data.northeast.lng + <span class="string">&quot;,&quot;</span> + data.northeast.lat + <span class="string">&quot;]&quot;</span>;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type == <span class="string">&quot;circle&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;lnglat&quot;</span>).innerHTML = <span class="string">&quot;圆心：&quot;</span> + overlays[<span class="number">0</span>].getCenter() + <span class="string">&quot;半径：&quot;</span> + overlays[<span class="number">0</span>].getRadius();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//清除</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;clear&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//不是点需要先关闭编辑工具</span></span></span><br><span class="line">            if (overlays.length &gt; 0) &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type != <span class="string">&#x27;marker&#x27;</span>) &#123;</span></span><br><span class="line">                    overlays[1].close();</span><br><span class="line">                &#125;</span><br><span class="line">                map.remove(overlays[0]);</span><br><span class="line">                draw(overlays[0].getExtData().type);</span><br><span class="line">            &#125;</span><br><span class="line">            overlays = [];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">//确认，自定义保存结果</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;confirm&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="built_in">JSON</span>.stringify(result));</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(result));</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 地图 </category>
          
          <category> 高德地图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地图 </tag>
            
            <tag> 高德地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsplumb绘制流程图</title>
      <link href="/2019/11/06/JS-JsPlumb%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
      <url>/2019/11/06/JS-JsPlumb%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>背景：公司项目需要一个能绘制流程图的功能，能绘制能保存，并且能够将每个节点和表单数据关联起来。决定使用jsPlumb，然后在github查阅资料看到<a href="https://github.com/smile1828/demo-jsPlumb">demo-jsPlumb</a>，在这个基础上进行了修改完善，一些细节方面也进行了优化，非常感谢 smile1828。</p><p>功能：</p><ul><li><p>按钮点击新增节点，或者拖拽新增节点</p><blockquote><p>项目上只需要用到一个图形，所以就做成新增按钮，需要多个节点拖动，html可以取消隐藏</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flow-body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flow-menu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span>&gt;</span>节点类型列表<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;flow-btns&quot;</span> <span class="attr">class</span>=<span class="string">&quot;flow-btns&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flow-btn btn-base&quot;</span> <span class="attr">data-type</span>=<span class="string">&quot;base&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flow-btn btn-flow&quot;</span> <span class="attr">data-type</span>=<span class="string">&quot;flow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flow-btn btn-node&quot;</span> <span class="attr">data-type</span>=<span class="string">&quot;node&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flow-btn btn-judge&quot;</span> <span class="attr">data-type</span>=<span class="string">&quot;judge&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flow-container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flow-main&quot;</span> <span class="attr">id</span>=<span class="string">&quot;flow-main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20191106161400.png" alt="新增节点"></p></li><li><p>单击节点，右上角出现删除角标点击删除，也可以按delete删除</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20191106161444.png" alt="删除节点"></p></li><li><p>双击节点，可打开自定义窗口</p></li><li><p>节点支持连线</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20191106161630.png" alt="连线节点"></p></li><li><p>连线单击选中后，按delete删除</p></li><li><p>连线双击可以添加label</p></li><li><p>点击保存按钮，可以将流程图存为json数据通过ajax传给后端保存</p></li><li><p>对于已经存在数据的可以直接调用draw方法绘制</p></li><li><p>支持清空画布</p></li></ul><p>参考链接：</p><ul><li><a href="https://github.com/smile1828/demo-jsPlumb">demo-jsPlumb</a></li><li><a href="https://www.cnblogs.com/xcj26/p/9870734.html">jsplumb 中文教程</a></li><li><a href="https://blog.csdn.net/T_tq_bnsg_bs_ll/article/details/91380367">jsPlumb应用指南（一）概念部分</a></li></ul><p>注：文件在<a href="https://github.com/fangchenyong/jsPlumb-Flowchart">Github地址</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> Jsplumb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Jsplumb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript常用方法</title>
      <link href="/2019/10/29/JS-JS%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/10/29/JS-JS%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript常用方法"><a href="#JavaScript常用方法" class="headerlink" title="JavaScript常用方法"></a>JavaScript常用方法</h1><h2 id="1-将数值四舍五入-保留2位小数-后格式化成金额形式"><a href="#1-将数值四舍五入-保留2位小数-后格式化成金额形式" class="headerlink" title="1. 将数值四舍五入(保留2位小数)后格式化成金额形式"></a>1. 将数值四舍五入(保留2位小数)后格式化成金额形式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数值四舍五入(保留2位小数)后格式化成金额形式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>num 数值(Number或者String)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>金额格式的字符串,如&#x27;1,234,567.45&#x27;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type <span class="variable">String</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatCurrency</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    num = num.toString().replace(<span class="regexp">/\$|\,/g</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(num))</span><br><span class="line">        num = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    sign = (num == (num = <span class="built_in">Math</span>.abs(num)));</span><br><span class="line">    num = <span class="built_in">Math</span>.floor(num*<span class="number">100</span>+<span class="number">0.50000000001</span>);</span><br><span class="line">    cents = num%<span class="number">100</span>;</span><br><span class="line">    num = <span class="built_in">Math</span>.floor(num/<span class="number">100</span>).toString();</span><br><span class="line">    <span class="keyword">if</span>(cents&lt;<span class="number">10</span>)</span><br><span class="line">    cents = <span class="string">&quot;0&quot;</span> + cents;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor((num.length-(<span class="number">1</span>+i))/<span class="number">3</span>); i++)</span><br><span class="line">    num = num.substring(<span class="number">0</span>,num.length-(<span class="number">4</span>*i+<span class="number">3</span>))+<span class="string">&#x27;,&#x27;</span>+</span><br><span class="line">    num.substring(num.length-(<span class="number">4</span>*i+<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> (((sign)?<span class="string">&#x27;&#x27;</span>:<span class="string">&#x27;-&#x27;</span>) + num + <span class="string">&#x27;.&#x27;</span> + cents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-金额转大写"><a href="#2-金额转大写" class="headerlink" title="2. 金额转大写"></a>2. 金额转大写</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//金额转大写</span></span><br><span class="line"><span class="keyword">var</span> digitUppercase = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fraction = [<span class="string">&#x27;角&#x27;</span>, <span class="string">&#x27;分&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> digit = [</span><br><span class="line">        <span class="string">&#x27;零&#x27;</span>, <span class="string">&#x27;壹&#x27;</span>, <span class="string">&#x27;贰&#x27;</span>, <span class="string">&#x27;叁&#x27;</span>, <span class="string">&#x27;肆&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;伍&#x27;</span>, <span class="string">&#x27;陆&#x27;</span>, <span class="string">&#x27;柒&#x27;</span>, <span class="string">&#x27;捌&#x27;</span>, <span class="string">&#x27;玖&#x27;</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">var</span> unit = [</span><br><span class="line">        [<span class="string">&#x27;元&#x27;</span>, <span class="string">&#x27;万&#x27;</span>, <span class="string">&#x27;亿&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;拾&#x27;</span>, <span class="string">&#x27;佰&#x27;</span>, <span class="string">&#x27;仟&#x27;</span>]</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">var</span> head = n &lt; <span class="number">0</span> ? <span class="string">&#x27;欠&#x27;</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.abs(n);</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fraction.length; i++) &#123;</span><br><span class="line">        s += (digit[<span class="built_in">Math</span>.floor(n * <span class="number">10</span> * <span class="built_in">Math</span>.pow(<span class="number">10</span>, i)) % <span class="number">10</span>] + fraction[i]).replace(<span class="regexp">/零./</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = s || <span class="string">&#x27;整&#x27;</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; unit[<span class="number">0</span>].length &amp;&amp; n &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; unit[<span class="number">1</span>].length &amp;&amp; n &gt; <span class="number">0</span>; j++) &#123;</span><br><span class="line">            p = digit[n % <span class="number">10</span>] + unit[<span class="number">1</span>][j] + p;</span><br><span class="line">            n = <span class="built_in">Math</span>.floor(n / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s = p.replace(<span class="regexp">/(零.)*零$/</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/^$/</span>, <span class="string">&#x27;零&#x27;</span>) + unit[<span class="number">0</span>][i] + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head + s.replace(<span class="regexp">/(零.)*零元/</span>, <span class="string">&#x27;元&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/(零.)+/g</span>, <span class="string">&#x27;零&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/^整$/</span>, <span class="string">&#x27;零元整&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-计算文件大小"><a href="#3-计算文件大小" class="headerlink" title="3. 计算文件大小"></a>3. 计算文件大小</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算文件大小函数(保留两位小数),Size为字节大小</span></span><br><span class="line"><span class="comment">// size：初始文件大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getfilesize</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1024.00</span>; <span class="comment">//byte</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; num)</span><br><span class="line">        <span class="keyword">return</span> size + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="built_in">Math</span>.pow(num, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> (size / num).toFixed(<span class="number">2</span>) + <span class="string">&quot;K&quot;</span>; <span class="comment">//kb</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="built_in">Math</span>.pow(num, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> (size / <span class="built_in">Math</span>.pow(num, <span class="number">2</span>)).toFixed(<span class="number">2</span>) + <span class="string">&quot;M&quot;</span>; <span class="comment">//M</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="built_in">Math</span>.pow(num, <span class="number">4</span>))</span><br><span class="line">        <span class="keyword">return</span> (size / <span class="built_in">Math</span>.pow(num, <span class="number">3</span>)).toFixed(<span class="number">2</span>) + <span class="string">&quot;G&quot;</span>; <span class="comment">//G</span></span><br><span class="line">    <span class="keyword">return</span> (size / <span class="built_in">Math</span>.pow(num, <span class="number">4</span>)).toFixed(<span class="number">2</span>) + <span class="string">&quot;T&quot;</span>; <span class="comment">//T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-获取输入框选中值"><a href="#4-获取输入框选中值" class="headerlink" title="4. 获取输入框选中值"></a>4. 获取输入框选中值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;dxs&quot;</span> name=<span class="string">&quot;name&quot;</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;获取&quot;</span>  onclick=<span class="string">&quot;getSelectedText()&quot;</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"><span class="keyword">var</span> inputDom =  <span class="built_in">document</span>.getElementById(<span class="string">&quot;dxs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.selection) <span class="comment">//IE</span></span><br><span class="line">    &#123; </span><br><span class="line">        alert(<span class="built_in">document</span>.selection.createRange().text); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        alert(inputDom.value.substring(inputDom.selectionStart,  </span><br><span class="line">                inputDom.selectionEnd));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="5-判断对象是不是数组"><a href="#5-判断对象是不是数组" class="headerlink" title="5. 判断对象是不是数组"></a>5. 判断对象是不是数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;[object Array]&#x27;</span> == <span class="built_in">Object</span>.prototype.toString.call(source);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-获取url根路径"><a href="#6-获取url根路径" class="headerlink" title="6. 获取url根路径"></a>6. 获取url根路径</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如  http://12.3.4.5/joey/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRootPath</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> strFullPath = <span class="built_in">window</span>.document.location.href;</span><br><span class="line">    <span class="keyword">var</span> strPath = <span class="built_in">window</span>.document.location.pathname;</span><br><span class="line">    <span class="keyword">var</span> pos = strFullPath.indexOf(strPath);</span><br><span class="line">    <span class="keyword">var</span> prePath = strFullPath.substring(<span class="number">0</span>, pos);</span><br><span class="line">    <span class="keyword">var</span> postPath = strPath.substring(<span class="number">0</span>, strPath.substr(<span class="number">1</span>).indexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (prePath + postPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-获取url指定参数"><a href="#7-获取url指定参数" class="headerlink" title="7. 获取url指定参数"></a>7. 获取url指定参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//strParame为参数名称,url为地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">strParame, url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> query = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!url)</span><br><span class="line">        query = <span class="built_in">unescape</span>(location.search.substring(<span class="number">1</span>)); <span class="comment">// Get query string</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = url.indexOf(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">        query = url.substring(index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pairs = query.split(<span class="string">&quot;&amp;&quot;</span>); <span class="comment">// Break at ampersand</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> pos = pairs[i].indexOf(<span class="string">&#x27;=&#x27;</span>); <span class="comment">// Look for &quot;name=value&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// If not found, skip</span></span><br><span class="line">        <span class="keyword">var</span> argname = pairs[i].substring(<span class="number">0</span>, pos); <span class="comment">// Extract the name</span></span><br><span class="line">        <span class="keyword">var</span> value = pairs[i].substring(pos + <span class="number">1</span>); <span class="comment">// Extract the value</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = <span class="built_in">decodeURIComponent</span>(value); <span class="comment">// Decode it, if needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">        args[argname] = value; <span class="comment">// Store as a property</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args[strParame]; <span class="comment">// Return the object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-创建GUID"><a href="#8-创建GUID" class="headerlink" title="8. 创建GUID"></a>8. 创建GUID</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//补了零的标准的guid格式（当然多了个“guid_”前缀,以及使用“_”代替“-”）。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateGUID</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">s4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor((<span class="number">1</span> + <span class="built_in">Math</span>.random()) * <span class="number">0x10000</span>)</span><br><span class="line">          .toString(<span class="number">16</span>)</span><br><span class="line">          .substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s4() + s4() + <span class="string">&#x27;-&#x27;</span> + s4() + <span class="string">&#x27;-&#x27;</span> + s4() + <span class="string">&#x27;-&#x27;</span> +</span><br><span class="line">      s4() + <span class="string">&#x27;-&#x27;</span> + s4() + s4() + s4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-判断一个值是否为空"><a href="#9-判断一个值是否为空" class="headerlink" title="9. 判断一个值是否为空"></a>9. 判断一个值是否为空</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsEmpty</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">&quot;00000000-0000-0000-0000-000000000000&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-设置cookie"><a href="#10-设置cookie" class="headerlink" title="10. 设置cookie"></a>10. 设置cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Days = <span class="number">300</span>; <span class="comment">//此 cookie 将被保存 30 天</span></span><br><span class="line">    <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>();    <span class="comment">//new Date(&quot;December 31, 9998&quot;);</span></span><br><span class="line">    exp.setTime(exp.getTime() + Days * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">&quot;=&quot;</span> + <span class="built_in">escape</span>(value) + <span class="string">&quot;;expires=&quot;</span> + exp.toGMTString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-获取cookie"><a href="#11-获取cookie" class="headerlink" title="11. 获取cookie"></a>11. 获取cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="built_in">document</span>.cookie.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;(^| )&quot;</span> + name + <span class="string">&quot;=([^;]*)(;|$)&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (arr != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(arr[<span class="number">2</span>]); <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-删除cookie"><a href="#12-删除cookie" class="headerlink" title="12. 删除cookie"></a>12. 删除cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    exp.setTime(exp.getTime() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> cval = getCookie(name);</span><br><span class="line">    <span class="keyword">if</span> (cval != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">document</span>.cookie = name + <span class="string">&quot;=&quot;</span> + cval + <span class="string">&quot;;expires=&quot;</span> + exp.toGMTString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-对象数组去重"><a href="#13-对象数组去重" class="headerlink" title="13. 对象数组去重"></a>13. 对象数组去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对connects进行去重，el.pageSourceId == element.pageSourceId是去重条件</span></span><br><span class="line"><span class="keyword">var</span> connects = connects.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!prev.find(<span class="function"><span class="params">el</span>=&gt;</span>(el.pageSourceId == element.pageSourceId))) &#123;</span><br><span class="line">        prev.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯地图坐标选取器</title>
      <link href="/2019/10/15/%E5%9C%B0%E5%9B%BE-%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E6%8B%BE%E5%8F%96%E5%99%A8/"/>
      <url>/2019/10/15/%E5%9C%B0%E5%9B%BE-%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E6%8B%BE%E5%8F%96%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="腾讯地图坐标选取器"><a href="#腾讯地图坐标选取器" class="headerlink" title="腾讯地图坐标选取器"></a>腾讯地图坐标选取器</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>项目地图<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://map.qq.com/api/js?v=2.exp&amp;key=你的key&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://open.map.qq.com/apifiles/2/4/79/main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/Scripts/plugins/jQuery/jquery-2.2.4.min.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/Scripts/plugins/bootstrap/bootstrap.min.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/App_Themes/Default/assets/plugins/bootstrap/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .map-seach &#123;</span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="number">#50a4ec</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.map-seach</span><span class="selector-pseudo">:active</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">80</span>, <span class="number">164</span>, <span class="number">236</span>, <span class="number">0.4</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;toolbar&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-group&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float: left;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;font-style&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-pencil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        <span class="symbol">&amp;nbsp;</span>经度:</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;longitude&quot;</span> <span class="attr">name</span>=<span class="string">&quot;longitude&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-group&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float: left&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;font-style&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-pencil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        <span class="symbol">&amp;nbsp;</span>纬度:</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;latitude&quot;</span> <span class="attr">name</span>=<span class="string">&quot;latitude&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-group&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;font-style&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-map-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                        <span class="symbol">&amp;nbsp;</span>详细地址:</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control box-wight&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mapseacrh&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;confirm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;height:500px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> lat=<span class="string">&quot;&quot;</span>, lng=<span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> geocoder, citylocation, map, marker, label = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> center = <span class="keyword">new</span> qq.maps.LatLng(<span class="number">19.940433</span>, <span class="number">110.362473</span>);</span></span><br><span class="line"><span class="javascript">            map = <span class="keyword">new</span> qq.maps.Map(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>), &#123;</span></span><br><span class="line">                center: center,</span><br><span class="line">                zoom: 13</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            label = <span class="keyword">new</span> qq.maps.Label(&#123;</span></span><br><span class="line">                map: map,</span><br><span class="line"><span class="javascript">                offset: <span class="keyword">new</span> qq.maps.Size(<span class="number">15</span>, -<span class="number">12</span>),</span></span><br><span class="line"><span class="javascript">                draggable: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">                clickable: <span class="literal">false</span></span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            geocoder = <span class="keyword">new</span> qq.maps.Geocoder(&#123;</span></span><br><span class="line"><span class="javascript">                complete: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">                    map.setCenter(result.detail.location);</span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> marker = <span class="keyword">new</span> qq.maps.Marker(&#123;</span></span><br><span class="line">                        map: map,</span><br><span class="line">                        position: result.detail.location</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            marker = <span class="keyword">new</span> qq.maps.Marker(&#123;</span></span><br><span class="line"><span class="javascript">                position: <span class="keyword">new</span> qq.maps.LatLng(lat, lng),</span></span><br><span class="line">                map: map</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="comment">//获取城市列表接口设置中心点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (lat == <span class="string">&#x27;&#x27;</span> || lng == <span class="string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                citylocation = <span class="keyword">new</span> qq.maps.CityService(&#123;</span></span><br><span class="line"><span class="javascript">                    complete: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line">                        map.setCenter(result.detail.latLng);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="javascript">                <span class="comment">//调用searchLocalCity();方法    根据用户IP查询城市信息。</span></span></span><br><span class="line">                citylocation.searchLocalCity();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">//绑定单击事件添加参数</span></span></span><br><span class="line"><span class="javascript">            qq.maps.event.addListener(map, <span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                marker.setMap(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;longitude&quot;</span>).value = event.latLng.getLng().toFixed(<span class="number">6</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;latitude&quot;</span>).value = event.latLng.getLat().toFixed(<span class="number">6</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> url = <span class="built_in">encodeURI</span>(<span class="string">&quot;https://apis.map.qq.com/ws/geocoder/v1/?location=&quot;</span> + event.latLng.getLat() + <span class="string">&quot;,&quot;</span> + event.latLng.getLng() + <span class="string">&quot;&amp;key=你的key&amp;output=jsonp&amp;&amp;callback=?&quot;</span>);</span></span><br><span class="line"><span class="javascript">                $.getJSON(url, <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (result.result != <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">&quot;address&quot;</span>).value = result.result.address;</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">&quot;address&quot;</span>).value = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line"><span class="javascript">                marker = <span class="keyword">new</span> qq.maps.Marker(&#123;</span></span><br><span class="line"><span class="javascript">                    position: <span class="keyword">new</span> qq.maps.LatLng(event.latLng.getLat(), event.latLng.getLng()),</span></span><br><span class="line">                    map: map</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">            qq.maps.event.addListener(map, <span class="string">&quot;mousemove&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> latlng = e.latLng;</span></span><br><span class="line">                label.setPosition(latlng);</span><br><span class="line"><span class="javascript">                label.setContent(latlng.getLat().toFixed(<span class="number">6</span>) + <span class="string">&quot;,&quot;</span> + latlng.getLng().toFixed(<span class="number">6</span>));</span></span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">            geocoder = <span class="keyword">new</span> qq.maps.Geocoder(&#123;</span></span><br><span class="line"><span class="javascript">                complete: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    marker.setMap(<span class="literal">null</span>);</span></span><br><span class="line">                    map.setCenter(result.detail.location);</span><br><span class="line"><span class="javascript">                    marker = <span class="keyword">new</span> qq.maps.Marker(&#123;</span></span><br><span class="line">                        map: map,</span><br><span class="line">                        position: result.detail.location</span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;latitude&quot;</span>).value = marker.position.lat;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">&quot;longitude&quot;</span>).value = marker.position.lng;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">//查询按钮绑定事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#mapseacrh&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                geocoder.getLocation($(<span class="string">&quot;#address&quot;</span>).val());</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="comment">//输入框值变化绑定事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#address&quot;</span>).bind(<span class="string">&quot;input propertychange change&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                geocoder.getLocation($(<span class="string">&quot;#address&quot;</span>).val());</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="comment">//回车事件绑定事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#address&quot;</span>).keypress(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (e.which == <span class="number">13</span>) geocoder.getLocation($(<span class="string">&quot;#address&quot;</span>).val());</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">//确定</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#confirm&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//关闭事件给上一个页面传参赋值自动关闭当前窗口</span></span></span><br><span class="line"><span class="javascript">                lng = <span class="built_in">document</span>.getElementById(<span class="string">&quot;longitude&quot;</span>).value;</span></span><br><span class="line"><span class="javascript">                lat = <span class="built_in">document</span>.getElementById(<span class="string">&quot;latitude&quot;</span>).value;</span></span><br><span class="line"><span class="javascript">                ComToolsCloseWindow(<span class="string">&quot;ok&quot;</span>, <span class="literal">null</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .font-style &#123;</span><br><span class="line"><span class="css">        <span class="comment">/*background: #50a4ec;*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">1px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-weight</span>: <span class="number">600</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#4f5155</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.font-style</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: right;</span></span><br><span class="line">        &#125;</span><br><span class="line">    .form-control &#123;</span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: right;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .box-group &#123;</span><br><span class="line"><span class="css">        <span class="comment">/*background: rgba(125, 180, 200, 0.53);*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line">    &#125;</span><br><span class="line">    #toolbar &#123;</span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">136</span>, <span class="number">195</span>, <span class="number">214</span>, <span class="number">0.89</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">    .box-wight &#123;</span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    .btn-primary &#123;</span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-top</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">4px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="number">#f2f1ed</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#4f5155</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">0px</span> solid <span class="number">#87c0d1</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-weight</span>: <span class="number">600</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">letter-spacing</span>: <span class="number">2px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.btn-primary</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="number">#ff9b08</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.btn-primary</span><span class="selector-pseudo">:active</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="number">#ff9b08</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: white;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 地图 </category>
          
          <category> 腾讯地图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地图 </tag>
            
            <tag> 腾讯地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8 String源码</title>
      <link href="/2019/09/06/Java-%E6%BA%90%E7%A0%81-JDK8-String/"/>
      <url>/2019/09/06/Java-%E6%BA%90%E7%A0%81-JDK8-String/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JDK8-String"><a href="#JDK8-String" class="headerlink" title="JDK8 String"></a>JDK8 String</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span></span><br></pre></td></tr></table></figure><p>从上可以看出：</p><ul><li>String 是final类，不能被继承。</li><li>实现了java.io.Serializable接口，这个序列化接口没有任何方法和域，仅用于标识序列化的语意。</li><li>实现了Comparable<String>接口，这个接口只有一个compareTo(T 0)接口，用于对两个实例化对象比较大小。</li><li>实现了CharSequence接口，这个接口是一个只读的字符序列。包括length(), charAt(int index), subSequence(int start, int end)这几个API接口，值得一提的是，StringBuffer和StringBuild也是实现了该接口。</li></ul><h2 id="2-主要字段属性"><a href="#2-主要字段属性" class="headerlink" title="2.主要字段属性"></a>2.主要字段属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来存字符串，是一个final的char型数组，不可修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line"><span class="comment">//缓存字符串的哈希。而hash是String实例化的hashcode的一个缓存。因为String经常被用于比较，比如在HashMap中。如果每次进行比较都重新计算hashcode的值的话，那无疑是比较麻烦的，而保存一个hashcode的缓存无疑能优化这样的操作。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="comment">//实现序列化的标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields </span><br><span class="line">= <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//静态内部类，用于忽略大小写得比较两个字符串。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">= <span class="keyword">new</span> CaseInsensitiveComparator(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3.构造方法"></a>3.构造方法</h2><table><thead><tr><th>Constructor</th><th>Method</th></tr></thead><tbody><tr><td>String()</td><td>初始化新创建的 <code>String</code>对象，使其表示空字符序列。</td></tr><tr><td>String(byte[] bytes)</td><td>通过使用平台的默认字符集解码指定的字节数组来构造新的 <code>String</code> 。</td></tr><tr><td>String(byte[] bytes, Charset charset)</td><td>构造一个新的<code>String</code>由指定用指定的字节的数组解码charset 。</td></tr><tr><td>String(byte[] bytes, int offset, int length)</td><td>通过使用平台的默认字符集解码指定的字节子阵列来构造新的 <code>String</code> 。</td></tr><tr><td>String(byte[] bytes,  int offset, int length,Charset charset)</td><td>构造一个新的<code>String</code>通过使用指定的指定字节子阵列解码charset  。</td></tr><tr><td>String(byte[] bytes,  int offset, int length, String charsetName)</td><td>构造一个新的 <code>String</code>通过使用指定的字符集解码指定的字节子阵列。</td></tr><tr><td>String(byte[] bytes,  String charsetName)</td><td>构造一个新的<code>String</code>由指定用指定的字节的数组解码charset 。</td></tr><tr><td>String(char[] value)</td><td>分配一个新的 <code>String</code> ，以便它表示当前包含在字符数组参数中的字符序列。</td></tr><tr><td>String(char[] value,  int offset, int count)</td><td>分配一个新的 <code>String</code> ，其中包含字符数组参数的子阵列中的字符。</td></tr><tr><td>String(int[] codePoints,  int offset, int count)</td><td>分配一个新的 <code>String</code> ，其中包含 Unicode code  point数组参数的子阵列中的字符 。</td></tr><tr><td>String(String original)</td><td>初始化新创建的<code>String</code>对象，使其表示与参数相同的字符序列;  换句话说，新创建的字符串是参数字符串的副本。</td></tr><tr><td>String(StringBuffer buffer)</td><td>分配一个新的字符串，其中包含当前包含在字符串缓冲区参数中的字符序列。</td></tr><tr><td>String(StringBuilder builder)</td><td>分配一个新的字符串，其中包含当前包含在字符串构建器参数中的字符序列。</td></tr></tbody></table><h2 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4.常用方法"></a>4.常用方法</h2><ul><li><p><strong>长度和判空</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回的就是char数组的长度，中文是两个字节的，char也是两个字节的。String a=&quot;中文&quot;，a的长度为2。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当char数组的长度为0，则代表String为&quot;&quot;，是空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>charAt、codePointAt类函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//返回String对象的char数组index位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;   <span class="comment">//index不允许小于0，不允许大于等于String的长度</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回String对象的char数组index位置的元素的ASSIC码(int类型)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointAtImpl(value, index, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回index位置元素的前一个元素的ASSIC码(int型)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = index - <span class="number">1</span>;  <span class="comment">//获得index前一个元素的索引位置</span></span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= value.length)) &#123; <span class="comment">//所以，index不能等于0，因为i = 0 - 1 = -1</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointBeforeImpl(value, index, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法返回的是代码点个数，是实际上的字符个数,功能类似于length()</span></span><br><span class="line"><span class="comment">* 对于正常的String来说，length方法和codePointCount没有区别，都是返回字符个数。</span></span><br><span class="line"><span class="comment">* 但当String是Unicode类型时则有区别了。</span></span><br><span class="line"><span class="comment">* 例如：String str = “/uD835/uDD6B” (即使 &#x27;Z&#x27; ), length() = 2 ,codePointCount() = 1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span> || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 也是相对Unicode字符集而言的，从index索引位置算起，偏移codePointOffset个位置，返回偏移后的位置是多少</span></span><br><span class="line"><span class="comment">* 例如，index = 2 ，codePointOffset = 3 ，maybe返回 5 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.offsetByCodePointsImpl(value, <span class="number">0</span>, value.length,</span><br><span class="line">                                            index, codePointOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>getChars、getBytes类函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个不对外的方法，是给String内部调用的，因为它是没有访问修饰符的，只允许同一包下的类访问</span></span><br><span class="line"><span class="comment">* 参数：dst[]是目标数组，dstBegin是目标数组的偏移量，既要复制过去的起始位置(从目标数组的什么位置覆盖)</span></span><br><span class="line"><span class="comment">* 作用就是将String的字符数组value整个复制到dst字符数组中，在dst数组的dstBegin位置开始拷贝</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, dst, dstBegin, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 得到char字符数组，原理是getChars() 方法将一个字符串的字符复制到目标字符数组中。 </span></span><br><span class="line"><span class="comment">* 参数：srcBegin是原始字符串的起始位置，srcEnd是原始字符串要复制的字符末尾的后一个位置(既复制区域不包括srcEnd)</span></span><br><span class="line"><span class="comment">* dst[]是目标字符数组，dstBegin是目标字符的复制偏移量，复制的字符从目标字符数组的dstBegin位置开始覆盖。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;           <span class="comment">//如果srcBegin小于，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;  <span class="comment">//如果srcEnd大于字符串的长度，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;      <span class="comment">//如果原始字符串其实位置大于末尾位置，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得charsetName编码格式的bytes数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName)</span><br><span class="line">    <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(charsetName, value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与上个方法类似，java内部存储字符串使用的unicode编码，注意编码转换！！！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(Charset charset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(charset, value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用平台默认的编码格式获得bytes数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong></p><ul><li>getChars是没有返回值的 ，使用System.arraycopy()方法直接拷贝至目标数组中，并且目标数组有个@NotNull非空注解，否则会抛出java.lang.ArrayIndexOutOfBoundsException异常。</li><li>getBytes是由返回值的。</li></ul></li><li><p><strong>equals类函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String的equals方法，重写了Object的equals方法（区分大小写）</span></span><br><span class="line"><span class="comment">* 比较的是两个字符串的值是否相等</span></span><br><span class="line"><span class="comment">* 参数是一个Object对象，而不是一个String对象。这是因为重写的是Object的equals方法，所以是Object</span></span><br><span class="line"><span class="comment">* 如果是String自己独有的方法，则可以传入String对象，不用多此一举</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 实例：str1.equals(str2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;   <span class="comment">//首先判断形参str2是否跟当前对象str1是同一个对象，既比较地址是否相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;          <span class="comment">//如果地址相等，那么自然值也相等，毕竟是同一个字符串对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;  <span class="comment">//判断str2对象是否是一个String类型，过滤掉非String类型的比较</span></span><br><span class="line">        String anotherString = (String)anObject; <span class="comment">//如果是String类型，转换为String类型</span></span><br><span class="line">        <span class="keyword">int</span> n = value.length;                    <span class="comment">//获得当前对象str1的长度</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;   <span class="comment">//比较str1的长度和str2的长度是否相等</span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;  <span class="comment">//v1为当前对象str1的值，v2为参数对象str2的值</span></span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;                <span class="comment">//就类似于for的int i =0的作用，因为这里使用while</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;                <span class="comment">//每次循环长度-1,直到长度消耗完，循环结束 </span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])              <span class="comment">//同索引位置的字符元素逐一比较</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                <span class="comment">//只要有一个不相等，则返回false</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;                     <span class="comment">//如比较期间没有问题，则说明相等，返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这也是一个String的equals方法，与上一个方法不同，该方法(不区分大小写)，从名字也能看出来</span></span><br><span class="line"><span class="comment">* 是对String的equals方法的补充。</span></span><br><span class="line"><span class="comment">* 这里参数这是一个String对象，而不是Object了，因为这是String本身的方法，不是重写谁的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span>        <span class="comment">//一样，先判断是否为同一个对象</span></span><br><span class="line">        : (anotherString != <span class="keyword">null</span>) </span><br><span class="line">    &amp;&amp; (anotherString.value.length == value.length) <span class="comment">//再判断长度是否相等</span></span><br><span class="line">    &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);  <span class="comment">//再执行regionMatchs方法 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个公有的比较方法，参数是StringBuffer类型</span></span><br><span class="line"><span class="comment">* 实际调用的是contentEquals(CharSequence cs)方法，可以说是StringBuffer的特供版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contentEquals((CharSequence)sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个私有方法，特供给比较StringBuffer和StringBuilder使用的。</span></span><br><span class="line"><span class="comment">* 比如在contentEquals方法中使用，参数是AbstractStringBuilder抽象类的子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonSyncContentEquals</span><span class="params">(AbstractStringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;               <span class="comment">//当前String对象的值</span></span><br><span class="line">    <span class="keyword">char</span> v2[] = sb.getValue();       <span class="comment">//AbstractStringBuilder子类对象的值</span></span><br><span class="line">    <span class="keyword">int</span> n = v1.length;         <span class="comment">//后面就不说了，其实跟equals方法是一样的，只是少了一些判断</span></span><br><span class="line">    <span class="keyword">if</span> (n != sb.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != v2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个常用于String对象跟StringBuffer和StringBuilder比较的方法</span></span><br><span class="line"><span class="comment">* 参数是StringBuffer或StringBuilder或String或CharSequence</span></span><br><span class="line"><span class="comment">* StringBuffer和StringBuilder和String都实现了CharSequence接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Argument is a StringBuffer, StringBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> AbstractStringBuilder) &#123;   <span class="comment">//如果是AbstractStringBuilder抽象类或其子类</span></span><br><span class="line">        <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> StringBuffer) &#123;        <span class="comment">//如果是StringBuffer类型，进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span>(cs) &#123;</span><br><span class="line">                <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">//如果是StringBuilder类型，则进入非同步块</span></span><br><span class="line">            <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***下面就是String和CharSequence类型的比较算法*****/</span></span><br><span class="line">    <span class="comment">// Argument is a String</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> String) &#123;                    </span><br><span class="line">        <span class="keyword">return</span> equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a generic CharSequence</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">int</span> n = v1.length;</span><br><span class="line">    <span class="keyword">if</span> (n != cs.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != cs.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong></p><ul><li>equals()方法怎么重写Object中的equals()实现对String内容的判断</li><li>equalsIgnoreCase()方法是对equals()方法补充，不区分大小写的判断，是String类自己的方法</li><li>contentEquals()则是用于String对象与4种类型的判断，通常用于跟StringBuilder和StringBuffer的判断,也是对equals方法的一个补充，如果是参数是String类型，就调用equals()方法</li></ul></li><li><p><strong>regionMatchs()方法</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个类似于equals的方法，比较的是字符串的片段，也即是部分区域的比较</span></span><br><span class="line"><span class="comment">* toffset是当前字符串的比较起始位置(偏移量),other是要比较的String对象参数，ooffset是要参数String的比较片段起始位置，len是两个字符串要比较的片段的长度大小</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 例子：String str1 = &quot;0123456&quot;,Str2 = &quot;0123456789&quot;; </span></span><br><span class="line"><span class="comment">* str1.regionMatchs(0,str2,0,6);意思是str1从0位置开始于str2的0位置开始比较6个长度的字符串片段</span></span><br><span class="line"><span class="comment">* 相等则返回 true,不等返回false </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;  <span class="comment">//当前对象的值</span></span><br><span class="line">    <span class="keyword">int</span> to = toffset;   <span class="comment">//当前对象的比较片段的起始位置，既偏移量</span></span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;  <span class="comment">//参数，既比较字符串的值</span></span><br><span class="line">    <span class="keyword">int</span> po = ooffset;         <span class="comment">//比较字符串的起始位置</span></span><br><span class="line">    <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)  <span class="comment">//起始位置不小于0或起始位置不大于字符串长度 - 片段长度，大于就截取不到这么长的片段了</span></span><br><span class="line">        || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">        || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;      <span class="comment">//惊讶脸，居然不是抛异常，而是返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;               <span class="comment">//使用while循环，当然也可以使for循环</span></span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;   <span class="comment">//片段区域的字符元素逐个比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这个跟上面的方法一样，只不过多了一个参数，既ignoreCase,既是否为区分大小写。</span></span><br><span class="line"><span class="comment">* 是equalsIgnoreCase()方法的片段比较版本，实际上equalsIgnoreCase()也是调用regionMatches函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                             String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">    <span class="keyword">int</span> po = ooffset;</span><br><span class="line">    <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">        || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">        || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面的解释同上</span></span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">        <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ignoreCase) &#123;   <span class="comment">//当ignoreCase为true时，既忽视大小写时</span></span><br><span class="line">            <span class="comment">// If characters don&#x27;t match but case may be ignored,</span></span><br><span class="line">            <span class="comment">// try converting both characters to uppercase.</span></span><br><span class="line">            <span class="comment">// If the results match, then the comparison scan should</span></span><br><span class="line">            <span class="comment">// continue.</span></span><br><span class="line">            <span class="keyword">char</span> u1 = Character.toUpperCase(c1);   <span class="comment">//片段中每个字符转换为大写</span></span><br><span class="line">            <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">            <span class="keyword">if</span> (u1 == u2) &#123; <span class="comment">//大写比较一次，如果相等则不执行下面的语句，进入下一个循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Unfortunately, conversion to uppercase does not work properly</span></span><br><span class="line">            <span class="comment">// for the Georgian alphabet, which has strange rules about case</span></span><br><span class="line">            <span class="comment">// conversion.  So we need to make one last check before</span></span><br><span class="line">            <span class="comment">// exiting.</span></span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                <span class="comment">//每个字符换行成小写比较一次</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>从上可以看出：</strong></p><ul><li>片段比较时针对的是String对象。所以如果要跟StringBuffer和StringBuilder比较，那么要toString。</li><li>两个字符串之间的片段比较，使用regionMatches，完整的比较，使用equals。</li></ul></li><li><p><strong>compareTo类函数和CaseInsensitiveComparator静态内部类</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个比较字符串中字符大小的函数，因为String实现了Comparable&lt;String&gt;接口，所以重写了compareTo方法</span></span><br><span class="line"><span class="comment">* Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。</span></span><br><span class="line"><span class="comment">* 实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 参数是需要比较的另一个String对象</span></span><br><span class="line"><span class="comment">* 返回的int类型，正数为大，负数为小，是基于字符的ASSIC码比较的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;                  <span class="comment">//当前对象的长度</span></span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;    <span class="comment">//比较对象的长度</span></span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);           <span class="comment">//获得最小长度</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;                        <span class="comment">//获得当前对象的值</span></span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;          <span class="comment">//获得比较对象的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;                    <span class="comment">//相当于for的int k = 0,就是为while循环的数组服务的</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;             <span class="comment">//当当前索引小于两个字符串中较短字符串的长度时，循环继续</span></span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];          <span class="comment">//获得当前对象的字符</span></span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];          <span class="comment">//获得比较对象的字符</span></span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;    <span class="comment">//从前向后遍历，只要其实一个不相等，返回字符ASSIC的差值,int类型</span></span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;   <span class="comment">//如果两个字符串同样位置的索引都相等，返回长度差值，完全相等则为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  这时一个类似compareTo功能的方法，但是不是comparable接口的方法，是String本身的方法</span></span><br><span class="line"><span class="comment">*  使用途径，我目前只知道可以用来不区分大小写的比较大小，但是不知道如何让它被工具类Collections和Arrays运用</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CASE_INSENSITIVE_ORDER.compare(<span class="keyword">this</span>, str);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个饿汉单例模式，是String类型的一个不区分大小写的比较器</span></span><br><span class="line"><span class="comment">* 提供给Collections和Arrays的sort方法使用</span></span><br><span class="line"><span class="comment">* 例如：Arrays.sort(strs,String.CASE_INSENSITIVE_ORDER);</span></span><br><span class="line"><span class="comment">* 效果就是会将strs字符串数组中的字符串对象进行忽视大小写的排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">                                         = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这一个私有的静态内部类，只允许String类本身调用</span></span><br><span class="line"><span class="comment">* 实现了序列化接口和比较器接口，comparable接口和comparator是有区别的</span></span><br><span class="line"><span class="comment">* 重写了compare方法，该静态内部类实际就是一个String类的比较器</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveComparator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8575799808933029326L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length();                 <span class="comment">//s1字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> n2 = s2.length();                 <span class="comment">//s2字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> min = Math.min(n1, n2);           <span class="comment">//获得最小长度 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s1.charAt(i);           <span class="comment">//逐一获得字符串i位置的字符</span></span><br><span class="line">            <span class="keyword">char</span> c2 = s2.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;                   <span class="comment">//部分大小写比较一次</span></span><br><span class="line">                c1 = Character.toUpperCase(c1);    <span class="comment">//转换大写比较一次</span></span><br><span class="line">                c2 = Character.toUpperCase(c2);</span><br><span class="line">                <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                    c1 = Character.toLowerCase(c1);  <span class="comment">//转换小写比较一次</span></span><br><span class="line">                    c2 = Character.toLowerCase(c2);</span><br><span class="line">                    <span class="keyword">if</span> (c1 != c2) &#123;                  <span class="comment">//返回字符差值</span></span><br><span class="line">                        <span class="comment">// No overflow because of numeric promotion</span></span><br><span class="line">                        <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;<span class="comment">//如果字符相等，但长度不等，则返回长度差值，短的教小，所以小-大为负数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Replaces the de-serialized object. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CASE_INSENSITIVE_ORDER; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上的代码可以看出：</p><p>  以上的最大问题可以能就是为什么要有个静态内部类，为什么实现了compareTo又有compare，移步到下面，有解答</p><p>  String实现了comparable接口，重写了compareTo方法，可以用于自己写类进行判断排序，也可以使用collections，Arrays工具类的sort进行排序。只有集合或数组中的元素实现了comparable接口，并重写了compareTo才能使用工具类排序。</p><p>  CASE_INSENSITIVE_ORDER是一个单例，是String提供为外部的比较器，该比较器的作用是忽视大小写进行比较，我们可以通过Collections或Arrays的sort方法将CASE_INSENSITIVE_ORDER比较器作为参数传入，进行排序。</p></li><li><p><strong>startWith、endWith类函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 作用就是当前对象[toffset,toffset + prefix.value.lenght]区间的字符串片段等于prefix</span></span><br><span class="line"><span class="comment">* 也可以说当前对象的toffset位置开始是否以prefix作为前缀</span></span><br><span class="line"><span class="comment">* prefix是需要判断的前缀字符串，toffset是当前对象的判断起始位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;     <span class="comment">//获得当前对象的值</span></span><br><span class="line">    <span class="keyword">int</span> to = toffset;      <span class="comment">//获得需要判断的起始位置，偏移量</span></span><br><span class="line">    <span class="keyword">char</span> pa[] = prefix.value; <span class="comment">//获得前缀字符串的值</span></span><br><span class="line">    <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">    <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;  <span class="comment">//偏移量不能小于0且能截取pc个长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//不能则返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;                  <span class="comment">//循环pc次，既prefix的长度</span></span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;      <span class="comment">//每次比较当前对象的字符串的字符是否跟prefix一样</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;                <span class="comment">//一样则pc--,to++,po++,有一个不同则返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//没有不一样则返回true，当前对象是以prefix在toffset位置做为开头</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断当前字符串对象是否以字符串prefix起头</span></span><br><span class="line"><span class="comment">* 是返回true,否返回fasle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startsWith(prefix, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断当前字符串对象是否以字符串prefix结尾</span></span><br><span class="line"><span class="comment">* 是返回true,否返回fasle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//suffix是需要判断是否为尾部的字符串。</span></span><br><span class="line">    <span class="comment">//value.length - suffix.value.length是suffix在当前对象的起始位置</span></span><br><span class="line">    <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>所以我们知道：</strong></p><ul><li>endsWith的实现也是startWith()，作用就是判断前后缀</li></ul></li><li><p><strong>hashCode()函数</strong></p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这是String字符串重写了Object类的hashCode方法。</span></span><br><span class="line"><span class="comment">   * 给由哈希表来实现的数据结构来使用，比如String对象要放入HashMap中。</span></span><br><span class="line"><span class="comment">   * 如果没有重写HashCode，或HaseCode质量很差则会导致严重的后果，既不靠谱的后果</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;  <span class="comment">//hash是属性字段，是成员变量，所以默认为0</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123; <span class="comment">//如果hash为0，且字符串对象长度大于0，不为&quot;&quot;</span></span><br><span class="line">        <span class="keyword">char</span> val[] = value;   <span class="comment">//获得当前对象的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重点，String的哈希函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;  <span class="comment">//遍历len次</span></span><br><span class="line">            h = <span class="number">31</span> * h + val[i]; <span class="comment">//每次都是31 * 每次循环获得的h +第i个字符的ASSIC码</span></span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;  <span class="comment">//由此可见&quot;&quot;空字符对象的哈希值为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  <strong>所以我们可以知道：</strong></p><ul><li>hashCode的重点就是哈希函数</li><li>String的哈希函数就是循环len次，每次循环体为 <code>31 * 每次循环获得的hash + 第i次循环的字符</code></li></ul></li><li><p>indexOf、lastIndexOf类函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回cn对应的字符在字符串中第一次出现的位置，从字符串的索引0位置开始遍历</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(ch, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * index方法就是返回ch字符第一次在字符串中出现的位置</span></span><br><span class="line"><span class="comment"> * 既从fromIndex位置开始查找，从头向尾遍历，ch整数对应的字符在字符串中第一次出现的位置</span></span><br><span class="line"><span class="comment"> * -1代表字符串没有这个字符，整数代表字符第一次出现在字符串的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> max = value.length; <span class="comment">//获得字符串对象的长度</span></span><br><span class="line">       <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;             <span class="comment">//如果偏移量小于0，则代表偏移量为0，校正偏移量</span></span><br><span class="line">           fromIndex = <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromIndex &gt;= max) &#123;   <span class="comment">//如果偏移量大于最大长度，则返回-1，代表没有字符串没有ch对应的字符</span></span><br><span class="line">           <span class="comment">// Note: fromIndex might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; <span class="comment">//emmm,这个判断，不懂</span></span><br><span class="line">           <span class="comment">// handle most cases here (ch is a BMP code point or a</span></span><br><span class="line">           <span class="comment">// negative value (invalid code point))</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;             <span class="comment">//获得字符串值</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;      <span class="comment">//从fromIndex位置开始向后遍历</span></span><br><span class="line">               <span class="keyword">if</span> (value[i] == ch) &#123;                    <span class="comment">//只有字符串中的某个位置的元素等于ch</span></span><br><span class="line">                   <span class="keyword">return</span> i;                            <span class="comment">//返回对应的位置，函数结束，既第一次出现的位置</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果没有出现，则返回-1</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> indexOfSupplementary(ch, fromIndex);  <span class="comment">//emmm,紧紧接着没看懂的地方</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Character.isValidCodePoint(ch)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span> hi = Character.highSurrogate(ch);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span> lo = Character.lowSurrogate(ch);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> max = value.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="number">1</span>] == lo) &#123;</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从尾部向头部遍历，返回cn第一次出现的位置，value.length - 1就是起点 </span></span><br><span class="line"><span class="comment">* 为了理解，我们可以认为是返回cn对应的字符在字符串中最后出现的位置</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">* ch是字符对应的整数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(ch, value.length - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从尾部向头部遍历，从fromIndex开始作为起点，返回ch对应字符第一次在字符串出现的位置</span></span><br><span class="line"><span class="comment">* 既从头向尾遍历，返回cn对应字符在字符串中最后出现的一次位置，fromIndex为结束点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;  <span class="comment">//之后不解释了,emmmmmmm</span></span><br><span class="line">           <span class="comment">// handle most cases here (ch is a BMP code point or a</span></span><br><span class="line">           <span class="comment">// negative value (invalid code point))</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="comment">//取最小值，作用就是校正，如果fromIndex传大了，就当时len - 1</span></span><br><span class="line">           <span class="keyword">int</span> i = Math.min(fromIndex, value.length - <span class="number">1</span>);   </span><br><span class="line">           <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;      <span class="comment">//算法中是从后向前遍历，直到i&lt;0,退出循环</span></span><br><span class="line">               <span class="keyword">if</span> (value[i] == ch) &#123;  <span class="comment">//只有有相等，返回对应的索引位置</span></span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;   <span class="comment">//没有找到则返回-1</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> lastIndexOfSupplementary(ch, fromIndex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lastIndexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Character.isValidCodePoint(ch)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">           <span class="keyword">char</span> hi = Character.highSurrogate(ch);</span><br><span class="line">           <span class="keyword">char</span> lo = Character.lowSurrogate(ch);</span><br><span class="line">           <span class="keyword">int</span> i = Math.min(fromIndex, value.length - <span class="number">2</span>);</span><br><span class="line">           <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="number">1</span>] == lo) &#123;</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回第一次出现的字符串的位置</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 从fromIndex开始遍历，返回第一次出现str字符串的位置</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">               str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个不对外公开的静态函数</span></span><br><span class="line"><span class="comment">* source就是原始字符串，sourceOffset就是原始字符串的偏移量，起始位置。</span></span><br><span class="line"><span class="comment">* sourceCount就是原始字符串的长度，target就是要查找的字符串。</span></span><br><span class="line"><span class="comment">* fromIndex就是从原始字符串的第fromIndex开始遍历</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           String target, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(source, sourceOffset, sourceCount,</span><br><span class="line">                      target.value, <span class="number">0</span>, target.value.length,</span><br><span class="line">                      fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 同是一个不对外公开的静态函数</span></span><br><span class="line"><span class="comment">* 比上更为强大。</span></span><br><span class="line"><span class="comment">* 多了一个targetOffset和targetCount，既代表别查找的字符串也可以被切割</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;   <span class="comment">//如果查找的起点大于当前对象的大小</span></span><br><span class="line">        <span class="comment">//如果目标字符串的长度为0，则代表目标字符串为&quot;&quot;，&quot;&quot;在任何字符串都会出现</span></span><br><span class="line">        <span class="comment">//配合fromIndex &gt;= sourceCount,所以校正第一次出现在最尾部，仅仅是校正作用</span></span><br><span class="line">           <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>); </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;  <span class="comment">//也是校正，如果起始点小于0，则返回0</span></span><br><span class="line">           fromIndex = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果目标字符串长度为0，代表为&quot;&quot;，则第一次出现在遍历起始点fromIndex</span></span><br><span class="line">       <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123; </span><br><span class="line">           <span class="keyword">return</span> fromIndex;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">char</span> first = target[targetOffset];   <span class="comment">//目标字符串的第一个字符</span></span><br><span class="line">       <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount); <span class="comment">//最大遍历次数</span></span><br><span class="line">    </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">           <span class="comment">/* Look for first character. */</span></span><br><span class="line">           <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">               <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">           &#125;</span><br><span class="line">    </span><br><span class="line">           <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">           <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">               <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                       == target[k]; j++, k++);</span><br><span class="line">    </span><br><span class="line">               <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                   <span class="comment">/* Found whole string. */</span></span><br><span class="line">                   <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查找字符串Str最后一次出现的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(str, value.length);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(value, <span class="number">0</span>, value.length,</span><br><span class="line">               str.value, <span class="number">0</span>, str.value.length, fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           String target, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lastIndexOf(source, sourceOffset, sourceCount,</span><br><span class="line">                      target.value, <span class="number">0</span>, target.value.length,</span><br><span class="line">                      fromIndex);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Check arguments; return immediately where possible. For</span></span><br><span class="line"><span class="comment">        * consistency, don&#x27;t check for null str.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> rightIndex = sourceCount - targetCount;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (fromIndex &gt; rightIndex) &#123;</span><br><span class="line">           fromIndex = rightIndex;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* Empty string always matches. */</span></span><br><span class="line">       <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> fromIndex;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">int</span> strLastIndex = targetOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">char</span> strLastChar = target[strLastIndex];</span><br><span class="line">       <span class="keyword">int</span> min = sourceOffset + targetCount - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> i = min + fromIndex;</span><br><span class="line">    </span><br><span class="line">   startSearchForLastChar:</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">while</span> (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</span><br><span class="line">               i--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (i &lt; min) &#123;</span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> start = j - (targetCount - <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">int</span> k = strLastIndex - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">           <span class="keyword">while</span> (j &gt; start) &#123;</span><br><span class="line">               <span class="keyword">if</span> (source[j--] != target[k--]) &#123;</span><br><span class="line">                   i--;</span><br><span class="line">                   <span class="keyword">continue</span> startSearchForLastChar;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> start - sourceOffset + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>  <strong>从上可以看出：</strong></p><ul><li>只对外提供了int整形，String字符串两种参数的重载方法(虽然是Int型，其实我们就当做是传char也无所谓，因为虚拟机会帮我们解决这个事情的)</li></ul></li><li><p>substring()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  截取当前字符串对象的片段，组成一个新的字符串对象</span></span><br><span class="line"><span class="comment">*  beginIndex为截取的初始位置，默认截到len - 1位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;   <span class="comment">//小于0抛异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> subLen = value.length - beginIndex;  <span class="comment">//新字符串的长度</span></span><br><span class="line">       <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;       <span class="comment">//小于0抛异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果beginIndex是0，则不用截取，返回自己(非新对象)，否则截取0到subLen位置，不包括(subLen)</span></span><br><span class="line">       <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 截取一个区间范围</span></span><br><span class="line"><span class="comment">* [beginIndex,endIndex)，不包括endIndex</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">       <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">               : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.substring(beginIndex, endIndex);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>  <strong>从上面可以看到：</strong></p><ul><li>substring函数是一个不完全闭包的区间，是[beginIndex,end)，不包括end位置</li><li><strong>subString的原理是通过String的构造函数实现的</strong></li></ul></li><li><p>concat()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String的拼接函数</span></span><br><span class="line"><span class="comment">* 例如:String  str = &quot;abc&quot;; str.concat(&quot;def&quot;)    output: &quot;abcdef&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();<span class="comment">//获得参数字符串的长度</span></span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123; <span class="comment">//如果长度为0，则代表不需要拼接，因为str为&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****重点****/</span></span><br><span class="line">    <span class="keyword">int</span> len = value.length;  <span class="comment">//获得当前对象的长度 </span></span><br><span class="line">    <span class="comment">//将数组扩容，将value数组拷贝到buf数组中，长度为len + str.lenght</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen); </span><br><span class="line">    str.getChars(buf, len); <span class="comment">//然后将str字符串从buf字符数组的len位置开始覆盖，得到一个完整的buf字符数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);<span class="comment">//构建新的String对象，调用私有的String构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>replace、replaceAll类函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换，将字符串中的oldChar字符全部替换成newChar</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;    <span class="comment">//如果旧字符不等于新字符的情况下</span></span><br><span class="line">        <span class="keyword">int</span> len = value.length;  <span class="comment">//获得字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;              <span class="comment">//flag</span></span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;      <span class="comment">//循环len次</span></span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123; <span class="comment">//找到第一个旧字符，打断循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;   <span class="comment">//如果第一个旧字符的位置小于len</span></span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len]; 新<span class="keyword">new</span>一个字符数组，len个长度</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    buf[j] = val[j];        把旧字符的前面的字符都复制到新字符数组上</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;           <span class="comment">//从i位置开始遍历</span></span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c; <span class="comment">//发生旧字符就替换，不想关的则直接复制</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);  <span class="comment">//通过新字符数组buf重构一个新String对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">//如果old = new ，直接返回自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换第一个旧字符</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceFirst(replacement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当不是正规表达式时，与replace效果一样，都是全体换。如果字符串的正则表达式，则规矩表达式全体替换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用旧字符串去替换新字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(</span><br><span class="line">        <span class="keyword">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从replace的算法中，我们可以发现，它不是从头开始遍历替换的，而是首先找到第一个要替换的字符，从要替换的字符开始遍历，发现一个替换一个。</p><p>  四种用法，字符全替换字符，表达式全体换字符，表达式只替换第一个字符，字符串替换字符串</p></li><li><p>matches()和contains()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* matches() 方法用于检测字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="comment">* regex -- 匹配字符串的正则表达式。</span></span><br><span class="line"><span class="comment">* 如：String Str = new String(&quot;www.snailmann.com&quot;);</span></span><br><span class="line"><span class="comment">* System.out.println(Str.matches(&quot;(.*)snailmann(.*)&quot;));   output:true</span></span><br><span class="line"><span class="comment">* System.out.println(Str.matches(&quot;www(.*)&quot;));             output:true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Pattern.matches(regex, <span class="keyword">this</span>);   <span class="comment">//实际使用的是Pattern.matches()方法</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//是否含有CharSequence这个子类元素，通常用于StrngBuffer,StringBuilder</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(s.toString()) &gt; -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>split()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">       <span class="comment">/* fastpath if the regex is a</span></span><br><span class="line"><span class="comment">        (1)one-char String and this character is not one of the</span></span><br><span class="line"><span class="comment">           RegEx&#x27;s meta characters &quot;.$|()[&#123;^?*+\\&quot;, or</span></span><br><span class="line"><span class="comment">        (2)two-char String and the first char is the backslash and</span></span><br><span class="line"><span class="comment">           the second is not the ascii digit or ascii letter.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            <span class="string">&quot;.$|()[&#123;^?*+\\&quot;</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">            (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">             regex.charAt(<span class="number">0</span>) == <span class="string">&#x27;\\&#x27;</span> &amp;&amp;</span><br><span class="line">             (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">&#x27;0&#x27;</span>)|(<span class="string">&#x27;9&#x27;</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             ((ch-<span class="string">&#x27;a&#x27;</span>)|(<span class="string">&#x27;z&#x27;</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             ((ch-<span class="string">&#x27;A&#x27;</span>)|(<span class="string">&#x27;Z&#x27;</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">           (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">            ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</span><br><span class="line">           ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</span><br><span class="line">                   list.add(substring(off, next));</span><br><span class="line">                   off = next + <span class="number">1</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></span><br><span class="line">                   <span class="comment">//assert (list.size() == limit - 1);</span></span><br><span class="line">                   list.add(substring(off, value.length));</span><br><span class="line">                   off = value.length;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// If no match was found, return this</span></span><br><span class="line">           <span class="keyword">if</span> (off == <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line">    </span><br><span class="line">           <span class="comment">// Add remaining segment</span></span><br><span class="line">           <span class="keyword">if</span> (!limited || list.size() &lt; limit)</span><br><span class="line">               list.add(substring(off, value.length));</span><br><span class="line">    </span><br><span class="line">           <span class="comment">// Construct result</span></span><br><span class="line">           <span class="keyword">int</span> resultSize = list.size();</span><br><span class="line">           <span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line">                   resultSize--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line">           <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> String[] split(String regex) &#123;</span><br><span class="line">       <span class="keyword">return</span> split(regex, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>join()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* join方法是JDK1.8加入的新函数，静态方法</span></span><br><span class="line"><span class="comment">* 这个方法就是跟split有些对立的函数,不过join是静态方法</span></span><br><span class="line"><span class="comment">* delimiter就是分割符，后面就是要追加的可变参数，比如str1,str2,str3</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 例子：String.join(&quot;,&quot;,new String(&quot;a&quot;),new String(&quot;b&quot;),new String(&quot;c&quot;))</span></span><br><span class="line"><span class="comment">* output: &quot;a,b,c&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(delimiter);  <span class="comment">//就是检测是否为Null,是null,抛异常</span></span><br><span class="line">      Objects.requireNonNull(elements);   <span class="comment">//不是就返回自己，即nothing happen</span></span><br><span class="line">      <span class="comment">// Number of elements not likely worth Arrays.stream overhead.</span></span><br><span class="line">      StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);  <span class="comment">//嗯，有兴趣自己看StringJoiner类源码啦</span></span><br><span class="line">      <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">          joiner.add(cs);   <span class="comment">//既用分割符delimiter将所有可变参数的字符串分割，合并成一个字符串</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> joiner.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能是一样的，不过传入的参数不同</span></span><br><span class="line"><span class="comment"> * 这里第二个参数一般就是装着CharSequence子类的集合</span></span><br><span class="line"><span class="comment"> * 比如String.join(&quot;,&quot;,lists)   </span></span><br><span class="line"><span class="comment"> * list可以是一个Collection接口实现类，所含元素的基类必须是CharSequence类型</span></span><br><span class="line"><span class="comment"> * 比如String,StringBuilder,StringBuffer等</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter,</span></span></span><br><span class="line"><span class="function"><span class="params">          Iterable&lt;? extends CharSequence&gt; elements)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(delimiter);</span><br><span class="line">      Objects.requireNonNull(elements);</span><br><span class="line">      StringJoiner joiner = <span class="keyword">new</span> StringJoiner(delimiter);</span><br><span class="line">      <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">          joiner.add(cs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> joiner.toString();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>Java 1.8加入的新功能，有点跟split对立的意思，是个静态方法</li><li>有两个重载方法，一个是直接传字符串数组，另个是传集合。传集合的方式是一个好功能，很方遍将集合的字符串元素拼接成一个字符串。(分割符为 <code>&quot;&quot;</code> ,well, It’s great!!)</li></ul></li><li><p>trim()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 去除字符串首尾部分的空值，如,&#x27; &#x27; or &quot; &quot;,非&quot;&quot;</span></span><br><span class="line"><span class="comment">* 原理是通过substring去实现的，首尾各一个指针</span></span><br><span class="line"><span class="comment">* 头指针发现空值就++，尾指针发现空值就--</span></span><br><span class="line"><span class="comment">* &#x27; &#x27;的Int值为32，其实不仅仅是去空的作用，应该是整数值小于等于32的去除掉</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = value.length; <span class="comment">//代表尾指针，实际是尾指针+1的大小</span></span><br><span class="line"><span class="keyword">int</span> st = <span class="number">0</span>;             <span class="comment">//代表头指针</span></span><br><span class="line">       <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//st&lt;len,且字符的整数值小于32则代表有空值，st++</span></span><br><span class="line">       <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;   </span><br><span class="line">           st++;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//len - 1才是真正的尾指针，如果尾部元素的整数值&lt;=32,则代表有空值，len--</span></span><br><span class="line">       <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">           len--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//截取st到len的字符串(不包括len位置)</span></span><br><span class="line">       <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>  常见去首尾的空值，实际是去除首尾凡是小于32的字符</p></li><li><p>toString()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>toCharArray()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 就是将String转换为字符数组并返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray() &#123;</span><br><span class="line">    <span class="comment">// Cannot use Arrays.copyOf because of class initialization order issues</span></span><br><span class="line">    <span class="keyword">char</span> result[] = <span class="keyword">new</span> <span class="keyword">char</span>[value.length];    <span class="comment">//定义一个要返回的空数组，长度为字符串长度</span></span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, value.length); <span class="comment">//拷贝</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>toLowerCase()、toUpperCase()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locale == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> firstUpper;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> len = value.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now check if there are any characters that need to be changed. */</span></span><br><span class="line">    scan: &#123;</span><br><span class="line">        <span class="keyword">for</span> (firstUpper = <span class="number">0</span> ; firstUpper &lt; len; ) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = value[firstUpper];</span><br><span class="line">            <span class="keyword">if</span> ((c &gt;= Character.MIN_HIGH_SURROGATE)</span><br><span class="line">                &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123;</span><br><span class="line">                <span class="keyword">int</span> supplChar = codePointAt(firstUpper);</span><br><span class="line">                <span class="keyword">if</span> (supplChar != Character.toLowerCase(supplChar)) &#123;</span><br><span class="line">                    <span class="keyword">break</span> scan;</span><br><span class="line">                &#125;</span><br><span class="line">                firstUpper += Character.charCount(supplChar);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != Character.toLowerCase(c)) &#123;</span><br><span class="line">                    <span class="keyword">break</span> scan;</span><br><span class="line">                &#125;</span><br><span class="line">                firstUpper++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">    <span class="keyword">int</span> resultOffset = <span class="number">0</span>;  <span class="comment">/* result may grow, so i+resultOffset</span></span><br><span class="line"><span class="comment">                                * is the write location in result */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just copy the first few lowerCase characters. */</span></span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, firstUpper);</span><br><span class="line"></span><br><span class="line">    String lang = locale.getLanguage();</span><br><span class="line">    <span class="keyword">boolean</span> localeDependent =</span><br><span class="line">        (lang == <span class="string">&quot;tr&quot;</span> || lang == <span class="string">&quot;az&quot;</span> || lang == <span class="string">&quot;lt&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] lowerCharArray;</span><br><span class="line">    <span class="keyword">int</span> lowerChar;</span><br><span class="line">    <span class="keyword">int</span> srcChar;</span><br><span class="line">    <span class="keyword">int</span> srcCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = firstUpper; i &lt; len; i += srcCount) &#123;</span><br><span class="line">        srcChar = (<span class="keyword">int</span>)value[i];</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">char</span>)srcChar &gt;= Character.MIN_HIGH_SURROGATE</span><br><span class="line">            &amp;&amp; (<span class="keyword">char</span>)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123;</span><br><span class="line">            srcChar = codePointAt(i);</span><br><span class="line">            srcCount = Character.charCount(srcChar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            srcCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (localeDependent ||</span><br><span class="line">            srcChar == <span class="string">&#x27;\u03A3&#x27;</span> || <span class="comment">// GREEK CAPITAL LETTER SIGMA</span></span><br><span class="line">            srcChar == <span class="string">&#x27;\u0130&#x27;</span>) &#123; <span class="comment">// LATIN CAPITAL LETTER I WITH DOT ABOVE</span></span><br><span class="line">            lowerChar = ConditionalSpecialCasing.toLowerCaseEx(<span class="keyword">this</span>, i, locale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lowerChar = Character.toLowerCase(srcChar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((lowerChar == Character.ERROR)</span><br><span class="line">            || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lowerChar == Character.ERROR) &#123;</span><br><span class="line">                lowerCharArray =</span><br><span class="line">                    ConditionalSpecialCasing.toLowerCaseCharArray(<span class="keyword">this</span>, i, locale);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcCount == <span class="number">2</span>) &#123;</span><br><span class="line">                resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lowerCharArray = Character.toChars(lowerChar);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Grow result if needed */</span></span><br><span class="line">            <span class="keyword">int</span> mapLen = lowerCharArray.length;</span><br><span class="line">            <span class="keyword">if</span> (mapLen &gt; srcCount) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] result2 = <span class="keyword">new</span> <span class="keyword">char</span>[result.length + mapLen - srcCount];</span><br><span class="line">                System.arraycopy(result, <span class="number">0</span>, result2, <span class="number">0</span>, i + resultOffset);</span><br><span class="line">                result = result2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; mapLen; ++x) &#123;</span><br><span class="line">                result[i + resultOffset + x] = lowerCharArray[x];</span><br><span class="line">            &#125;</span><br><span class="line">            resultOffset += (mapLen - srcCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i + resultOffset] = (<span class="keyword">char</span>)lowerChar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, len + resultOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toLowerCase(Locale.getDefault());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locale == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> firstLower;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> len = value.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now check if there are any characters that need to be changed. */</span></span><br><span class="line">    scan: &#123;</span><br><span class="line">        <span class="keyword">for</span> (firstLower = <span class="number">0</span> ; firstLower &lt; len; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = (<span class="keyword">int</span>)value[firstLower];</span><br><span class="line">            <span class="keyword">int</span> srcCount;</span><br><span class="line">            <span class="keyword">if</span> ((c &gt;= Character.MIN_HIGH_SURROGATE)</span><br><span class="line">                &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123;</span><br><span class="line">                c = codePointAt(firstLower);</span><br><span class="line">                srcCount = Character.charCount(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                srcCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> upperCaseChar = Character.toUpperCaseEx(c);</span><br><span class="line">            <span class="keyword">if</span> ((upperCaseChar == Character.ERROR)</span><br><span class="line">                || (c != upperCaseChar)) &#123;</span><br><span class="line">                <span class="keyword">break</span> scan;</span><br><span class="line">            &#125;</span><br><span class="line">            firstLower += srcCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* result may grow, so i+resultOffset is the write location in result */</span></span><br><span class="line">    <span class="keyword">int</span> resultOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[len]; <span class="comment">/* may grow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just copy the first few upperCase characters. */</span></span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, result, <span class="number">0</span>, firstLower);</span><br><span class="line"></span><br><span class="line">    String lang = locale.getLanguage();</span><br><span class="line">    <span class="keyword">boolean</span> localeDependent =</span><br><span class="line">        (lang == <span class="string">&quot;tr&quot;</span> || lang == <span class="string">&quot;az&quot;</span> || lang == <span class="string">&quot;lt&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] upperCharArray;</span><br><span class="line">    <span class="keyword">int</span> upperChar;</span><br><span class="line">    <span class="keyword">int</span> srcChar;</span><br><span class="line">    <span class="keyword">int</span> srcCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = firstLower; i &lt; len; i += srcCount) &#123;</span><br><span class="line">        srcChar = (<span class="keyword">int</span>)value[i];</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">char</span>)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp;</span><br><span class="line">            (<span class="keyword">char</span>)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123;</span><br><span class="line">            srcChar = codePointAt(i);</span><br><span class="line">            srcCount = Character.charCount(srcChar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            srcCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (localeDependent) &#123;</span><br><span class="line">            upperChar = ConditionalSpecialCasing.toUpperCaseEx(<span class="keyword">this</span>, i, locale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            upperChar = Character.toUpperCaseEx(srcChar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((upperChar == Character.ERROR)</span><br><span class="line">            || (upperChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (upperChar == Character.ERROR) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localeDependent) &#123;</span><br><span class="line">                    upperCharArray =</span><br><span class="line">                        ConditionalSpecialCasing.toUpperCaseCharArray(<span class="keyword">this</span>, i, locale);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    upperCharArray = Character.toUpperCaseCharArray(srcChar);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcCount == <span class="number">2</span>) &#123;</span><br><span class="line">                resultOffset += Character.toChars(upperChar, result, i + resultOffset) - srcCount;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                upperCharArray = Character.toChars(upperChar);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Grow result if needed */</span></span><br><span class="line">            <span class="keyword">int</span> mapLen = upperCharArray.length;</span><br><span class="line">            <span class="keyword">if</span> (mapLen &gt; srcCount) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] result2 = <span class="keyword">new</span> <span class="keyword">char</span>[result.length + mapLen - srcCount];</span><br><span class="line">                System.arraycopy(result, <span class="number">0</span>, result2, <span class="number">0</span>, i + resultOffset);</span><br><span class="line">                result = result2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; mapLen; ++x) &#123;</span><br><span class="line">                result[i + resultOffset + x] = upperCharArray[x];</span><br><span class="line">            &#125;</span><br><span class="line">            resultOffset += (mapLen - srcCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i + resultOffset] = (<span class="keyword">char</span>)upperChar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, len + resultOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toUpperCase(Locale.getDefault());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>format()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JAVA字符串格式化</span></span><br><span class="line"><span class="comment">//新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Formatter().format(format, args).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(Locale l, String format, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Formatter(l).format(format, args).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>valueOf类函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将Object转换为String</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将char数组转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符数组的子数组转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将布尔值转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将单个字符转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data[] = &#123;c&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将int转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将long转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Long.toString(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将float转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Float.toString(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将double转换为String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.toString(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>从上看：</strong></p></li><li><p>copyValueOf和valueOf在Java8看来已经是完全没有区别的函数</p><ul><li>所有的value的本质都是新new一个String对象</li></ul></li><li><p>intern()函数</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>  <strong>String类中唯一的一条本地方法，既不是用Java语言实现的方法。</strong></p><p>  比如str.intern(),作用就是去字符串常量池中寻找str字符串，如果有则返回str在常量池中的引用，如果没有则在常量池中创建str对象</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 源码 </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2019/09/05/%E6%A1%86%E6%9E%B6-Mybatis/"/>
      <url>/2019/09/05/%E6%A1%86%E6%9E%B6-Mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 <strong>MyBatis</strong>？</h1><p>​        MyBatis 是支持普通 SQL 查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的 JDBC 代码和参数的手工设置以及对结果集的检索。MyBatis 可以使用简单的XML 或注解用于配置和原始映射，将接口和 Java 的 POJO（Plain Old Java Objects，普通的Java 对象）映射成数据库中的记录。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>​        每一个 MyBatis 的应 用程序 都以一 个 SqlSessionFactory 对象的 实例为 核心。SqlSessionFactory 对 象 的 实 例 可 以 通 过 SqlSessionFactoryBuilder 对 象 来 获 得 。SqlSessionFactoryBuilder 对象可以通过 XML 配置文件，或从以往使用惯例中准备好的Configuration 类实例中来构建 SqlSessionFactory 对象。</p><h2 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 <strong>XML</strong> 中构建 <strong>SqlSessionFactory</strong></h2><pre><code>     从 XML 文件中构建 SqlSessionFactory 的实例非常简单。这里建议你使用类路径下的资源文件来配置，但是你可以使用任意的 Reader 实例，这个实例包括由文字形式的文件路径或 URL 形式的文件路径 file://来创建。MyBatis 包含了一些工具类，称作为资源，这些工具类包含一些方法，这些方法使得从类路径或其它位置加载资源文件更加简单。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;org/mybatis/example/Configuration.xml&quot;</span>;</span><br><span class="line">Reader reader = Resources.getResourceAsReader(resource); </span><br><span class="line">sqlMapper = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br></pre></td></tr></table></figure><p>XML 配置文件包含对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源和决定事务范围和控制的事务管理器。关于 XML 配置文件的详细内容可以在文档后面找到， 这里给出一个简单的示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        当然，在XML 配置文件中还有很多可以配置的，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，需要用来验证 XML 文档正确性。environment 元素体中包含对事务管理和连接池的环境配置。mappers 元素是包含所有 mapper映射器）的列表，这些 mapper的 XML 文件包含 SQL 代码和映射定义信息。</p><h2 id="不使用-XML-构建-SqlSessionFactory"><a href="#不使用-XML-构建-SqlSessionFactory" class="headerlink" title="不使用 XML 构建 SqlSessionFactory"></a>不使用 <strong>XML</strong> 构建 <strong>SqlSessionFactory</strong></h2><p>​        如果你喜欢从 Java 程序而不是 XML 文件中直接创建配置实例，或创建你自己的配置构建器，MyBatis 也提供完整的配置类，提供所有从 XML 文件中加载配置信息的选项。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory(); </span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment); configuration.addMapper(BlogMapper.class);</span><br><span class="line">SqlSessionFactory sqlSessionFactory =<span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure><p>​        注意这种情况下配置是添加映射器类。映射器类是 Java 类，这些类包含 SQL 映射语句的注解从而避免了 XML 文件的依赖，XML 映射仍然在大多数高级映射（比如：嵌套 Join 映射）时需要。出于这样的原因，如果存在 XML 配置文件的话，MyBatis 将会自动查找和加载一个对等的 XML 文件（这种情况下，基于类路径下的 BlogMapper.class 类的类名，那么 BlogMapper.xml 将会被加载）。后面我们会了解更多。</p><h2 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h2><p>​        现在，我们已经知道如何获取 SqlSessionFactory 对象了，基于同样的启示，我们就可以获得 SqlSession 的实例了。SqlSession 对象完全包含以数据库为背景的所有执行 SQL 操作的方法。你可以用 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlMapper.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Blog blog = (Blog) session.selectOne( <span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这种方法起到的作用，和我们使用之前的 MyBatis 版本是相似的，现在有一种更简洁的方法。使用合理描述参数和  SQL 语句返回值的接口（比如  BlogMapper.class），这样现在就可以执行更简单，更安全的代码，没有容易发生的字符串文字和转换的错误。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession(); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">    Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来探究一下这里到底执行了什么。</p><h2 id="探究已映射的-SQL-语句"><a href="#探究已映射的-SQL-语句" class="headerlink" title="探究已映射的 SQL 语句"></a>探究已映射的 <strong>SQL</strong> 语句</h2><p>​        这里你也许想知道通过 SqlSession 和 Mapper 对象到底执行了什么操作。已映射的 SQL 语句是一个很大的主题，而且这个主题会贯穿本文档的大部分内容。为了给出一个宏观的概念，这里有一些示例。</p><p>​        上面提到的任何一个示例，语句是通过 XML 或注解定义的。我们先来看看 XML。使用基于 XML 的映射语言，在过去的几年中使得 MyBatis 非常流行，它为 MyBatis 提供所有的特性设置。如果你以前用过 MyBatis，这个概念就应该很熟悉了，但是 XML 映射文件也有很多的改进，后面我们会详细来说。这里给出一个基于 XML 映射语句的示例，这些语句应该可以满足上述示例中 SqlSession 对象的调用。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> &lt;http://mybatis.org/dtd/mybatis-3-mapper.dtd&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span> </span><br><span class="line">select * from Blog where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        这个简单的例子中看起来有很多额外的东西，但是也相当简洁了。如果你喜欢，你可以在一个单独的 XML 映射文件中定义很多的映射语句，除 XML 头部和文档类型声明之外， 你可以得 到很 多方便 之处。 在文件 的剩 余部分 是很好 的自我 解释 。在命 名空间“com.mybatis.example.BlogMapper”中，它定义了一个名为“selectBlog”的映射语句，这样它允许你使用完全限定名“org.mybatis.example.BlogMapper.selectBlog”来调用映射语句，我们下面示例中所有的写法也是这样的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Blog blog = (Blog) session.selectOne( <span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure><p>​        要注意这个使用完全限定名调用 Java 对象的方法是相似的，这样做是有原因的。这个命名可以直接映射相同命名空间下的映射器类，使用一个名称，参数和返回值和已映射的查询语句都一样的方法即可。这就允许你非常容易地调用映射器接口中的方法，这和你前面看到的是一样的，下面这个示例中它又出现了。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class); </span><br><span class="line">Blog blog = mapper.selectBlog(101);</span><br></pre></td></tr></table></figure><p>​        第二种方式有很多的优点，首先它不是基于文字的，那就更安全了。第二，如果你的IDE 有代码补全功能，那么你可以利用它来操纵已映射的 SQL 语句。第三，不需要强制类型转换，同时 BlogMapper 接口可以保持简洁，返回值类型很安全（参数类型也很安全）。</p><h2 id="命名空间的一点注释"><a href="#命名空间的一点注释" class="headerlink" title="命名空间的一点注释"></a>命名空间的一点注释</h2><blockquote><p>​        命名空间在之前版本的 MyBatis 中是可选项，非常混乱在使用上也没有帮助。现在， 命名空间是必须的，而且有一个目的，它使用更长的完全限定名来隔离语句。 命名空间使得接口绑定成为可能，就像你看到的那样，如果之前不了解，那么现在你 就会使用它们了，你应该按照下面给出示例的来练习，以免改变自己的想法。使用命名空间，并将它放在合适的 Java 包空间之下，这将会使你的代码变得简洁，在很长的时间内提高 MyBatis 的作用。 命名解析：为了减少输入量，MyBatis 对所有的命名配置元素使用如下的命名解析规则，包括语句，结果映射，缓存等。 </p><ul><li>直接查找完全限定名（比如“com.mypackage.MyMapper.selectAllThings”），如果发现就使用。 l</li><li>短名称（比如“selectAllThings”）可以用来引用任意含糊的对象。而如果有两个或两个以上的（比如“com.foo.selectAllThings ”和“com.bar.selectAllThings”）,那么就会得到错误报告，说短名称是含糊的，因此就必须使用完全限定名。</li></ul></blockquote><p>​        对 BlogMapper 这样的映射器类来说，还有一个妙招。它们中间映射的语句可以不需要在 XML 中来写，而可以使用 Java 注解来替换。比如，上面的 XML 示例可以如下来替换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example; <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        对于简单语句来说，使用注解代码会更加清晰，然而 Java 注解对于复杂语句来说就会混乱，应该限制使用。因此，如果你不得不做复杂的事情，那么最好使用 XML 来映射语句。当然这也取决于你和你的项目团队的决定，看哪种更适合你来使用，还有以长久方式来使用映射语句的重要性。也就是说，不要将自己局限在一种方式中。你可以轻松地将注解换成 XML 映射语句，反之亦然。</p><h2 id="范围和生命周期"><a href="#范围和生命周期" class="headerlink" title="范围和生命周期"></a>范围和生命周期</h2><p>​        理解我们目前已经讨论过的不同范围和生命周期类是很重要的。不正确的使用它们会导致严重的并发问题。</p><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a><strong>SqlSessionFactoryBuilder</strong></h2><pre><code>     这个类可以被实例化，使用和丢弃。一旦你创建了 SqlSessionFactory 后，这个类就不需要存在了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围（也就是本地方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好的方式是 不需要保持它一直存在来保证所有 XML 解析资源，因为还有更重要的事情要做。</code></pre><p><strong>SqlSessionFactory</strong></p><pre><code>     一旦被创建，SqlSessionFactory 实例应该在你的应用程序执行期间都存在。没有理由来处理或重新创建它。使用 SqlSessionFactory 的最佳实践是在应用程序运行期间不要重复创建多次。这样的操作将被视为是非常糟糕的。因此 SqlSessionFactory 的最佳范围是应用范围。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。然而这两种方法都不认为是最佳实践。这样的话，你可以考虑依赖注入容器，比如 Google Guice 或 Spring。这样的框架允许你创建支持程序来管理单例 SqlSessionFactory 的生命周期。</code></pre><p><strong>SqlSession</strong></p><p>​        每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将 SqlSession 实例的引用放在一个类的静态字段甚至是实例字段中。也绝不能将 SqlSession 实例的引用放在任何类型的管理范围中，比如 Serlvet 架构中的 HttpSession。如果你现在正用任意的 Web  框架，要考虑SqlSession 放在一个和 HTTP 请求对象相似的范围内。换句话说，基于收到的 HTTP 请求， 你可以打开了一个 SqlSession，然后返回响应，就可以关闭它了。关闭 Session 很重要，你应该确保使用 finally 块来关闭它。下面的示例就是一个确保 SqlSession 关闭的基本模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession(); <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在你的代码中一贯地使用这种模式，将会保证所有数据库资源都正确地关闭（假设你没有通过你自己的连接关闭，这会给 MyBatis 造成一种迹象表明你要自己管理连接资源）。</p><h3 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h3><p>映射器是你创建绑定映射语句的接口。映射器接口的实例可以从 SqlSession 中获得。那么从技术上来说，当被请求时，任意映射器实例的最宽范围和 SqlSession 是相同的。然而， 映射器实例的最佳范围是方法范围。也就是说，它们应该在使用它们的方法中被请求，然后就抛弃掉。它们不需要明确地关闭，那么在请求对象中保留它们也就不是什么问题了，这和</p><p>SqlSession 相似。你也许会发现，在这个水平上管理太多的资源的话会失控。保持简单，将</p><p>映射器放在方法范围内。下面的示例就展示了这个实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession(); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line"><span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XML-映射配置文件"><a href="#XML-映射配置文件" class="headerlink" title="XML 映射配置文件"></a><strong>XML</strong> 映射配置文件</h2><p>MyBatis 的 XML 配置文件包含了影响 MyBatis 行为甚深的设置和属性信息。</p><p>XML 文档的高层级结构如下：</p><ul><li>configuration 配置</li><li>properties 属 性</li><li>settings 设 置</li><li>typeAliases 类型命名</li><li>ltypeHandlers 类型处理器</li><li>objectFactory 对象工厂</li><li>plugins 插 件 </li><li>environments 环 境<ul><li>environment 环境变量<ul><li>transactionManager事务管理器</li><li>dataSource 数据源</li></ul></li></ul></li><li>映射器</li></ul><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><pre><code>     这些是外部化的，可替代的属性，这些属性也可以配置在典型的 Java 属性配置文件中， 或者通过 properties 元素的子元素来传递。例如：</code></pre><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中的属性就可以在整个配置文件中使用，使用可替换的属性来实现动态配置。比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        这个例子中的 username 和 password 将会由 properties 元素中设置的值来替换。driver 和url 属性将会从包含进来的 config.properties 文件中的值来替换。这里提供很多配置的选项。属性也可以被传递到 SqlSessionBuilder.build()方法中。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, props);</span><br><span class="line"><span class="comment">// ... or ... </span></span><br><span class="line">SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, </span><br><span class="line">                                                           environment, </span><br><span class="line">                                                           props);</span><br></pre></td></tr></table></figure><p>如果在这些地方，属性多于一个的话，MyBatis 按照如下的顺序加载它们：</p><ul><li><p>在 properties 元素体内指定的属性首先被读取。</p></li><li><p>从类路径下资源或 properties 元素的 url 属性中加载的属性第二被读取，它会覆盖已经存在的完全一样的属性。</p></li><li><p>作为方法参数传递的属性最后被读取，它也会覆盖任一已经存在的完全一样的属性，这些属性可能是从 properties 元素体内和资源/url 属性中加载的。</p></li></ul><p>因此，最高优先级的属性是那些作为方法参数的，然后是资源/url 属性，最后是 properties<br>元素中指定的属性。</p><h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><pre><code>     这些是极其重要的调整，它们会修改 MyBatis 在运行时的行为方式。下面这个表格描述了设置信息，它们的含义和默认值。</code></pre><table><thead><tr><th>设置参数</th><th>描述</th><th>有效值</th><th>默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>这个配置使全局的映射器启用或禁用   缓存。</td><td>true | false</td><td>true</td></tr><tr><td>lazyLoadingEnabled</td><td>全局启用或禁用延迟加载。当禁用时，   所有关联对象都会即时加载。</td><td>true | false</td><td>true</td></tr><tr><td>aggressiveLazyLoading</td><td>当启用时，有延迟加载属性的对象在被   调用时将会完全加载任意属性。否则，   每种属性将会按需要加载。</td><td>true | false</td><td>true</td></tr><tr><td>multipleResultSetsEnabled</td><td>允许或不允许多种结果集从一个单独   的语句中返回（需要适合的驱动）。</td><td>true | false</td><td>true</td></tr><tr><td>useColumnLabel</td><td>使用列标签代替列名。不同的驱动在这方便表现不同。参考驱动文档或充分测   试两种方法来决定所使用的驱动。</td><td>true | false</td><td>true</td></tr><tr><td>useGeneratedKeys</td><td>允许 JDBC 支持生成的键。需要适合的驱动。如果设置为 true 则这个设置强制生成的键被使用，尽管一些驱动拒绝兼   容但仍然有效（比如   Derby）。</td><td>true | false</td><td>false</td></tr><tr><td>autoMappingBehavior</td><td>指定 MyBatis 如何自动映射列到字段/   属性。PARTIAL 只会自动映射简单， 没有嵌套的结果。FULL   会自动映射任   意复杂的结果（嵌套的或其他情况）。</td><td>NONE, PARTIAL, FULL</td><td>PARTIAL</td></tr><tr><td>defaultExecutorType</td><td>配置默认的执行器。SIMPLE 执行器没   有什么特别之处。REUSE 执行器重用预处理语句。BATCH 执行器重用语句   和批量更新</td><td>SIMPLE, REUSE, BAT CH</td><td>SIMPLE</td></tr><tr><td>defaultStatementTimeout</td><td>设置超时时间，它决定驱动等待一个数   据库响应的时间。</td><td>任 何 正 整    数</td><td>Not   Set   (null)</td></tr></tbody></table><p>一个设置信息元素的示例，完全的配置如下所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;enhancementEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h2><p>​        类型别名是为 Java 类型命名一个短的名字。它只和 XML 配置有关，只用来减少类完全限定名的多余部分。例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Post&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Section&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Section&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Tag&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Tag&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        使用这个配置，“Blog”可以任意用来替代“domain.blog. Blog”所使用的地方。</p><p>​        对于普通的 类型有许多内建的类型别名。它们都是大小写不敏感的，由于重载的名字，要注意原生类型的特殊处理。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><h2 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h2><pre><code>     无论是 MyBatis 在预处理语句中设置一个参数，还是从结果集中取出一个值时，类型处理器被用来将获取的值以合适的方式转换成 Java 类型。下面这个表格描述了默认的类型处理器。</code></pre><table><thead><tr><th>类型处理器</th><th><strong>Java</strong> 类型</th><th><strong>JDBC</strong> 类型</th></tr></thead><tbody><tr><td>BooleanTypeHandler</td><td>Boolean，boolean</td><td>任何兼容的布尔值</td></tr><tr><td>ByteTypeHandler</td><td>Byte，byte</td><td>任何兼容的数字或字节类型</td></tr><tr><td>ShortTypeHandler</td><td>Short，short</td><td>任何兼容的数字或短整型</td></tr><tr><td>IntegerTypeHandler</td><td>Integer，int</td><td>任何兼容的数字和整型</td></tr><tr><td>LongTypeHandler</td><td>Long，long</td><td>任何兼容的数字或长整型</td></tr><tr><td>FloatTypeHandler</td><td>Float，float</td><td>任何兼容的数字或单精度浮点型</td></tr><tr><td>DoubleTypeHandler</td><td>Double，double</td><td>任何兼容的数字或双精度浮点型</td></tr><tr><td>BigDecimalTypeHandler</td><td>BigDecimal</td><td>任何兼容的数字或十进制小数类型</td></tr><tr><td>StringTypeHandler</td><td>String</td><td>CHAR   和 VARCHAR 类 型</td></tr><tr><td>ClobTypeHandler</td><td>String</td><td>CLOB   和 LONGVARCHAR 类 型</td></tr><tr><td>NStringTypeHandler</td><td>String</td><td>NVARCHAR   和 NCHAR 类 型</td></tr><tr><td>NClobTypeHandler</td><td>String</td><td>NCLOB   类型</td></tr><tr><td>ByteArrayTypeHandler</td><td>byte[]</td><td>任何兼容的字节流类型</td></tr><tr><td>BlobTypeHandler</td><td>byte[]</td><td>BLOB   和 LONGVARBINARY 类型</td></tr><tr><td>DateTypeHandler</td><td>Date（java.util）</td><td>TIMESTAMP   类型</td></tr><tr><td>DateOnlyTypeHandler</td><td>Date（java.util）</td><td>DATE   类型</td></tr><tr><td>TimeOnlyTypeHandler</td><td>Date（java.util）</td><td>TIME   类型</td></tr><tr><td>SqlTimestampTypeHandler</td><td>Timestamp（java.sql）</td><td>TIMESTAMP   类型</td></tr><tr><td>SqlDateTypeHandler</td><td>Date（java.sql）</td><td>DATE   类型</td></tr><tr><td>SqlTimeTypeHandler</td><td>Time（java.sql）</td><td>TIME   类型</td></tr><tr><td>ObjectTypeHandler</td><td>任意</td><td>其他或未指定类型</td></tr><tr><td>EnumTypeHandler</td><td>Enumeration   类型</td><td>VARCHAR-任何兼容的字符串类型，   作为代码存储（而不是索引）。</td></tr></tbody></table><p>​        你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。要这样做的话，简单实现 TypeHandler 接口（org.mybatis.type），然后映射新的类型处理器类到 Java 类型，还有可选的一个 JDBC 类型。例如：</p><p><strong>// Example Type Handler.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTypeHandler</span> <span class="keyword">implements</span> <span class="title">TypeHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> i, </span></span></span><br><span class="line"><span class="function"><span class="params">                             Object parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">                             JdbcType jdbcType)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ps.setString(i, (String) parame ter);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rs.getString(col umnName );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getResult</span><span class="params">(CallableStatement cs, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> columnIndex)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cs.getString(col umnInde x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>// MapperConfig.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">javaType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">handler</span>=<span class="string">&quot;org.mybatis.example.ExampleTypeHandler&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        使用这样的类型处理器将会覆盖已经存在的处理 Java 的 String 类型属性和 VARCHAR 参数及结果的类型处理器。要注意 MyBatis 不会审视数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指定那是 VARCHAR 类型的字段，来绑定到正确的类型处理器上。这是因为 MyBatis 直到语句被执行都不知道数据类型的这个现实导致的。</p><h2 id="objectFactory"><a href="#objectFactory" class="headerlink" title="objectFactory"></a>objectFactory</h2><pre><code>     MyBatis 每次创建结果对象新的实例时，它使用一个 ObjectFactory 实例来完成。如果参数映射存在，默认的 ObjectFactory 不比使用默认构造方法或带参数的构造方法实例化目标类做的工作多。如果你想重写默认的 ObjectFactory，你可以创建你自己的。比如：</code></pre><p><strong>// Example Objec tFac tory.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleObjectFactory</span> <span class="keyword">extends</span> <span class="title">DefaultObjectFactory</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type,</span></span></span><br><span class="line"><span class="function"><span class="params">                         List&lt;Class&gt; constructorArgTypes, </span></span></span><br><span class="line"><span class="function"><span class="params">                         List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setProperties(properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>// MapperConfig.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.example.ExampleObjectFactory&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        ObjectFactory 接口非常简单。它包含两个用于创建的方法，一个是默认构造方法，另外一个是处理带参数的构造方法。最终，setProperties 方法可以被用来配置 ObjectFactory。在初始化你的ObjectFactory 实例后，objectFactory 元素体中定义的属性会被传递给setProperties方法。</p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><pre><code>     MyBatis 允许你在某一点拦截已映射语句执行的调用。默认情况下，MyBatis 允许使用插件来拦截方法调用：</code></pre><ul><li><p>Executor</p><blockquote><p>(update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</p></blockquote></li><li><p>ParameterHandler</p><blockquote><p>(getParameterObject, setParameters)</p></blockquote></li><li><p>ResultSetHandler</p><blockquote><p>(handleResultSets, handleOutputParameters)</p></blockquote></li><li><p>StatementHandler</p><blockquote><p>(prepare, parameterize, batch, update, query)</p></blockquote></li></ul><p>​        这些类中方法的详情可以通过查看每个方法的签名来发现，而且它们的源代码存在于MyBatis 的发行包中。你应该理解你所覆盖方法的行为，假设你所做的要比监视调用要多。如果你尝试修改或覆盖一个给定的方法，你可能会打破 MyBatis 的核心。这是低层次的类和方法，要谨慎使用插件。</p><p>​        使用插件是它们提供的非常简单的力量。简单实现拦截器接口，要确定你想拦截的指定签名。</p><p><strong>// ExamplePlugin.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type= Executor.class,method = &quot;update&quot;, </span></span><br><span class="line"><span class="meta">    args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>// MapperConfig.xml</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;org.mybatis.example.Example Plugin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        上面的插件将会拦截在 实例中所有的update方法调用它也是负责低层次映射语句执行的内部对象。</p><blockquote><p> 覆盖配置类</p><p>​        除了用插件来修改 MyBatis 核心行为之外，你也可以完全覆盖配置类。简单扩展它， 然后覆盖其中的任意方法，之后传递它到 sqlSessionFactoryBuilder.build(myConfig)方法 的调用。这可能会严重影响 MyBatis 的行为，所以要小心。</p></blockquote><h2 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h2><p>​        MyBatis 可以配置多种环境。这会帮助你将 SQL 映射应用于多种数据库之中。例如， 你也许为开发要设置不同的配置，测试和生产环境。或者你可能有多种生产级数据库却共享相同的模式，所以你会想对不同数据库使用相同的 SQL 映射。这种用例是很多的。</p><p>​        <strong>要记得一个很重要的问题：你可以配置多种环境，但你只能为每个 <em>SqlSessionFactory</em></strong></p><p><strong>实例选择一个。</strong></p><p>​        所以，如果你想连接两个数据库，你需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，你就需要三个实例，以此类推。记忆起来很简单：</p><p>Ø  每个数据库对应一个 <strong>SqlSessionFactory</strong></p><p>为了明确创建哪种环境，你可以将它作为可选的参数传递给 SqlSessionFactoryBuilder。可以接受环境配置的两个方法签名是：</p><p>SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment); SqlSessionFactory          factory  =                                       sqlSessionFactoryBuilder.build(reader,</p><p>environment,properties);</p><p>如果环境被忽略，那么默认环境将会被加载，如下进行：</p><p>SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader); SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader,properties);</p><p>环境元素定义了如何配置环境。</p><environments default="**development**"><environment id="**development**"><p>&lt;**transactionManager** type=”JDBC”&gt;</p><property name="..." value="..."/></transactionManager><p>&lt;**dataSource** type=”POOLED”&gt;</p><property name="driver" value="${driver}"/><property name="url" value="${url}"/><property name="username" value="${username}"/><property name="password" value="${password}"/></dataSource></environment></environments><p>注意这里的关键部分：</p><p>l  默认的环境 ID（比如：default=”development”）。</p><p>l  每个 environment 元素定义的环境 ID（比如：id=”development”）。</p><p>l  事务管理器的配置（比如：type=”JDBC”）。</p><p>l  数据源的配置（比如：type=”POOLED”）。</p><p>默认的环境和环境 ID 是自我解释的。你可以使用你喜欢的名称来命名，只要确定默认的要匹配其中之一。</p><p><strong>transactionManager</strong></p><p>在 MyBatis 中有两种事务管理器类型（也就是 type=”[JDBC|MANAGED]”）：</p><p>l  <strong>JDBC</strong> – 这个配置直接简单使用了 JDBC 的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。</p><p>l  <strong>MANAGED</strong> – 这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期（比如 Spring 或 JEE 应用服务器的上下文）。默认情况下它会关闭连接。然而一些容器并不希望这样，因此如果你需要从连接中停止它，将 closeConnection 属性设置为 false。例如：</p><transactionManager type="MANAGED"><property name="**closeConnection**" value="**false**"/></transactionManager><p>这两种事务管理器都不需要任何属性。然而它们都是类型别名，要替换使用它们，你需要放置将你自己的类的完全限定名或类型别名，它们引用了你对 TransacFactory 接口的实现类。</p><p>public interface TransactionFactory { void setProperties(Properties props);</p><p>Transaction newTransaction(Connection conn, boolean autoCommit);</p><p>}</p><p>任何在 XML 中配置的属性在实例化之后将会被传递给 setProperties()方法。你的实现类需要创建一个事务接口的实现，这个接口也很简单：</p><p>public interface Transaction { Connection getConnection();</p><p>void commit() throws SQLException;</p><p>void rollback() throws SQLException; void close() throws SQLException;</p><p>}</p><p>使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。</p><p><strong>dataSsource</strong></p><p>dataSource 元素使用基本的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p><p>Ø  许多 MyBatis 的应用程序将会按示例中的例子来配置数据源。然而它并不是必须的。要知道为了方便使用延迟加载，数据源才是必须的。</p><p>有三种内建的数据源类型（也就是 type=”???”）：</p><p><strong>UNPOOLED</strong> – 这个数据源的实现是每次被请求时简单打开和关闭连接。它有一点慢， 这是对简单应用程序的一个很好的选择，因为它不需要及时的可用连接。不同的数据库对这个的表现也是不一样的，所以对某些数据库来说配置数据源并不重要，这个配置也是闲置的。UNPOOLED 类型的数据源仅仅用来配置以下 5 种属性：</p><p>l  <strong>driver</strong> – 这是 JDBC 驱动的 Java 类的完全限定名（如果你的驱动包含的有，它也不是数据源类）。</p><p>l  <strong>url</strong> – 这是数据库的 JDBC URL 地址。</p><p>l  <strong>username</strong> –  登录数据库的用户名。</p><p>l  <strong>password</strong> – 登录数据库的密码。</p><p>l  <strong>defaultTransactionIsolationLevel</strong> – 默认的连接事务隔离级别。</p><p>作为可选项，你可以传递数据库驱动的属性。要这样做，属性的前缀是以“driver.”开 头的，例如：</p><p>l  driver.encoding=UTF8</p><p>这 样 就 会 传 递 以 值 “ UTF8 ” 来 传 递                      “ encoding ” 属 性 ， 它 是 通 过  </p><p>DriverManager.getConnection(url,driverProperties)方法传递给数据库驱动。</p><p><strong>POOLED</strong> – 这是 JDBC 连接对象的数据源连接池的实现，用来避免创建新的连接实例时必要的初始连接和认证时间。这是一种当前 Web 应用程序用来快速响应请求很流行的方法。</p><p>除了上述（UNPOOLED）的属性之外，还有很多属性可以用来配置 POOLED 数据源：</p><p>l  <strong>poolMaximumActiveConnections –</strong> 在任意时间存在的活动（也就是正在使用）连接的数量。默认值：10</p><p>l  <strong>poolMaximumIdleConnections –</strong>  任意时间存在的空闲连接数。</p><p>l  <strong>poolMaximumCheckoutTime –</strong> 在被强制返回之前，池中连接被检查的时间。默认值：20000 毫秒（也就是 20 秒）</p><p>l  <strong>poolTimeToWait</strong> <strong>–</strong> 这是给连接池一个打印日志状态机会的低层次设置，还有重新尝试获得连接，这些情况下往往需要很长时间（为了避免连接池没有配置时静默失败）。默认值：20000 毫秒（也就是 20 秒）</p><p>l  <strong>poolPingQuery –</strong> 发送到数据的侦测查询，用来验证连接是否正常工作，并且准备接受请求。默认是“NO  PING  QUERY SET”，这会引起许多数据库驱动连接由一个错误信息而导致失败。</p><p>l  <strong>poolPingEnabled</strong> – 这是开启或禁用侦测查询。如果开启，你必须用一个合法的</p><p>SQL 语句（最好是很快速的）设置 poolPingQuery 属性。默认值：false。</p><p>l  <strong>poolPingConnectionsNotUsedFor</strong> – 这是用来配置 poolPingQuery 多次时间被用一次。这可以被设置匹配标准的数据库连接超时时间，来避免不必要的侦测。默认值： 0（也就是所有连接每一时刻都被侦测-但仅仅当 poolPingEnabled 为 true 时适用）。 <strong>JNDI</strong> –  这个数据源的实现是为了使用如 Spring 或应用服务器这类的容器，容器可以集</p><p>中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这个数据源配置只需要两个属性：</p><p>l  <strong>initial_context –</strong> 这 个 属 性 用 来 从 初 始 上 下 文 中 寻 找 环 境 （ 也 就 是</p><p>initialContext.lookup（initial——context））。这是个可选属性，如果被忽略，那么</p><p>data_source 属性将会直接以 initialContext 为背景再次寻找。</p><p>l  <strong>data_source –</strong> 这是引用数据源实例位置的上下文的路径。它会以由 initial_context 查询返回的环境为背景来查找，如果 initial_context 没有返回结果时，直接以初始上下文为环境来查找。</p><p>和其他数据源配置相似，它也可以通过名为“env.”的前缀直接向初始上下文发送属性。比如：</p><p>l  env.encoding=UTF8</p><p>在初始化之后，这就会以值“UTF8”向初始上下文的构造方法传递名为“encoding”</p><p>的属性。</p><h2 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h2><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是，首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用，或者字符表示，或 url 引用的完全限定名（包括 file:///URLs）。例如：</p><p>// 使用相对于类路径的资源</p><mappers><mapper resource="org/mybatis/builder/AuthorMapper.xml"/><mapper resource="org/mybatis/builder/BlogMapper.xml"/><mapper resource="org/mybatis/builder/PostMapper.xml"/></mappers><p>// 使用完全限定路径</p><mappers><mapper url="file:///var/sqlmaps/AuthorMapper.xml"/><mapper url="file:///var/sqlmaps/BlogMapper.xml"/><mapper url="file:///var/sqlmaps/PostMapper.xml"/></mappers><p>这些语句简单告诉了 MyBatis 去哪里找映射文件。其余的细节就是在每个 SQL 映射文件中了，下面的部分我们来讨论 SQL 映射文件。</p><p><strong>SQL</strong> 映射的 <strong>XML</strong> 文件</p><p>MyBatis 真正的力量是在映射语句中。这里是奇迹发生的地方。对于所有的力量，SQL 映射的 XML 文件是相当的简单。当然如果你将它们和对等功能的 JDBC 代码来比较，你会发现映射文件节省了大约 95%的代码量。MyBatis 的构建就是聚焦于 SQL 的，使其远离于普通的方式。</p><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p><p>l  cache - 配置给定命名空间的缓存。</p><p>l  cache-ref – 从其他命名空间引用缓存配置。</p><p>l  resultMap – 最复杂，也是最有力量的元素，用来描述如何从数据库结果集中来加载你的对象。</p><p> l    parameterMap – 已经被废弃了！老式风格的参数映射。内联参数是首选，这个元</p><p>素可能在将来被移除。这里不会记录。</p><p>l  sql – 可以重用的 SQL 块，也可以被其他语句引用。</p><p>l  insert – 映射插入语句</p><p>l  update – 映射更新语句</p><p>l  delete –  映射删除语句</p><p>l  select – 映射查询语句</p><p>下一部分将从语句本身开始来描述每个元素的细节。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>查询语句是使用 MyBatis 时最常用的元素之一。直到你从数据库取出数据时才会发现将数据存在数据库中是多么的有价值，所以许多应用程序的查询操作要比更改数据操作多的多。对于每次插入，更新或删除，那也会有很多的查询。这是 MyBatis 的一个基本原则，也是将 重心和努力放到查询和结果映射的原因。对简单类别的查询元素是非常简单的。比如：</p><p><strong><select id=”selectPerson” parameter Type=”int” resultType =”hashmap” ></strong></p><p>SELECT * FROM PERSON WHERE ID = #{id}</p><p><strong></select></strong></p><p>这个语句被称作 selectPerson，使用一个 in（t  或 Integer）类型的参数，并返回一个 HashMap</p><p>类型的对象，其中的键是列名，值是列对应的值。</p><p>注意参数注释：</p><p>#{id}</p><p>这就告诉 MyBatis 创建一个 PreparedStatement（预处理语句）参数。使用 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><p>// 相似的JDBC代码，不是MyBatis 的</p><p>String selectPerson = “SELECT * FROM PERSON WHERE ID=?”; PreparedStatement ps = conn.prepareStatement(selectPerson); ps.setInt(1,id);</p><p>当然，这需要很多单独的 JDBC 的代码来提取结果并将它们映射到对象实例中，这就是</p><p>MyBatis 节省你时间的地方。我们需要深入了解参数和结果映射。那些细节部分我们下面来了解。</p><p>select 元素有很多属性允许你配置，来决定每条语句的作用细节。</p><p>&lt;select</p><p>id=”selectPerson” parameterType=”int” parameterMap=”deprecated” resultType=”hashmap” resultMap=”personResultMap” flushCache=”false” useCache=”true” timeout=”10000” fetchSize=”256” statementType=”PREPARED” resultSetType=”FORWARD_ONLY”</p><p>&gt; </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数类的完全限定名或别名。</td></tr><tr><td>parameterMap</td><td>这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数   映射和 parameterType 属性。</td></tr><tr><td>resultType</td><td>从这条语句中返回的期望类型的类的完全限定名或别名。注意集   合情形，那应该是集合可以包含的类型，而不能是集合本身。使</td></tr></tbody></table><table><thead><tr><th></th><th>用 resultType 或 resultMap，但不能同时使用。</th></tr></thead><tbody><tr><td>resultMap</td><td>命名引用外部的 resultMap。返回 map 是 MyBatis 最具力量的特性， 对其有一个很好的理解的话，许多复杂映射的情形就能被解决了。   使用 resultMap 或 resultType，但不能同时使用。</td></tr><tr><td>flushCache</td><td>将其设置为 true，无论语句什么时候被调用，都会导致缓存被清   空。默认值：false。</td></tr><tr><td>useCache</td><td>将其设置为 true，将会导致本条语句的结果被缓存。默认值：true。</td></tr><tr><td>timeout</td><td>这个设置驱动程序等待数据库返回请求结果，并抛出异常时间的   最大等待值。默认不设置（驱动自行处理）。</td></tr><tr><td>fetchSize</td><td>这是暗示驱动程序每次批量返回的结果行数。默认不设置（驱动   自行处理）。</td></tr><tr><td>statementType</td><td>STATEMENT,PREPARED 或 CALLABLE   的一种。这会让 MyBatis   使用选择使用 Statement，PreparedStatement 或 CallableStatement。   默认值：PREPARED。</td></tr><tr><td>resultSetType</td><td>FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE   中的一种。默认是不设置（驱动自行处理）。</td></tr></tbody></table><h2 id="insert，-update，-delete"><a href="#insert，-update，-delete" class="headerlink" title="insert， update， delete"></a>insert， update， delete</h2><p>数据修改语句 insert，update 和 delete 在它们的实现中非常相似：</p><p>&lt;insert</p><p>id=”insertAuthor” parameterType=”domain.blog.Author” flushCache=”true” statementType=”PREPARED” keyProperty=””</p><p>useGeneratedKeys=”” timeout=”20000”&gt;</p><p>&lt;update</p><p>id=”insertAuthor” parameterType=”domain.blog.Author” flushCache=”true” statementType=”PREPARED” timeout=”20000”&gt;</p><p>&lt;delete</p><p>id=”insertAuthor” parameterType=”domain.blog.Author” flushCache=”true” statementType=”PREPARED” timeout=”20000”&gt;</p><table><thead><tr><th>id</th><th>在命名空间中唯一的标识符，可以被用来引用这条语句。</th></tr></thead><tbody><tr><td>parameterType</td><td>将会传入这条语句的参数类的完全限定名或别名。</td></tr><tr><td>parameterMap</td><td>这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数   映射和 parameterType 属性。</td></tr><tr><td>flushCache</td><td>将其设置为 true，不论语句什么时候被带哦用，都会导致缓存被清   空。默认值：false。</td></tr><tr><td>timeout</td><td>这个设置驱动程序等待数据库返回请求结果，并抛出异常时间的最   大等待值。默认不设置（驱动自行处理）。</td></tr><tr><td>statementType</td><td>STATEMENT,PREPARED 或 CALLABLE 的一种。这会让 MyBatis   使用选择使用 Statement，PreparedStatement 或 CallableStatement。   默认值：PREPARED。</td></tr><tr><td>useGeneratedKeys</td><td>（ 仅 对    insert   有 用  ） 这 会  告 诉      MyBatis   使 用    JDBC 的   getGeneratedKeys  方法来取出由数据（比如：像  MySQL 和  SQL   Server 这样的数据库管理系统的自动递增字段）内部生成的主键。   默认值：false。</td></tr><tr><td>keyProperty</td><td>（仅对insert 有用）标记一个属性，MyBatis 会通过getGeneratedKeys   或者通过 insert 语句的 selectKey 子元素设置它的值。默认：不设置。</td></tr></tbody></table><p>下面就是 insert，update 和 delete 语句的示例：</p><p><strong><insert i d="insertAuthor" parame terType ="domain.bl og.Author"></strong></p><p>insert into Author (id,username,password,email,bio) values (#{id},#{username},#{password},#{email},#{bio})</p><p><strong></insert></strong></p><p><strong><update i d="updateAuthor " par ameter Type="domain.bl og.Author"></strong></p><p>update Author set username = #{username}, password = #{password}, email = #{email},</p><p>bio = #{bio} where id = #{id}</p><p><strong></update></strong></p><p><strong>&lt;delete i d=”deleteAuthor” par ameter Type =”int”&gt;</strong></p><p>delete from Author where id = #{id}</p><p><strong>&lt;/ delete&gt;</strong></p><p>如前所述，插入语句有一点多，它有一些属性和子元素用来处理主键的生成。</p><p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server 数据库）， 那么你可以设置 useGeneratedKeys=”true”，而且设置 keyProperty 到你已经做好的目标属性上。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为：</p><p><strong>&lt;insert i d=”insertAuthor” parame terType =”domain.bl og.Author” useGener ate dKe ys=”true” keyProperty=”i d”&gt;</strong></p><p>insert into Author (username,password,email,bio) values (#{username},#{password},#{email},#{bio})</p><p><strong></insert></strong></p><p>MyBatis 有另外一种方法来处理数据库不支持自动生成类型，或者可能 JDBC 驱动不支持自动生成主键时的主键生成问题。</p><p>这里有一个简单（甚至很傻）的示例，它可以生成一个随机 ID（可能你不会这么做， 但是这展示了 MyBatis 处理问题的灵活性，因为它并不真的关心 ID 的生成）：</p><p><strong><insert i d="insertAuthor" parame terType ="domain.bl og.Auth or"></strong></p><p><strong><selectKe y keyPr operty="i d" resultType="int" or der="B EFORE"></strong></p><p>select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1</p><p><strong></selectKey></strong></p><p>insert into Author</p><p>(id, username, password, email,bio, favourite_section) values</p><p>(#{id}, #{username}, #{password}, #{email}, #{bio}, #{favouriteSection,jdbcType=VARCHAR}</p><p>)</p><p><strong></insert></strong></p><p>在上面的示例中，selectKey 元素将会首先运行，Author 的 id 会被设置，然后插入语句会被调用。这给你了一个简单的行为在你的数据库中来处理自动生成的主键，而不需要使你的 Java 代码变得复杂。</p><p>selectKey 元素描述如下：</p><p>&lt;selectKey</p><p>keyProperty=”id” resultType=”int” order=”BEFORE” statementType=”PREPARED”&gt;</p><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p>这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。比如：</p><p><sql id=”userColumns”> id,username,password </sql></p><p>这个 SQL 片段可以被包含在其他语句中，例如：</p><p><select id=”selectUsers” parameterType=”int” resultType=”hashmap”> select <include refid=”userColumns”/></p><p>from some_table where id = #{id}</p></select><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>在之前的语句中，你已经看到了一些简单参数的示例。在 MyBatis 中参数是非常强大的元素。对于简单的做法，大概 90%的情况，是不用太多的，比如：</p><p><select id=”selectUsers” parameterType=”int” resultType=”User”> select id, username, password</p><p>from users</p><p>where id = #{id}</p></select><p>上面的这个示例说明了一个非常简单的命名参数映射。参数类型被设置为“int”，因此这个参数可以被设置成任何内容。原生的类型或简单数据类型，比如整型和没有相关属性的字符串，因此它会完全用参数来替代。然而，如果你传递了一个复杂的对象，那么 MyBatis 的处理方式就会有一点不同。比如：</p><p><insert id=”insertUser” parameterType=”User” > insert into users (id, username, password) values (#{id}, #{username}, #{password})</p></insert><p>如果 User 类型的参数对象传递到了语句中，id、username 和 password 属性将会被查找，然后它们的值就被传递到预处理语句的参数中。</p><p>这点对于传递参数到语句中非常好。但是对于参数映射也有一些其他的特性。首先，像 MyBatis 的其他部分，参数可以指定一个确定的数据类型。</p><p>#{property,javaType=int,jdbcType=NUMERIC}</p><p>像 MyBatis 的剩余部分，javaType 通常可以从参数对象中来确定，除非对象是一个</p><p>HashMap。那么 javaType 应该被确定来保证使用正确类型处理器。</p><p>注意：如果 null 被当作值来传递，对于所有可能为空的列，JDBC Type 是需要的。也可以通过阅读 PreparedStatement. setNull()方法的 JavaDocs 文档来研究它。</p><p>为了以后自定义类型处理器，你可以指定一个确定的类型处理器类（或别名），比如：</p><p>#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}</p><p>尽管它看起来繁琐，但是实际上是你很少设置它们其中之一。</p><p>对于数值类型，对于决定有多少数字是相关的，有一个数值范围。</p><p>#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}</p><p>最后，mode 属性允许你指定 IN，OUT 或 INOUT 参数。如果参数为 OUT 或 INOUT， 参数对象属性的真实值将会被改变，就像你期望你需要你个输出参数。如果 mode 为 OUT</p><p>（或 INOUT），而且 jdbcType 为  CURSOR（也就是 Oracle 的  REFCURSOR），你必须指定一个 resultMap 来映射结果集到参数类型。要注意这里的 javaType 属性是可选的，如果左边的空白是 jdbcType 的 CURSOR 类型，它会自动地被设置为结果集。</p><p>#{department,</p><p>mode=OUT, jdbcType=CURSOR, javaType=ResultSet,</p><p>resultMap=departmentResultMap}</p><p>MyBatis 也支持很多高级的数据类型，比如结构体，但是当注册 out 参数时你必须告诉语句类型名称。比如（再次提示，在实际中不要像这样换行）：</p><p>#{middleInitial,</p><p>mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE,</p><p>resultMap=departmentResultMap}</p><p>尽管所有这些强大的选项很多时候你只简单指定属性名，MyBatis 会自己计算剩余的。最多的情况是你为 jdbcType 指定可能为空的列名。</p><p>#{firstName} #{middleInitial,jdbcType=VARCHAR} #{lastName}</p><p>字符串替换</p><p>默认情况下，使用#{}格式的语法会导致 MyBatis 创建预处理语句属性并以它为背景设置安全的值（比如?）。这样做很安全，很迅速，也是首选的做法，有时你只是想直接在 SQL语句中插入一个不改变的字符串。比如，像 ORDER BY，你可以这样来使用：</p><p>ORDER BY ${columnName}</p><p>这里 MyBatis 不会修改或转义字符串。</p><p>重要：接受从用户输出的内容并提供给语句中不变的字符串，这样做是不安全的。这会导致潜在的 SQL 注入攻击，因此你不应该允许用户输入这些字段，或者通常自行转义并检查。</p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>resultMap 元素是 MyBatis 中最重要最强大的元素。它就是让你远离 90%的需要从结果集中取出数据的 JDBC 代码的那个东西，而且在一些情形下允许你做一些 JDBC 不支持的事情。事实上，编写相似于对复杂语句联合映射这些等同的代码，也许可以跨过上千行的代码。</p><p>ResultMap 的设计就是简单语句不需要明确的结果映射，而很多复杂语句确实需要描述它们的关系。</p><p>你已经看到简单映射语句的示例了，但没有明确的 resultMap。比如：</p><p><select id=”selectUsers” parameterType=”int” resultType=”hashmap”> select id, username, hashedPassword</p><p>from some_table where id = #{id}</p></select><p>这样一个语句简单作用于所有列被自动映射到 HashMap 的键上，这由 resultType 属性指定。这在很多情况下是有用的，但是 HashMap 不能很好描述一个领域模型。那样你的应用程序将会使用 JavaBeans 或 POJOs（Plain Old Java Objects，普通 Java 对象）来作为领域模型。MyBatis 对两者都支持。看看下面这个 JavaBean：</p><p>package com.someapp.model; public class User {</p><p>private int id;</p><p>private String username; private String hashedPassword; public int getId() {</p><p>return id;</p><p>}</p><p>public void setId(int id) { this.id = id;</p><p>}</p><p>public String getUsername() { return username;</p><p>}</p><p>public void setUsername(String username) { this.username = username;</p><p>}</p><p>public String getHashedPassword() { return hashedPassword;</p><p>}</p><p>public void setHashedPassword(String hashedPassword) { this.hashedPassword = hashedPassword;</p><p>}</p><p>}</p><p>基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些在 select 语句中会精确匹配到列名。</p><p>这样的一个 JavaBean 可以被映射到结果集，就像映射到 HashMap 一样简单。</p><p>&lt;select id=”selectUsers” parameterType=”int” resultType=”**com.some app.model.User**”&gt;</p><p>select id, username, hashedPassword</p><p>from some_table where id = #{id}</p></select><p>要记住类型别名是你的伙伴。使用它们你可以不用输入类的全路径。比如：</p><!-- 在XML配置文件中--><p>&lt;typeAlias type=”**com.some app.model.User**” alias=” **User**”/&gt;</p><!-- 在SQL映射的XML文件中--><p>&lt;select id=”selectUsers” parameterType=”int” resultType=” **User**”&gt;</p><p>select id, username, hashedPassword from some_table</p><p>where id = #{id}</p></select><p>这些情况下，MyBatis 会在幕后自动创建一个 ResultMap，基于属性名来映射列到</p><p>JavaBean 的属性上。如果列名没有精确匹配，你可以在列名上使用 select 字句的别名（一个标准的 SQL 特性）来匹配标签。比如：</p><p>&lt;select id=”selectUsers” parameterType=”int” resultType=” **User**”&gt; select</p><p>user_id <strong>as “id”</strong>, user_name <strong>as “userName”</strong>,</p><p>hashed_password <strong>as</strong> <strong>“hashe dPasswor d”</strong></p><p>from some_table</p><p>where id = #{id}</p></select><p>ResultMap 最优秀的地方你已经了解了很多了，但是你还没有真正的看到一个。这些简单的示例不需要比你看到的更多东西。只是出于示例的原因，让我们来看看最后一个示例中外部的 resultMap 是什么样子的，这也是解决列名不匹配的另外一种方式。</p><resultMap id="**userResultMap**" type="User"><id property="id" column="user_id" /><result property="username" column="user_name"/><result property="password" column="hashed_password"/></resultMap><p>引用它的语句使用 resultMap 属性就行了（注意我们去掉了 resultType 属性）。比如：</p><select id=”selectUsers” parameterType=”int” resultMap=”**userResultMap**”><p>select user_id, user_name, hashed_password</p><p>from some_table where id = #{id}</p></select><p>如果世界总是这么简单就好了。</p><h3 id="高级结果映射"><a href="#高级结果映射" class="headerlink" title="高级结果映射"></a>高级结果映射</h3><p>MyBatis 创建的一个想法：数据库不用永远是你想要的或需要它们是什么样的。而我们最喜欢的数据库最好是第三范式或 BCNF 范式，但它们有时不是。如果可能有一个单独的数据库映射，所有应用程序都可以使用它，这是非常好的，但有时也不是。结果映射就是MyBatis 提供处理这个问题的答案。</p><p>比如，我们如何映射下面这个语句？</p><!-- 非常复杂的语句 --><select id="selectBlogDetails" parameterType="int" resultMap="detailedBlogResultMap"><p>select</p><p>B.id as blog_id, B.title as blog_title,</p><p>B.author_id as blog_author_id,</p><p>A.id as author_id,</p><p>A.username as author_username, A.password as author_password, A.email as author_email,</p><p>A.bio as author_bio,</p><p>A.favourite_section as author_favourite_section, P.id as post_id,</p><p>P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section,</p><p>P.subject as post_subject, P.draft as draft,</p><p>P.body as post_body, C.id as comment_id,</p><p>C.post_id as comment_post_id, C.name as comment_name, C.comment as comment_text, T.id as tag_id,</p><p>T.name as tag_name</p><p>from Blog B</p><p>left outer join Author A on B.author_id = A.id left outer join Post P on B.id = P.blog_id left outer join Comment C on P.id = C.post_id</p><p>left outer join Post_Tag PT on PT.post_id = P.id</p><p>left outer join Tag T on PT.tag_id = T.id where B.id = #{id}</p></select><p>你可能想把它映射到一个智能的对象模型，包含一个作者写的博客，有很多的博文，每篇博文有零条或多条的评论和标签。下面是一个完整的复杂结果映射例子（假设作者，博客， 博文，评论和标签都是类型的别名）。我们来看看，但是不用紧张，我们会一步一步来说明。当天最初它看起来令人生畏，但实际上非常简单。</p><!-- 非常复杂的结果映射 --><resultMap id="detailedBlogResultMap" type="Blog"><constructor><idArg column="blog_id" javaType="int"/></constructor><result property="title" column="blog_title"/><association property="author" column="blog_author_id" javaType=" Author"><id property="id" column="author_id"/><result property="username" column="author_username"/><result property="password" column="author_password"/><result property="email" column="author_email"/><result property="bio" column="author_bio"/><result property="favouriteSection" column="author_favourite_section"/></association><collection property="posts" ofType="Post"><id property="id" column="post_id"/><result property="subject" column="post_subject"/><association property="author" column="post_author_id" javaType="Author"/><collection property="comments" column="post_id" ofType=" Comment"><id property="id" column="comment_id"/></collection><collection property="tags" column="post_id" ofType=" Tag" ><id property="id" column="tag_id"/></collection><discriminator javaType="int" column="draft"><case value="1" resultType="DraftPost"/></discriminator></collection></resultMap><p>resultMap 元素有很多子元素和一个值得讨论的结构。下面是 resultMap 元素的概念视图</p><p>resultMap</p><p>l  <strong>constructor</strong> – 类在实例化时，用来注入结果到构造方法中</p><p>l  <strong>idArg</strong> – ID 参数；标记结果作为 ID 可以帮助提高整体效能</p><p>l  <strong>arg</strong> – 注入到构造方法的一个普通结果</p><p>l  <strong>id</strong> – 一个 ID 结果；标记结果作为 ID 可以帮助提高整体效能</p><p>l  <strong>result</strong> –  注入到字段或 JavaBean 属性的普通结果</p><p>l  <strong>association</strong> – 一个复杂的类型关联；许多结果将包成这种类型</p><p>l  嵌入结果映射 –  结果映射自身的关联，或者参考一个</p><p>l  <strong>collection</strong> – 复杂类型的集</p><p>l  嵌入结果映射 – 结果映射自身的集，或者参考一个</p><p>l  <strong>discriminator</strong> – 使用结果值来决定使用哪个结果映射</p><p>l  <strong>case</strong> – 基于某些值的结果映射</p><p>l  嵌入结果映射 – 这种情形结果也映射它本身，因此可以包含很多相同的元素，或者它可以参照一个外部的结果映射。</p><p>最佳实践：通常逐步建立结果映射。单元测试的真正帮助在这里。如果你尝试创建一次创建一个向上面示例那样的巨大的结果映射，那么可能会有错误而且很难去控制它来工作。开始简单一些，一步一步的发展。而且要进行单元测试！使用该框架的缺点是它们有时是黑盒（是否可见源代码）。你确定你实现想要的行为的最好选择是编写单元测试。它也可以你帮助得到提交时的错误。</p><p>下面一部分将详细说明每个元素。</p><p><strong>id</strong>，<strong>result</strong></p><id property="id" column="post_id"/><result property="subject" column="post_subject"/><p>这些是结果映射最基本内容。id 和 result 都映射一个单独列的值到简单数据类型（字符串，整型，双精度浮点数，日期等）的单独属性或字段。</p><p>这两者之间的唯一不同是 id 表示的结果将是当比较对象实例时用到的标识属性。这帮</p><p>助来改进整体表现，特别是缓存和嵌入结果映射（也就是联合映射）。每个都有一些属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>property</td><td>映射到列结果的字段或属性。如果匹配的是存在的，和给定名称相同   的 JavaBeans 的属性，那么就会使用。否则   MyBatis 将会寻找给定名称</td></tr></tbody></table><table><thead><tr><th></th><th>的字段。这两种情形你可以使用通常点式的复杂属性导航。比如，你可以这样映射一些东西：“username”，或者映射到一些复杂的东西：   “address.street.number”。</th></tr></thead><tbody><tr><td>column</td><td>从数据库中得到的列名，或者是列名的重命名标签。这也是通常和会   传递给 resultSet.getString(columnName)方法参数中相同的字符串。</td></tr><tr><td>javaType</td><td>一个 Java   类的完全限定名，或一个类型别名（参加上面内建类型别名的列表）。如果你映射到一个 JavaBean，MyBatis   通常可以断定类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType   来保证所需的行为。</td></tr><tr><td>jdbcType</td><td>在这个表格之后的所支持的 JDBC 类型列表中的类型。<strong>JDBC</strong> 类型是仅仅需要对插入，更新和删除操作可能为空的列进行处理。这是 JDBC 的需要，而不是 MyBatis   的。如果你直接使用 JDBC 编程，你需要指定   这个类型-但仅仅对可能为空的值。</td></tr><tr><td>typeHandler</td><td>我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。这个属性值是类的完全限定名或者是一个类型处理   器的实现，或者是类型别名。</td></tr></tbody></table><p>支持的 <strong>JDBC</strong> 类型</p><p>为了未来的参考，MyBatis jdbcType JDBC </p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><constructor><idArg column="id" javaType="int"/><arg column=”username” javaType=”String”/></constructor><p>对于大多数数据传输对象(Data Transfer Object，DTO)类型，属性可以起作用，而且像绝大多数的领域模型，指令也许是你想使用一成不变的类的地方。通常包含引用或查询数据的表很少或基本不变的话对一成不变的类来说是合适的。构造方法注入允许你在初始化时为类设置属性的值，而不用暴露出公有方法。MyBatis 也支持私有属性和私有 JavaBeans 属性来达到这个目的，但是一些人更青睐构造方法注入。<em>Constructor</em>（构造方法）元素支持这个。</p><p>看看下面这个构造方法：</p><p>public class User {</p><p>//…</p><p><strong>public User(int id, S tring username) {</strong></p><p><strong>//…</strong></p><p><strong>}</strong></p><p>//…</p><p>}</p><p>为了向这个构造方法中注入结果，MyBatis 需要通过它的参数的类型来标识构造方法。</p><p>Java 没有自查（或反射）参数名的方法。所以当创建一个构造方法元素时，保证参数是按顺序排列的，而且数据类型也是确定的。</p><constructor><idArg column="id" javaType="int"/><arg column=”username” javaType=”String”/></constructor><p>剩余的属性和规则和固定的 和result </p><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><association property="author" column="blog_author_id" javaType=" Author"><id property="id" column="author_id"/><result property="username" column="author_username"/></association><p>关联元素处理“有一个”类型的关系。比如，在我们的示例中，一个博客有一个用户。 关联映射就工作于这种结果之上。你指定了目标属性，来获取值的列，属性的 java 类型（很多情况下 MyBatis 可以自己算出来），如果需要的话还有 jdbc 类型，如果你想覆盖或获取的结果值还需要类型控制器。</p><p>关联中不同的是你需要告诉 MyBatis 如何加载关联。MyBatis 在这方面会有两种不同的方式：</p><p>l  嵌套查询：通过执行另外一个 SQL 映射语句来返回预期的复杂类型。</p><p>l  嵌套结果：使用嵌套结果映射来处理重复的联合结果的子集。</p><p>首先，然让我们来查看这个元素的属性。所有的你都会看到，它和普通的只由 select 和</p><p>resultMap 属性的结果映射不同。</p><table><thead><tr><th></th><th>JavaBeans 的属性，那么就会使用。否则 MyBatis 将会寻找给定名称的字段。这两种情形你可以使用通常点式的复杂属性导航。比如，你可以这样映射一  些  东  西  ：“  username  ”，  或  者  映  射  到  一  些  复  杂  的  东  西  ：   “address.street.number”。</th></tr></thead><tbody><tr><td>column</td><td>来 自 数 据 库 的 列 名 ， 或 重 命 名 的   列 标 签 。 这 和 通 常 传 递 给   resultSet.getString(columnName)方法的字符串是相同的。   注意： 要处理复合主键，你可以指定多个列名通过 <strong>column=</strong> ”   <strong>{prop1=col1,prop2=col2}</strong> ” 这种语法来传递给嵌套查询语句。这会引起   <strong>prop1</strong>   和 <strong>prop2</strong>   以参数对象形式来设置给目标嵌套查询语句。</td></tr><tr><td>javaType</td><td>一个 Java 类的完全限定名，或一个类型别名（参加上面内建类型别名的列   表）。如果你映射到一个   JavaBean，MyBatis 通常可以断定类型。然而，如果你映射到的是   HashMap，那么你应该明确地指定 javaType 来保证所需的   行为。</td></tr><tr><td>jdbcType</td><td>在这个表格之前的所支持的 JDBC   类型列表中的类型。<strong>JDBC</strong>   类型是仅仅需要对插入，更新和删除操作可能为空的列进行处理。这是   JDBC 的需要， 而不是 MyBatis 的。如果你直接使用 JDBC 编程，你需要指定这个类型-但   仅仅对可能为空的值。</td></tr><tr><td>typeHandler</td><td>我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。这个属性值是类的完全限定名或者是一个类型处理器的实现，   或者是类型别名。</td></tr></tbody></table><p>关联的嵌套查询</p><p>示例：</p><resultMap id=”blogResult” type=”Blog”><p>&lt;association property=”author” column=”blog_author_id” javaType=”Author” **select=”selectAuthor”**/&gt;</p></resultMap><p><select id=”selectBlog” parameterType=”int” resultMap=”blogResult”> SELECT * FROM BLOG WHERE ID = #{id}</p></select><p><select id=”selectAuthor” parameterType=”int” resultType="Author"> SELECT * FROM AUTHOR WHERE ID = #{id}</p></select><p>我们有两个查询语句：一个来加载博客，另外一个来加载作者，而且博客的结果映射描述了“selectAuthor”语句应该被用来加载它的 author 属性。</p><h6 id="其他所有的属性将会被自动加载，假设它们的列和属性名相匹配。"><a href="#其他所有的属性将会被自动加载，假设它们的列和属性名相匹配。" class="headerlink" title="其他所有的属性将会被自动加载，假设它们的列和属性名相匹配。"></a>其他所有的属性将会被自动加载，假设它们的列和属性名相匹配。</h6><p>这种方式很简单，但是对于大型数据集合和列表将不会表现很好。问题就是我们熟知的</p><p>“N+1 查询问题”。概括地讲，N+1 查询问题可以是这样引起的：</p><p>l  你执行了一个单独的 SQL 语句来获取结果列表（就是“+1”）。</p><p>l  对返回的每条记录，你执行了一个查询语句来为每个加载细节（就是“N”）。这个问题会导致成百上千的 SQL 语句被执行。这通常不是期望的。</p><p>MyBatis 能延迟加载这样的查询就是一个好处，因此你可以分散这些语句同时运行的消耗。然而，如果你加载一个列表，之后迅速迭代来访问嵌套的数据，你会调用所有的延迟加载，这样的行为可能是很糟糕的。</p><p>所以还有另外一种方法。关联的嵌套结果</p><table><thead><tr><th>resultMap</th><th>这是结果映射的   ID，可以映射关联的嵌套结果到一个合适的对象图中。这   是一种替代方法来调用另外一个查询语句。这允许你联合多个表来合成到一个单独的结果集。这样的结果集可能包含重复，数据的重复组需要被分解，合理映射到一个嵌套的对象图。为了使它变得容易，MyBatis 让你“链接”结果映射，来处理嵌套结果。例子会很容易来仿照，这个表格后面也   有一个示例。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在上面你已经看到了一个非常复杂的嵌套关联的示例。下面这个是一个非常简单的示例来说明它如何工作。代替了执行一个分离的语句，我们联合博客表和作者表在一起，就像：</p><p><select id="selectBlog" parameterType="int" resultMap="blogResult"> select</p><p>B.id as blog_id, B.title as blog_title,</p><p>B.author_id as blog_author_id, A.id as author_id,</p><p>A.username as author_username, A.password as author_password, A.email as author_email,</p><p>A. bio as author_bio</p><p>From Blog B <strong>left outer join Author A on B.author_id = A.id</strong></p><p>where B.id = #{id}</p></select><p>注意这个联合查询，以及采取保护来确保所有结果被唯一而且清晰的名字来重命名。这使得映射非常简单。现在我们可以映射这个结果：</p><p><strong><resultMap id="blogResult" type="Blog"></strong></p><p><strong><id property=”blog_id” column="id" /></strong></p><result property="title" column="blog_title"/><p>&lt;association property=”author” column=”blog_author_id” javaType=”Author” <strong>resultMap=”authorResult”/&gt;</strong></p><p><strong></resultMap></strong></p><p><strong><resultMap id="authorResult" type="Author"></strong></p><p><strong><id property="id" column="author_id"/></strong></p><result property="username" column="author_username"/><result property="password" column="author_password"/><result property="email" column="author_email"/><result property="bio" column="author_bio"/><p><strong></resultMap></strong></p><p>在上面的示例中你可以看到博客的作者关联代表着“authorResult”结果映射来加载作</p><p>者实例。</p><p>非常重要：在嵌套结果映射中 <em>id</em> 元素扮演了非常重要的角色。应该通常指定一个或多个属性，它们可以用来唯一标识结果。实际上就是如果你不使用它（id 元素），但是会产生一个严重的性能问题，不过 MyBatis 仍然可以正常工作。选择的属性越少越好，它们可以唯一地标识结果。主键就是一个显而易见的选择（即便是联合主键）。</p><p>现在，上面的示例用了外部的结果映射元素来映射关联。这使得 Author 结果映射可以重用。然而，如果你不需要重用它的话，或者你仅仅引用你所有的结果映射合到一个单独描述的结果映射中。你可以嵌套结果映射。这里给出使用这种方式的相同示例：</p><p><strong><resultMap id="blogResult" type="Blog"></strong></p><p><strong><id property=”blog_id” column="id" /></strong></p><result property="title" column="blog_title"/><association property="author" column="blog_author_id" javaType="Author"><p><strong><id property="id" column="author_id"/></strong></p><result property="username" column="author_username"/><result property="password" column="author_password"/><result property="email" column="author_email"/><result property="bio" column="author_bio"/></association><p><strong></resultMap></strong></p><p>上面你已经看到了如何处理“有一个”类型关联。但是“有很多个”是怎样的？下面这个部分就是来讨论这个主题的。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><collection property="posts" ofType="domain.blog.Post"><id property="id" column="post_id"/><result property="subject" column="post_subject"/><result property="body" column="post_body"/></collection><p>集合元素的作用几乎和关联是相同的。实际上，它们也很相似，文档的异同是多余的。     所以我们更多关注于它们的不同。</p><p>我们来继续上面的示例，一个博客只有一个作者。但是博客有很多文章。在博客类中，</p><p>这可以由下面这样的写法来表示：</p><p>private List<Post> posts;</p><p>要映射嵌套结果集合到 List 中，我们使用集合元素。就像关联元素一样，我们可以从连接中使用嵌套查询，或者嵌套结果。</p><p>集合的嵌套查询</p><p>首先，让我们看看使用嵌套查询来为博客加载文章。</p><resultMap id=”blogResult” type=”Blog”><p><strong><collection property="posts" javaType=”ArrayList” column="blog_id" ofType="Post" select=”selectPostsForBlog”/></strong></p></resultMap><select id=”selectBlog” parameterType=”int” resultMap=”blogResult”><p>SELECT * FROM BLOG WHERE ID = #{id}</p></select><p><select id=”selectPostsForBlog” parameterType=”int” resultType="Author"> SELECT * FROM POST WHERE <strong>BLOG_ID = #{id}</strong></p></select><p>这里你应该注意很多东西，但大部分代码和上面的关联元素是非常相似的。首先，你应该注意我们使用的是集合元素。然后要注意那个新的“<strong>of Type</strong>”属性。这个属性用来区分</p><p>JavaBean（或字段）属性类型和集合包含的类型来说是很重要的。所以你可以读出下面这个映射：</p><p><strong><collection property="posts" javaType=”ArrayList” column="blog_id" ofType="Post" select=”selectPostsForBlog”/></strong></p><p>读作：“在 Post 类型的 ArrayList 中的 posts 的集合。”</p><p>javaType 属性是不需要的，因为 MyBatis 在很多情况下会为你算出来。所以你可以缩短写法：</p><p><strong><collection property="posts" column="blog_id" ofType="Post" select=”selectPostsForBlog”/></strong></p><p>集合的嵌套结果</p><p>至此，你可以猜测集合的嵌套结果是如何来工作的，因为它和关联完全相同，除了它应用了一个“<strong>ofType</strong>”属性</p><p><select id="selectBlog" parameterType="int" resultMap="blogResult"> select</p><p>B. id as blog_id, B.title as blog_title,</p><p>B.author_id as blog_author_id, P.id as post_id,</p><p>P.subject as post_subject, P.body as post_body,</p><p>from Blog B</p><p>left outer join Post P on B.id = P.blog_id where B.id = #{id}</p></select><p>我们又一次联合了博客表和文章表，而且关注于保证特性，结果列标签的简单映射。现在用文章映射集合映射博客，可以简单写为：</p><p><strong><resultMap id="blogResult" type="Blog"></strong></p><p><strong><id property=”id” column="blog_id" /></strong></p><result property="title" column="blog_title"/><p><strong><collection property="posts" ofType="Post"></strong></p><p><strong><id property="id" column="post_id"/></strong></p><result property="subject" column="post_subject"/><result property="body" column="post_body"/><p><strong></collection></strong></p><p><strong></resultMap></strong></p><p>同样，要记得 <em>id</em> 元素的重要性，如果你不记得了，请阅读上面的关联部分。</p><p>同样，如果你引用更长的形式允许你的结果映射的更多重用，你可以使用下面这个替代的映射：</p><p><strong><resultMap id="blogResult" type="Blog"></strong></p><p><strong><id property=”id” column="blog_id" /></strong></p><result property="title" column="blog_title"/><p><strong><collection property="posts" ofType="Post" resultMap=”blogPostResult”/></strong></p><p><strong></resultMap></strong></p><p><strong><resultMap id="blogPostResult" type="Post"></strong></p><p><strong><id property="id" column="post_id"/></strong></p><result property="subject" column="post_subject"/><result property="body" column="post_body"/><p><strong></resultMap></strong></p><p>注意：这个对你所映射的内容没有深度，广度或关联和集合相联合的限制。当映射它们时你应该在大脑中保留它们的表现。你的应用在找到最佳方法前要一直进行的单元测试和性能测试。好在 myBatis 让你后来可以改变想法，而不对你的代码造成很小（或任何）影响。高级关联和集合映射是一个深度的主题。文档只能给你介绍到这了。加上一点联系，你</p><p>会很快清楚它们的用法。</p><h3 id="鉴别器"><a href="#鉴别器" class="headerlink" title="鉴别器"></a>鉴别器</h3><discriminator javaType="int" column="draft"><case value="1" resultType="DraftPost"/></discriminator><p>有时一个单独的数据库查询也许返回很多不同（但是希望有些关联）数据类型的结果集。鉴别器元素就是被设计来处理这个情况的，还有包括类的继承层次结构。鉴别器非常容易理解，因为它的表现很像 Java 语言中的 switch 语句。</p><p>定义鉴别器指定了 <em>column</em> 和 <em>javaType</em> 属性。列是 MyBatis 查找比较值的地方。JavaType 是需要被用来保证等价测试的合适类型（尽管字符串在很多情形下都会有用）。比如：</p><resultMap id="vehicleResult" type="Vehicle"><id property=”id” column="id" /><result property="vin" column="vin"/><result property="year" column="year"/><result property="make" column="make"/><result property="model" column="model"/><result property="color" column="color"/><discriminator javaType="int" column="vehicle_type"><case value="1" resultMap="carResult"/><case value="2" resultMap="truckResult"/><case value="3" resultMap="vanResult"/><case value="4" resultMap="suvResult"/></discriminator></resultMap><p>在这个示例中，MyBatis 会从结果集中得到每条记录，然后比较它的 vehicle 类型的值。如果它匹配任何一个鉴别器的实例，那么就使用这个实例指定的结果映射。换句话说，这样做完全是剩余的结果映射被忽略（除非它被扩展，这在第二个示例中讨论）。如果没有任何一个实例相匹配，那么 MyBatis 仅仅使用鉴别器块外定义的结果映射。所以，如果 carResult</p><p>按如下声明：</p><resultMap id="carResult" type="Car"><result property=”doorCount” column="door_count" /></resultMap><p>那么只有 doorCount 属性会被加载。这步完成后完整地允许鉴别器实例的独立组，尽管和父结果映射可能没有什么关系。这种情况下，我们当然知道 cars 和 vehicles 之间有关系， 如 Car 是一个 Vehicle 实例。因此，我们想要剩余的属性也被加载。我们设置的结果映射的简单改变如下。</p><resultMap id="carResult" type="Car" extends=”vehicleResult”><result property=”doorCount” column="door_count" /></resultMap><p>现在 vehicleResult 和 carResult 的属性都会被加载了。</p><p>尽管曾经有些人会发现这个外部映射定义会多少有一些令人厌烦之处。因此还有另外一种语法来做简洁的映射风格。比如：</p><resultMap id="vehicleResult" type="Vehicle"><id property=”id” column="id" /><result property="vin" column="vin"/><result property="year" column="year"/><result property="make" column="make"/><result property="model" column="model"/><result property="color" column="color"/><discriminator javaType="int" column="vehicle_type"><case value="1" resultType="carResult"><result property=”doorCount” column="door_count" /></case><case value="2" resultType="truckResult"><result property=”boxSize” column="box_size" /><result property=”extendedCab” column="extended_cab" /></case><case value="3" resultType="vanResult"><result property=”powerSlidingDoor” column="power_sliding_door" /></case><case value="4" resultType="suvResult"><result property=”allWheelDrive” column="all_wheel_drive" /></case></discriminator></resultMap><p>要记得这些都是结果映射，如果你不指定任何结果，那么 MyBatis 将会为你自动匹配列和属性。所以这些例子中的大部分是很冗长的，而其实是不需要的。也就是说，很多数据库是很复杂的，我们不太可能对所有示例都能依靠它。</p><p>缓存</p><p>MyBatis 包含一个非常强大的查询缓存特性，它可以非常方便地配置和定制。MyBatis 3</p><p>中的缓存实现的很多改进都已经实现了，使得它更加强大而且易于配置。</p><p>默认情况下是没有开启缓存的，除了局部的 session 缓存，可以增强变现而且处理循环依赖也是必须的。要开启二级缓存，你需要在你的 SQL 映射文件中添加一行：</p><cache/><p>字面上看就是这样。这个简单语句的效果如下：</p><p>l  映射语句文件中的所有 <strong>select</strong> 语句将会被缓存。</p><p>l  映射语句文件中的所有 <strong>insert</strong>，<strong>update</strong> 和 <strong>delete</strong> 语句会刷新缓存。</p><p>l  缓存会使用 <strong>Least Recently Used</strong>（<strong>LRU</strong>，最近最少使用的）算法来收回。</p><p>l  根据时间表（比如 <strong>n****o  Flush  Interval</strong>，没有刷新间隔），缓存不会以任何时间顺序来刷新。</p><p>l  缓存会存储列表集合或对象（无论查询方法返回什么）的 <strong>1024</strong> 个引用。</p><p>l  缓存会被视为是 <strong>read/write</strong>（可读/可写）的缓存，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</p><p>所有的这些属性都可以通过缓存元素的属性来修改。比如：</p><p>&lt;cache</p><p>eviction=”FIFO” flushInterval=”60000” size=”512” readOnly=”true”/&gt;</p><p>这个更高级的配置创建了一个 FIFO 缓存，并每隔 60 秒刷新，存数结果对象或列表的</p><p>512 个引用，而且返回的对象被认为是只读的，因此在不同线程中的调用者之间修改它们会导致冲突。</p><p>可用的收回策略有：</p><p>l  <strong>LRU</strong> – 最近最少使用的：移除最长时间不被使用的对象。</p><p>l  <strong>FIFO</strong> – 先进先出：按对象进入缓存的顺序来移除它们。</p><p>l  <strong>SOFT</strong> – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</p><p>l  <strong>WEAK</strong> – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。默认的是 LRU。</p><p><strong>flushInterval</strong>（刷新间隔）可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。</p><p><strong>size</strong>（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值是 1024。</p><p><strong>readOnly</strong>（只读）属性可以被设置为 <em>true</em> 或 <em>false</em>。只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 <em>false</em>。</p><h3 id="使用自定义缓存"><a href="#使用自定义缓存" class="headerlink" title="使用自定义缓存"></a>使用自定义缓存</h3><p>除了这些自定义缓存的方式，你也可以通过实现你自己的缓存或为其他第三方缓存方案创建适配器来完全覆盖缓存行为。</p><cache type=”com.domain.something.MyCustomCache”/><p>这个示例展示了如何使用一个自定义的缓存实现。type 属性指定的类必须实现</p><p>org.mybatis.cache.Cache 接口。这个接口是 MyBatis 框架中很多复杂的接口之一，但是简单给定它做什么就行。</p><p>public interface Cache { String getId();</p><p>int getSize();</p><p>void putObject(Object key, Object value); Object getObject(Object key);</p><p>boolean hasKey(Object key); Object removeObject(Object key); void clear();</p><p>ReadWriteLock getReadWriteLock();</p><p>}</p><p>要配置你的缓存，简单和公有的 JavaBeans 属性来配置你的缓存实现，而且是通过 cache 元素来传递属性，比如，下面代码会在你的缓存实现中调用一个称为“setCacheFile(String file)”的方法：</p><cache type=”com.domain.something.MyCustomCache”><property name=”cacheFile” value=”/tmp/my-custom-cache.tmp”/></cache><p>你可以使用所有简单类型作为 JavaBeans 的属性，MyBatis 会进行转换。</p><p>记得缓存配置和缓存实例是绑定在 SQL 映射文件的命名空间是很重要的。因此，所有在相同命名空间的语句正如绑定的缓存一样。语句可以修改和缓存交互的方式，或在语句的语句的基础上使用两种简单的属性来完全排除它们。默认情况下，语句可以这样来配置：</p><p>&lt;select … flushCache=”false” useCache=”true”/&gt;</p><p>&lt;insert … flushCache=”true”/&gt;</p><p>&lt;update … flushCache=”true”/&gt;</p><p>&lt;delete … flushCache=”true”/&gt;</p><p>因为那些是默认的，你明显不能明确地以这种方式来配置一条语句。相反，如果你想改变默认的行为，只能设置 flushCache 和 useCache 属性。比如，在一些情况下你也许想排除从缓存中查询特定语句结果，或者你也许想要一个查询语句来刷新缓存。相似地，你也许有一些更新语句依靠执行而不需要刷新缓存。</p><p>参照缓存</p><p>回想一下上一节内容，这个特殊命名空间的唯一缓存会被使用或者刷新相同命名空间内的语句。也许将来的某个时候，你会想在命名空间中共享相同的缓存配置和实例。在这样的情况下你可以使用 cache-ref 元素来引用另外一个缓存。</p><cache-ref namespace=”com.someone.application.data.SomeMapper”/><p>动态 <strong>SQL</strong></p><p>MyBatis 的一个强大的特性之一通常是它的动态 SQL 能力。如果你有使用 JDBC 或其他</p><p>相似框架的经验，你就明白条件地串联 SQL 字符串在一起是多么的痛苦，确保不能忘了空格或在列表的最后省略逗号。动态 SQL 可以彻底处理这种痛苦。</p><p>通常使用动态 SQL 不可能是独立的一部分，MyBatis 当然使用一种强大的动态 SQL 语言来改进这种情形，这种语言可以被用在任意映射的 SQL 语句中。</p><p>动态 SQL 元素和使用 JSTL 或其它相似的基于 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多的元素需要来了解。MyBatis 3 大大提升了它们，现在用不到原先一半的元素就能工作了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。</p><p>l  if</p><p>l  choose(when,otherwise)</p><p>l  trim(where,set)</p><p>l  foreach</p><p><strong>if</strong></p><p>在动态 SQL 中所做的最通用的事情是包含部分 where 字句的条件。比如：</p><p><select id=”findActiveBlogWithTitleLike” parameterType=”Blog” resultType=”Blog”> SELECT * FROM BLOG</p><p>WHERE state = „ACTIVE‟</p><p>&lt;if test=”title != null”&gt; AND title like #{title}</p></if></select><p>这条语句会提供一个可选的文本查找功能。如果你没有传递 title，那么所有激活的博客都会被返回。但是如果你传递了 title，那么就会查找相近的 title（对于敏锐的检索，这中情况下你的参数值需要包含任意的遮掩或通配符）的博客。</p><p>假若我们想可选地搜索 title 和 author 呢？首先，要改变语句的名称让它有意义。然后简单加入另外的一个条件。</p><select id=”findActiveBlogLike” parameterType=”Blog” resultType=”Blog”><p>SELECT * FROM BLOG WHERE state = „ACTIVE‟</p><p>&lt;if test=”title != null”&gt; AND title like #{title}</p></if><p>&lt;if test=”author != null and author.name != null”&gt; AND title like #{author.name}</p></if></select><p><strong>choose, when, otherwise</strong></p><p>有时我们不想应用所有的条件，相反我们想选择很多情况下的一种。和 Java 中的 switch</p><p>语句相似，MyBatis 提供 choose 元素。</p><p>我们使用上面的示例，但是现在我们来搜索当 title 提供时仅有 title 条件，当 author 提供时仅有 author 条件。如果二者都没提供，只返回 featured blogs（也许是由管理员策略地选择的结果列表，而不是返回大量没有意义的，随机的博客结果列表）。</p><select id=”findActiveBlogLike” parameterType=”Blog” resultType=”Blog”><p>SELECT * FROM BLOG WHERE state = „ACTIVE‟</p><choose><p>&lt;when test=”title != null”&gt; AND title like #{title}</p></when><p>&lt;when test=”author != null and author.name != null”&gt; AND title like #{author.name}</p></when><otherwise><p>AND featured = 1</p></otherwise></choose></select><p><strong>trim, where, set</strong></p><p>前面的例子已经方便地处理了一个臭名昭著的动态 SQL 问题。要考虑我们回到“<em>i**f</em>”示例后会发生什么，但是这次我们将“ACTIVE = 1”也设置成动态的条件。</p><select id=”findActiveBlogLike” parameterType=”Blog” resultType=”Blog”><p>SELECT * FROM BLOG WHERE</p><p>&lt;if test=”state != null”&gt;</p><p>state = #{state}</p></if><p>&lt;if test=”title != null”&gt; AND title like #{title}</p></if><p>&lt;if test=”author != null and author.name != null”&gt; AND title like #{author.name}</p></if></select><p>如果这些条件都没有匹配上将会发生什么？这条 SQL 结束时就会成这样：</p><p>SELECT * FROM BLOG WHERE</p><p>这会导致查询失败。如果仅仅第二个条件匹配是什么样的？这条 SQL 结束时就会是这</p><p>样：</p><p>SELECT * FROM BLOG WHERE</p><p><strong>AND</strong> title like „someTitle‟</p><p>这个查询也会失败。这个问题不能简单的用条件来解决，如果你从来没有这样写过，那么你以后也不会这样来写。</p><p>MyBatis 有一个简单的处理，这在 90%的情况下都会有用。而在不能使用的地方，你可</p><p>以自定义处理方式。加上一个简单的改变，所有事情都会顺利进行：</p><select id=”findActiveBlogLike” parameterType=”Blog” resultType=”Blog”><p>SELECT * FROM BLOG</p><p><strong><where></strong></p><p>&lt;if test=”state != null”&gt; state = #{state}</p></if><p>&lt;if test=”title != null”&gt; AND title like #{title}</p></if><p>&lt;if test=”author != null and author.name != null”&gt; AND title like #{author.name}</p></if><p><strong>&lt;/ where &gt;</strong></p></select><p><em>w**here</em> 元素知道如果由被包含的标记返回任意内容，就仅仅插入“WHERE”。而且，如果以“AND”或“OR”开头的内容，那么就会跳过 WHERE 不插入。</p><p>如果 <em>where</em> 元素没有做出你想要的，你可以使用 <em>trim</em> 元素来自定义。比如，和 <em>where</em></p><p>元素相等的 <em>trim</em> 元素是：</p><trim prefix="WHERE" prefixOverrides="AND |OR "><p>…</p></trim><p>overrides 属性采用管道文本分隔符来覆盖，这里的空白也是重要的。它的结果就是移除在 <em>overrides</em> 属性中指定的内容，插入在 <em>with</em> 属性中的内容。</p><p>和动态更新语句相似的解决方案是 <em>set</em>。<em>set</em> 元素可以被用于动态包含更新的列，而不包含不需更新的。比如：</p><update id="updateAuthorIfNecessary" parameterType="domain.blog.Author"><p>update Author</p><set><p><if test="username != null">username=#{username},</if></p><p><if test="password != null">password=#{password},</if></p><p><if test="email != null">email=#{email},</if></p><p><if test="bio != null">bio=#{bio}</if></p></set><p>where id=#{id}</p></update><p>这里，<em>set</em> 元素会动态前置 SET 关键字，而且也会消除任意无关的逗号，那也许在应用条件之后来跟踪定义的值。</p><p>如果你对和这相等的 <em>trim</em> 元素好奇，它看起来就是这样的：</p><trim prefix="SET" suffixOverrides=","><p>…</p></trim><p>注意这种情况下我们覆盖一个后缀，而同时也附加前缀。</p><p><strong>foreach</strong></p><p>另外一个动态SQL 通用的必要操作是迭代一个集合，通常是构建在IN 条件中的。比如：</p><p><select id="selectPostIn" resultType="domain.blog.Post"> SELECT *</p><p>FROM POST P WHERE ID in</p><p><strong><foreac h ite m="ite m" inde x="index" c ollection="list" open="(" separator="," close=")"></strong></p><p><strong>#{item}</strong></p><p><strong>&lt;/fore ach&gt;</strong></p></select><p><em>foreach</em> 元素是非常强大的，它允许你指定一个集合，声明集合项和索引变量，它们可以用在元素体内。它也允许你指定开放和关闭的字符串，在迭代之间放置分隔符。这个元素是很智能的，它不会偶然地附加多余的分隔符。</p><p>注意：你可以传递一个 List 实例或者数组作为参数对象传给 MyBatis。当你这么做的时候，MyBatis  会自动将它包装在一个  Map 中，用名称作为键。List 实例将会以“list”作为键，而数组实例将会以“array”作为键。</p><p>这个部分是对关于 XML 配置文件和 XML 映射文件的而讨论的。下一部分将详细讨论</p><p>Java API，所以你可以得到你已经创建的最有效的映射。</p><p><strong>Java API</strong></p><p>既然你已经知道如何配置 MyBatis 和创建映射文件，你就已经准备好来提升技能了。MyBatis 的 Java API 就是你收获你所做的努力的地方。正如你即将看到的，和 JDBC 相比， MyBatis 很大程度简化了你的代码而且保持简洁，很容易理解和维护。MyBatis 3 已经引入了很多重要的改进来使得 SQL 映射更加优秀。</p><p>应用目录结构</p><p>在我们深入 Java API 之前，理解关于目录结构的最佳实践是很重要的。MyBatis 非常灵活，你可以用你自己的文件来做几乎所有的事情。但是对于任一框架，都有一些最佳的方式。</p><p>让我们看一下典型应用的目录结构：</p><h6 id="my-application"><a href="#my-application" class="headerlink" title="/my_application"></a>/my_application</h6><h6 id="bin"><a href="#bin" class="headerlink" title="/bin"></a>/bin</h6><h6 id="devlib"><a href="#devlib" class="headerlink" title="/devlib"></a>/devlib</h6><p><strong>/lib</strong>                                                                                    ←MyBatis *.jar文件在这里。</p><h6 id="src"><a href="#src" class="headerlink" title="/src"></a>/src</h6><h6 id="org-myapp"><a href="#org-myapp" class="headerlink" title="/org/myapp/"></a>/org/myapp/</h6><h6 id="action"><a href="#action" class="headerlink" title="/action"></a>/action</h6><p><strong>/data</strong>                                                                  ←MyBatis配置文件在这里，</p><p>/SqlMapConfig.xml             包括映射器类，XML配置，</p><p>/BlogMapper.java              XML映射文件。</p><h5 id="BlogMapper-xml"><a href="#BlogMapper-xml" class="headerlink" title="/BlogMapper.xml"></a>/BlogMapper.xml</h5><h6 id="model"><a href="#model" class="headerlink" title="/model"></a>/model</h6><h6 id="service"><a href="#service" class="headerlink" title="/service"></a>/service</h6><h6 id="view"><a href="#view" class="headerlink" title="/view"></a>/view</h6><p><strong>/prope</strong> <strong>rties</strong>                                                                ←在你XML中配置的属性</p><p>/test                                      文件在这里。</p><h6 id="org-myapp-1"><a href="#org-myapp-1" class="headerlink" title="/org/myapp/"></a>/org/myapp/</h6><h6 id="action-1"><a href="#action-1" class="headerlink" title="/action"></a>/action</h6><h6 id="data"><a href="#data" class="headerlink" title="/data"></a>/data</h6><h6 id="model-1"><a href="#model-1" class="headerlink" title="/model"></a>/model</h6><h6 id="service-1"><a href="#service-1" class="headerlink" title="/service"></a>/service</h6><h6 id="view-1"><a href="#view-1" class="headerlink" title="/view"></a>/view</h6><h6 id="properties-1"><a href="#properties-1" class="headerlink" title="/properties"></a>/properties</h6><h6 id="web-要记得这只是参照，而不是"><a href="#web-要记得这只是参照，而不是" class="headerlink" title="/web                                    要记得这只是参照，而不是"></a>/web                                    要记得这只是参照，而不是</h6><h6 id="WEB-INF-要求，可能其他人会感谢你"><a href="#WEB-INF-要求，可能其他人会感谢你" class="headerlink" title="/WEB-INF                             要求，可能其他人会感谢你"></a>/WEB-INF                             要求，可能其他人会感谢你</h6><h6 id="web-xml-使用了通用的目录结构。"><a href="#web-xml-使用了通用的目录结构。" class="headerlink" title="/web.xml                          使用了通用的目录结构。"></a>/web.xml                          使用了通用的目录结构。</h6><p>这部分内容剩余的示例将假设你使用了这种目录结构。</p><h2 id="SqlSessions"><a href="#SqlSessions" class="headerlink" title="SqlSessions"></a>SqlSessions</h2><p>使用 MyBatis 的主要 Java 接口就是 SqlSession。尽管你可以使用这个接口执行命令，获取映射器和管理事务。我们会讨论 SqlSession 本身更多，但是首先我们还是要了解如果获取一个 SqlSession 实例。SqlSessions 是由 SqlSessionFactory 实例创建的。SqlSessionFactory 对象 包 含 创 建 SqlSession 实 例 的 所 有 方 法 。 而 SqlSessionFactory 本 身 是 由SqlSessionFactoryBuilder 创建的，它可以从 XML 配置，注解或手动配置 Java 来创建SqlSessionFactory。</p><p><strong>SqlSessionFactoryBuilder</strong></p><p>SqlSessionFactoryBuilder 有五个 build()方法，每一种都允许你从不同的资源中创建一个</p><p>SqlSession 实例。</p><p>SqlSessionFactory build(Reader reader)</p><p>SqlSessionFactory build(Reader reader, String environment) SqlSessionFactory build(Reader reader, Properties properties) SqlSessionFactory build(Reader reader, String env, Properties props) SqlSessionFactory build(Configuration config)</p><p>第一种方法是最常用的，它使用了一个参照了 XML 文档或上面讨论过的更特定的</p><p>SqlMapConfig.xml 文件的 Reader 实例。可选的参数是 <em>environment</em> 和 <em>properties</em>。Environment</p><p>决定加载哪种环境，包括数据源和事务管理器。比如：</p><environments default=" **de** **velopment**"><environment id=" **de** **velopment**"><transactionManager type="JDBC"><p>…</p><dataSource type="POOLED"><p>…</p></environment><environment id=" **producti** **on**"><transactionManager type="EXTERNAL"><p>…</p><dataSource type="JNDI"><p>…</p></environment></environments><p>如果你调用了一个使用 <em>environment</em> 参数的 build 方法， 那么 MyBatis 将会使用</p><p>configuration 对象来配置这个 environment。当然，如果你指定了一个不合法的 environment， 你会得到错误提示。如果你调用了其中之一没有 <em>environment</em> 参数的 build 方法，那么就使用默认的 environment（在上面的示例中就会指定为 default=”development”）。</p><p>如果你调用了使用 properties 实例的方法，那么 MyBatis 就会加载那些 properties（属性</p><p>配置文件），并你在你配置中可使用它们。那些属性可以用${propName}语法形式多次用在配置文件中。</p><p>回想一下，属性可以从 SqlMapConf ig.xml 中被引用，或者直接指定它。因此理解优先</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="file:///C:/Users/10136/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="img"></td></tr></tbody></table><p> 级是很重要的。我们在文档前面已经提及它了，但是这里要再次重申：</p><p>如果一个属性存在于这些位置，那么 MyBatis 将会按找下面的顺序来加载它们：</p><p>l  在 properties 元素体中指定的属性首先被读取，</p><p>l  从 properties 元素的类路径 resource 或 url 指定的属性第二个被读取，可以覆盖已经指定的重复属性，</p><p>l  作为方法参数传递的属性最后被读取，可以覆盖已经从 properties 元素体和</p><p>resource/url 属性中加载的任意重复属性。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="file:///C:/Users/10136/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="img"></td></tr></tbody></table><p> 因此，最高优先级的属性是通过方法参数传递的，之后是 属性指定的，最后是在 元素体中指定的属性。</p><p>总结一下，前四个方法很大程度上是相同的，但是由于可以覆盖，就允许你可选地指定environment 和/或 properties。这里给出一个从 SqlMapConfig.xml 文件创建 SqlSessionFactory 的示例：</p><p>String <strong>resource</strong> = “org/mybatis/builder/MapperConfig.xml”; Reader <strong>reader</strong> = Resources.getResourceAsReader(<strong>resource</strong>);</p><p>SqlSessionFactoryBuilder <strong>buil der</strong> = new SqlSessionFactoryBuilder(); SqlSessionFactory <strong>fac tor y</strong> = builder.build(<strong>re ader</strong>);</p><p>注意这里我们使用了 <em>Resources</em> 工具类，这个类在 org.mybatis.io 包中。<em>Resources</em> 类正</p><p>如其名，会帮助你从类路径下，文件系统或一个 web URL 加载资源文件。看一下这个类的源代码或者通过你的 IDE 来查看，就会看到一整套有用的方法。这里给出一个简表：</p><p>URL getResourceURL(String resource)</p><p>URL getResourceURL(ClassLoader loader, String resource) InputStream getResourceAsStream(String resource)</p><p>InputStream getResourceAsStream(ClassLoader loader, String resource) Properties getResourceAsProperties(String resource)</p><p>Properties getResourceAsProperties(ClassLoader loader, String resource)</p><p>Reader getResourceAsReader(String resource)</p><p>Reader getResourceAsReader(ClassLoader loader, String resource) File getResourceAsFile(String resource)</p><p>File getResourceAsFile(ClassLoader loader, String resource) InputStream getUrlAsStream(String urlString)</p><p>Reader getUrlAsReader(String urlString)</p><p>Properties getUrlAsProperties(String urlString) Class classForName(String className)</p><p>最后一个 build 方法使用了一个 Configuration 实例。configuration 类包含你可能需要了</p><p>解 SqlSessionFactory 实例的所有内容。Configuration 类对于配置的自查很有用，包含查找和操作 SQL 映射（不推荐使用，因为应用正接收请求）。configuration 类有所有配置的开关， 这些你已经了解了，只在  Java  API  中露出来。这里有一个简单的示例，如何手动配置</p><p>configuration 实例，然后将它传递给 build()方法来创建 SqlSessionFactory。</p><p>DataSource <strong>dataSource</strong> = BaseDataTest.createBlogDataSource(); TransactionFactory <strong>transactionFac tor y</strong> = new JdbcTransactionFactory( ); Environment <strong>environment</strong> =</p><p>new Environment(“development”, <strong>transactionFac tor y</strong>, <strong>dataSource</strong>); Configuration <strong>configurati on</strong> = n ew Configuration(<strong>envir onme nt</strong>); configuration.setLazyLoadingEnabled(true); configuration.setEnhancementEnabled(true); configuration.getTypeAliasRegistry().registerAlias(Blog.class); configuration.getTypeAliasRegistry().registerAlias(Post.class); configuration.getTypeAliasRegistry().registerAlias(Author.class); configuration.addMapper(BoundBlogMapper.class); configuration.addMapper(BoundAuthorMapper.class); SqlSessionFactoryBuilder <strong>buil der</strong> = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(<strong>configurati on</strong>);</p><p>现在你有一个 SqlSessionFactory，可以用来创建 SqlSession 实例。</p><p><strong>SqlSessionFactory</strong></p><p>SqlSessionFactory 有六个方法可以用来创建 SqlSession 实例。通常来说，如何决定是你选择下面这些方法时：</p><p>l  <strong>Transaction</strong>（事务）：你想为 session 使用事务或者使用自动提交（通常意味着很多数据库和/或 JDBC 驱动没有事务）？</p><p>l  <strong>C****onnection</strong>（连接）：你想  MyBatis  获得来自配置的数据源的连接还是提供你自己定义的连接？</p><p>l  <strong>Execution</strong>（执行）：你想 MyBatis 复用预处理语句和/或批量更新语句（包括插入和删除）？</p><p>重载的 openSession()方法签名设置允许你选择这些可选中的任何一个组合。</p><p>SqlSession openSession()</p><p>SqlSession openSession(boolean autoCommit) SqlSession openSession(Connection connection)</p><p>SqlSession openSession(TransactionIsolationLevel level)</p><p>SqlSession openSession(ExecutorType execType,</p><p>TransactionIsolationLevel level) SqlSession openSession(ExecutorType execType)</p><p>SqlSession openSession(ExecutorType execType, boolean autoCommit) SqlSession openSession(ExecutorType execType, Connec tion connection) Configuration getConfiguration();</p><p>默认的 openSession()方法没有参数，它会创建有如下特性的 SqlSession：</p><p>l  将会开启一个事务（也就是不自动提交）范围</p><p>l  连接对象会从由活动环境配置的数据源实例中得到。</p><p>l  事务隔离级别将会使用驱动或数据源的默认设置。</p><p>l  预处理语句不会被复用，也不会批量处理更新。</p><p>这些方法大都可以自我解释的。开启自动提交，传递“true”给可选的 <em>autoCommit</em> 参数。提供自定义的连接，传递一个 Connection 实例给 <em>connection</em> 参数。注意没有覆盖同时设置Connection 和 autoCommit 两者的方法，因为 MyBatis 会使用当前 connection 对象提供的设置。MyBatis 为事务隔离级别调用使用一个 Java 枚举包装器，称为 TransactionIsolationLevel， 否 则 它 们 按 预 期 的 方 式 来 工 作 ， 并 有 JDBC 支 持 的 5 级</p><p>（ NONE,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERI ALIZA BLE）</p><p>还有一个可能对你来说是新见到的参数，就是 ExecutorType。这个枚举类型定义了 3 个值：</p><p>ExecutorType.SIMPLE</p><p>这个执行器类型不做特殊的事情。它为每个语句的执行创建一个新的预处理语句。</p><p>ExecutorType.REUSE</p><p>这个执行器类型会复用预处理语句。</p><p>ExecutorType.BATCH</p><p>这个执行器会批量执行所有更新语句，如果 SELECT  在它们中间执行还会标定它们是必须的，来保证一个简单并易于理解的行为。</p><p>注意：在 SqlSessionFactory 中还有一个方法我们没有提及，就是 *getConfiguration()*。这个方法会返回一个 Configuration 实例，在运行时你可以使用它来自检 MyBatis 的配置。</p><p>注意：如果你已经使用之前版本 MyBatis，你要回忆那些 session，transaction 和 batch</p><p>都是分离的。现在和以往不同了，这些都包含在 session 的范围内了。你需要处理分开处理事务或批量操作来得到它们的效果。</p><p><strong>SqlSession</strong></p><p>如上面所提到的，SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会发现所有执行语句的方法，提交或回滚事务，还有获取映射器实例。</p><p>在 SqlSession 类中有超过 20 个方法，所以将它们分开成易于理解的组合。语句执行方法</p><p>这些方法被用来执行定义在 SQL 映射的 XML 文件中的 SELECT，INSERT，UPDAT E 和 DELETE 语句。它们都会自行解释，每一句都使用语句的 ID 属性和参数对象，参数可以是原生类型（自动装箱或包装类），JavaBean，POJO 或 Map。</p><p>Object selectOne(String statement, Object parameter) List selectList(String statement, Object parameter) int insert(String statement, Object parameter)</p><p>int update(String statement, Object parameter) int delete(String statement, Object parameter)</p><p>selectOne 和 selectList 的不同仅仅是 selectOne 必须返回一个对象。如果多余一个，或者</p><p>没有返回（或返回了 null），那么就会抛出异常。如果你不知道需要多少对象，使用 selectList。如果你想检查一个对象是否存在，那么最好返回统计数（0 或 1）。因为并不是所有语句都需要参数，这些方法都是有不同重载版本的，它们可以不需要参数对象。</p><p>Object selectOne(String statement) List selectList(String statement) int insert(String statement)</p><p>int update(String statement) int delete(String statement)</p><p>最后，还有查询方法的三个高级版本，它们允许你限制返回行数的范围，或者提供自定</p><p>义结果控制逻辑，这通常用于大量的数据集合。</p><p>List selectList</p><p>(String statement, Object parameter, RowBounds rowBounds)</p><p>void select</p><p>(String statement, Object parameter, ResultHandler handler) void select</p><p>(String statement, Object parameter, RowBounds rowBounds,</p><p>ResultHandler handler)</p><p>RowBounds 参数会告诉 MyBatis 略过指定数量的记录，还有限制返回结果的数量。</p><p>RowBounds 类有一个构造方法来接收 offset 和 limit，否则是不可改变的。</p><p>int offset = 100; int limit = 25;</p><p>RowBounds rowBounds = new RowBounds(offset, limit);</p><p>不同的驱动会实现这方面的不同级别的效率。对于最佳的表现，使用结果集类型的</p><p>SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE（或句话说：不是 FORWARD_ONLY）。</p><p>ResultHandler 参数允许你按你喜欢的方式处理每一行。你可以将它添加到 List 中，创建Map，Set 或抛出每个结果而不是只保留总计。你可以使用ResultHandler 做很多漂亮的事，那就是 MyBatis 内部创建结果集列表。</p><p>它的接口很简单。</p><p>package org.mybatis.executor.result; public interface ResultHandler {</p><p>void handleResult(ResultContext context);</p><p>}</p><p>ResultContext 参数给你访问结果对象本身的方法，大量结果对象被创建，你可以使用布尔返回值的 stop()方法来停止 MyBatis 加载更多的结果。</p><p>事务控制方法</p><p>控制事务范围有四个方法。当然，如果你已经选择了自动提交或你正在使用外部事务管理器，这就没有任何效果了。然而，如果你正在使用 JDBC 事务管理员，由 Connection 实例来控制，那么这四个方法就会派上用场：</p><p>void commit()</p><p>void commit(boolean force) void rollback()</p><p>void rollback(boolean force)</p><p>默认情况下 MyBatis 不会自动提交事务，除非它侦测到有插入，更新或删除操作改变了数据库。如果你已经做出了一些改变而没有使用这些方法，那么你可以传递 true 到 commit 和 rollback 方法来保证它会被提交（注意，你不能在自动提交模式下强制 session，或者使用了外部事务管理器时）。很多时候你不用调用 rollback()，因为如果你没有调用 commit 时MyBatis 会替你完成。然而，如果你需要更多对多提交和回滚都可能的 session 的细粒度控制，你可以使用回滚选择来使它成为可能。</p><p>清理 <strong>Session</strong> 级的缓存</p><p>void clearCache()</p><p>SqlSession 实例有一个本地缓存在执行 update，commit，rollback 和 close 时被清理。要明确地关闭它（获取打算做更多的工作），你可以调用 clearCache()。</p><p>确保 <strong>SqlSession</strong> 被关闭</p><p>void close()</p><p>你必须保证的最重要的事情是你要关闭所打开的任何 session。保证做到这点的最佳方式是下面的工作模式：</p><p>SqlSession session = sqlSessionFactory.openSession(); try {</p><p>// 下面3行pseudocod来做一些工作</p><p>session.insert(…); session.update(…); session.delete(…); session.commit();</p><p>} finally {</p><p>session.close();</p><p>}</p><p>注意：就像 SqlSessionFactory，你可以通过调用 getConfiguration()方法获得 SqlSession</p><p>使用的 Configuration 实例</p><p>Configuration getConfiguration()</p><p>使用映射器</p><p><T> T getMapper(Class<T> type)</p><p>上述的各个 insert，update，delete 和 select 方法都很强大，但也有些繁琐，没有类型安全，对于你的 IDE 也没有帮助，还有可能的单元测试。在上面的入门章节中我们已经看到了一个使用映射器的示例。</p><p>因此，一个更通用的方式来执行映射语句是使用映射器类。一个映射器类就是一个简单</p><p>的接口，其中的方法定义匹配于 SqlSession 方法。下面的示例展示了一些方法签名和它们是如何映射到 SqlSession 的。</p><p><strong>public inter face Author Mapper {</strong></p><p>// (Author) selectOne(“selectAuthor”,5);</p><p><strong>Author selectAuthor(int i d);</strong></p><p>// (List<Author>) selectList(“selectAuthors”)</p><p><strong>List<Author > selectAuthors();</strong></p><p>// insert(“insertAuthor”, author)</p><p><strong>voi d insertAuthor(Author author);</strong></p><p>// updateAuthor(“updateAuhor”, author)</p><p><strong>voi d update Author(Author author );</strong></p><p>// delete(“deleteAuthor”,5)</p><p><strong>voi d delete Author(int i d);</strong></p><p><strong>}</strong></p><p>总之，每个映射器方法签名应该匹配相关联的 SqlSession 方法，而没有字符串参数 ID。相反，方法名必须匹配映射语句的 ID。</p><p>此外，返回类型必须匹配期望的结果类型。所有常用的类型都是支持的，包括：原生类型，Map，POJO 和 JavaBean。</p><p>映射器接口不需要去实现任何接口或扩展任何类。只要方法前面可以被用来唯一标识对应的映射语句就可以了。</p><p>映射器接口可以扩展其他接口。当使用 XML 来构建映射器接口时要保证在合适的命名空间中有语句。而且，唯一的限制就是你不能在两个继承关系的接口中有相同的方法签名（这也是不好的想法）。</p><p>你可以传递多个参数给一个映射器方法。如果你这样做了，默认情况下它们将会以它们在参数列表中的位置来命名，比如：#{1},#{2}等。如果你想改变参数的名称（只在多参数</p><p>情况下），那么你可以在参数上使用@Param(“paramName”)注解。你也可以给方法传递一个 RowBounds 实例来限制查询结果。</p><p>映射器注解</p><p>因为最初设计时，MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的，而且映射语句也是定义在 XML 中的。而到了 MyBatis 3，有新的可用的选择了。MyBatis 3 构建在基于全面而且强大的 Java 配置 API 之上。这个配置 API 是基于 XML 的 MyBatis 配置的基础，也是新的基于注解配置的基础。注解提供了一种简单的方式来实现简单映射语句，而不会引入大量的开销。</p><p>注意：不幸的是，Java 注解限制了它们的表现和灵活。尽管很多时间都花调查，设计和</p><p>实验上，最强大的 MyBatis 映射不能用注解来构建，那并不可笑。C#属性（做示例）就没有这些限制，因此 MyBatis.NET 将会比 XML 有更丰富的选择。也就是说，基于 Java 注解的配置离不开它的特性。</p><p>注解有下面这些：</p><table><thead><tr><th></th><th></th><th></th><th>示了应该被用于比较（和在 XML 映射中的<id>相似）的属性。one 属性是单独的联系， 和<association> 相似，而   many   属 性 是 对 集 合 而 言 的 ， 和    <collection>相似。它们这样命名是为了   避免名称冲突。</th></tr></thead><tbody><tr><td><strong>@One</strong></td><td>方法</td><td><association></td><td>复杂类型的单独属性值映射。属性：   <strong>select</strong>，已映射语句（也就是映射器方法）的完全限定名，它可以加载合适类型的实例。注意：联合映射在注解 API 中是不支持的。这是因为  Java 注解的   限制，不允许循环引用。</td></tr><tr><td><strong>@Many</strong></td><td>方法</td><td><collection></td><td>复杂类型的集合属性映射。属性：   <strong>select</strong>，是映射语句（也就是映射器方法）的完全限定名，它可以加载合适类型的一组实例。注意：联合映射在 Java   注解中是不支持的。这是因为  Java 注   解的限制，不允许循环引用。</td></tr><tr><td><strong>@Options</strong></td><td>方法</td><td>映射语句的属性</td><td>这个注解提供访问交换和配置选项的宽广范围，它们通常在映射语句上作为属性出现。而不是将每条语句注解变复杂，Options 注解提供连贯清晰的方式来访问它们。属性：<strong>useCache=true</strong> ， <strong>flushCache=false</strong> ，   <strong>resultSetType=FORWARD_ONLY</strong>   ， <strong>statementType=PREPARED</strong>            ， <strong>fetchSize=-1</strong> ， <strong>timeout=-1</strong> ， <strong>useGeneratedKeys=false</strong>                  ，   <strong>keyProperty=”id”</strong>。理解 Java 注解是很重要的，因为没有办法来指定“null”作为值。因此，一旦你使用了 Options 注解，语句就受所有默认值的支配。要注意什么样的默认值来避免不期望的   行为。</td></tr><tr><td><strong>@Insert   @Update @Delete</strong></td><td>方法</td><td><insert>   <update>   <delete></td><td>这些注解中的每一个代表了执行的真实 SQL。它们每一个都使用字符串数组   （或单独的字符串）。如果传递的是字符串数组，它们由每个分隔它们的单独空间串联起来。这就当用 Java 代码构建 SQL 时避免了“丢失空间”的问题。然而，如果你喜欢，也欢迎你串联单独的字符串。属性：<strong>value</strong>，这是字符串   数组用来组成单独的 SQL 语句。</td></tr><tr><td><strong>@InsertProvider</strong></td><td>方法</td><td><insert></td><td>这些可选的 SQL 注解允许你指定一个</td></tr></tbody></table><table><thead><tr><th><strong>@UpdateProvider   @DeleteProvider @SelectProvider</strong></th><th></th><th><update>   <delete>   <select>   允许创建动态    SQL。</th><th>类名和一个方法在执行时来返回运行的 SQL。基于执行的映射语句，MyBatis会实例化这个类，然后执行由 provider 指定的方法. 这个方法可以选择性的接受参数对象作为它的唯一参数，但是必须只指定该参数或者没有参数。属性：   <strong>type</strong>，<strong>method</strong>。type   属性是类的完全限定名。method 是该类中的那个方法名。注意：这节之后是对   SelectBuilder   类的讨论，它可以帮助你以干净，容于阅读   的方式来构建动态 SQL。</th></tr></thead><tbody><tr><td><strong>@Param</strong></td><td>参数</td><td>N/A</td><td>如果你的映射器的方法需要多个参数， 这个注解可以被应用于映射器的方法参数来给每个参数一个名字。否则，多参数将会以它们的顺序位置来被命名   （不包括任何 RowBounds 参数）。比如   #{1} ， #{2} 等，这是默认的。使用   @Param(“person”)，参数应该被命名为   #{person}。</td></tr></tbody></table><p><strong>SelectBuilder</strong></p><p>一个 Java 程序员面对的最痛苦的事情之一就是在 Java 代码中嵌入 SQL 语句。通常这么做是因为 SQL 要动态的生成-否则你可以将它们放到外部的文件或存储过程中。正如你已经看到的，MyBatis 在它的 XML 映射特性中有处理生成动态 SQL 的很强大的方案。然而，有时必须在 Java 代码中创建 SQL 语句的字符串。这种情况下，MyBatis 有另外一种特性来帮助你，在减少典型的加号，引号，新行，格式化问题和嵌入条件来处理多余的逗号或 AND 连接词之前，事实上，在 Java 代码中动态生成 SQL 就是一个噩梦。</p><p>MyBatis 3 引入了一些不同的理念来处理这个问题，我们可以创建一个类的实例来调用其中的方法来一次构建 SQL 语句。但是我们的 SQL 结尾时看起来很像 Java 代码而不是 SQL 语句。相反，我们尝试了一些不同的做法。最终的结果是关于特定领域语言的结束，Java 也 不 断 实 现 它 目 前 的 形 式 …                                                                               <strong>SelectBuilder</strong> 的秘密</p><p>SelectBuilder 类并不神奇，如果你不了解它的工作机制也不会有什么好的作用。别犹豫，</p><p>让我们来看看它是怎么工作的。SelectBuilder 使用了静态引入和 TreadLocal 变量的组合来开启简洁的语法可以很容易地用条件进行隔行扫描，而且为你保护所有 SQL 的格式。它允许你创建这样的方法：</p><p>public String selectBlogsSql() {</p><p><strong>B EGIN</strong>(); // Clears ThreadLocal variable</p><p><strong>SELECT</strong>(“*”);</p><p><strong>FROM</strong>(“BLOG”);</p><p>return <strong>SQL</strong>();</p><p>}</p><p>这是一个非常简单的示例，你也许会选择静态地来构建。所以这里给出一个复杂一点的</p><p>示例：</p><p>private String selectPersonSql() {</p><p><strong>B EGIN</strong>(); // Clears ThreadLocal variable <strong>SELECT</strong>(“P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME”); <strong>SELECT</strong>(“P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON”); <strong>FROM</strong>(“PERSON P”);</p><p><strong>FROM</strong>(“ACCOUNT A”);</p><p><strong>INNER_JOIN</strong>(“DEPARTMENT D on D.ID = P.DEPARTMENT_ID”);</p><p><strong>INNER_JOIN</strong>(“COMPANY C on D.COMPANY_ID = C.ID”);</p><p><strong>WHERE</strong>(“P.ID = A.ID”);</p><p><strong>WHERE</strong>(“P.FIRST_NAME like ?”);</p><p><strong>OR</strong>();</p><p><strong>WHERE</strong>(“P.LAST_NAME like ?”); <strong>GROUP_B Y</strong>(“P.ID”); <strong>HAVING</strong>(“P.LAST_NAME like ?”); <strong>OR</strong>();</p><p><strong>HAVING</strong>(“P.FIRST_NAME like ?”);</p><p><strong>ORDER_B Y</strong>(“P.ID”); <strong>ORDER_B Y</strong>(“P.FULL_NAME”);</p><p>return <strong>SQL</strong>();</p><p>}</p><p>用字符串连接的方式来构建上面的 SQL 就会有一些繁琐了。比如：</p><p>“SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, “ “P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON “ +</p><p>“FROM PERSON P, ACCOUNT A “ +</p><p>“INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID “ + “INNER JOIN COMPANY C on D.COMPANY_ID = C.ID “ + “WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) “ +</p><p>“OR (P.LAST_NAME like ?) “ +</p><p>“GROUP BY P.ID “ +</p><p>“HAVING (P.LAST_NAME like ?) “ + “OR (P.FIRST_NAME like ?) “ + “ORDER BY P.ID, P.FULL_NAME”;</p><p>如果你喜欢那样的语法，那么你就可以使用它。它很容易出错，要小心那些每行结尾增</p><p>加的空间。现在，即使你喜欢这样的语法，下面的示例比 Java 中的字符串连接要简单也是没有疑问的：</p><p>private String selectPersonLike(Person p){</p><p><strong>B EGIN</strong>(); // Clears ThreadLocal variable</p><p><strong>SELECT</strong>(“P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME”);</p><p><strong>FROM</strong>(“PERSON P”);</p><p>if (p.id != null) {</p><p><strong>WHERE</strong>(“P.ID like #{id}”);</p><p>}</p><p>if (p.firstName != null) {</p><p><strong>WHERE</strong>(“P.FIRST_NAME like #{firstName}”);</p><p>}</p><p>if (p.lastName != null) {</p><p><strong>WHERE</strong>(“P.LAST_NAME like #{lastName}”);</p><p>}</p><p><strong>ORDER_B Y</strong>(“P.LAST_NAME”);</p><p>return <strong>SQL</strong>();</p><p>}</p><p>这个例子有什么特殊之处？如果你看得仔细，那就不同担心偶然会重复的“AND”关键字，或在“WHERE”和“AND”或两者都没有中选择！上面的语句将会由例子对所有</p><p>PERSON 记录生成一个查询，有像参数一样的 ID 或 firstName 或 lastName-或这三者的任意组合。SelectBuilder 对理解哪里放置“WHERE”，哪里应该使用“AND”还有所有的字符串连接都是很小心的。最好的情况，无论你以何种顺序调用这些方法（只有一种例外使用 OR() 方法）。</p><p>有两个方法会吸引你的眼球：BEGIN()和 SQL()。总之，每个 SelectBuilder 方法应该以调用 BEGIN（）开始，以调用 SQL()结束。当然你可以在中途提取方法来打断你执行的逻辑，但是 SQL 生成的范围应该以 BEGIN()方法开始而且以 SQL()方法结束。BEGIN()方法清理 ThreadLocal 变量，来确保你不会不小心执行了前面的状态，而且 SQL()方法会基于这些调用，从最后一次调用 BEGIN()开始组装你的 SQL 语句。注意 BEGIN()有一个称为 RESET() 的代替方法，它们所做的工作相同，只是 RESET()会在特定上下文中读取的更好。</p><p>要按照上面示例的方式使用 SelectBuilder，你应该静态引入如下内容：</p><p>import <strong>static</strong> org.mybatis.jdbc.<strong>SelectBuilder.* ;</strong></p><p>只要这个被引入了，那么你使用的类就会拥有 SelectBuilder 的所有可用的方法。下表就是可用方法的完整列表：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>BEGIN()/RESET()</td><td>这些方法清理 SelectBuilder 类的 ThreadLocal   的状态，而且准备构建新的语句。当开始一条新的语句时，BEGIN()读取得最好。当在执行中间因为某些原因（在某些条件下，也许处理逻辑需要一个完整的而且不同的语句）要清理一条语句   时 RESET()读取的做好。</td></tr><tr><td>SELECT(String)</td><td>开始或附加一个 SELECT   子句。可以被多次调用，而且参数会被追加在 SELECT 子句后面。参数通常是逗号分隔的列名   列表和别名，但要是驱动程序可以接受的东西。</td></tr><tr><td>SELECT_DISTINCT(String)</td><td>开始或附加一个   SELECT 子句，也在生成的查询语句中添加   “DISTINCT”关键字。可以被多次调用，而且参数会被追加在 SELECT 子句后面。参数通常是逗号分隔的列名列表和   别名，但要是驱动程序可以接受的东西。</td></tr><tr><td>FROM(String)</td><td>开始或附加一个 FROM 子句。可以被多次调用，而且参数会被追加在 FROM   子句后面。参数通常是表明或别名，或是驱   动程序可以接受的任意内容。</td></tr><tr><td>JOIN(String)   INNER_JOIN(String)   LEFT_OUTER_JOIN(String)</td><td>基于调用的方法，添加一个合适类型的新的   JOIN   子句。参数可以包含列之间基本的 join 连接还有条件连接。</td></tr></tbody></table><table><thead><tr><th>RIGHT_OUTER_JOIN(String)</th><th></th></tr></thead><tbody><tr><td>WHERE(String)</td><td>添加一个新的 WHERE 条件子句，由 AND 串联起来。可以被多次调用，由 AND 告诉它来串联一个新的条件。使用 OR()   方法来分隔 OR 条件。</td></tr><tr><td>OR()</td><td>使用 OR 来分隔当前 WHERE 子句的条件。可以被多次调用，   但是在一行上多次调用会生成不稳定的 SQL。</td></tr><tr><td>AND()</td><td>使用 AND 来分隔当前 WHERE 字句的条件。可以被多次调   用，但是在一行上多次调用会生成不稳定的 SQL。因为   WHERE 和 HAVING 两者都自动串联 AND，这样使用是非   常罕见的，包含它也仅仅是为了完整性。</td></tr><tr><td>GROUP_BY(String)</td><td>附加一个新的 GROUP BY 子句，由逗号串联起来。可以被   多次调用，每次使用逗号来告诉它串联一个新的条件。</td></tr><tr><td>HAVING(String)</td><td>附加一个新的 HAVING   条件子句，由 AND 串联起来。可以被多次调用，每次使用   AND   来告诉它要串联新的条件。使   用 OR()方法来分隔 OR 条件。</td></tr><tr><td>ORDER_BY(String)</td><td>附加一个新的 ORDER BY 子句，由逗号串联起来。可以被   多次调用，每次使用逗号来告诉它串联新的条件。</td></tr><tr><td>SQL()</td><td>这会返回生成  SQL 而且重置  SelectBuilder  的状态（正如   BEGIN()或 RESET()方法被调用）。因此，这个方法只能被调   用一次！</td></tr></tbody></table><p><strong>SqlBuilder</strong></p><p>和 SelectBuilder 相似，MyBatis 也包含一个一般性的 SqlBuilder。它包含 SelectBuilder 的所有方法，还有构建 insert，update 和 delete 的方法。在 DeleteProvider，InsertProvider 或UpdateProvider 中（还有 SelectProvider）构建 SQL 字符串时这个类就很有用。</p><p>在上述示例中要使用 SqlBuilder，你只需简单静态引入如下内容：</p><p>import <strong>static</strong> org.mybatis.jdbc.<strong>S</strong> <strong>qlBuil der.*;</strong></p><p>SqlBuilder 包含 中的所有方法，还有下面这些额外的方法：</p><p>这里是一些示例：</p><p>public String deletePersonSql() {</p><p><strong>B EGIN</strong>(); // Clears ThreadLocal variable</p><p><strong>DELET E_ FROM(</strong>“PERSON”);</p><p><strong>WHERE(</strong>“ID = ${id}”);</p><p>return <strong>SQL</strong>();</p><p>}</p><p>public String insertPersonSql() {</p><p><strong>B EGIN</strong>(); // Clears ThreadLocal variable</p><p><strong>INS ERT_ INTO(</strong>“PERSON”);</p><p><strong>VALUES (</strong>“ID, FIRST_NAME”, “${id}, ${firstName}”);</p><p><strong>VALUES (</strong>“LAST_NAME”, “${lastName}”);</p><p>return <strong>SQL</strong>();</p><p>}</p><p>public String updatePersonSql() {</p><p><strong>B EGIN</strong>(); // Clears ThreadLocal variable</p><p><strong>UPDATE(</strong>“PERSON”);</p><p><strong>SET(</strong>“FIRST_NAME = ${firstName}”);</p><p><strong>WHERE(</strong>“ID = ${id}”);</p><p>return <strong>SQL</strong>();</p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring笔记</title>
      <link href="/2019/09/02/%E6%A1%86%E6%9E%B6-Spring/"/>
      <url>/2019/09/02/%E6%A1%86%E6%9E%B6-Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring笔记"><a href="#Spring笔记" class="headerlink" title="Spring笔记"></a>Spring笔记</h2><h3 id="1-Spring-IOC"><a href="#1-Spring-IOC" class="headerlink" title="1. Spring IOC"></a>1. Spring IOC</h3><h4 id="1-1-Spring核心包"><a href="#1-1-Spring核心包" class="headerlink" title="1.1 Spring核心包"></a>1.1 Spring核心包</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190905092338.png" alt="Spring核心包"></p><blockquote><p><em>XML编写提示：配置Schema，修改Key type 为Schema location</em></p></blockquote><h4 id="1-2-SpringIOC入门"><a href="#1-2-SpringIOC入门" class="headerlink" title="1.2. SpringIOC入门"></a>1.2. SpringIOC入门</h4><ol><li><p>IOC: Inversion of Control(控制反转)。将对象的创建权反转给（交给）Spring。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.joey.spring.Bean1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DI：依赖注入，前提必须有IOC的环境，Spring管理这个类的时候将类的依赖的属性注入（设置）进来。</p></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190902210244.png" alt="IOC"></p><h4 id="1-3-Spring工厂类结构图"><a href="#1-3-Spring工厂类结构图" class="headerlink" title="1.3. Spring工厂类结构图"></a>1.3. Spring工厂类结构图</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190902210417.png" alt="工厂类结构图"></p><ol><li><p>ApplicationContext继承BeanFactory</p></li><li><p>BeanFactory</p><blockquote><p>老版本的工厂类，在调用getBean的时候才会产生类的实例</p></blockquote></li><li><p>ApplicationContext</p><blockquote><p>新版本的工厂类，加载配置文件的时候，将Spring管理的类都实例化</p><p>两个实现类：</p><ul><li>ClassPathXmlApplicationContext：加载类路径下的配置文件</li><li>FileSystemXmlApplicationContext：加载文件系统下的配置文件</li></ul></blockquote></li></ol><h4 id="1-4-Spring-Bean配置"><a href="#1-4-Spring-Bean配置" class="headerlink" title="1.4. Spring Bean配置"></a>1.4. Spring Bean配置</h4><ol><li><p><bean>标签的id和name配置</p><blockquote><p>id：使用了约束中的唯一约束，里面不能出现特殊字符。</p><p>name：没有使用约束中的唯一约束（理论上可以出现重复的，但是实际开发不能出现），里面可以出现特殊字符。</p></blockquote></li><li><p>Bean的生命周期配置</p><blockquote><p>init-method：Bean被初始化的时候执行的方法</p><p>destory-method：Bean被销毁的时候执行的方法（Bean是单例创建，工厂关闭）</p></blockquote></li><li><p>Bean的作用范围配置</p><blockquote><p>scope：Bean的作用范围</p><ul><li>singleton：默认单例模式创建对象</li><li>prototype：多例模式</li><li>request：应用在web项目中，Spring创建这个类以后存到request范围中</li><li>session：应用在web项目中，Spring创建这个类以后存到session范围中</li><li>globalsession：应用在web项目中，必须在porlet环境下使用，但是如果没有这种环境，相对于session</li></ul></blockquote></li></ol><h4 id="1-5-Spring的Bean管理（XML方式）"><a href="#1-5-Spring的Bean管理（XML方式）" class="headerlink" title="1.5. Spring的Bean管理（XML方式）"></a>1.5. Spring的Bean管理（XML方式）</h4><ol><li><p>Spring的Bean的实例化方式</p><blockquote><ol><li><p>无参构造方法</p><ul><li><p>编写类构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.pringt(<span class="string">&quot;Bean1的无参构造方法执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写XML配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.joey.spring.Bean1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态工厂实例化</p><ul><li><p>编写静态工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean2Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bean2 <span class="title">createBean2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.pringt(<span class="string">&quot;Bean2的静态工厂方法执行。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写XML配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.joey.spring.Bean2Factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createBean2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>实例工厂实例化</p><ul><li><p>编写实例工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean3Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bean3 <span class="title">createBean3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.pringt(<span class="string">&quot;Bean3的实例工厂方法执行。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置XML文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean3Factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.joey.spring.Bean3Factory&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean3&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bean3Factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createBean3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></blockquote></li><li><p>Spring的属性注入(DI)</p><ol><li><p>构造方法的方式属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个可以执行批量的sqlSession --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;executorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Set方法的方式属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--================== 配置和MyBatis的整合=============== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mybatis全局配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;pooledDataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mybatis，mapper文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>P名称空间属性注入</p><ol><li><p>引入P名称空间</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>P名称空间的属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.joey.spring.Car&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;&quot;</span> <span class="attr">p:price</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.joey.spring.Employee&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;&quot;</span> <span class="attr">p:car-ref</span>=<span class="string">&quot;car&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>SpEL的属性注入（Spring3.0以后）</p><blockquote><p>spring表达式语言简称<strong>SPEL</strong>：是一个支持运行时查询和操作对象图的强大的表达式语言。语法类似于<strong>EL</strong>，SpEL 使用 #{…} 作为定界符 , 所有在大括号中的字符都将被认为是 SpEL , SpEL 为 bean 的属性进行动态赋值提供了便利。</p></blockquote><blockquote><h5 id="通过-SpEL-可以实现："><a href="#通过-SpEL-可以实现：" class="headerlink" title="通过 SpEL 可以实现："></a>通过 SpEL 可以实现：</h5><ul><li>通过 bean 的 id 对 bean 进行引用。</li><li>调用方式以及引用对象中的属性。</li><li>计算表达式的值</li><li>正则表达式的匹配</li></ul></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;carInfo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.joey.spring.CarInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.joey.spring.car&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;carInfo.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;drive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;carInfo.drive()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Spring集合类型属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring的集合属性的注入============================ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注入数组类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;collectionBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.joey.spring.CollectionBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数组类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arrs&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入list集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>7<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入set集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入Map集合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;aaa&quot;</span> <span class="attr">value</span>=<span class="string">&quot;111&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;bbb&quot;</span> <span class="attr">value</span>=<span class="string">&quot;222&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ccc&quot;</span> <span class="attr">value</span>=<span class="string">&quot;333&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p> 分模块开发配置</p></li><li><p>加载配置文件的时候加载多个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationCOntext applicationCOntext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationConetxt.xml&quot;</span>,<span class="string">&quot;applicationConetxt.xml2&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p> 在一个配置文件中引入多个配置文件</p></li></ol><pre><code>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">import</span> resource=<span class="string">&quot;applicationConetxt2.xml&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></code></pre><h4 id="1-6-Spring的Bean管理（注解开发）"><a href="#1-6-Spring的Bean管理（注解开发）" class="headerlink" title="1.6. Spring的Bean管理（注解开发）"></a>1.6. Spring的Bean管理（注解开发）</h4><ol><li><p>引入context约束</p></li><li><p>开启Spring组件扫描</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.joey.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>类上添加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Compoent(&quot;userDao&quot;)</span> <span class="comment">//相当于&lt;bean id=&quot;userDao&quot; class=&quot;com.joey.spring.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注解方式设置属性值</p><blockquote><p>使用注解方式，可以没有set方法的</p><ul><li><p>属性如果有set方法，需要将属性注入的注解添加到set方法</p></li><li><p>如果没有set方法，需要将属性注入的注解添加属性上</p></li></ul></blockquote></li><li><p>IOC 注解</p><ol><li>@Component：组件，修饰一个类，将这个类交给Spring管理</li><li>三个衍生注解，修饰类<ul><li>@Controller：Web层</li><li>@ServIce：service层</li><li>@Respository：dao层</li></ul></li><li>属性注入的注解：<ul><li>普通属性：@Value</li><li>按照类型对象注入：@Autoware</li><li>按照名称对象注入：@Resource</li></ul></li><li>Bean的其他注解：<ul><li>生命周期相关注解<ul><li>PostConstruct：初始化方法</li><li>PreDestory：销毁方法</li></ul></li><li>Bean作用范围的注解<ul><li>@Scope<ul><li>Singleton</li><li>prototype</li><li>request</li><li>session</li><li>globalsession</li></ul></li></ul></li></ul></li></ol></li><li><p>IOC的XML和注解开发比较</p><blockquote><p>XML ：可以适用任何场景，结构清晰，维护方便</p><p>注解：有些地方用不了，类不是自己提供，开发方便</p><p>XML和注解整合开发：XML管理Bean，注解完成属性注入</p><p>没有使用扫描类上的注解，需要开启属性注入的注解</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;context：annotation-config/&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>基于XML配置</th><th>基于注解配置</th></tr></thead><tbody><tr><td>Bean定义</td><td><bean id="" class=""/></td><td>@Component，衍生类：@Repository、@Service、@Controller</td></tr><tr><td>Bean名称</td><td>通过id或name指定</td><td>@Component(“person”)</td></tr><tr><td>Bean注入</td><td><property>或者通过p命名空间</td><td>@Autowired按照类型注入，@Qualifier按照名称注入</td></tr><tr><td>生命过程，Bean作用范围</td><td>init-method，destory-method，范围scope属性</td><td>@PostConstructa初始化、@PreDestory销毁、@Scope设置作用范围</td></tr><tr><td>适合场景</td><td>Bean来自第三方，使用其它</td><td>Bean的实现类由用户自己开发</td></tr></tbody></table></blockquote></li></ol><h3 id="2-Spring-AOP"><a href="#2-Spring-AOP" class="headerlink" title="2. Spring AOP"></a>2. Spring AOP</h3><h4 id="2-1-Spring-底层实现原理"><a href="#2-1-Spring-底层实现原理" class="headerlink" title="2.1 Spring 底层实现原理"></a>2.1 Spring 底层实现原理</h4><blockquote><p>动态代理</p><ul><li><p>JDK动态代理（默认，先修改java文件然后再编译成class文件）</p><blockquote><p>JDK动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）</p><p>JDK动态代理主要涉及java.lang.reflect包下的两个类：Proxy类和InvocationHandler接口。<br>JDK动态代理实现的三个要点：</p><ol><li>通过java.lang.reflect.Proxy类来动态生成代理类</li><li>代理类要实现InvocationHandler接口</li><li>JDK动态代理只能基于接口进行动态代理的</li></ol></blockquote></li><li><p>Cglib动态代理（运行更快,在内存直接生成子类class文件继承父类重写所有父类方法(不能声明成final)）</p><blockquote><p>Cglib采用非常底层的字节码技术，可以为一个类创建子类，并在子类中采用方法拦截的技术拦截所有的父类方法的调用，并顺势织入横切逻辑。</p></blockquote></li><li><p>区别</p><blockquote><p>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p><p>而Cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p><ol><li><p>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</p></li><li><p>如果目标对象实现了接口，可以强制使用CGLIB实现AOP’</p><blockquote><p>如何强制使用Cglib：</p><ol><li>在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=“true”/&gt;</li><li>EnableAspectJAutoProxy注解参数proxyTargetClass=true使用Cglib</li></ol></blockquote></li><li><p>如果目标对象没有实现了接口，必须采用Cglib库，spring会自动在JDK动态代理和Cglib之间转换</p></li><li><p>JDK动态代理和Cglib字节码生成的区别？<br>（1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br>（2）Cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。   因为是继承，所以该类或方法最好不要声明成final</p></li></ol></blockquote></li><li><p>性能问题</p><blockquote><p>由于Cglib代理是利用ASM字节码生成框架在内存中生成一个需要被代理类的子类完成代理，而JDK动态代理是利用反射原理完成动态代理，所以Cglib创建的动态代理对象性能比JDK动态代理动态创建出来的代理对象新能要好的多，但是对象创建的速度比JDK动态代理要慢，所以，当Spring使用的是单例情况下可以选用Cglib代理，反之使用JDK动态代理更加合适。同时还有一个问题，被final修饰的类只能使用JDK动态代理，因为被final修饰的类不能被继承，而Cglib则是利用的继承原理实现代理的。</p></blockquote></li></ul></blockquote><h4 id="2-2-Spring-AOP相关术语"><a href="#2-2-Spring-AOP相关术语" class="headerlink" title="2.2 Spring AOP相关术语"></a>2.2 Spring AOP相关术语</h4><blockquote><ul><li><p>Joinpoint(连接点) : </p><p>​        所谓连接点是指那些被拦截到的点。在Spring中,这些点指的是方法，因为Spring只支持方法类型的连接点。</p></li><li><p>Pointcut(切入点) : </p><p>​        所谓的切入点是指我们要对哪些Joinpoint进行拦截的定义。</p></li><li><p>Advice(通知/增强) : </p><p>​        所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。</p><p>​        通知的类型：前置类型，后置通知，异常通知，环绕通知。</p></li><li><p>Introduction(引介) : </p><p>​        引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field。</p></li><li><p>Target(目标对象) : </p><p>​        代理的目标对象。</p></li><li><p>Weaving(织入) : </p><p>​        是指把增强应用到目标对象来创建新的代理对象的过程。</p><p>​        Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。</p></li><li><p>Proxy(代理) : </p><p>​        一个类被AOP织入增强，就产生一个结果代理类。</p></li><li><p>Aspect(切面) : </p><p>​        是切入点和通知（引介）的结合。</p></li></ul></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190905152719.png" alt="AOP相关术语"></p><h4 id="2-3-SpringAOP-的入门开发"><a href="#2-3-SpringAOP-的入门开发" class="headerlink" title="2.3 SpringAOP 的入门开发"></a>2.3 SpringAOP 的入门开发</h4><ol><li><p>引入jar包</p></li><li><p>编写目标类并配置</p></li><li><p>编写切面类并配置</p></li><li><p>进行aop配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(表达式&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类型</p><ul><li>前置通知</li><li>后置通知</li><li>环绕通知</li><li>异常抛出通知</li><li>最终通知</li></ul></li><li><p>XML配置</p></li><li><p>基于execution的函数完成</p><blockquote><p>[访问修饰符] 方法返回值 包名.类名.方法名(参数)</p></blockquote></li></ol><h4 id="2-4-基于AspectJ的XML配置"><a href="#2-4-基于AspectJ的XML配置" class="headerlink" title="2.4  基于AspectJ的XML配置"></a>2.4  基于AspectJ的XML配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前置通知 : 获得切入点信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--后置通知 : 获得方法的返回值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--环绕通知 : 阻止目标方法的执行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--异常抛出通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最终通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-基于AspectJ的注解配置"><a href="#2-5-基于AspectJ的注解配置" class="headerlink" title="2.5 基于AspectJ的注解配置"></a>2.5 基于AspectJ的注解配置</h4><ol><li><p>在配置文件中开启AOP注解开发</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>切面类上使用注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectj</span></span>&#123;</span><br><span class="line">    <span class="meta">@Before(value=&quot;execution(* com.joey.spring.save(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;execution(* com.joey.spring.save(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(value=&quot;execution(* com.joey.spring.save(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;execution(* com.joey.spring.save(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常抛出通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(value=&quot;execution(* com.joey.spring.save(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Spring的JDBC模板使用"><a href="#3-Spring的JDBC模板使用" class="headerlink" title="3. Spring的JDBC模板使用"></a>3. Spring的JDBC模板使用</h3><ul><li><p>Spring的JDBC模板</p><table><thead><tr><th>ORM持久化技术</th><th>模板类</th></tr></thead><tbody><tr><td>JDBC</td><td>org.springframework.jdbc.core.JdbcTemplate</td></tr><tr><td>Hibernate3.0</td><td>org.springframework.orm.hibernate3.HeibernateTemplate</td></tr><tr><td>IBatis(Mybatis)</td><td>org.springframework.orm.ibatis.SqlMapClientTemplate</td></tr><tr><td>JPA</td><td>org.springframework.orm.jpa.JpaTemplate</td></tr></tbody></table></li><li><p>JDBC模板使用(例: c3p0)</p><ol><li><p>引入jar包</p></li><li><p>配置c3p0连接池</p></li><li><p>抽取配置到属性文件</p></li><li><p>在Spring的配置文件中引入属性文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一种(常用)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:dbconfig.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第二种--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:dbconfig.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入属性文件的值 </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;pooledDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.jdbcUrl&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="4-Spring-的事务管理"><a href="#4-Spring-的事务管理" class="headerlink" title="4. Spring 的事务管理"></a>4. Spring 的事务管理</h3><h4 id="4-1-事务特性"><a href="#4-1-事务特性" class="headerlink" title="4. 1 事务特性"></a>4. 1 事务特性</h4><ul><li>原子性 : 事务不可分割</li><li>一致性 : 事务执行前后数据完整性保持一致</li><li>隔离性 : 一个事务的执行不应该受到其他事务的干扰</li><li>持久性 : 一旦事务结束,数据就持久到数据库</li></ul><h4 id="4-2-事务隔离级别"><a href="#4-2-事务隔离级别" class="headerlink" title="4.2 事务隔离级别"></a>4.2 事务隔离级别</h4><ul><li><p>Read uncommitted ：未提交读，任何读问题解决不了。</p></li><li><p>Read committed      ：已提交读，解决脏读，但是不可重复读和虚读有可能发生。</p></li><li><p>Repeatable read      ：重复读，解决脏读和不可重复读，但是虚读有可能发生。</p></li><li><p>Serializable               ：解决所有读问题。</p></li></ul><h4 id="4-3-事务管理的API"><a href="#4-3-事务管理的API" class="headerlink" title="4.3 事务管理的API"></a>4.3 事务管理的API</h4><ol><li><p>PlatformTransactionManager: 平台事务管理器</p><blockquote><ul><li>DataSourceTransactionManager: 底层使用JDBC管理事务</li><li>HibernateTransactionManager   : 底层使用Hibernate管理事务</li></ul></blockquote></li><li><p>事务定义信息</p><blockquote><p> 用于定义事务的相关信息</p><ul><li>隔离级别</li><li>超时信息</li><li>传播行为</li><li>是否只读 </li></ul></blockquote></li><li><p>事务的状态</p><blockquote><p>用于记录在事务管理过程中, 事务的状态的对象</p></blockquote></li></ol><h4 id="4-4-Spring事务的传播行为-七种事务"><a href="#4-4-Spring事务的传播行为-七种事务" class="headerlink" title="4.4 Spring事务的传播行为(七种事务)"></a>4.4 Spring事务的传播行为(七种事务)</h4><ol><li>保证多个操作在同一个事务中<ul><li><strong>PROPAGATION_REQUIRED</strong>     <strong>：默认值，如果A中有事务，使用A中的事务，如果A没有，创建一个新的事务，将操作包含进来</strong></li><li><strong>PROPAGATION_SUPPORTS   ：支持事务，如果A中有事务，使用A中的事务。如果A没有事务，不使用事务。</strong></li><li><strong>PROPAGATION_MANDATORY：如果A中有事务，使用A中的事务。如果A没有事务，抛出异常。</strong></li></ul></li><li>保证多个操作不在同一个事务中<ul><li><strong>PROPAGATION_REQUIRES_NEW   ：如果A中有事务，将A的事务挂起（暂停），创建新事务，只包含自身操作。如果A中没有事务，创建一个新事务，包含自身操作。</strong></li><li><strong>PROPAGATION_NOT_SUPPORTED ：如果A中有事务，将A的事务挂起。不使用事务管理。</strong></li><li><strong>PROPAGATION_NEVER：如果A中有事务，报异常。</strong></li></ul></li><li>嵌套式事务<ul><li><strong>PROPAGATION_NESTED：嵌套事务，如果A中有事务，按照A的事务执行，执行完成后，设置一个保存点，执行B中的操作，如果没有异常，执行通过，如果有异常，可以选择回滚到最初始位置，也可以回滚到保存点。</strong></li></ul></li></ol><h4 id="4-5-Spring事务管理"><a href="#4-5-Spring事务管理" class="headerlink" title="4.5 Spring事务管理"></a>4.5 Spring事务管理</h4><ol><li><p>编程式事务(需手动编写代码)</p><ol><li>配置平台事务管理器</li><li>配置事务管理的模板类</li><li>在业务层注入事务管理的模板</li><li>编写事务管理的代码</li></ol></li><li><p>声明式事务管理(XML方式)</p><ol><li><p>配置事务管理器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--控制住数据源  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;pooledDataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置增强</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 所有方法都是事务方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以get开始的所有方法  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>AOP配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 切入点表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.joey.service..*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txPoint&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPoint&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>声明式事务管理(注解方式)</p><ol><li><p>配置事务管理器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务增强，事务如何切入  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 所有方法都是事务方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以get开始的所有方法  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>开启注解事务</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transationManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在业务层添加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImple</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Netty+WebSocket简易版微信</title>
      <link href="/2019/08/23/%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8ENetty+WebSocket%E7%AE%80%E6%98%93%E7%89%88%E5%BE%AE%E4%BF%A1/"/>
      <url>/2019/08/23/%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8ENetty+WebSocket%E7%AE%80%E6%98%93%E7%89%88%E5%BE%AE%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Netty-WebSocket简易版微信-慕课网"><a href="#基于Netty-WebSocket简易版微信-慕课网" class="headerlink" title="基于Netty+WebSocket简易版微信-慕课网"></a>基于Netty+WebSocket简易版微信-慕课网</h1><h3 id="1-技术栈"><a href="#1-技术栈" class="headerlink" title="1. 技术栈"></a>1. 技术栈</h3><p><strong>前端：MUI 、H5PLUS</strong></p><p><strong>后端：SpringBoot 、Netty、WebSocket、Mysql、FastDFS、Nginx、Mybatis</strong></p><h3 id="2-数据库建表"><a href="#2-数据库建表" class="headerlink" title="2. 数据库建表"></a>2. 数据库建表</h3><h4 id="表：users"><a href="#表：users" class="headerlink" title="表：users"></a>表：users</h4><table><thead><tr><th>表名</th><th align="left">users</th><th>表名中文</th><th>用户表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td align="left">列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td align="left">id</td><td>主键</td><td>varchar</td><td>64</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td align="left">username</td><td>名称</td><td>varchar</td><td>20</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td align="left">password</td><td>密码</td><td>varchar</td><td>64</td><td></td><td>M</td><td></td><td></td></tr><tr><td>4</td><td align="left">face_image</td><td>头像</td><td>varchar</td><td>255</td><td></td><td>N</td><td></td><td></td></tr><tr><td>5</td><td align="left">face_image_big</td><td>大头像</td><td>varchar</td><td>255</td><td></td><td>N</td><td></td><td></td></tr><tr><td>6</td><td align="left">nickname</td><td>昵称</td><td>varchar</td><td>20</td><td></td><td>N</td><td></td><td></td></tr><tr><td>7</td><td align="left">qrcode</td><td>二维码</td><td>varchar</td><td>255</td><td></td><td>N</td><td></td><td></td></tr><tr><td>8</td><td align="left">cid</td><td>设备ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr></tbody></table><h4 id="表：friends-request"><a href="#表：friends-request" class="headerlink" title="表：friends_request"></a>表：friends_request</h4><table><thead><tr><th>表名</th><th>friends_request</th><th>表名中文</th><th>用户请求表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>id</td><td>主键</td><td>varchar</td><td>64</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>send_user_id</td><td>发送者ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td>accept_user_id</td><td>接收者ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>4</td><td>request_date_time</td><td>接收时间</td><td>datetime</td><td>0</td><td></td><td>N</td><td></td><td></td></tr></tbody></table><h4 id="表：my-friends"><a href="#表：my-friends" class="headerlink" title="表：my_friends"></a>表：my_friends</h4><table><thead><tr><th>表名</th><th>my_friends</th><th>表名中文</th><th>好友中间表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>id</td><td>主键</td><td>varchar</td><td>64</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>my_user_id</td><td>我的ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td>my_friend_user_id</td><td>好友的ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr></tbody></table><h4 id="表：chat-msg"><a href="#表：chat-msg" class="headerlink" title="表：chat_msg"></a>表：chat_msg</h4><table><thead><tr><th>表名</th><th>chat_msg</th><th>表名中文</th><th>好友中间表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>id</td><td>主键</td><td>varchar</td><td>64</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>send_user_id</td><td>我的ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td>accept_user_id</td><td>好友的ID</td><td>varchar</td><td>64</td><td></td><td>N</td><td></td><td></td></tr><tr><td>4</td><td>msg</td><td>消息</td><td>varchar</td><td>255</td><td></td><td>N</td><td></td><td></td></tr><tr><td>5</td><td>sign_flag</td><td>已读未读</td><td>int</td><td>1</td><td></td><td>N</td><td></td><td></td></tr><tr><td>6</td><td>create_time</td><td>发送时间</td><td>datetime</td><td>0</td><td></td><td>N</td><td></td><td></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">not</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">username <span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">password <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">face_image <span class="type">varchar</span>(<span class="number">255</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">face_image_big  <span class="type">varchar</span>(<span class="number">255</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;大头像&#x27;</span>,</span><br><span class="line">nickname <span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">qrcode <span class="type">varchar</span>(<span class="number">255</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;二维码&#x27;</span>,</span><br><span class="line">cid <span class="type">VARCHAR</span>(<span class="number">64</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;设备ID&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> friends_request(</span><br><span class="line">id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">not</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">send_user_id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;发送者ID&#x27;</span>,</span><br><span class="line">accept_user_id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;接收者ID&#x27;</span>,</span><br><span class="line">request_date_time datetime  <span class="keyword">null</span> COMMENT <span class="string">&#x27;接收时间&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> my_friends(</span><br><span class="line">id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">not</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">my_user_id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;我的ID&#x27;</span>,</span><br><span class="line">my_friend_user_id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;好友的ID&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> chat_msg(</span><br><span class="line">id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">not</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">send_user_id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;我的ID&#x27;</span>,</span><br><span class="line">accept_user_id <span class="type">varchar</span>(<span class="number">64</span>)  <span class="keyword">null</span> COMMENT <span class="string">&#x27;好友的ID&#x27;</span>,</span><br><span class="line">msg <span class="type">varchar</span>(<span class="number">255</span>)   <span class="keyword">null</span> COMMENT <span class="string">&#x27;消息&#x27;</span>,</span><br><span class="line">    sign_flag <span class="type">int</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;已读未读&#x27;</span>,</span><br><span class="line">    create_time datetime  <span class="keyword">null</span> COMMENT <span class="string">&#x27;发送时间&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><h3 id="问题解决记录"><a href="#问题解决记录" class="headerlink" title="问题解决记录"></a>问题解决记录</h3><ul><li><a href="https://fangchenyong.top/2019/08/14/install_FastDFS+Nginx/">安装fastDFS+nginx实现文件存储服务器</a></li><li><a href="https://blog.csdn.net/svneclipse/article/details/80719480">The type org.springframework.context.ConfigurableApplicationContext cannot be resolved.</a></li><li><a href="https://www.iteye.com/blog/1615714">Spring配置事务的传播行为（PROPAGATION)和隔离级别(Isolation)（终于懂了）</a></li><li><a href="https://ask.dcloud.net.cn/question/8161">mui.ajax() abort</a></li><li><a href="https://blog.csdn.net/bmw601055/article/details/77414855">Uncaught SyntaxError: Unexpected token o</a> </li></ul><p><em>注：安装测试需要更改application.properties中fastdfs配置以及数据库连接，修改前端app.js配置以及后端新增用户产生二维码的文件目录和文件上传目录</em></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8 Object源码</title>
      <link href="/2019/08/23/Java-%E6%BA%90%E7%A0%81-JDK8-Object/"/>
      <url>/2019/08/23/Java-%E6%BA%90%E7%A0%81-JDK8-Object/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JDK8-Object"><a href="#JDK8-Object" class="headerlink" title="JDK8 Object"></a>JDK8 Object</h1><h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h2><p>Java对象被设计成单继承，所有的对象都直接或者间接的继承Object类，拥有Object的一些属性和方法。所以Object也可以理解为所有类的父类。</p><h2 id="2-方法汇总"><a href="#2-方法汇总" class="headerlink" title="2.方法汇总"></a>2.方法汇总</h2><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>protected Object</td><td>clone()</td><td>Creates and returns a copy of this object.</td></tr><tr><td>boolean</td><td>equals(Object obj)</td><td>Indicates whether some other object is “equal to” this one.</td></tr><tr><td>protected void</td><td>finalize()</td><td>Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.</td></tr><tr><td>Class&lt;?&gt;</td><td>getClass()</td><td>Returns the runtime class of this Object.</td></tr><tr><td>int</td><td>hashCode()</td><td>Returns a hash code value for the object.</td></tr><tr><td>String</td><td>toString()</td><td>Returns a string representation of the object.</td></tr><tr><td>void</td><td>notify()</td><td>Wakes up a single thread that is waiting on this object’s monitor.</td></tr><tr><td>void</td><td>notifyAll()</td><td>Wakes up all threads that are waiting on this object’s monitor.</td></tr><tr><td>void</td><td>wait()</td><td>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.</td></tr><tr><td>void</td><td>wait(long timeout)</td><td>Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.</td></tr><tr><td>void</td><td>wait(long timeout, int nanos)</td><td>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object, or some other thread interrupts the current thread, or a certain amount of real time has elapsed.</td></tr></tbody></table><h2 id="3-方法详细信息"><a href="#3-方法详细信息" class="headerlink" title="3.方法详细信息"></a>3.方法详细信息</h2><ol><li><p>Clone()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建并返回此对象的副本。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br></pre></td></tr></table></figure><p> 如何实现拷贝，到底是浅拷贝？还是深拷贝？</p><ol><li>要想重写clone方法，需要实现Cloneable接口</li><li>通过super.clone()获取Objec.clone()方法返回的拷贝对象</li><li>如果你想要实现深拷贝，你需要在对象返回前进行修改</li></ol><blockquote><p>情况一：创建一个Person类，实现Cloneable接口，重写clone方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不重写toString()方法，为了看哈希值是否一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;年龄：&quot;</span> + <span class="keyword">this</span>.age + <span class="string">&quot;,姓名：&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">18</span>,<span class="string">&quot;joey&quot;</span>);</span><br><span class="line">        <span class="comment">//深拷贝一个对象</span></span><br><span class="line">        Person person1 = (Person)person.clone();</span><br><span class="line">        <span class="comment">//输出对象的哈希地址值</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">        <span class="comment">//输出对象的内容</span></span><br><span class="line">        System.out.println(person.show());</span><br><span class="line">        System.out.println(person1.show());</span><br><span class="line">        <span class="comment">//修改复制的对象</span></span><br><span class="line">        person1.setAge(<span class="number">24</span>);</span><br><span class="line">        person1.setName(<span class="string">&quot;方陈勇&quot;</span>);</span><br><span class="line">        <span class="comment">//输出判断是否会修改person的值，其实地址值不一样就已经很清楚了</span></span><br><span class="line">        System.out.println(person.show());</span><br><span class="line">        System.out.println(person1.show());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">com.joey.object.Person@1b6d3586</span></span><br><span class="line"><span class="comment">com.joey.object.Person@4554617c</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey</span></span><br><span class="line"><span class="comment">年龄：24,姓名：方陈勇</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>结论一：单纯看地址值能够判断两个是不同的对象，属于深拷贝，并且修改person1的值不会影响person的值。</strong></p><p>情况二：创建一个Address类，重写toString()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>&#123;</span><br><span class="line">    String location;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Address&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;location=&#x27;&quot;</span> + location + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类做一下修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name,Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address= address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不重写toString()方法，为了看地址值是否一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;年龄：&quot;</span> + <span class="keyword">this</span>.age + <span class="string">&quot;,姓名：&quot;</span> + <span class="keyword">this</span>.name +<span class="string">&quot;,地址：&quot;</span> +<span class="keyword">this</span>.address;</span><br><span class="line"> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span></span>&#123;</span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">     Person person = <span class="keyword">new</span> Person(<span class="number">18</span>,<span class="string">&quot;joey&quot;</span>,<span class="keyword">new</span> Address(<span class="string">&quot;杭州西湖&quot;</span>));</span><br><span class="line">     <span class="comment">//拷贝一个对象</span></span><br><span class="line">     Person person1 = (Person)person.clone();</span><br><span class="line">        <span class="comment">//输出对象的哈希地址值</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">        <span class="comment">//输出对象的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**********************复制后************************&quot;</span>);</span><br><span class="line">        System.out.println(person.show());</span><br><span class="line">        System.out.println(person1.show());</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//修改复制的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************修改person1中的age和name*************&quot;</span>);</span><br><span class="line">        person1.setAge(<span class="number">24</span>);</span><br><span class="line">     person1.setName(<span class="string">&quot;方陈勇&quot;</span>);</span><br><span class="line">        <span class="comment">//输出判断</span></span><br><span class="line">        System.out.println(person.show());</span><br><span class="line">        System.out.println(person1.show());</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//修改复制的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************修改person1中的age和name*************&quot;</span>);</span><br><span class="line">        Address address = person1.getAddress();</span><br><span class="line">     address.setLocation(<span class="string">&quot;杭州滨江&quot;</span>);</span><br><span class="line">        <span class="comment">//输出判断</span></span><br><span class="line">        System.out.println(person.show());</span><br><span class="line">        System.out.println(person1.show());</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">   com.joey.object.Person@1b6d3586</span></span><br><span class="line"><span class="comment">   com.joey.object.Person@4554617c</span></span><br><span class="line"><span class="comment">**********************复制后************************</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey,地址：Address&#123;location=&#x27;杭州西湖&#x27;&#125;</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey,地址：Address&#123;location=&#x27;杭州西湖&#x27;&#125;</span></span><br><span class="line"><span class="comment">*****************修改person1中的age和name*************</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey,地址：Address&#123;location=&#x27;杭州西湖&#x27;&#125;</span></span><br><span class="line"><span class="comment">年龄：24,姓名：方陈勇,地址：Address&#123;location=&#x27;杭州西湖&#x27;&#125;</span></span><br><span class="line"><span class="comment">*****************修改person1中的age和name*************</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey,地址：Address&#123;location=&#x27;杭州滨江&#x27;&#125;</span></span><br><span class="line"><span class="comment">年龄：24,姓名：方陈勇,地址：Address&#123;location=&#x27;杭州滨江&#x27;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>结论二：person1只修改age和name时发现不会影响person的值，但是修改address对象的值时就会有影响。是因为Address类没有重写Clone()方法，person和person1指向的都是同一个Address对象</strong></p><p>情况三：那么如何实现深拷贝。修改Address类实现Cloneable接口，重写clone()方法，在Person类中重写Clone()方法的时候调用Address重写后的clone()方法，即同时克隆Person类和Address类。</p><p>修改Address类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  &gt;<span class="keyword">package</span> com.joey.object;</span><br><span class="line"></span><br><span class="line">  &gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">String location;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.location = location;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> location;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.location = location;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;Address&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;location=&#x27;&quot;</span> + location + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>   修改Person类中重写的Clone()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   &gt;<span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"> Person person = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line"> person.address = (Address) <span class="keyword">this</span>.address.clone();</span><br><span class="line"> <span class="keyword">return</span> person;</span><br><span class="line">    <span class="comment">//return super.clone();</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">   com.joey.object.Person@1b6d3586</span></span><br><span class="line"><span class="comment">com.joey.object.Person@4554617c</span></span><br><span class="line"><span class="comment">**********************复制后************************</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey,地址：Address&#123;location=&#x27;杭州西湖&#x27;&#125;</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey,地址：Address&#123;location=&#x27;杭州西湖&#x27;&#125;</span></span><br><span class="line"><span class="comment">*****************修改person1中的age和name*************</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey,地址：Address&#123;location=&#x27;杭州西湖&#x27;&#125;</span></span><br><span class="line"><span class="comment">年龄：24,姓名：方陈勇,地址：Address&#123;location=&#x27;杭州西湖&#x27;&#125;</span></span><br><span class="line"><span class="comment">*****************修改person1中的age和name*************</span></span><br><span class="line"><span class="comment">年龄：18,姓名：joey,地址：Address&#123;location=&#x27;杭州西湖&#x27;&#125;</span></span><br><span class="line"><span class="comment">年龄：24,姓名：方陈勇,地址：Address&#123;location=&#x27;杭州滨江&#x27;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>结论三：可以看到最后person的address内容也没有改变。也就是说，当一个类里有很多引用类型时，如果想实现深拷贝那就得将每个引用类型都实现Cloneable接口重写一下clone()方法，比较麻烦的。可能好奇为什么String为什么没有影响，因为String是不可变的，相当于重新new了一个String。</strong></p><p><strong>所以，对于很多引用类型，可以使用序列化对象的方式进行深拷贝。</strong></p></blockquote></li><li><p>equals(Object obj)</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接判断的是引用，若想判断内容是否相同，需要重写此方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure><p> 常见问题：equals()和==的比较</p><ul><li>equals()用于引用类型的比较，如果引用类型没有重写equals()方法，调用的就是Object类中的equals()，比较的是地址值。</li><li>==用于在基本数据类型和引用数据类型的比较。如果是基本数据类型，比较的是内容，如果是引用数据类型，那比较的就是地址值。</li></ul><p> 哪些类重写了equals()方法</p><ul><li>String</li><li>Date</li><li>File</li><li>包装类</li><li>…</li></ul><p> 如何重写equals方法</p><blockquote><p>equals()方法里面提到了四个原则：</p><ol><li>自反性reflexive，a.equals(a) == true</li><li>对称性symmetric，a.equals(b) == b.equals(a)</li><li>传递性transitive，当a.equals(b) == true且b.equals(c) == true时，a.equals(c) == true</li><li>一致性consistent，当equals实现不变时，a.equals(b)返回值永远不变</li></ol><p>例如String中的equals()，重写判断的是内容相等，hashCode()方法也重写了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p> <strong>注意：重写equals()方法，需要重写hashCode()</strong></p></li><li><p>finalize()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>finalize的原理</p><p>（1）对象在初始化的过程中会判断是否重写了finalize，方法是判断两个字段标志has_finalizer_flag和RegisterFinalizersAtInit。</p><p>（2）如果重写了finalize，那就把当前对象注册到FinalizerThread的ReferenceQueue队列中。注册之后的对象就叫做Finalizer。方法是调用register_finalizer函数。此时java虚拟机一看当前有这个对象的引用，于是就不进行垃圾回收了。</p><p>（3）对象开始被调用，FinalizerThread线程负责从ReferenceQueue队列中获取Finalizer对象。开始执行finalize方法，在执行之前，这个对象一直在堆中。</p><p>（4）对象执行完毕之后，将这个Finalizer对象从队列中移除，java虚拟机一看对象没有引用了，就进行垃圾回收了。</p><p>这就是整个过程。不过在这里我们主要看的是finalize方法对垃圾回收的影响，其实就是在第三步，也就是这个对象含有finalize，进入了队列但一直没有被调用的这段时间，会一直占用内存。</p></blockquote><p> <strong>注意：应该避免使用finalize()方法，可能会导致内存溢出。</strong></p></li><li><p>getClass()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回此Object运行时类类型，final修饰不可重写，一般和getName()联合使用，如getName().getClass().</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p> getClass()返回调用对象的包名+类名，jvm可以根据这个唯一定位一个类</p></li><li><p>hashCode()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回对象的哈希码值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p> 这里存在一种情况，重写了equals()方法没有重写，两个对象的内容确实相等了。但是，地址值还是不一样。</p><p> 比如String类中，String a = “a”;String b = new String(“a”); a在字符串常量池中，b在堆中，地址值不一样。比如在使用集合Set或者其他一些需要唯一性判断的地方，内容相等其实就是相等，但是有两个地址值，可能会造成重复。</p><p> 所以说重写equals()方法同时也要注意重写hashCode()方法</p></li><li><p>toString()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回了Object对象的全限定类名+@+16进制表示的物理地址，它建议所有的子类都重写该方法，以致于可以打印出关键信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p>notify()</p></li><li><p>notifyAll()</p></li><li><p>wait()</p></li><li><p>wait(long timeout)</p></li><li><p>wait(long timeout, int nanos)</p></li></ol><p>到线程再看这几个……</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 源码 </category>
          
          <category> Object </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码 </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 安装FastDFS+nginx</title>
      <link href="/2019/08/14/Linux-install_FastDFS+Nginx/"/>
      <url>/2019/08/14/Linux-install_FastDFS+Nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS7-安装FastDFS-nginx"><a href="#CentOS7-安装FastDFS-nginx" class="headerlink" title="CentOS7 安装FastDFS+nginx"></a>CentOS7 安装FastDFS+nginx</h2><h4 id="1-先查看有没有安装gcc，FastDFS是C语言开发，编译依赖gcc环境"><a href="#1-先查看有没有安装gcc，FastDFS是C语言开发，编译依赖gcc环境" class="headerlink" title="1.  先查看有没有安装gcc，FastDFS是C语言开发，编译依赖gcc环境"></a>1.  先查看有没有安装gcc，FastDFS是C语言开发，编译依赖gcc环境</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# gcc -v</span><br><span class="line">bash: gcc: 未找到命令...</span><br><span class="line"><span class="meta">#</span><span class="bash">安装gcc、libevent、perl</span></span><br><span class="line">[root@root ~]# yum install gcc-c++</span><br><span class="line">[root@root ~]# yum -y install libevent</span><br><span class="line">[root@root ~]# yum install perl</span><br></pre></td></tr></table></figure><h4 id="2-解压libfastcommon"><a href="#2-解压libfastcommon" class="headerlink" title="2.  解压libfastcommon"></a>2.  解压libfastcommon</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root opt]# cd fastDFS/</span><br><span class="line">[root@root fastDFS]# ls</span><br><span class="line">fastdfs-nginx-module_v1.16.tar.gz  FastDFS_v5.05.tar.gz  libfastcommonV1.0.7.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">解压libfastcommon</span></span><br><span class="line">[root@root fastDFS]# tar -zxvf libfastcommonV1.0.7.tar.gz </span><br><span class="line">[root@root fastDFS]# cd libfastcommon-1.0.7/</span><br><span class="line">[root@root libfastcommon-1.0.7]# ls</span><br><span class="line">HISTORY  INSTALL  libfastcommon.spec  make.sh  README  src</span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line">[root@root libfastcommon-1.0.7]# ./make.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">[root@root libfastcommon-1.0.7]# ./make.sh install</span><br><span class="line">mkdir -p /usr/lib64</span><br><span class="line">install -m 755 libfastcommon.so /usr/lib64</span><br><span class="line">mkdir -p /usr/include/fastcommon</span><br><span class="line">install -m 644 common_define.h hash.h chain.h logger.h base64.h shared_func.h pthread_func.h ini_file_reader.h _os_bits.h sockopt.h sched_thread.h http_func.h md5.h local_ip_func.h avl_tree.h ioevent.h ioevent_loop.h fast_task_queue.h fast_timer.h process_ctrl.h fast_mblock.h connection_pool.h /usr/include/fastcommon</span><br><span class="line">[root@root lib64]# cd /usr/lib64</span><br><span class="line">[root@root lib64]# ls libfastcommon.*</span><br><span class="line">libfastcommon.so</span><br><span class="line"><span class="meta">#</span><span class="bash">拷贝到32位环境中</span></span><br><span class="line">[root@root lib64]# cp libfastcommon.so /usr/lib</span><br><span class="line">[root@root lib64]# cd /usr/lib</span><br><span class="line">[root@root lib]# ls libfastcommon.*</span><br><span class="line">libfastcommon.so</span><br></pre></td></tr></table></figure><h4 id="3-安装FastDFS"><a href="#3-安装FastDFS" class="headerlink" title="3.安装FastDFS"></a>3.安装FastDFS</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">[root@root fastDFS]# tar -zxvf FastDFS_v5.05.tar.gz </span><br><span class="line">[root@root fastDFS]# cd FastDFS/</span><br><span class="line">[root@root FastDFS]# ls</span><br><span class="line">client  conf             fastdfs.spec  init.d   make.sh     README.md   stop.sh  test</span><br><span class="line">common  COPYING-3_0.txt  HISTORY       INSTALL  php_client  restart.sh  storage  tracker</span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line">[root@root FastDFS]# ./make.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">[root@root FastDFS]# ./make.sh install</span><br></pre></td></tr></table></figure><h4 id="4-配置tracker节点"><a href="#4-配置tracker节点" class="headerlink" title="4.  配置tracker节点"></a>4.  配置tracker节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root FastDFS]# cd conf/</span><br><span class="line">[root@root conf]# ls</span><br><span class="line">anti-steal.jpg  client.conf  http.conf  mime.types  storage.conf  storage_ids.conf  tracker.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">拷贝所有配置文件到 /etc/fdfs目录下</span></span><br><span class="line">[root@root conf]# cp * /etc/fdfs/</span><br><span class="line">[root@root conf]# cd /etc/fdfs/</span><br><span class="line">[root@root fdfs]# ls</span><br><span class="line">anti-steal.jpg  client.conf.sample  mime.types    storage.conf.sample  tracker.conf</span><br><span class="line">client.conf     http.conf           storage.conf  storage_ids.conf     tracker.conf.sample</span><br><span class="line"><span class="meta">#</span><span class="bash">修改tracker配置文件修改存储和日志路径</span></span><br><span class="line">[root@root fdfs]# vim tracker.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> the base path to store data and <span class="built_in">log</span> files</span></span><br><span class="line">base_path=/fastdfs/tracker</span><br><span class="line"><span class="meta">#</span><span class="bash">创建存储路径，顺带创建storage和client存储路径</span></span><br><span class="line">[root@root /]# mkdir /fastdfs/tracker -p</span><br><span class="line">[root@root fastdfs]# mkdir storage</span><br><span class="line">[root@root fastdfs]# mkdir client</span><br><span class="line"><span class="meta">#</span><span class="bash">进入usr/bin文件夹，以/etc/fdfs/tracker.conf配置文件启动tracker</span></span><br><span class="line">[root@root bin]# /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start</span><br><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">[root@root bin]# /usr/bin/fdfs_trackerd fdfs_trackerd /etc/fdfs/tracker.conf restart</span><br></pre></td></tr></table></figure><h4 id="5-配置storage节点"><a href="#5-配置storage节点" class="headerlink" title="5. 配置storage节点"></a>5. 配置storage节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root bin]# cd /etc/fdfs/</span><br><span class="line"><span class="meta">#</span><span class="bash">编辑storage配置文件，修改以下配置</span></span><br><span class="line">[root@root fdfs]# vim storage.conf</span><br><span class="line">group_name=joey   #组名，可根据实际情况修改，</span><br><span class="line">base_path=/fastdfs/storage #设置storage数据文件和日志目录，需预先创建</span><br><span class="line">store_path0=/fastdfs/storage #存储路径</span><br><span class="line">tracker_server=192.168.116.145:22122 # #tracker 服务器的 IP地址和端口号，如果是单机搭建，IP不要写127.0.0.1，否则启动不成功。</span><br><span class="line"><span class="meta">#</span><span class="bash">启动storage</span></span><br><span class="line">[root@root bin]# /usr/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">重启storage</span></span><br><span class="line">[root@root bin]# /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart</span><br></pre></td></tr></table></figure><h4 id="6-配置client"><a href="#6-配置client" class="headerlink" title="6. 配置client"></a>6. 配置client</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编辑client，修改存储路径和tracker_server为本机IP</span></span><br><span class="line">[root@root fdfs]# vim client.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> the base path to store <span class="built_in">log</span> files</span></span><br><span class="line">base_path=/fastdfs/client</span><br><span class="line"><span class="meta">#</span><span class="bash"> tracker_server can ocur more than once, and tracker_server format is</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  <span class="string">&quot;host:port&quot;</span>, host can be hostname or ip address</span></span><br><span class="line">tracker_server=192.168.1.20:22122</span><br></pre></td></tr></table></figure><h4 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. 测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root home]# /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/guanli.png </span><br><span class="line">This is FastDFS client test program v5.05</span><br><span class="line"></span><br><span class="line">Copyright (C) 2008, Happy Fish / YuQing</span><br><span class="line"></span><br><span class="line">FastDFS may be copied only under the terms of the GNU General</span><br><span class="line">Public License V3, which may be found in the FastDFS source kit.</span><br><span class="line">Please visit the FastDFS Home Page http://www.csource.org/ </span><br><span class="line">for more detail.</span><br><span class="line"></span><br><span class="line">[2019-08-14 15:55:42] DEBUG - base_path=/fastdfs/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0</span><br><span class="line"></span><br><span class="line">tracker_query_storage_store_list_without_group: </span><br><span class="line">server 1. group_name=, ip_addr=192.168.1.20, port=23000</span><br><span class="line"></span><br><span class="line">group_name=joey, ip_addr=192.168.1.20, port=23000</span><br><span class="line">storage_upload_by_filename</span><br><span class="line">group_name=joey, remote_filename=M00/00/00/wKgBFF1Tvn6AL_ulAAhuqKakO_M091.png</span><br><span class="line">source ip address: 192.168.1.20</span><br><span class="line">file timestamp=2019-08-14 15:55:42</span><br><span class="line">file size=552616</span><br><span class="line">file crc32=2795781107</span><br><span class="line">example file url: http://192.168.1.20/joey/M00/00/00/wKgBFF1Tvn6AL_ulAAhuqKakO_M091.png</span><br><span class="line">storage_upload_slave_by_filename</span><br><span class="line">group_name=joey, remote_filename=M00/00/00/wKgBFF1Tvn6AL_ulAAhuqKakO_M091_big.png</span><br><span class="line">source ip address: 192.168.1.20</span><br><span class="line">file timestamp=2019-08-14 15:55:42</span><br><span class="line">file size=552616</span><br><span class="line">file crc32=2795781107</span><br><span class="line">example file url: http://192.168.1.20/joey/M00/00/00/wKgBFF1Tvn6AL_ulAAhuqKakO_M091_big.png</span><br><span class="line"><span class="meta">#</span><span class="bash">返回链接就是成功了，但是还是访问不了，需要安装nginx服务器</span></span><br></pre></td></tr></table></figure><h4 id="8-安装nginx"><a href="#8-安装nginx" class="headerlink" title="8.  安装nginx"></a>8.  安装nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">解压安装fastdfs-nginx-module</span></span><br><span class="line">[root@root fastDFS]# tar -zxvf fastdfs-nginx-module_v1.16.tar.gz </span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑 Nginx 模块的配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制配置文件至/etc/fdfs/，编辑config文件删除路径中的<span class="built_in">local</span></span></span><br><span class="line">[root@root src]# cp * /etc/fdfs/</span><br><span class="line">[root@root src]# vim /fastdfs-nginx-module/src/config</span><br><span class="line">ngx_addon_name=ngx_http_fastdfs_module</span><br><span class="line">HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_fastdfs_module&quot;</span><br><span class="line">NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_fastdfs_module.c&quot;</span><br><span class="line">CORE_INCS=&quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/&quot;</span><br><span class="line">CORE_LIBS=&quot;$CORE_LIBS -L/usr/lib -lfastcommon -lfdfsclient&quot;</span><br><span class="line">CFLAGS=&quot;$CFLAGS -D_FILE_OFFSET_BITS=64 -DFDFS_OUTPUT_CHUNK_SIZE=&#x27;256*1024&#x27; -DFDFS_MOD_CONF_FILENAME=&#x27;\&quot;/etc/fdfs/mod_fastdfs.conf\&quot;&#x27;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">安装nginx依赖</span></span><br><span class="line">[root@root fastDFS]# yum install -y pcre pcre-devel</span><br><span class="line">[root@root fastDFS]# yum install -y zlib zlib-devel</span><br><span class="line">[root@root fastDFS]# yum install -y openssl openssl-devel</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压nginx wget http://nginx.org/download/nginx-1.8.0.tar.gz</span></span><br><span class="line">[root@root fastDFS]# tar -zxvf nginx-1.8.0.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">nginx配置记得修改最后的module路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash">复制粘贴在nginx目录下执行</span></span><br><span class="line">[root@root nginx-1.8.0]# ./configure \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --prefix=/usr/<span class="built_in">local</span>/nginx \</span></span><br><span class="line"><span class="bash">&gt; --pid-path=/var/<span class="built_in">local</span>/nginx/nginx.pid \</span></span><br><span class="line"><span class="bash">&gt; --lock-path=/var/lock/nginx/nginx.lock \</span></span><br><span class="line"><span class="bash">&gt; --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log \</span></span><br><span class="line"><span class="bash">&gt; --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log \</span></span><br><span class="line"><span class="bash">&gt; --with-http_gzip_static_module \</span></span><br><span class="line"><span class="bash">&gt; --http-client-body-temp-path=/var/temp/nginx/client \</span></span><br><span class="line"><span class="bash">&gt; --http-proxy-temp-path=/var/temp/nginx/proxy \</span></span><br><span class="line"><span class="bash">&gt; --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span></span><br><span class="line"><span class="bash">&gt; --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span></span><br><span class="line"><span class="bash">&gt; --http-scgi-temp-path=/var/temp/nginx/scgi \</span></span><br><span class="line"><span class="bash">&gt; --add-module=/opt/fastDFS/fastdfs-nginx-module/src</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line">[root@root nginx-1.8.0]# make</span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">[root@root nginx-1.8.0]# make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看安装文件</span></span><br><span class="line">[root@root nginx-1.8.0]# cd /usr/local/</span><br><span class="line">[root@root local]# ls</span><br><span class="line">bin  etc  games  include  lib  lib64  libexec  nginx  sbin  share  src</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">复制粘贴配置文件</span></span><br><span class="line">[root@root local]# cd /opt/fastDFS/fastdfs-nginx-module/src/</span><br><span class="line">[root@root src]# ls</span><br><span class="line">common.c  common.h  config  mod_fastdfs.conf  ngx_http_fastdfs_module.c</span><br><span class="line">[root@root src]# cp mod_fastdfs.conf /etc/fdfs/</span><br><span class="line">[root@root src]# vim /etc/fdfs/mod_fastdfs.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">修改日志存储路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the base path to store <span class="built_in">log</span> files</span></span><br><span class="line">base_path=/fastdfs/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash">修改tracker路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FastDFS tracker_server can ocur more than once, and tracker_server format is</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  <span class="string">&quot;host:port&quot;</span>, host can be hostname or ip address</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> valid only when load_fdfs_parameters_from_tracker is <span class="literal">true</span></span></span><br><span class="line">tracker_server=192.168.1.20:22122</span><br><span class="line"><span class="meta">#</span><span class="bash"> the group name of the <span class="built_in">local</span> storage server</span></span><br><span class="line">group_name=joey</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> the url / uri including the group name</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> to <span class="literal">false</span> when uri like /M00/00/00/xxx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> to <span class="literal">true</span> when uri like <span class="variable">$&#123;group_name&#125;</span>/M00/00/00/xxx, such as group1/M00/xxx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> default value is <span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> store_path<span class="comment">#, based 0, if store_path0 not exists, it&#x27;s value is base_path</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the paths must be exist</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> must same as storage.conf</span></span><br><span class="line">store_path0=/fastdfs/storage</span><br><span class="line"><span class="meta">#</span><span class="bash">store_path1=/home/yuqing/fastdfs1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">编辑配置文件添加下面这段，注意nginx使用的配置文件是哪个，/usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span></span><br><span class="line">[root@root conf]# vim nginx.conf</span><br><span class="line">        server &#123;</span><br><span class="line">            listen       88;</span><br><span class="line">            server_name  192.168.1.20 ;</span><br><span class="line"></span><br><span class="line">            location / &#123;</span><br><span class="line">                nginx_fastdfs_module;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">检查</span></span><br><span class="line">[root@root conf]cd /usr/local/nginx/sbin/</span><br><span class="line">[root@root sbin]# ./nginx -t</span><br><span class="line">ngx_http_fastdfs_set pid=33746</span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: [emerg] mkdir() &quot;/var/temp/nginx/client&quot; failed (2: No such file or directory)</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test failed</span><br><span class="line"><span class="meta">#</span><span class="bash">[emerg] mkdir() <span class="string">&quot;/var/temp/nginx/client&quot;</span> failed (2: No such file or directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">报错显示没有目录/var/temp/nginx/client</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">去创建目录</span></span><br><span class="line">[root@root sbin]# mkdir /var/temp/nginx -p</span><br><span class="line"><span class="meta">#</span><span class="bash">再次检查</span></span><br><span class="line">[root@root sbin]# ./nginx -t</span><br><span class="line">ngx_http_fastdfs_set pid=33766</span><br><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">检查失败，访问失败，去查看防火墙状态：active (running)</span></span><br><span class="line">[root@root sbin]# sudo systemctl status firewalld</span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 三 2019-08-14 11:34:40 CST; 5h 51min ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line"> Main PID: 771 (firewalld)</span><br><span class="line">    Tasks: 2</span><br><span class="line">   CGroup: /system.slice/firewalld.service</span><br><span class="line">           └─771 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line"></span><br><span class="line">8月 14 11:34:38 root systemd[1]: Starting firewalld - dynamic firewall daemon...</span><br><span class="line">8月 14 11:34:40 root systemd[1]: Started firewalld - dynamic firewall daemon.</span><br><span class="line"><span class="meta">#</span><span class="bash">暂时关闭防火墙，下次重启会失效或者<span class="built_in">disable</span>掉</span></span><br><span class="line">[root@root sbin]# sudo systemctl stop firewalld</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190814172907.png" alt="访问nginx成功"></p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190814173428.png" alt="访问图片失败"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置</span></span><br><span class="line">[root@root fdfs]# vim mod_fastdfs.conf </span><br><span class="line"><span class="meta">#</span><span class="bash"> store_path<span class="comment">#, based 0, if store_path0 not exists, it&#x27;s value is base_path</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the paths must be exist</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> must same as storage.conf</span></span><br><span class="line">store_path0=/fastdfs/storage</span><br><span class="line"><span class="meta">#</span><span class="bash">store_path1=/home/yuqing/fastdfs1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">重启所有服务</span></span><br><span class="line">[root@root fdfs]# /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart</span><br><span class="line">waiting for pid [28338] exit ...</span><br><span class="line">starting ...</span><br><span class="line">[root@root fdfs]# /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart</span><br><span class="line">waiting for pid [28841] exit ...</span><br><span class="line">starting ...</span><br><span class="line">[root@root fdfs]# cd /usr/local/nginx/sbin/</span><br><span class="line">[root@root sbin]# ./nginx -s reload</span><br><span class="line">ngx_http_fastdfs_set pid=34197</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190814174007.png" alt="图片访问成功"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> FastDFS </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> FastDFS </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理财产品系统（慕课网）</title>
      <link href="/2019/07/29/%E9%A1%B9%E7%9B%AE-%E7%90%86%E8%B4%A2%E4%BA%A7%E5%93%81%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/29/%E9%A1%B9%E7%9B%AE-%E7%90%86%E8%B4%A2%E4%BA%A7%E5%93%81%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="理财产品系统（慕课网）"><a href="#理财产品系统（慕课网）" class="headerlink" title="理财产品系统（慕课网）"></a><a href="https://coding.imooc.com/class/211.html">理财产品系统（慕课网）</a></h1><p>junit、swagger、JSON-RPC、MySql、hazelcast、HTTPS、RSA签名、权限控制、节流限速、访问统计、TYK</p><p>快速：</p><ol><li>开发快</li><li>迭代快</li></ol><p>高效：</p><ol><li>高并发 </li><li>响应快</li></ol><p>安全：</p><ol><li>加密</li><li>权限</li></ol><p>模块化开发：</p><ol><li>Manager</li><li>Seller</li><li>Entity</li><li>Api</li><li>Util</li><li>Quartz</li><li>Swagger</li></ol><p>数据库设计：</p><ul><li><p>产品表</p><table><thead><tr><th>表名</th><th>product</th><th>表名中文</th><th>产品表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>id</td><td>编号</td><td>varchar</td><td>50</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>name</td><td>名称</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td></td></tr><tr><td>3</td><td>threshold_amount</td><td>起投金额</td><td>decimal</td><td>15,4</td><td></td><td>M</td><td>0</td><td></td></tr><tr><td>4</td><td>step_amount</td><td>投资步长</td><td>decimal</td><td>15,4</td><td></td><td>N</td><td>0</td><td></td></tr><tr><td>5</td><td>lock_term</td><td>锁定期</td><td>smallint</td><td></td><td></td><td>N</td><td>0</td><td>单位天</td></tr><tr><td>6</td><td>reward_rate</td><td>收益率</td><td>decimal</td><td>5,4</td><td></td><td>N</td><td></td><td>0-100，百分比</td></tr><tr><td>7</td><td>status</td><td>状态</td><td>varchar</td><td>20</td><td></td><td>N</td><td></td><td>审核中：Audinting，销售中：In_Sell，暂停销售：Locked，已结束：Finished</td></tr><tr><td>8</td><td>memo</td><td>备注</td><td>varchar</td><td>200</td><td></td><td>N</td><td></td><td></td></tr><tr><td>9</td><td>create_at</td><td>创建时间</td><td>datetime</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td>create_user</td><td>创建者ID</td><td>varchar</td><td>20</td><td></td><td></td><td></td><td></td></tr><tr><td>11</td><td>update_at</td><td>更新时间</td><td>datetime</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>12</td><td>update_user</td><td>更新者ID</td><td>varchar</td><td>20</td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>订单表</p><table><thead><tr><th>表名</th><th>order_t</th><th>表名中文</th><th>订单表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No</td><td>列名</td><td>列名中文</td><td>类型</td><td>长度</td><td>Key</td><td>Null</td><td>默认值</td><td>备注</td></tr><tr><td>1</td><td>order_id</td><td>订单编号</td><td>varchar</td><td>50</td><td>Y</td><td>N</td><td></td><td></td></tr><tr><td>2</td><td>chan_id</td><td>渠道编号</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>套壳公司编号</td></tr><tr><td>3</td><td>product_id</td><td>产品编号</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td></td></tr><tr><td>4</td><td>chan_user_id</td><td>用户编号</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>套壳公司的用户编号</td></tr><tr><td>5</td><td>order_type</td><td>订单类型</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>申购：Apply，赎回：Redeem</td></tr><tr><td>6</td><td>order_status</td><td>订单状态</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>初始化：Init，处理中：Process，成功：Success，失败：Fail</td></tr><tr><td>7</td><td>outer_order_id</td><td>外部订单编号</td><td>varchar</td><td>50</td><td></td><td>N</td><td></td><td>套壳公司的订单编号</td></tr><tr><td>8</td><td>amount</td><td>订单金额</td><td>decimal</td><td>15，4</td><td></td><td>N</td><td></td><td></td></tr><tr><td>9</td><td>memo</td><td>备注</td><td>varchar</td><td>200</td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td>create_at</td><td>创建时间</td><td>datetime</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>11</td><td>update_at</td><td>更新时间</td><td>datetime</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>创建项目添加依赖</p><p>SpringBoot    1.5.4 Release</p><p>spring-boot-starter-web</p><p>Spring-boot-starter-data-jpa</p><p>commons-lang3    3.5</p><p>mysql-connector-java    5.1.29</p><p>spring-boot-starter-test</p></li><li><p>创建每个模块</p><ol><li>Manager</li><li>Seller</li><li>Entity</li><li>Api</li><li>Util</li><li>Quartz</li><li>Swagger</li></ol></li><li><p>创建Entity实体类</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate各种主键生成策略与配置详解（转自[starskyhu])</title>
      <link href="/2019/07/26/ORM-Hibernate-Hibernate%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
      <url>/2019/07/26/ORM-Hibernate-Hibernate%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Hibernate各种主键生成策略与配置详解（转自-starskyhu"><a href="#Hibernate各种主键生成策略与配置详解（转自-starskyhu" class="headerlink" title="Hibernate各种主键生成策略与配置详解（转自[starskyhu])"></a><a href="https://www.cnblogs.com/hoobey/p/5508992.html"><strong>Hibernate各种主键生成策略与配置详解（转自[starskyhu])</strong></a></h2><blockquote><p>在项目中使用Hibernate+Oracle，在是生成GUID时遇到问题，查询解决后记录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GenericGenerator(name = &quot;generator&quot;, strategy = &quot;uuid.hex&quot;)</span></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(generator = &quot;generator&quot;)</span></span><br><span class="line"><span class="meta">@Column(name = &quot;ID&quot;, unique = true, nullable = false, length = 36)</span></span><br><span class="line"><span class="keyword">private</span> String ID;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1、assigned"><a href="#1、assigned" class="headerlink" title="1、assigned"></a><strong>1、assigned</strong></h3><p>主键由外部程序负责生成，在 save() 之前必须指定一个。Hibernate不负责维护主键生成。与Hibernate和底层数据库都无关，可以跨数据库。在存储对象前，必须要使用主键的setter方法给主键赋值，至于这个值怎么生成，完全由自己决定，这种方法应该尽量避免。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;assigned&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>“ud”是自定义的策略名，人为起的名字，后面均用“ud”表示。</p><p><strong>特点：可以跨数据库，人为控制主键生成，应尽量避免。</strong></p><h3 id="2、increment"><a href="#2、increment" class="headerlink" title="2、increment"></a><strong>2、increment</strong></h3><p>由Hibernate从数据库中取出主键的最大值（每个session只取1次），以该值为基础，每次增量为1，在内存中生成主键，不依赖于底层的数据库，因此可以跨数据库。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;increment&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Hibernate调用org.hibernate.id.IncrementGenerator类里面的generate()方法，使用select max(idColumnName) from tableName语句获取主键最大值。该方法被声明成了synchronized，所以在一个独立的Java虚拟机内部是没有问题的，然而，在多个JVM同时并发访问数据库select max时就可能取出相同的值，再insert就会发生Dumplicate entry的错误。所以只能有一个Hibernate应用进程访问数据库，否则就可能产生主键冲突，所以不适合多进程并发更新数据库，适合单一进程访问数据库，不能用于群集环境。</p><p>官方文档：只有在没有其他进程往同一张表中插入数据时才能使用，在集群下不要使用。</p><p><strong>特点：跨数据库，不适合多进程并发更新数据库，适合单一进程访问数据库，不能用于群集环境。</strong></p><h3 id="3、hilo"><a href="#3、hilo" class="headerlink" title="3、hilo"></a><strong>3、hilo</strong></h3><p>hilo（高低位方式high low）是hibernate中最常用的一种生成方式，需要一张额外的表保存hi的值。保存hi值的表至少有一条记录（只与第一条记录有关），否则会出现错误。<strong>可以跨数据库。</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;hilo&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;table&quot;</span>&gt;</span>hibernate_hilo<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;column&quot;</span>&gt;</span>next_hi<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_lo&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;table&quot;</span>&gt;</span>hibernate_hilo<span class="tag">&lt;/<span class="name">param</span>&gt;</span> 指定保存hi值的表名</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;column&quot;</span>&gt;</span>next_hi<span class="tag">&lt;/<span class="name">param</span>&gt;</span> 指定保存hi值的列名</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_lo&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">param</span>&gt;</span> 指定低位的最大值</span><br></pre></td></tr></table></figure><p>也可以省略table和column配置，其默认的表为hibernate_unique_key，列为next_hi</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;hilo&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_lo&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hilo生成器生成主键的过程（以hibernate_unique_key表，next_hi列为例）：</p><ol><li><p>获得hi值：读取并记录数据库的hibernate_unique_key表中next_hi字段的值，数据库中此字段值加1保存。</p></li><li><p>获得lo值：从0到max_lo循环取值，差值为1，当值为max_lo值时，重新获取hi值，然后lo值继续从0到max_lo循环。</p></li><li><p>根据公式 hi * (max_lo + 1) + lo计算生成主键值。</p></li></ol><p>注意：当hi值是0的时候，那么第一个值不是0*(max_lo+1)+0=0，而是lo跳过0从1开始，直接是1、2、3……</p><p>那max_lo配置多大合适呢？</p><p>这要根据具体情况而定，如果系统一般不重启，而且需要用此表建立大量的主键，可以吧max_lo配置大一点，这样可以减少读取数据表的次数，提高效率；反之，如果服务器经常重启，可以吧max_lo配置小一点，可以避免每次重启主键之间的间隔太大，造成主键值主键不连贯。</p><p><strong>特点：跨数据库，hilo算法生成的标志只能在一个数据库中保证唯一。</strong></p><h3 id="4、seqhilo"><a href="#4、seqhilo" class="headerlink" title="4、seqhilo"></a><strong>4、seqhilo</strong></h3><p>与hilo类似，通过hi/lo算法实现的主键生成机制，只是将hilo中的数据表换成了序列sequence，需要数据库中先创建sequence，适用于支持sequence的数据库，如Oracle。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;seqhilo&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sequence&quot;</span>&gt;</span>hibernate_seq<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_lo&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>特点：与hilo类似，只能在支持序列的数据库中使用。</strong></p><h3 id="5、sequence"><a href="#5、sequence" class="headerlink" title="5、sequence"></a><strong>5、sequence</strong></h3><p>采用数据库提供的sequence机制生成主键，需要数据库支持sequence。如oralce、DB、SAP DB、PostgerSQL、McKoi中的sequence。MySQL这种不支持sequence的数据库则不行（可以使用identity）。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;sequence&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sequence&quot;</span>&gt;</span>hibernate_id<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sequence&quot;</span>&gt;</span>hibernate_id<span class="tag">&lt;/<span class="name">param</span>&gt;</span> 指定sequence的名称**</span><br></pre></td></tr></table></figure><p>Hibernate生成主键时，查找sequence并赋给主键值，主键值由数据库生成，Hibernate不负责维护，使用时必须先创建一个sequence，如果不指定sequence名称，则使用Hibernate默认的sequence，名称为hibernate_sequence，前提要在数据库中创建该sequence。</p><p><strong>特点：只能在支持序列的数据库中使用，如Oracle。</strong></p><h3 id="6、identity"><a href="#6、identity" class="headerlink" title="6、identity"></a><strong>6、identity</strong></h3><p>identity由底层数据库生成标识符。identity是由数据库自己生成的，但这个主键必须设置为自增长，使用identity的前提条件是底层数据库支持自动增长字段类型，如DB2、SQL Server、MySQL、Sybase和HypersonicSQL等，Oracle这类没有自增字段的则不支持。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例：如果使用MySQL数据库，则主键字段必须设置成auto_increment。</p><p>id int(11) primary key auto_increment</p><p><strong>特点：只能用在支持自动增长的字段数据库中使用，如MySQL。</strong></p><h3 id="7、native"><a href="#7、native" class="headerlink" title="7、native"></a><strong>7、native</strong></h3><p>native由hibernate根据使用的数据库自行判断采用identity、hilo、sequence其中一种作为主键生成方式，灵活性很强。如果能支持identity则使用identity，如果支持sequence则使用sequence。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如MySQL使用identity，Oracle使用sequence</p><p>注意：如果Hibernate自动选择sequence或者hilo，则所有的表的主键都会从Hibernate默认的sequence或hilo表中取。并且，有的数据库对于默认情况主键生成测试的支持，效率并不是很高。</p><p>使用sequence或hilo时，可以加入参数，指定sequence名称或hi值表名称等，如</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sequence&quot;</span>&gt;</span>hibernate_id<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>特点：根据数据库自动选择，项目中如果用到多个数据库时，可以使用这种方式，使用时需要设置表的自增字段或建立序列，建立表等。</strong></p><p><strong>8、uuid</strong></p><p>UUID：Universally Unique Identifier，是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字，标准的UUID格式为：</p><p><strong>xxxxxxxx-xxxx-xxxx-xxxxxx-xxxxxxxxxx (8-4-4-4-12)</strong></p><p>其中每个 <strong>x</strong> 是 0-9 或 a-f 范围内的一个十六进制的数字。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;uuid&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Hibernate在保存对象时，生成一个UUID字符串作为主键，保证了唯一性，但其并无任何业务逻辑意义，只能作为主键，唯一缺点长度较大，32位（Hibernate将UUID中间的“-”删除了）的字符串，占用存储空间大，但是有两个很重要的优点，Hibernate在维护主键时，不用去数据库查询，从而提高效率，而且它是跨数据库的，以后切换数据库极其方便。</p><p><strong>特点：uuid长度大，占用空间大，跨数据库，不用访问数据库就生成主键值，所以效率高且能保证唯一性，移植非常方便，推荐使用。</strong></p><p><strong>9、guid</strong></p><p>GUID：Globally Unique Identifier全球唯一标识符，也称作 UUID，是一个128位长的数字，用16进制表示。算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成GUID。从理论上讲，如果一台机器每秒产生10000000个GUID，则可以保证（概率意义上）3240年不重复。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;guid&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Hibernate在维护主键时，先查询数据库，获得一个uuid字符串，该字符串就是主键值，该值唯一，缺点长度较大，支持数据库有限，优点同uuid，跨数据库，但是仍然需要访问数据库。</p><p><strong>注意：长度因数据库不同而不同</strong></p><p>MySQL中使用select uuid()语句获得的为36位（包含标准格式的“-”）</p><p>Oracle中，使用select rawtohex(sys_guid()) from dual语句获得的为32位（不包含“-”） </p><p><strong>特点：需要数据库支持查询uuid，生成时需要查询数据库，效率没有uuid高，推荐使用uuid。</strong></p><h3 id="10、foreign"><a href="#10、foreign" class="headerlink" title="10、foreign"></a><strong>10、foreign</strong></h3><p>使用另外一个相关联的对象的主键作为该对象主键。主要用于一对一关系中。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;foreign&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;property&quot;</span>&gt;</span>user<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;domain.User&quot;</span> <span class="attr">constrained</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>该例使用domain.User的主键作为本类映射的主键。</p><p><strong>特点：很少使用，大多用在一对一关系中。</strong></p><h3 id="11、select"><a href="#11、select" class="headerlink" title="11、select"></a><strong>11、select</strong></h3><p>使用触发器生成主键，主要用于早期的数据库主键生成机制，能用到的地方非常少。</p><h3 id="12、其他注释方式配置"><a href="#12、其他注释方式配置" class="headerlink" title="12、其他注释方式配置"></a><strong>12、其他注释方式配置</strong></h3><p>注释方式与配置文件底层实现方式相同，只是配置的方式换成了注释方式</p><p>自动增长，适用于支持自增字段的数据库</p><p><strong>@Id</strong></p><p><strong>@GeneratedValue(strategy = GenerationType.IDENTITY)</strong></p><p>根据底层数据库自动选择方式，需要底层数据库的设置</p><p>如MySQL，会使用自增字段，需要将主键设置成auto_increment。</p><p><strong>@Id</strong></p><p><strong>@GeneratedValue(strategy = GenerationType.AUTO)</strong></p><p>使用表存储生成的主键，可以跨数据库。</p><p>每次需要主键值时，查询名为**”hibernate_table”<strong>的表，查找主键列</strong>“gen_pk”<strong>值为</strong>“2”<strong>记录，得到这条记录的</strong>“gen_val”<strong>值，根据这个值，和</strong>allocationSize**的值生成主键值。</p><p><strong>@Id</strong></p><p><strong>@GeneratedValue(strategy = GenerationType.<em>TABLE</em>, generator = “ud”)</strong></p><p><strong>@TableGenerator(name = “ud”,</strong></p><p><strong>table = “hibernate_table”,</strong></p><p><strong>pkColumnName = “gen_pk”,</strong></p><p><strong>pkColumnValue = “2”,</strong></p><p><strong>valueColumnName = “gen_val”,</strong></p><p><strong>initialValue = 2,</strong></p><p><strong>allocationSize = 5)</strong></p><p>使用序列存储主键值</p><p><strong>@Id</strong></p><p><strong>@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = “ud”)</strong></p><p><strong>@SequenceGenerator(name = “ud”,</strong></p><p><strong>sequenceName = “hibernate_seq”,</strong></p><p><strong>allocationSize = 1,</strong></p><p><strong>initialValue = 2)</strong></p><h3 id="13、小结"><a href="#13、小结" class="headerlink" title="13、小结"></a><strong>13、小结</strong></h3><p><strong>1、为了保证对象标识符的唯一性与不可变性，应该让Hibernate来为主键赋值，而不是程序。</strong></p><p><strong>2、正常使用Hibernate维护主键，最好将主键的setter方法设置成private，从而避免人为或程序修改主键，而使用assigned方式，就不能用private，否则无法给主键赋值。</strong></p><p><strong>2、Hibernate中唯一一种最简单通用的主键生成器就是uuid。虽然是个32位难读的长字符串，但是它没有跨数据库的问题，将来切换数据库极其简单方便，推荐使用！</strong></p><p><strong>3、自动增长字段类型与序列</strong></p><table><thead><tr><th><strong>数据库</strong></th><th><strong>自动增长字段</strong></th><th><strong>序列</strong></th></tr></thead><tbody><tr><td><strong>MySQL</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>Oracle</strong></td><td></td><td><strong>是</strong></td></tr><tr><td><strong>DB2</strong></td><td><strong>是</strong></td><td><strong>是</strong></td></tr><tr><td><strong>MS SQL Server</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>Sybase</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>HypersonicSQL</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>PostgreSQL</strong></td><td></td><td><strong>是</strong></td></tr><tr><td><strong>SAP DB</strong></td><td></td><td><strong>是</strong></td></tr><tr><td><strong>HSQLDB</strong></td><td><strong>是</strong></td><td></td></tr><tr><td><strong>Infomix</strong></td><td><strong>是</strong></td><td></td></tr></tbody></table><p><strong>4、关于hilo机制注意：</strong></p><p><strong>hilo算法生成的标志只能在一个数据库中保证唯一。</strong></p><p><strong>当用户为Hibernate自行提供连接，或者Hibernate通过JTA，从应用服务器的数据源获取数据库连接时，无法使用hilo，因为这不能保证hilo单独在新的数据库连接的事务中访问hi值表，这种情况，如果数据库支持序列，可以使用seqhilo。</strong></p><p><strong>5、使用identity、native、GenerationType.AUTO等方式生成主键时，只要用到自增字段，数据库表的字段必须设置成自动增加的，否则出错。</strong></p><p><strong>6、还有一些方法未列出来，例如uuid.hex，sequence-identity等，这些方法不是很常用，且已被其他方法代替，如uuid.hex，官方文档里建议不使用，而直接使用uuid方法。</strong></p><p><strong>7、Hibernate的各版本主键生成策略配置有略微差别，但实现基本相同。如，有的版本默认sequence不指定序列名，则使用名为hibernate_sequence的序列，有的版本则必须指定序列名。</strong></p><p><strong>8、还可以自定义主键生成策略，这里暂时不讨论，只讨论官方自带生成策略。</strong> </p>]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
          <category> Hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ORM </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维码扫描下载APP页面</title>
      <link href="/2019/07/25/JS-%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E4%B8%8B%E8%BD%BDAPP/"/>
      <url>/2019/07/25/JS-%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E4%B8%8B%E8%BD%BDAPP/</url>
      
        <content type="html"><![CDATA[<h1 id="二维码扫描下载APP页面"><a href="#二维码扫描下载APP页面" class="headerlink" title="二维码扫描下载APP页面"></a>二维码扫描下载APP页面</h1><p><strong>将该页面链接转成二维码即可实现扫描同一个二维码下载苹果或者安卓APP</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>APP下载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">        /*</span><br><span class="line">         * 智能机浏览器版本信息:</span><br><span class="line">         *</span><br><span class="line">         */</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> browser = &#123;</span></span><br><span class="line"><span class="javascript">            versions: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> u = navigator.userAgent, app = navigator.appVersion;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;<span class="comment">//移动终端浏览器版本信息</span></span></span><br><span class="line"><span class="javascript">                    trident: u.indexOf(<span class="string">&#x27;Trident&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//IE内核</span></span></span><br><span class="line"><span class="javascript">                    presto: u.indexOf(<span class="string">&#x27;Presto&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//opera内核</span></span></span><br><span class="line"><span class="javascript">                    webKit: u.indexOf(<span class="string">&#x27;AppleWebKit&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//苹果、谷歌内核</span></span></span><br><span class="line"><span class="javascript">                    gecko: u.indexOf(<span class="string">&#x27;Gecko&#x27;</span>) &gt; -<span class="number">1</span> &amp;&amp; u.indexOf(<span class="string">&#x27;KHTML&#x27;</span>) == -<span class="number">1</span>, <span class="comment">//火狐内核</span></span></span><br><span class="line"><span class="javascript">                    mobile: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>) || !!u.match(<span class="regexp">/AppleWebKit/</span>), <span class="comment">//是否为移动终端</span></span></span><br><span class="line"><span class="javascript">                    ios: !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span></span><br><span class="line"><span class="javascript">                    android: u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//android终端或者uc浏览器</span></span></span><br><span class="line"><span class="javascript">                    iPhone: u.indexOf(<span class="string">&#x27;iPhone&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Mac&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否为iPhone或者QQHD浏览器</span></span></span><br><span class="line"><span class="javascript">                    iPad: u.indexOf(<span class="string">&#x27;iPad&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否iPad</span></span></span><br><span class="line"><span class="javascript">                    webApp: u.indexOf(<span class="string">&#x27;Safari&#x27;</span>) == -<span class="number">1</span> <span class="comment">//是否web应该程序，没有头部与底部</span></span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;(),</span><br><span class="line">            language: (navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (browser.versions.ios || browser.versions.iPhone || browser.versions.iPad) &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//  此处写ios的下载地址，从AppStore获取              </span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.location = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">else</span> <span class="keyword">if</span> (browser.versions.android) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 此处写Andoird 的下载地址               </span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.location = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">&quot;语言版本: &quot;</span> + browser.language);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">&quot; 是否为移动终端: &quot;</span> + browser.versions.mobile);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">&quot; ios终端: &quot;</span> + browser.versions.ios);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">&quot; android终端: &quot;</span> + browser.versions.android);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">&quot; 是否为iPhone: &quot;</span> + browser.versions.iPhone);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(<span class="string">&quot; 是否iPad: &quot;</span> + browser.versions.iPad);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.writeln(navigator.userAgent);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 二维码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.2安装ActiveMQ 5.14.5</title>
      <link href="/2019/07/23/Linux-install_ActiveMQ/"/>
      <url>/2019/07/23/Linux-install_ActiveMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-2安装ActiveMQ-5-14-5"><a href="#CentOS-7-2安装ActiveMQ-5-14-5" class="headerlink" title="CentOS 7.2安装ActiveMQ 5.14.5"></a>CentOS 7.2安装ActiveMQ 5.14.5</h2><h4 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos activemq]# wget http://apache.fayea.com/activemq/5.14.5/apache-activemq-5.14.5-bin.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E4%B8%8B%E8%BD%BD.png" alt="img"></p><blockquote><p>具体版本下载可进入<a href="http://apache.fayea.com/activemq/%E6%9F%A5%E7%9C%8B">http://apache.fayea.com/activemq/查看</a></p></blockquote><h4 id="2-解压压缩包"><a href="#2-解压压缩包" class="headerlink" title="2. 解压压缩包"></a>2. 解压压缩包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos activemq]# tar -zxvf apache-activemq-5.14.5-bin.tar.gz </span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E8%A7%A3%E5%8E%8B.png" alt="img"></p><h4 id="3-进入bin文件下的Linux文件下启动"><a href="#3-进入bin文件下的Linux文件下启动" class="headerlink" title="3. 进入bin文件下的Linux文件下启动"></a>3. 进入bin文件下的Linux文件下启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos activemq]# ls</span><br><span class="line">apache-activemq-5.14.5  apache-activemq-5.14.5-bin.tar.gz</span><br><span class="line">[root@VM_0_5_centos activemq]# cd apache-activemq-5.14.5/</span><br><span class="line">[root@VM_0_5_centos apache-activemq-5.14.5]# ls</span><br><span class="line">activemq-all-5.14.5.jar  conf  docs      lib      NOTICE      webapps</span><br><span class="line">bin                      data  examples  LICENSE  README.txt  webapps-demo</span><br><span class="line">[root@VM_0_5_centos apache-activemq-5.14.5]# cd bin/linux-x86-64/</span><br><span class="line">[root@VM_0_5_centos linux-x86-64]# ./activemq start</span><br><span class="line">Starting ActiveMQ Broker...</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E5%90%AF%E5%8A%A8.png" alt="img"></p><h4 id="4-查看启动状态"><a href="#4-查看启动状态" class="headerlink" title="4. 查看启动状态"></a>4. 查看启动状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">activemq未启动</span></span><br><span class="line">[root@VM_0_5_centos bin]# ps -ef|grep activemq</span><br><span class="line">root      2756 25178  0 16:44 pts/0    00:00:00 grep --color=auto activemq</span><br></pre></td></tr></table></figure><h4 id="5-查看启动日志，解决报错"><a href="#5-查看启动日志，解决报错" class="headerlink" title="5. 查看启动日志，解决报错"></a>5. 查看启动日志，解决报错</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos bin]# ./activemq console</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0.png" alt="img"></p><ol><li> <strong>报错原因</strong>-服务器主机名有下划线存在特殊字符</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR | Failed to start Apache ActiveMQ ([localhost, ID:VM_0_5_centos-39529-1548405340021-0:1], java.net.URISyntaxException: Illegal character in hostname at index 7: ws://VM_0_5_centos:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>修改conf目录下的activemq.xml文件</strong></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos bin]# cd ..</span><br><span class="line">[root@VM_0_5_centos apache-activemq-5.14.5]# cd conf/</span><br><span class="line">[root@VM_0_5_centos conf]# ls</span><br><span class="line">activemq.xml           client.ks                   groups.properties       jmx.access          login.config</span><br><span class="line">broker.ks              client.ts                   java.security           jmx.password        users.properties</span><br><span class="line">broker-localhost.cert  credentials-enc.properties  jetty-realm.properties  log4j.properties</span><br><span class="line">broker.ts              credentials.properties      jetty.xml               logging.properties</span><br><span class="line">[root@VM_0_5_centos conf]# vim activemq.xml </span><br><span class="line"><span class="meta">#</span><span class="bash">将127.0.0.1修改为0.0.0.0 【重新改为0.0.0.0 否则后续远程连接访问报错】</span></span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E5%A4%B1%E8%B4%A5%E4%BF%AE%E6%94%B9.png" alt="img"></p><ol start="3"><li><p><strong>始终报错，修改etc/hosts文件，删除映射到VM_0_5_centos的配置</strong></p><blockquote><p><strong>hostnamectl set-hostname  XXX</strong></p><p>或者直接设置host名称然后reboot重启</p></blockquote></li><li><p><strong>重新启动，运行activemq，查看运行状态</strong></p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos bin]# ./activemq status</span><br><span class="line">INFO: Loading &#x27;/usr/local/activemq/apache-activemq-5.14.5//bin/env&#x27;</span><br><span class="line">INFO: Using java &#x27;/usr/java/jdk1.8.0_192/bin/java&#x27;</span><br><span class="line">ActiveMQ is running (pid &#x27;3941&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E6%88%90%E5%8A%9F.png" alt="img"></p><ol start="5"><li><strong>访问8161管理员页面,使用配置的账号密码登录</strong></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E6%88%90%E5%8A%9F1.png" alt="activemq成功"></p><ol start="6"><li><strong>进入conf文件夹下配置文件，修改密码</strong></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos apache-activemq-5.14.5]# cd conf/</span><br><span class="line">[root@VM_0_5_centos conf]# ls</span><br><span class="line">activemq.xml           client.ks                   groups.properties       jmx.access          login.config</span><br><span class="line">broker.ks              client.ts                   java.security           jmx.password        users.properties</span><br><span class="line">broker-localhost.cert  credentials-enc.properties  jetty-realm.properties  log4j.properties</span><br><span class="line">broker.ts              credentials.properties      jetty.xml               logging.properties</span><br><span class="line">[root@VM_0_5_centos conf]# vim jetty-realm.properties </span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E5%AF%86%E7%A0%81.png" alt="img"></p><h4 id="6-SpringBoot整合ActiveMQ"><a href="#6-SpringBoot整合ActiveMQ" class="headerlink" title="6. SpringBoot整合ActiveMQ"></a>6. SpringBoot整合ActiveMQ</h4><ol><li>maven引入jar包</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--整合activemq--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编辑配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>    </span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://IP+端口号61616</span></span><br><span class="line">    <span class="attr">in-memory:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>window客户端可使用telnet 命令查看端口是否可以访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet IP 端口号 例：telnet 127.0.0.1 8080</span><br></pre></td></tr></table></figure></li><li><p>编写服务提供方</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.activemq;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsMessagingTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈服务者〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-01-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, <span class="keyword">final</span> String message)</span></span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(destination, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写消费方</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.activemq;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.annotation.JmsListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈消费者〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-01-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;myqueues&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message:&quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写控制器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.controller;</span><br><span class="line"><span class="keyword">import</span> com.joey.activemq.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.command.ActiveMQQueue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/activemq&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tests</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Destination destination = <span class="keyword">new</span> ActiveMQQueue(<span class="string">&quot;myqueues&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) &#123;</span><br><span class="line">            producer.sendMessage(destination, <span class="string">&quot;hello world! 第&quot;</span>+i+<span class="string">&quot;次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问成功</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E6%88%90%E5%8A%9F2.png" alt="activemq成功"></p></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/activemq%E6%88%90%E5%8A%9F3.png" alt="activemq成功"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> ActiveMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> ActiveMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7.2下安装JDK三种方法</title>
      <link href="/2019/07/23/Linux-install_JDK1.8/"/>
      <url>/2019/07/23/Linux-install_JDK1.8/</url>
      
        <content type="html"><![CDATA[<h2 id="Centos7-2下安装JDK三种方法"><a href="#Centos7-2下安装JDK三种方法" class="headerlink" title="Centos7.2下安装JDK三种方法"></a>Centos7.2下安装JDK三种方法</h2><h3 id="方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量"><a href="#方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量" class="headerlink" title="方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量"></a>方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量</h3><h4 id="1-在-usr-目录下创建java目录"><a href="#1-在-usr-目录下创建java目录" class="headerlink" title="1. 在/usr/目录下创建java目录"></a>1. 在/usr/目录下创建java目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir/usr/java</span><br><span class="line">[root@localhost ~]# cd /usr/java</span><br></pre></td></tr></table></figure><h4 id="2-下载jdk-然后解压"><a href="#2-下载jdk-然后解压" class="headerlink" title="2. 下载jdk,然后解压"></a>2. 下载jdk,然后解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# curl -O （jdk下载链接）</span><br><span class="line">[root@localhost java]# tar -zxvf jdk-8u192-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h4 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3. 设置环境变量"></a>3. 设置环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# vim /etc/profile</span><br></pre></td></tr></table></figure><blockquote><p>在profile中最后添加如下内容:</p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">JAVA_HOME</span>=<span class="string">/usr/java/jdk1.8.0_192</span></span><br><span class="line"><span class="attr">JRE_HOME</span>=<span class="string">/usr/java/jdk1.8.0_192/jre</span></span><br><span class="line"><span class="attr">CLASS_PATH</span>=<span class="string">.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span></span><br><span class="line"><span class="attr">PATH</span>=<span class="string">$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span></span><br><span class="line"><span class="attr">export</span> <span class="string">JAVA_HOME JRE_HOME CLASS_PATH PATH</span></span><br></pre></td></tr></table></figure><blockquote><p>让修改生效:</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# source /etc/profile</span><br></pre></td></tr></table></figure><blockquote><p> 若因修改环境变量导致系统出现command not found错误,可尝试以下方法</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编辑环境变量文件</span></span><br><span class="line">[root@localhost java]# /usr/bin/vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">修改或删除原先配置文件 :wq 保存退出 执行<span class="built_in">export</span></span></span><br><span class="line">[root@localhost java]# export PATH=/usr/bin:/usr/sbin:/bin:/sbin</span><br><span class="line"><span class="meta">#</span><span class="bash">重新执行使更改立即生效</span></span><br><span class="line">[root@localhost java]# source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="4-验证JDK有效性"><a href="#4-验证JDK有效性" class="headerlink" title="4. 验证JDK有效性"></a>4. 验证JDK有效性</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos jdk1.8.0_192]# java -version</span><br><span class="line">java version &quot;1.8.0_192&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_192-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.192-b12, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="方法二：使用yum命令在线安装JDK"><a href="#方法二：使用yum命令在线安装JDK" class="headerlink" title="方法二：使用yum命令在线安装JDK"></a>方法二：使用yum命令在线安装JDK</h3><h4 id="1-查看yum库中都有哪些jdk版本，全是openjdk"><a href="#1-查看yum库中都有哪些jdk版本，全是openjdk" class="headerlink" title="1. 查看yum库中都有哪些jdk版本，全是openjdk"></a>1. 查看yum库中都有哪些jdk版本，全是openjdk</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos jdk1.8.0_192]# yum search java|grep jdk</span><br><span class="line">ldapjdk-javadoc.noarch : Javadoc for ldapjdk</span><br><span class="line">java-1.6.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">...</span><br><span class="line">java-1.7.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">...</span><br><span class="line">java-1.8.0-openjdk.i686 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk-accessibility.i686 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-accessibility-debug.i686 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-accessibility-debug.x86_64 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-debug.i686 : OpenJDK Runtime Environment with full debug on</span><br><span class="line">java-1.8.0-openjdk-debug.x86_64 : OpenJDK Runtime Environment with full debug on</span><br><span class="line">java-1.8.0-openjdk-demo.i686 : OpenJDK Demos</span><br><span class="line">java-1.8.0-openjdk-demo.x86_64 : OpenJDK Demos</span><br><span class="line">java-1.8.0-openjdk-demo-debug.i686 : OpenJDK Demos with full debug on</span><br><span class="line">java-1.8.0-openjdk-demo-debug.x86_64 : OpenJDK Demos with full debug on</span><br><span class="line">java-1.8.0-openjdk-devel.i686 : OpenJDK Development Environment</span><br><span class="line">java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment</span><br><span class="line">java-1.8.0-openjdk-devel-debug.i686 : OpenJDK Development Environment with full</span><br><span class="line">java-1.8.0-openjdk-devel-debug.x86_64 : OpenJDK Development Environment with</span><br><span class="line">java-1.8.0-openjdk-headless.i686 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk-headless.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk-headless-debug.i686 : OpenJDK Runtime Environment with full</span><br><span class="line">java-1.8.0-openjdk-headless-debug.x86_64 : OpenJDK Runtime Environment with full</span><br><span class="line">java-1.8.0-openjdk-javadoc.noarch : OpenJDK API Documentation</span><br><span class="line">java-1.8.0-openjdk-javadoc-debug.noarch : OpenJDK API Documentation for packages</span><br><span class="line">java-1.8.0-openjdk-javadoc-zip.noarch : OpenJDK API Documentation compressed in</span><br><span class="line">java-1.8.0-openjdk-javadoc-zip-debug.noarch : OpenJDK API Documentation</span><br><span class="line">java-1.8.0-openjdk-src.i686 : OpenJDK Source Bundle</span><br><span class="line">java-1.8.0-openjdk-src.x86_64 : OpenJDK Source Bundle</span><br><span class="line">java-1.8.0-openjdk-src-debug.i686 : OpenJDK Source Bundle for packages with</span><br><span class="line">java-1.8.0-openjdk-src-debug.x86_64 : OpenJDK Source Bundle for packages with</span><br><span class="line">java-11-openjdk.i686 : OpenJDK Runtime Environment 11</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-选择版本进行安装"><a href="#2-选择版本进行安装" class="headerlink" title="2. 选择版本进行安装"></a>2. 选择版本进行安装</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">选择1.8版本进行安装,安装完之后，默认的安装目录是在: /usr/lib/jvm/</span></span><br><span class="line">[root@localhost ~]# yum install java-1.8.0-openjdk</span><br></pre></td></tr></table></figure><h4 id="3-设置环境变量-，使修改立即生效，查看是否安装成功参考方法一"><a href="#3-设置环境变量-，使修改立即生效，查看是否安装成功参考方法一" class="headerlink" title="3. 设置环境变量 ，使修改立即生效，查看是否安装成功参考方法一"></a>3. 设置环境变量 ，使修改立即生效，查看是否安装成功参考方法一</h4><h3 id="方法三：使用rpm安装"><a href="#方法三：使用rpm安装" class="headerlink" title="方法三：使用rpm安装"></a>方法三：使用rpm安装</h3><h4 id="1-其他步骤具体参考上述方法"><a href="#1-其他步骤具体参考上述方法" class="headerlink" title="1. 其他步骤具体参考上述方法"></a>1. 其他步骤具体参考上述方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost  ~]# rpm -ivh jdk-7u79-linux-x64.rpm</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.2安装MongoDB 4.0.5</title>
      <link href="/2019/07/23/Linux-install_MongoDB4.0.5/"/>
      <url>/2019/07/23/Linux-install_MongoDB4.0.5/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-2安装MongoDB-4-0-5"><a href="#CentOS-7-2安装MongoDB-4-0-5" class="headerlink" title="CentOS 7.2安装MongoDB 4.0.5"></a>CentOS 7.2安装MongoDB 4.0.5</h2><h4 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h4><blockquote><p><a href="https://www.mongodb.com/download-center/community">MongoDB官网</a>下载安装包上传至服务器或者获取下载链接使用wget命令</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E5%AE%98%E7%BD%91.png" alt="MongoDB官网"></p><blockquote><p>创建mongdb目录，使用wget命令下载压缩包</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E4%B8%8B%E8%BD%BD.png" alt="MongoDB下载"></p><h4 id="2-解压压缩包"><a href="#2-解压压缩包" class="headerlink" title="2. 解压压缩包"></a>2. 解压压缩包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos mongodb]# tar zxvf mongodb-linux-x86_64-4.0.5.tgz</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E8%A7%A3%E5%8E%8B.png" alt="MongoDB解压"></p><h4 id="3-新建data文件夹用于存放数据，logs文件夹存放日志"><a href="#3-新建data文件夹用于存放数据，logs文件夹存放日志" class="headerlink" title="3. 新建data文件夹用于存放数据，logs文件夹存放日志"></a>3. 新建data文件夹用于存放数据，logs文件夹存放日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos mongodb-linux-x86_64-4.0.5]# mkdir data</span><br><span class="line">[root@VM_0_5_centos mongodb-linux-x86_64-4.0.5]# mkdir logs</span><br><span class="line">[root@VM_0_5_centos mongodb-linux-x86_64-4.0.5]# ls</span><br><span class="line">bin  data  LICENSE-Community.txt  logs  MPL-2  README  THIRD-PARTY-NOTICES</span><br></pre></td></tr></table></figure><h4 id="4-新建一个配置文件mongodb-conf"><a href="#4-新建一个配置文件mongodb-conf" class="headerlink" title="4. 新建一个配置文件mongodb.conf"></a>4. 新建一个配置文件mongodb.conf</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="MongoDB配置文件"></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">27017</span></span><br><span class="line"><span class="comment">#数据库存文件存放目录</span></span><br><span class="line"><span class="attr">dbpath</span>=<span class="string">/usr/local/mongodb/mongodb-linux-x86_64-4.0.5/data</span></span><br><span class="line"><span class="comment">#日志文件存放路径</span></span><br><span class="line"><span class="attr">logpath</span>=<span class="string">/usr/local/mongodb/mongodb-linux-x86_64-4.0.5/data/mongodb.log</span></span><br><span class="line"><span class="comment">#使用追加的方式写日志</span></span><br><span class="line"><span class="attr">logappend</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#在后台运行</span></span><br><span class="line"><span class="attr">fork</span>=<span class="string">true </span></span><br><span class="line"><span class="comment">#最大同时连接数</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="string">100</span></span><br><span class="line"><span class="comment">#不启用验证</span></span><br><span class="line"><span class="attr">noauth</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）</span></span><br><span class="line"><span class="attr">journal</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#存储引擎有mmapv1、wiretiger、mongorocks，即使宕机，启动时wiredtiger会先将数据恢复到最近一次的checkpoint点，然后重放后续的journal日志来恢复。</span></span><br><span class="line"><span class="attr">storageEngine</span>=<span class="string">wiredTiger</span></span><br><span class="line"><span class="comment">#配置外部访问</span></span><br><span class="line"><span class="attr">bind_ip</span> = <span class="string">0.0.0.0</span></span><br></pre></td></tr></table></figure><h4 id="5-用配置文件启动MongoDB"><a href="#5-用配置文件启动MongoDB" class="headerlink" title="5. 用配置文件启动MongoDB"></a>5. 用配置文件启动MongoDB</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos bin]# ./mongod --config /usr/local/mongodb/mongodb-linux-x86_64-4.0.5/mongodb.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 26478</span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure><h4 id="6-用RoBo连接MongoDB"><a href="#6-用RoBo连接MongoDB" class="headerlink" title="6. 用RoBo连接MongoDB"></a>6. 用RoBo连接MongoDB</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E8%BF%9E%E6%8E%A51.png" alt="MongoDB连接1"></p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E8%BF%9E%E6%8E%A52.png" alt="MongoDB连接2"></p><h4 id="7-java连接MongoDB"><a href="#7-java连接MongoDB" class="headerlink" title="7. java连接MongoDB"></a>7. java连接MongoDB</h4><blockquote><p>出现报错</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E6%8A%A5%E9%94%99.png" alt="MongoDB报错"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.2 安装MySql 5.7</title>
      <link href="/2019/07/23/Linux-install_MySql5.7/"/>
      <url>/2019/07/23/Linux-install_MySql5.7/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-2-安装MySql-5-7"><a href="#CentOS-7-2-安装MySql-5-7" class="headerlink" title="CentOS 7.2 安装MySql 5.7"></a>CentOS 7.2 安装MySql 5.7</h2><h4 id="1-下载rpm包"><a href="#1-下载rpm包" class="headerlink" title="1. 下载rpm包"></a>1. 下载rpm包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# wget http://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E4%B8%8B%E8%BD%BD.png" alt="mysql下载"></p><h4 id="2-下载安装软件源"><a href="#2-下载安装软件源" class="headerlink" title="2. 下载安装软件源"></a>2. 下载安装软件源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# yum localinstall mysql57-community-release-el7-9.noarch.rpm </span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E5%AE%89%E8%A3%85.png" alt="mysql安装"></p><h4 id="3-查看系统是否添加该源"><a href="#3-查看系统是否添加该源" class="headerlink" title="3. 查看系统是否添加该源"></a>3. 查看系统是否添加该源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# yum repolist all | grep mysql</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E6%BA%90.png" alt="mysql源"></p><h4 id="4-安装MySql"><a href="#4-安装MySql" class="headerlink" title="4. 安装MySql"></a>4. 安装MySql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# yum install mysql-community-server.x86_64 </span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B.png" alt="mysql安装过程"></p><h4 id="5-启动MySql-Server"><a href="#5-启动MySql-Server" class="headerlink" title="5. 启动MySql Server"></a>5. 启动MySql Server</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动Mysql</span></span><br><span class="line">[root@VM_0_5_centos home]# systemctl start mysqld</span><br><span class="line"><span class="meta">#</span><span class="bash">查看启动状态</span></span><br><span class="line">[root@VM_0_5_centos home]# systemctl status mysqld</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E5%90%AF%E5%8A%A8.png" alt="mysql启动"></p><h4 id="6-查看MySQL随机临时密码"><a href="#6-查看MySQL随机临时密码" class="headerlink" title="6. 查看MySQL随机临时密码"></a>6. 查看MySQL随机临时密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# grep &#x27;temporary password&#x27; /var/log/mysqld.log </span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E4%B8%B4%E6%97%B6%E5%AF%86%E7%A0%81.png" alt="mysql临时密码"></p><h4 id="7-修改MySql密码"><a href="#7-修改MySql密码" class="headerlink" title="7. 修改MySql密码"></a>7. 修改MySql密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# mysql_secure_installation</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%8A%A5%E9%94%99.png" alt="mysql修改密码报错"></p><blockquote><p>MySQL里带了一个密码验证的插件来防止密码设置过于简单。</p><p>密码要求：</p><ul><li>特殊字符</li><li>大小写字母</li><li>数字</li><li>长度8位</li></ul><p>实例密码：Fangchy1120.！</p></blockquote><h4 id="8-登录MySql修改密码"><a href="#8-登录MySql修改密码" class="headerlink" title="8. 登录MySql修改密码"></a>8. 登录MySql修改密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# mysql -uroot -p</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E6%8A%A5%E9%94%99.png" alt="mysql报错"></p><blockquote><p>原来MySQL5.6.6版本之后增加了密码强度验证插件validate_password，相关参数设置的较为严格。<br>使用了该插件会检查设置的密码是否符合当前设置的强度规则，若不满足则拒绝设置。影响的语句和函数有：create user,grant,set password,password(),old password。</p></blockquote><ol><li><strong>查看mysql全局参数</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| validate_password_check_user_name    | OFF    |</span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 8      |</span><br><span class="line">| validate_password_mixed_case_count   | 1      |</span><br><span class="line">| validate_password_number_count       | 1      |</span><br><span class="line">| validate_password_policy             | MEDIUM |</span><br><span class="line">| validate_password_special_char_count | 1      |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>参数解释</strong></p><blockquote><ul><li><p>validate_password_dictionary_file</p><p>插件用于验证密码强度的字典文件路径。</p></li><li><p>validate_password_length</p><p>密码最小长度，参数默认为8，它有最小值的限制，最小值为：validate_password_number_count + validate_password_special_char_count + (2 * validate_password_mixed_case_count)</p></li><li><p>validate_password_mixed_case_count</p><p>密码至少要包含的小写字母个数和大写字母个数。</p></li><li><p>validate_password_number_count</p><p>密码至少要包含的数字个数。</p></li><li><p>validate_password_policy</p><p>密码强度检查等级，0/LOW、1/MEDIUM、2/STRONG。有以下取值：</p><table><thead><tr><th>Policy</th><th>Tests Performed</th></tr></thead><tbody><tr><td>0 or LOW</td><td>Length</td></tr><tr><td>1 or MEDIUM</td><td>Length; numeric, lowercase/uppercase, and special characters</td></tr><tr><td>2 or STRONG</td><td>Length; numeric, lowercase/uppercase, and special characters; dictionary file</td></tr></tbody></table><p>默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。</p></li><li><p>validate_password_special_char_count</p><p>密码至少要包含的特殊字符数。  </p></li></ul></blockquote></li><li><p><strong>修改上面的各项参数，全部执行成功</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy&#x3D;0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_mixed_case_count&#x3D;0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_number_count&#x3D;3;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_special_char_count&#x3D;0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_length&#x3D;3;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>查看修改后的参数</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;validate_password%&#39;;</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| Variable_name                        | Value |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| validate_password_check_user_name    | OFF   |</span><br><span class="line">| validate_password_dictionary_file    |       |</span><br><span class="line">| validate_password_length             | 3     |</span><br><span class="line">| validate_password_mixed_case_count   | 0     |</span><br><span class="line">| validate_password_number_count       | 3     |</span><br><span class="line">| validate_password_policy             | LOW   |</span><br><span class="line">| validate_password_special_char_count | 0     |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>修改成简单密码</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&#39;123&#39;);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>使用新密码登录</strong></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos ~]# mysql -uroot -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 16</span><br><span class="line">Server version: 5.7.24 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and&#x2F;or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</span><br></pre></td></tr></table></figure><ol start="7"><li>配置远程连接(腾讯云不需要配置端口)</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看mysql端口</span></span><br><span class="line">[root@VM_0_5_centos ~]# netstat -ntlp|grep 3306</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      13929/mysqld  </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置远程连接，赋予任何主机上以root身份访问数据的权限 </span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E8%BF%9E%E6%8E%A51.png" alt="mysql连接1"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos 7.2 安装目前最新版Redis5.0.3</title>
      <link href="/2019/07/23/Linux-install_Redis5.0.3/"/>
      <url>/2019/07/23/Linux-install_Redis5.0.3/</url>
      
        <content type="html"><![CDATA[<h2 id="Centos-7-2-安装目前最新版Redis5-0-3"><a href="#Centos-7-2-安装目前最新版Redis5-0-3" class="headerlink" title="Centos 7.2 安装目前最新版Redis5.0.3"></a>Centos 7.2 安装目前最新版Redis5.0.3</h2><h4 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E4%B8%8B%E8%BD%BD.png" alt="redis下载"></p><h4 id="2-解压安装包"><a href="#2-解压安装包" class="headerlink" title="2. 解压安装包"></a>2. 解压安装包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# tar -zxvf redis-5.0.3.tar.gz </span><br></pre></td></tr></table></figure><h4 id="3-进入解压后的目录，编译"><a href="#3-进入解压后的目录，编译" class="headerlink" title="3. 进入解压后的目录，编译"></a>3. 进入解压后的目录，编译</h4><blockquote><p>redis使用c语言开发的，所以编译依赖gcc环境，先查看是否安装了gcc</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/gcc.png" alt="gcc"></p><blockquote><p>如果没有安装，先执行安装gcc命令</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos local]# yum -y install gcc-c++</span><br></pre></td></tr></table></figure><blockquote><p>再进行编译</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# cd redis-5.0.3/</span><br><span class="line">[root@VM_0_5_centos redis-5.0.3]# make</span><br></pre></td></tr></table></figure><h4 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-5.0.3]# ls</span><br><span class="line">00-RELEASENOTES  COPYING  Makefile   redis.conf       runtest-sentinel  tests</span><br><span class="line">BUGS             deps     MANIFESTO  runtest          sentinel.conf     utils</span><br><span class="line">CONTRIBUTING     INSTALL  README.md  runtest-cluster  src</span><br><span class="line">[root@VM_0_5_centos redis-5.0.3]# vim redis.conf </span><br><span class="line"><span class="meta">#</span><span class="bash">修改绑定ip为0.0.0.0，支持远程访问</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定日志文件目录</span></span><br><span class="line">logfile &quot;/usr/local/redis/log/server-out.log&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用后台启动</span></span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><h4 id="5-启动redis"><a href="#5-启动redis" class="headerlink" title="5. 启动redis"></a>5. 启动redis</h4><blockquote><p>进入src目录，用配置文件启动redis</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入src目录</span></span><br><span class="line">[root@VM_0_5_centos redis-5.0.3]# cd src</span><br><span class="line"><span class="meta">#</span><span class="bash">启动redis</span></span><br><span class="line">[root@VM_0_5_centos src]# ./redis-server ../redis.conf </span><br></pre></td></tr></table></figure><h4 id="6-查看redis是否启动"><a href="#6-查看redis是否启动" class="headerlink" title="6. 查看redis是否启动"></a>6. 查看redis是否启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos src]# netstat -nlpt|grep 6379</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E5%90%AF%E5%8A%A8.png" alt="redis启动"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos src]# ps -aux|grep redis</span><br><span class="line">root      7655  0.0  0.5 159456 10264 ?        Ssl  16:41   0:00 ./redis-server 0.0.0.0:6379</span><br><span class="line">root      7971  0.0  0.0 112644   964 pts/0    R+   16:45   0:00 grep --color=auto redis</span><br><span class="line"><span class="meta">#</span><span class="bash">进入redis客户端</span></span><br><span class="line">[root@VM_0_5_centos src]# ./redis-cli </span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E5%AE%A2%E6%88%B7%E7%AB%AF.png" alt="redis客户端"></p><h4 id="7-给redis添加密码"><a href="#7-给redis添加密码" class="headerlink" title="7. 给redis添加密码"></a>7. 给redis添加密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos src]# vim ../redis.conf </span><br><span class="line"><span class="meta">#</span><span class="bash">命令行状态/requirepass 按回车查找 ，n查找下一个，添加下面一行</span></span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><h4 id="8-重启redis"><a href="#8-重启redis" class="headerlink" title="8. 重启redis"></a>8. 重启redis</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">关闭客户端</span></span><br><span class="line">[root@VM_0_5_centos src]# ./redis-cli shutdown</span><br><span class="line"><span class="meta">#</span><span class="bash">重启redis服务</span></span><br><span class="line">[root@VM_0_5_centos src]# ./redis-server ../redis.conf </span><br><span class="line"><span class="meta">#</span><span class="bash">重新连接客户端（没有权限访问）</span></span><br><span class="line">[root@VM_0_5_centos src]# ./redis-cli </span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line"><span class="meta">#</span><span class="bash">密码登录</span></span><br><span class="line">[root@VM_0_5_centos src]# ./redis-cli -a 123456</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br></pre></td></tr></table></figure><h4 id="9-SpringBoot连接redis"><a href="#9-SpringBoot连接redis" class="headerlink" title="9. SpringBoot连接redis"></a>9. SpringBoot连接redis</h4><blockquote><p>引入maven依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--整合单机版redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>添加配置</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">118.25</span><span class="number">.24</span><span class="number">.23</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>启动类开启缓存</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>service实现类中的方法添加@Cacheable接口</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value=&quot;mybook&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Books <span class="title">getBooksById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;从数据库中查询。。。&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> booksMapper.getBooksById(id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>bean未序列化报错解决</p><p>解决办法：Bean类实现Serializable接口</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E7%BC%93%E5%AD%98%E6%8A%A5%E9%94%99.png" alt="redis缓存报错"></p><blockquote><p>单机版部署成功</p><p>执行两次查询，输出一次</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E6%88%90%E5%8A%9F.png" alt="redis成功"></p><blockquote><p>查看redis客户端</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/redis%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="redis服务器"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7.2安装Redis 5.0.3集群</title>
      <link href="/2019/07/23/Linux-install_Redis5.0.3_cluster/"/>
      <url>/2019/07/23/Linux-install_Redis5.0.3_cluster/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-2安装Redis-5-0-3集群"><a href="#CentOS-7-2安装Redis-5-0-3集群" class="headerlink" title="CentOS 7.2安装Redis 5.0.3集群"></a>CentOS 7.2安装Redis 5.0.3集群</h2><h4 id="1-安装redis-5-0（参考install-Redis5-0-3-md）"><a href="#1-安装redis-5-0（参考install-Redis5-0-3-md）" class="headerlink" title="1. 安装redis 5.0（参考install_Redis5.0.3.md）"></a>1. 安装redis 5.0（参考install_Redis5.0.3.md）</h4><h4 id="2-创建redis-cluster目录，方便管理我们创建的redis实例，复制之前安装好的redis为redis01"><a href="#2-创建redis-cluster目录，方便管理我们创建的redis实例，复制之前安装好的redis为redis01" class="headerlink" title="2. 创建redis-cluster目录，方便管理我们创建的redis实例，复制之前安装好的redis为redis01"></a>2. 创建redis-cluster目录，方便管理我们创建的redis实例，复制之前安装好的redis为redis01</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# mkdir redis-cluster</span><br><span class="line">[root@VM_0_5_centos redis]# ls</span><br><span class="line">log  redis-5.0.3  redis-5.0.3.tar.gz  redis-cluster</span><br><span class="line">[root@VM_0_5_centos redis]# cp -r redis-5.0.3 ./redis-cluster/redis01</span><br><span class="line">[root@VM_0_5_centos redis]# ls redis-cluster/</span><br><span class="line">redis01</span><br></pre></td></tr></table></figure><h4 id="3-修改redis01的配置文件"><a href="#3-修改redis01的配置文件" class="headerlink" title="3. 修改redis01的配置文件"></a>3. 修改redis01的配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis]# cd redis-cluster/redis01/</span><br><span class="line">[root@VM_0_5_centos redis01]# ls</span><br><span class="line">00-RELEASENOTES  COPYING  Makefile   redis.conf       runtest-sentinel  tests</span><br><span class="line">BUGS             deps     MANIFESTO  runtest          sentinel.conf     utils</span><br><span class="line">CONTRIBUTING     INSTALL  README.md  runtest-cluster  src</span><br><span class="line">[root@VM_0_5_centos redis01]# vim redis.conf </span><br></pre></td></tr></table></figure><h4 id="4-把-bind-127-0-0-1-给注释掉或者改为0-0-0-0，这里的bind指的是只有指定的网段才能远程访问这个redis"><a href="#4-把-bind-127-0-0-1-给注释掉或者改为0-0-0-0，这里的bind指的是只有指定的网段才能远程访问这个redis" class="headerlink" title="4. 把 bind 127.0.0.1 给注释掉或者改为0.0.0.0，这里的bind指的是只有指定的网段才能远程访问这个redis"></a>4. 把 bind 127.0.0.1 给注释掉或者改为0.0.0.0，这里的bind指的是只有指定的网段才能远程访问这个redis</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A41.png" alt="集群1"></p><h4 id="5-开启远程访问-protected-mode-no-和-修改端口-port-7001"><a href="#5-开启远程访问-protected-mode-no-和-修改端口-port-7001" class="headerlink" title="5. 开启远程访问 protected-mode no 和 修改端口 port 7001"></a>5. 开启远程访问 protected-mode no 和 修改端口 port 7001</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A42.png" alt="集群2"></p><h4 id="6-设置后台运行-daemonize-yes"><a href="#6-设置后台运行-daemonize-yes" class="headerlink" title="6. 设置后台运行 daemonize yes"></a>6. 设置后台运行 daemonize yes</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A43.png" alt="集群3"></p><h4 id="7-设置pidfile存放在-run目录下的文件名-pidfile-var-run-redis-7001-pid"><a href="#7-设置pidfile存放在-run目录下的文件名-pidfile-var-run-redis-7001-pid" class="headerlink" title="7. 设置pidfile存放在 run目录下的文件名  pidfile  /var/run/redis_7001.pid"></a>7. 设置pidfile存放在 run目录下的文件名  pidfile  /var/run/redis_7001.pid</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A44.png" alt="集群4"></p><h4 id="8-设置redis集群密码-masterauth-123456-和-requirepass-123456-注意：所有节点的密码都必须一致，masterauth也要加"><a href="#8-设置redis集群密码-masterauth-123456-和-requirepass-123456-注意：所有节点的密码都必须一致，masterauth也要加" class="headerlink" title="8. 设置redis集群密码 masterauth 123456 和 requirepass 123456       注意：所有节点的密码都必须一致，masterauth也要加"></a>8. 设置redis集群密码 masterauth 123456 和 requirepass 123456       注意：所有节点的密码都必须一致，masterauth也要加</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A45.1.png" alt="集群5.1"></p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A45.2.png" alt="集群5.2"></p><h4 id="9-设置开启AOF模式-appendonly-yes"><a href="#9-设置开启AOF模式-appendonly-yes" class="headerlink" title="9. 设置开启AOF模式  appendonly yes"></a>9. 设置开启AOF模式  appendonly yes</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A46.png" alt="集群6"></p><h4 id="10-设置启用集群模式-cluster-enabled-yes，开启配置文件cluster-config-file-nodes-conf-，超时时间-cluster-node-timeout-5000"><a href="#10-设置启用集群模式-cluster-enabled-yes，开启配置文件cluster-config-file-nodes-conf-，超时时间-cluster-node-timeout-5000" class="headerlink" title="10. 设置启用集群模式 cluster-enabled yes，开启配置文件cluster-config-file nodes.conf ，超时时间 cluster-node-timeout 5000"></a>10. 设置启用集群模式 cluster-enabled yes，开启配置文件cluster-config-file nodes.conf ，超时时间 cluster-node-timeout 5000</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A47.png" alt="集群7"></p><h4 id="11-配置好后，拷贝-redis01再创建五个redis实例"><a href="#11-配置好后，拷贝-redis01再创建五个redis实例" class="headerlink" title="11. 配置好后，拷贝 redis01再创建五个redis实例"></a>11. 配置好后，拷贝 redis01再创建五个redis实例</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A48.png" alt="集群8"></p><h4 id="12-修改redis02-06的配置文件，修改端口号，修改pidfile存放文件名"><a href="#12-修改redis02-06的配置文件，修改端口号，修改pidfile存放文件名" class="headerlink" title="12. 修改redis02~06的配置文件，修改端口号，修改pidfile存放文件名"></a>12. 修改redis02~06的配置文件，修改端口号，修改pidfile存放文件名</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis02/redis.conf </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis03/redis.conf </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis04/redis.conf </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis05/redis.conf </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# vim redis06/redis.conf </span><br></pre></td></tr></table></figure><h4 id="13-在redis-cluster目录下，编写redis-start-all-sh启动脚本，启动redis实例"><a href="#13-在redis-cluster目录下，编写redis-start-all-sh启动脚本，启动redis实例" class="headerlink" title="13. 在redis-cluster目录下，编写redis_start_all.sh启动脚本，启动redis实例"></a>13. 在redis-cluster目录下，编写redis_start_all.sh启动脚本，启动redis实例</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A410.png" alt="集群10"></p><h4 id="14-刚创建好的启动脚本没有权限，会提示Permission-denied，所以需要给脚本添加可执行权限"><a href="#14-刚创建好的启动脚本没有权限，会提示Permission-denied，所以需要给脚本添加可执行权限" class="headerlink" title="14. 刚创建好的启动脚本没有权限，会提示Permission denied，所以需要给脚本添加可执行权限"></a>14. 刚创建好的启动脚本没有权限，会提示Permission denied，所以需要给脚本添加可执行权限</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A411.png" alt="集群11"></p><blockquote><p><strong>权限部分说明</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 root root  490 Jan 13 22:32 redis_cluster_start_all.sh</span><br></pre></td></tr></table></figure><p><strong>含义</strong></p><p>u 代表所有者（user）<br>g 代表所有者所在的组群（group）<br>o 代表其他用户（other）<br>a 代表全部的人（u、g、o）</p><p>r 表示文件可读（read）<br>w 表示文件可写（write）<br>x 表示文件可执行（是程序）<br>– 表示相应的权限为空</p><p>+ 表示添加权限<br>– 表示删除权限<br>= 表示使之成为唯一的权限</p><p><strong>数字表示</strong></p><p>0代表—<br>1代表–x<br>2代表-w-<br>3代表-wx<br>4代表r–<br>5代表r-x<br>6代表rw-<br>7代表rwx</p><p>-rw——-    (600) 只有所有者才有读和写的权限</p><p>-rw-r–r–    (644) 只有所有者才有读和写的权限，组群和其他用户只有读的权限</p><p>-rwx——    (700) 只有所有者才有读，写，执行的权限</p><p>-rwxr-xr-x    (755) 只有所有者才有读，写，执行的权限，组群和其他用户只有读和执行的权限</p><p>-rwx–x–x    (711) 只有所有者才有读，写，执行的权限，组群和其用户只有执行的权限</p><p>-rw-rw-rw- (666) 每个人都有读写的权限</p><p>-rwxrwxrwx (777) 每个人都有读写和执行的权限</p></blockquote></blockquote><h4 id="15-启动redis集群"><a href="#15-启动redis集群" class="headerlink" title="15. 启动redis集群"></a>15. 启动redis集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-cluster]# ./redis_cluster_start_all.sh</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A412.png" alt="集群12"></p><h4 id="16-复进入到redis01-bin-目录下，拷贝一份-redis-cli-到-redis-cluster-目录下"><a href="#16-复进入到redis01-bin-目录下，拷贝一份-redis-cli-到-redis-cluster-目录下" class="headerlink" title="16. 复进入到redis01/bin/ 目录下，拷贝一份 redis-cli 到  redis-cluster/ 目录下"></a>16. 复进入到redis01/bin/ 目录下，拷贝一份 redis-cli 到  redis-cluster/ 目录下</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos src]# cp redis-cli /usr/local/redis/redis-cluster/</span><br><span class="line">[root@VM_0_5_centos src]# ls ../../</span><br><span class="line">redis01  redis02  redis03  redis04  redis05  redis06  redis-cli  redis_cluster_start_all.sh</span><br></pre></td></tr></table></figure><h4 id="17-创建redis集群"><a href="#17-创建redis集群" class="headerlink" title="17. 创建redis集群"></a>17. 创建redis集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-cluster]# ./redis-cli --cluster create 118.25.24.23:7001 118.25.24.23:7002 118.25.24.23:7003 118.25.24.23:7004 118.25.24.23:7005 118.25.24.23:7006 --cluster-replicas 1 -a 123456</span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 118.25.24.23:7004 to 118.25.24.23:7001</span><br><span class="line">Adding replica 118.25.24.23:7005 to 118.25.24.23:7002</span><br><span class="line">Adding replica 118.25.24.23:7006 to 118.25.24.23:7003</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span></span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: b50c435cf63df50862a94dadadd9ca5e051449fd 118.25.24.23:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: acf23e9fdab3c902d3cdae65b3120361aabb916f 118.25.24.23:7002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 9608312874a165adcea031713c5256c4c3d7eb63 118.25.24.23:7003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 30a12a011575d62c8865c0e9249e7e768c1a9bae 118.25.24.23:7004</span><br><span class="line">   replicates acf23e9fdab3c902d3cdae65b3120361aabb916f</span><br><span class="line">S: 1733a42b8b6471f81d9dab5f8213ea62b1492fe8 118.25.24.23:7005</span><br><span class="line">   replicates 9608312874a165adcea031713c5256c4c3d7eb63</span><br><span class="line">S: dfac6c68ed0204eda79ceff6b4fd688b1e68df7e 118.25.24.23:7006</span><br><span class="line">   replicates b50c435cf63df50862a94dadadd9ca5e051449fd</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 118.25.24.23:7001)</span></span><br><span class="line">M: b50c435cf63df50862a94dadadd9ca5e051449fd 118.25.24.23:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: dfac6c68ed0204eda79ceff6b4fd688b1e68df7e 118.25.24.23:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b50c435cf63df50862a94dadadd9ca5e051449fd</span><br><span class="line">S: 1733a42b8b6471f81d9dab5f8213ea62b1492fe8 118.25.24.23:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 9608312874a165adcea031713c5256c4c3d7eb63</span><br><span class="line">M: acf23e9fdab3c902d3cdae65b3120361aabb916f 118.25.24.23:7002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 30a12a011575d62c8865c0e9249e7e768c1a9bae 118.25.24.23:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates acf23e9fdab3c902d3cdae65b3120361aabb916f</span><br><span class="line">M: 9608312874a165adcea031713c5256c4c3d7eb63 118.25.24.23:7003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><h4 id="18-在redis-cluster目录下，编写redis-cluster-stop-all-sh关闭脚本"><a href="#18-在redis-cluster目录下，编写redis-cluster-stop-all-sh关闭脚本" class="headerlink" title="18. 在redis-cluster目录下，编写redis_cluster_stop_all.sh关闭脚本"></a>18. 在redis-cluster目录下，编写redis_cluster_stop_all.sh关闭脚本</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A415.png" alt="集群15"></p><h4 id="19-给redis-cluster-stop-all-sh脚本添加可执行权限-参考11点给启动脚本添加权限"><a href="#19-给redis-cluster-stop-all-sh脚本添加可执行权限-参考11点给启动脚本添加权限" class="headerlink" title="19. 给redis_cluster_stop_all.sh脚本添加可执行权限(参考11点给启动脚本添加权限)"></a>19. 给redis_cluster_stop_all.sh脚本添加可执行权限(参考11点给启动脚本添加权限)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos redis-cluster]# ll | grep redis_cluster_stop_all.sh</span><br><span class="line">-rw-r--r-- 1 root root     552 Jan 14 10:42 redis_cluster_stop_all.sh</span><br><span class="line">[root@VM_0_5_centos redis-cluster]# chmod +x redis_cluster_stop_all.sh </span><br><span class="line">[root@VM_0_5_centos redis-cluster]# ll | grep redis_cluster_stop_all.sh</span><br><span class="line">-rwxr-xr-x 1 root root     552 Jan 14 10:42 redis_cluster_stop_all.sh</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A416.png" alt="集群16"></p><h4 id="20-执行停止脚本"><a href="#20-执行停止脚本" class="headerlink" title="20. 执行停止脚本"></a>20. 执行停止脚本</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A417.png" alt="集群17"></p><h4 id="21-java使用jedis连接集群"><a href="#21-java使用jedis连接集群" class="headerlink" title="21. java使用jedis连接集群"></a>21. java使用jedis连接集群</h4><blockquote><ol><li><strong>pom.xml中引入相关jar包</strong></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--整合redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>配置文件中添加集群节点信息</strong></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="number">118.25</span><span class="number">.24</span><span class="number">.23</span><span class="string">:7001,118.25.24.23:7002,118.25.24.23:7003,118.25.24.23:7004,118.25.24.23:7005,118.25.24.23:7006</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>编写redis配置类</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joey.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈redis集群配置〉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-01-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.cluster.nodes&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisNodes;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">getJedisCluster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] redisnodes = redisNodes.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String node:redisnodes)&#123;</span><br><span class="line">                String[] arr = node.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                HostAndPort hostAndPort = <span class="keyword">new</span> HostAndPort(arr[<span class="number">0</span>], Integer.parseInt(arr[<span class="number">1</span>]));</span><br><span class="line">                nodes.add(hostAndPort);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;集群节点配置有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        <span class="comment">//配置password否则会报权限错误</span></span><br><span class="line">        JedisCluster cluster = <span class="keyword">new</span> JedisCluster(nodes,<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="string">&quot;123456&quot;</span>,jedisPoolConfig);</span><br><span class="line">        <span class="keyword">return</span> cluster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>编写Service接口类，实现类以及Controller类</strong></p><p>(1). 接口类</p></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A4%E6%8E%A5%E5%8F%A3%E7%B1%BB.png" alt="集群接口类"></p><p>​    (2). 实现类</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="集群实现类"></p><p>​    (3). Controller类</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A4%E6%8E%A7%E5%88%B6%E7%B1%BB.png" alt="集群控制类"></p><ol start="5"><li><strong>浏览器访问</strong></li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E9%9B%86%E7%BE%A4%E6%88%90%E5%8A%9F.png" alt="集群成功"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7.2 安装tomcat8.5</title>
      <link href="/2019/07/23/Linux-install_Tomcat8/"/>
      <url>/2019/07/23/Linux-install_Tomcat8/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS7-2-安装tomcat8-5"><a href="#CentOS7-2-安装tomcat8-5" class="headerlink" title="CentOS7.2 安装tomcat8.5"></a>CentOS7.2 安装tomcat8.5</h2><h4 id="1-官网下载tomcat压缩包"><a href="#1-官网下载tomcat压缩包" class="headerlink" title="1.  官网下载tomcat压缩包"></a>1.  <a href="http://tomcat.apache.org/download-80.cgi">官网下载</a>tomcat压缩包</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E4%B8%8B%E8%BD%BD.png" alt="tomcat下载"></p><h4 id="2-上传至云服务器（本人使用xFtp6上传）"><a href="#2-上传至云服务器（本人使用xFtp6上传）" class="headerlink" title="2. 上传至云服务器（本人使用xFtp6上传）"></a>2. 上传至云服务器（本人使用xFtp6上传）</h4><h4 id="3-执行解压操作"><a href="#3-执行解压操作" class="headerlink" title="3. 执行解压操作"></a>3. 执行解压操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos tomcat]# tar -zxvf apache-tomcat-8.5.37</span><br><span class="line">[root@VM_0_5_centos tomcat]# ls</span><br><span class="line">apache-tomcat-8.5.37  apache-tomcat-8.5.37.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>解压后文件目录结构</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E8%A7%A3%E5%8E%8B.png" alt="tomcat解压"></p><h4 id="4-查看是否已经正确配置JAVA-HOME，输出JAVA-HOME路径"><a href="#4-查看是否已经正确配置JAVA-HOME，输出JAVA-HOME路径" class="headerlink" title="4. 查看是否已经正确配置JAVA_HOME，输出JAVA_HOME路径"></a>4. 查看是否已经正确配置JAVA_HOME，输出JAVA_HOME路径</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos apache-tomcat-8.5.37]# echo $JAVA_HOME</span><br><span class="line">/usr/java/jdk1.8.0_192</span><br></pre></td></tr></table></figure><h4 id="5-可以将解压后的tomcat文件复制到所需位置"><a href="#5-可以将解压后的tomcat文件复制到所需位置" class="headerlink" title="5. 可以将解压后的tomcat文件复制到所需位置"></a>5. 可以将解压后的tomcat文件复制到所需位置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos tomcat]# cp -r /usr/tomcat/apache-tomcat-8.5.37 /usr/local/tomcat/</span><br><span class="line">[root@VM_0_5_centos tomcat]# ls /usr/local/tomcat/</span><br><span class="line">apache-tomcat-8.5.37</span><br></pre></td></tr></table></figure><h4 id="6-进入bin文件，启动tomcat"><a href="#6-进入bin文件，启动tomcat" class="headerlink" title="6. 进入bin文件，启动tomcat"></a>6. 进入bin文件，启动tomcat</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E5%90%AF%E5%8A%A8.png" alt="tomcat启动"></p><h4 id="7-查看是否启动成功"><a href="#7-查看是否启动成功" class="headerlink" title="7. 查看是否启动成功"></a>7. 查看是否启动成功</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">访问8080端口出现html代码即启动成功</span></span><br><span class="line">[root@VM_0_5_centos ~]# curl http://localhost:8080</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E6%88%90%E5%8A%9F.png" alt="tomcat成功"></p><h4 id="8-查看tomcat启动日志"><a href="#8-查看tomcat启动日志" class="headerlink" title="8. 查看tomcat启动日志"></a>8. 查看tomcat启动日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos ~]# cd /usr/local/tomcat/apache-tomcat-8.5.37/logs/</span><br><span class="line">[root@VM_0_5_centos logs]# tail -f catalina.out</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E6%97%A5%E5%BF%97.png" alt="tomcat日志"></p><h4 id="9-查看端口监听"><a href="#9-查看端口监听" class="headerlink" title="9. 查看端口监听"></a>9. 查看端口监听</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有端口</span></span><br><span class="line">[root@VM_0_5_centos logs]# netstat -ntlp  </span><br><span class="line"><span class="meta">#</span><span class="bash">查看指定端口</span></span><br><span class="line">[root@VM_0_5_centos logs]# netstat -an | grep 8080</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN    </span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E7%AB%AF%E5%8F%A3.png" alt="tomcat端口"></p><h4 id="10-本地浏览器打开直接可以远程访问8080端口-本人使用的是腾讯云，其他云可能需要设置一下防火墙，具体情况具体分析"><a href="#10-本地浏览器打开直接可以远程访问8080端口-本人使用的是腾讯云，其他云可能需要设置一下防火墙，具体情况具体分析" class="headerlink" title="10. 本地浏览器打开直接可以远程访问8080端口(本人使用的是腾讯云，其他云可能需要设置一下防火墙，具体情况具体分析)"></a>10. 本地浏览器打开直接可以远程访问8080端口(本人使用的是腾讯云，其他云可能需要设置一下防火墙，具体情况具体分析)</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/tomcat%E6%9C%AC%E5%9C%B0.png" alt="tomcat本地"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7.2 系统服务器中挖矿病毒查杀</title>
      <link href="/2019/07/23/Linux-zigw%E7%97%85%E6%AF%92%E6%9F%A5%E6%9D%80/"/>
      <url>/2019/07/23/Linux-zigw%E7%97%85%E6%AF%92%E6%9F%A5%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS7-2-系统服务器中挖矿病毒查杀"><a href="#CentOS7-2-系统服务器中挖矿病毒查杀" class="headerlink" title="CentOS7.2 系统服务器中挖矿病毒查杀"></a>CentOS7.2 系统服务器中挖矿病毒查杀</h2><p>本文参考链接如下：</p><ul><li><a href="https://blog.csdn.net/sayWhat_sayHello/article/details/83988443">zigw挖矿病毒查杀</a></li><li><a href="https://mp.weixin.qq.com/s/FhcoPGXG_udkRCj3AFOmxA">如何排查常见挖矿木马</a></li></ul><h4 id="1-服务卡顿，执行top-c命令"><a href="#1-服务卡顿，执行top-c命令" class="headerlink" title="1. 服务卡顿，执行top c命令"></a>1. 服务卡顿，执行top c命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos ~]# top c</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%97%85%E6%AF%92.png" alt="服务器病毒"></p><blockquote><p><strong>关于top命令</strong>（<a href="https://blog.csdn.net/wxh2013/article/details/50995501">参考</a>）</p><p>1.作用<br>top命令用来显示执行中的程序进程，使用权限是所有用户。</p><p>2.格式<br>top [－] [d delay] [q] [c] [S] [s] [i] [n]</p><p>3.主要参数<br>d：指定更新的间隔，以秒计算。<br>q：没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行。<br>c：显示进程完整的路径与名称。<br>S：累积模式，会将己完成或消失的子行程的CPU时间累积起来。<br>s：安全模式。<br>i：不显示任何闲置(Idle)或无用(Zombie)的行程。<br>n：显示更新的次数，完成后将会退出top。</p><p>4.每行信息详解</p><ul><li><p>第一行表示的项目依次为当前时间、系统运行时间、当前系统登录用户数目、1/5/10分钟系统平均负载(一般来说，这个负载值应该不太可能超过 1 才对，除非您的系统很忙碌。 如果持续高于 5 的话，那么…..仔细的看看到底是那个程序在影响整体系统吧！)。</p></li><li><p>第二行显示的是所有启动的进程、目前运行、挂起 (Sleeping)的和无用(Zombie)的进程。(比较需要注意的是最后的 zombie 那个数值，如果不是 0 ，嘿嘿！好好看看到底是那个 process 变成疆尸了吧？！)(stop模式：与sleep进程应区别，sleep会主动放弃cpu，而stop是被动放弃cpu ，例单步跟踪，stop（暂停）的进程是无法自己回到运行状态的)</p></li><li><p>第三行显示的是目前CPU的使用情况，包括us用户空间占用CPU百分比、sy 内核空间占用CPU百分比、ni 用户进程空间内改变过优先级的进程占用CPU百分比(中断处理占用)、id 空闲CPU百分比、wa 等待输入输出的CPU时间百分比、hi,si,st 三者的意思目录还不清楚</p></li><li><p>第四行显示物理内存的使用情况，包括总的可以使用的内存、已用内存、空闲内存、缓冲区占用的内存。</p></li><li><p>第五行显示交换分区使用情况，包括总的交换分区、使用的、空闲的和用于高速缓存的大小。</p></li><li><p>第六行显示的项目最多，下面列出了详细解释。<br>PID（Process ID）：进程标示号 ( 每个 process 的 ID )<br>USER：进程所有者的用户名 ( 该 process 所属的使用者 )<br>PR：进程的优先级别 ( Priority 的简写，程序的优先执行顺序，越小越早被执行 )<br>NI：进程的优先级别数值 ( Nice 的简写，与 Priority 有关，也是越小越早被执行 )<br>VIRT：进程占用的虚拟内存值。<br>RES：进程占用的物理内存值。<br>SHR：进程使用的共享内存值。<br>S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。<br>%CPU：该进程占用的CPU使用率。<br>%MEM：该进程占用的物理内存和总内存的百分比。<br>TIME＋：该进程启动后占用的总的CPU时间 ( CPU 使用时间的累加 )<br>Command：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行。</p></li></ul><p>top命令使用过程中，还可以使用一些交互的命令来完成其它参数的功能。这些命令是通过快捷键启动的。<br>＜空格＞：立刻刷新。<br>P：根据CPU使用大小进行排序。<br>T：根据时间、累计时间排序。<br>q：退出top命令。<br>m：切换显示内存信息。<br>t：切换显示进程和CPU状态信息。<br>c：切换显示命令名称和完整命令行。<br>M：根据使用内存大小进行排序。<br>W：将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</p></blockquote><h4 id="2-查看系统运行情况，记录PID"><a href="#2-查看系统运行情况，记录PID" class="headerlink" title="2.查看系统运行情况，记录PID"></a>2.查看系统运行情况，记录PID</h4><blockquote><p>可以看到./zigw正在运行占用了系统98%的CPU从而导致系统卡顿</p><p>记录运行的PID 3692</p></blockquote><h4 id="3-查看定时任务"><a href="#3-查看定时任务" class="headerlink" title="3. 查看定时任务"></a>3. 查看定时任务</h4><blockquote><p>进入/var/spool/cron 目录以及/etc/cron.daily/、/etc/cron.hourly/、/etc/cron.monthly……等</p></blockquote><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E7%97%85%E6%AF%92%E6%9F%A5%E6%89%BE.png" alt="病毒查找"></p><h4 id="4-删除定时任务文件"><a href="#4-删除定时任务文件" class="headerlink" title="4. 删除定时任务文件"></a>4. 删除定时任务文件</h4><blockquote><p>执行rm -rf 删除root以及dump.rdb文件（第一次未成功使用xftp连接直接删除成功）</p><p>执行过程可能会报没有权限删除，查看是否是因为chattr命令锁定了</p><p>先使用lsattr命令查看文件属性，如果有权限锁定使用chattr命令修改权限</p><p>chattr命令的用法：chattr [ -RVf ] [ -v version ] [ mode ] files…</p><p>例：chattr -i root </p><p><strong>参数说明</strong></p><blockquote><p>+：在原有参数设定基础上，追加参数。</p><p>-：在原有参数设定基础上，移除参数。<br>= ：更新为指定参数设定。<br>A：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防例如手提电脑磁盘I/O错误的发生。<br>S：硬盘I/O同步选项，功能类似sync。<br>a：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，只有root才能设定这个属性。<br>c：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。<br>d：即no dump，设定文件不能成为dump程序的备份目标。<br>i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。<br>j：即journal，设定此参数使得当通过mount参数：data=ordered 或者 data=writeback 挂 载的文件系统，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效。<br>s：保密性地删除文件或目录，即硬盘空间被全部收回。<br>u：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。<br>各参数选项中常用到的是a和i。a选项强制只可添加不可删除，多用于日志系统的安全设定。而i是更为严格的安全设定，只有superuser (root) 或具有CAP_LINUX_IMMUTABLE处理能力（标识）的进程能够施加该选项。</p><p>…….</p></blockquote></blockquote><h4 id="5-进入-proc目录，查看指定端口信息"><a href="#5-进入-proc目录，查看指定端口信息" class="headerlink" title="5. 进入/proc目录，查看指定端口信息"></a>5. 进入/proc目录，查看指定端口信息</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E7%97%85%E6%AF%92%E6%9F%A5%E6%89%BE2.png" alt="病毒查找2"></p><blockquote><p>可以看到有一条指向/etc/zigw</p></blockquote><h4 id="6-进入etc目录"><a href="#6-进入etc目录" class="headerlink" title="6. 进入etc目录"></a>6. 进入etc目录</h4><blockquote><p>先杀进程 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos 3692]# kill -9 3692</span><br></pre></td></tr></table></figure><p>再用chattr改变zigw等病毒文件的权限进行删除。</p></blockquote><h4 id="7-删除ssh-keys"><a href="#7-删除ssh-keys" class="headerlink" title="7. 删除ssh-keys"></a>7. 删除ssh-keys</h4><blockquote><p>进入/root/.ssh目录 ，删除authorize_keys</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/ssh%E5%88%A0%E9%99%A4.png" alt="ssh删除"></p></blockquote><h4 id="8-再执行top-c查看"><a href="#8-再执行top-c查看" class="headerlink" title="8. 再执行top c查看"></a>8. 再执行top c查看</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E7%97%85%E6%AF%92%E5%A4%8D%E5%8F%91.png" alt="病毒复发"></p><h4 id="9-重新执行"><a href="#9-重新执行" class="headerlink" title="9. 重新执行"></a>9. 重新执行</h4><blockquote><p> 重新删除root以及dump.rdb文件，查看定时任务情况，在xftp下都进行删除，重新执行kill -9 14120杀死进程，不再复发。</p></blockquote><h4 id="10-重新配置redis安全配置"><a href="#10-重新配置redis安全配置" class="headerlink" title="10. 重新配置redis安全配置"></a>10. 重新配置redis安全配置</h4>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> CentOS </category>
          
          <category> zigw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> zigw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle中使用正则表达式</title>
      <link href="/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-Oracle-Oracle%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-Oracle-Oracle%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle中使用正则表达式"><a href="#Oracle中使用正则表达式" class="headerlink" title="Oracle中使用正则表达式"></a>Oracle中使用正则表达式</h2><ol><li><h3 id="regexp-like"><a href="#regexp-like" class="headerlink" title="regexp_like"></a>regexp_like</h3><blockquote><p><strong>regexp_like</strong> 只能用于条件表达式，和 like 类似，但是使用的正则表达式进行匹配</p><p>语法： REGEXP_LIKE(srcstr, pattern [,match_option])</p><ol><li>srcstr : 搜索值</li><li>pattern : 正则表达式</li><li>match_option : 匹配选项，可以包含一个或多个<ul><li>“c” : 使用区分大小写的匹配（默认值）</li><li>“i” : 使用不区分大小写的匹配</li><li>“n” : 允许匹配任何字符的运算符来匹配换行符</li><li>“m” : 将源字符串作为多行处理</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> str <span class="keyword">from</span> tmp <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;like&#x27;</span> <span class="keyword">and</span> regexp_like(str,<span class="string">&#x27;A\d+&#x27;</span>,<span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="regexp-substr"><a href="#regexp-substr" class="headerlink" title="regexp_substr"></a>regexp_substr</h3><blockquote><p><strong>regexp_substr</strong> 函数，和 substr 类似，截取符合正则匹配的字符串</p><p>语法：REGEXP_SUBSTR(srcstr, pattern [, position [, occurrence [, match_option]]])</p><ol><li>position : 搜索的起始位置</li><li>occurrence : 搜索的匹配项</li><li>match_option : 匹配选项，可以包含一个或多个<ul><li>“c” : 使用区分大小写的匹配（默认值）</li><li>“i” : 使用不区分大小写的匹配</li><li>“n” : 允许匹配任何字符的运算符来匹配换行符</li><li>“m” : 将源字符串作为多行处理</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">str, </span><br><span class="line">regexp_substr(str,<span class="string">&#x27;[^,]+&#x27;</span>) str,</span><br><span class="line">regexp_substr(str,<span class="string">&#x27;[^,]+&#x27;</span>,<span class="number">1</span>,<span class="number">1</span>) str,</span><br><span class="line">regexp_substr(str,<span class="string">&#x27;[^,]+&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>) str,</span><br><span class="line">regexp_substr(str,<span class="string">&#x27;[^,]+&#x27;</span>,<span class="number">2</span>,<span class="number">1</span>) str</span><br><span class="line"><span class="keyword">from</span> tmp</span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;substr&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="regexp-instr"><a href="#regexp-instr" class="headerlink" title="regexp_instr"></a>regexp_instr</h3><blockquote><p><strong>regexp_instr</strong>函数， 和 instr 类似，用于标定正则匹配的字符子串的开始位置</p><p>语法：REGEXP_INSTR(srcstr, pattern [, position [, occurrence[, return_option [, match_option]]]])</p><ol><li>srcstr : 搜索值</li><li>pattern : 正则表达式</li><li>position : 搜索的起始位置</li><li>occurrence : 搜索的匹配项</li><li>return_option : 匹配项的开头或结尾位置</li><li>match_option : 匹配选项，可以包含一个或多个<ul><li>“c” : 使用区分大小写的匹配（默认值）</li><li>“i” : 使用不区分大小写的匹配</li><li>“n” : 允许匹配任何字符的运算符来匹配换行符</li><li>“m” : 将源字符串作为多行处理</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">str, </span><br><span class="line">regexp_instr(str,<span class="string">&#x27;\.&#x27;</span>    ) ind ,</span><br><span class="line">regexp_instr(str,<span class="string">&#x27;\.&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>) ind ,</span><br><span class="line">regexp_instr(str,<span class="string">&#x27;\.&#x27;</span>,<span class="number">5</span>,<span class="number">2</span>) ind</span><br><span class="line"><span class="keyword">from</span> tmp <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;instr&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><h3 id="regexp-replace"><a href="#regexp-replace" class="headerlink" title="regexp_replace"></a>regexp_replace</h3><blockquote><p><strong>regexp_replace</strong> 函数，和 replace 类似，用于替换符合正则表达式的字符串</p><p>语法：REGEXP_REPLACE(srcstr, pattern [,replacestr [, position[, occurrence [, match_option]]]])</p><ol><li>srcstr : 搜索值</li><li>pattern : 正则表达式</li><li>replacestr : 替换模式的字符串</li><li>position : 搜索的起始位置</li><li>occurrence : 搜索的匹配项</li><li>match_option : 匹配选项，可以包含一个或多个<ul><li>“c” : 使用区分大小写的匹配（默认值）</li><li>“i” : 使用不区分大小写的匹配</li><li>“n” : 允许匹配任何字符的运算符来匹配换行符</li><li>“m” : 将源字符串作为多行处理</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">str,</span><br><span class="line">regexp_replace(str,<span class="string">&#x27;020&#x27;</span>,<span class="string">&#x27;GZ&#x27;</span>) str,</span><br><span class="line">regexp_replace(str,<span class="string">&#x27;(\d&#123;3&#125;)(\d&#123;3&#125;)&#x27;</span>,<span class="string">&#x27;&lt;\2\1&gt;&#x27;</span>) str </span><br><span class="line"><span class="comment">-- 将第一、第二捕获组交换位置，用尖括号标识出来</span></span><br><span class="line"><span class="keyword">from</span> tmp</span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;replace&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Oracle </category>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Oracle </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle常用操作</title>
      <link href="/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-Oracle-Oracle%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-Oracle-Oracle%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库误删恢复"><a href="#数据库误删恢复" class="headerlink" title="数据库误删恢复"></a>数据库误删恢复</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--10分钟前数据可用于误删恢复</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名_tmp <span class="keyword">as</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">AS</span> <span class="keyword">OF</span> <span class="type">TIMESTAMP</span> SYSDATE <span class="operator">-</span> <span class="number">10</span><span class="operator">/</span><span class="number">1440</span></span><br><span class="line">)；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名_tmp；</span><br><span class="line">update 表名A  <span class="keyword">set</span> A.S_GRADE<span class="operator">=</span>(<span class="keyword">select</span> S_GRADE  <span class="keyword">from</span> 表名_TMP B <span class="keyword">where</span> A.ID<span class="operator">=</span>B.ID)；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--闪回</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 enable <span class="type">row</span> movement;</span><br><span class="line">flashback <span class="keyword">table</span> 表名 <span class="keyword">to</span> <span class="type">timestamp</span> to_timestamp(<span class="string">&#x27;2018-08-09 10:00:00&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd HH24:MI:SS&#x27;</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 disable <span class="type">row</span> movement; </span><br></pre></td></tr></table></figure><h2 id="处理锁定"><a href="#处理锁定" class="headerlink" title="处理锁定"></a>处理锁定</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--处理锁定</span></span><br><span class="line"><span class="keyword">select</span> t1.sid, t1.serial#, t1.username, t1.logon_time <span class="keyword">from</span> v$session t1 , v$locked_object t2</span><br><span class="line"><span class="keyword">where</span> t1.sid <span class="operator">=</span> t2.session_id <span class="keyword">order</span> <span class="keyword">by</span> t1.logon_time;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> kill session <span class="string">&#x27;1025,1152&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查询历史执行记录"><a href="#查询历史执行记录" class="headerlink" title="查询历史执行记录"></a>查询历史执行记录</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看oracle执行的语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$<span class="keyword">sql</span> t</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">t.PARSING_SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;数据库名称&#x27;</span> <span class="comment">--数据库</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">lower</span>(t.SQL_TEXT) <span class="keyword">like</span> <span class="string">&#x27;%sql语句中包含的信息%&#x27;</span> <span class="comment">--查询某类SQL语句</span></span><br><span class="line"><span class="keyword">and</span>  t.LAST_ACTIVE_TIME<span class="operator">&gt;</span>(sysdate <span class="operator">-</span> <span class="type">interval</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">MINUTE</span>)  <span class="comment">--执行1分钟内的SQL语句</span></span><br><span class="line"><span class="keyword">and</span> (t.MODULE <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">or</span> t.MODULE <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;%PL/SQL%&#x27;</span>) <span class="comment">--不是在某些终端里的执行</span></span><br></pre></td></tr></table></figure><h2 id="触发器和序列"><a href="#触发器和序列" class="headerlink" title="触发器和序列"></a>触发器和序列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--序列</span></span><br><span class="line"><span class="keyword">CREATE</span> SEQUENCE POWERPMS.S_NBG_MAT_APPLY</span><br><span class="line">    INCREMENT <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span></span><br><span class="line">    MAXVALUE <span class="number">1000000000000000000000000000</span></span><br><span class="line">    NOMINVALUE</span><br><span class="line">    NOCYCLE</span><br><span class="line">    CACHE <span class="number">20</span></span><br><span class="line">    NOORDER</span><br><span class="line">GO</span><br><span class="line"><span class="comment">--触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">TRIGGER</span> POWERPMS.TID_NBG_MAT_APPLY</span><br><span class="line">  before <span class="keyword">insert</span> <span class="keyword">on</span> NBG_MAT_APPLY</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> S_NBG_MAT_APPLYT.NEXTVAL <span class="keyword">INTO</span> :NEW.OLD_UNIQUEID <span class="keyword">FROM</span> DUAL; </span><br><span class="line"><span class="keyword">END</span> TID_NBG_MAT_APPLY;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h2 id="关联更新"><a href="#关联更新" class="headerlink" title="关联更新"></a>关联更新</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span>  表A <span class="keyword">USING</span>  表B <span class="keyword">ON</span> ( 表A.字段<span class="operator">=</span> 表B.字段) <span class="keyword">WHEN</span> MATCHED <span class="keyword">THEN</span></span><br><span class="line">UPDATE</span><br><span class="line"><span class="keyword">SET</span> 表A.字段 <span class="operator">=</span> 表B.字段</span><br></pre></td></tr></table></figure><h2 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h2><blockquote><p>10g ：wm_concat</p><p>11g : pivot ，unpivot </p><p>12c :  listagg</p><p><a href="https://www.cnblogs.com/mellowsmile/p/4642306.html">参考链接</a></p></blockquote><h2 id="表空间不足"><a href="#表空间不足" class="headerlink" title="表空间不足"></a>表空间不足</h2><p>项目中使用出现报错</p><blockquote><p>ORA-01653: 表xx无法通过 8192 (在表空间 xx_data 中) 扩展。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询剩余表空间，发现没有要找的表空间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(F.TABLESPACE_NAME) &quot;表空间名&quot;,D.TOT_GROOTTE_MB &quot;表空间大小(M)&quot;,D.TOT_GROOTTE_MB <span class="operator">-</span> F.TOTAL_BYTES &quot;已使用空间(M)&quot;,</span><br><span class="line">TO_CHAR(ROUND((D.TOT_GROOTTE_MB <span class="operator">-</span> F.TOTAL_BYTES)<span class="operator">/</span>D.TOT_GROOTTE_MB <span class="operator">*</span> <span class="number">100</span>,<span class="number">2</span>),<span class="string">&#x27;990.99&#x27;</span>) &quot;使用比&quot;,</span><br><span class="line">F.TOTAL_BYTES &quot;空闲空间(M)&quot;,</span><br><span class="line">F.MAX_BYTES &quot;最大块(M)&quot;</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> TABLESPACE_NAME,</span><br><span class="line">ROUND(<span class="built_in">SUM</span>(BYTES)<span class="operator">/</span>(<span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>), <span class="number">2</span>) TOTAL_BYTES,</span><br><span class="line">ROUND(<span class="built_in">MAX</span>(BYTES)<span class="operator">/</span>(<span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>), <span class="number">2</span>) MAX_BYTES</span><br><span class="line"><span class="keyword">FROM</span> SYS.DBA_FREE_SPACE</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TABLESPACE_NAME) F,</span><br><span class="line">(<span class="keyword">SELECT</span> DD.TABLESPACE_NAME,</span><br><span class="line">ROUND(<span class="built_in">SUM</span>(DD.BYTES)<span class="operator">/</span>(<span class="number">1024</span> <span class="operator">*</span> <span class="number">1024</span>),<span class="number">2</span>) TOT_GROOTTE_MB</span><br><span class="line"><span class="keyword">FROM</span> SYS.DBA_DATA_FILES DD</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> DD.TABLESPACE_NAME) D</span><br><span class="line"><span class="keyword">WHERE</span> D.TABLESPACE_NAME <span class="operator">=</span> F.TABLESPACE_NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">4</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看表空间是否具有自动扩展的能力   </span></span><br><span class="line"><span class="keyword">SELECT</span> T.TABLESPACE_NAME,D.FILE_NAME,D.AUTOEXTENSIBLE,D.BYTES,D.MAXBYTES,D.STATUS</span><br><span class="line"><span class="keyword">FROM</span> DBA_TABLESPACES T,DBA_DATA_FILES D</span><br><span class="line"><span class="keyword">WHERE</span> T.TABLESPACE_NAME <span class="operator">=</span>D.TABLESPACE_NAME</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> TABLESPACE_NAME,FILE_NAME;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改表空间文件扩展方式:  路径是上面查询的 FILE_NAME</span></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE  DATAFILE <span class="string">&#x27;D:\ORACLE\PRODUCT\10.2.0\ORADATA\NBGPMC\POWERPMS.ORA&#x27;</span> AUTOEXTEND  <span class="keyword">ON</span> NEXT <span class="number">50</span>M MAXSIZE UNLIMITED</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlServer存储过程使用游标循环</title>
      <link href="/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-Sql%20Server-sqlserver%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-Sql%20Server-sqlserver%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>项目需求描述：</strong></p><blockquote><p>公司架构：–总公司(LongCode:1)</p><p>​                        –子公司A(LongCode:1.1)</p><p>​                            –孙公司A1(LongCode:1.1.1)</p><p>​                                –A1孙公司项目(LongCode:1.1.1.1)</p><p>​                            –孙公司A2(LongCode:1.1.2)</p><p>​                            –A公司项目(LongCode:1.1.3)</p><p>​                        –子公司B(LongCode:1.2)</p><p>​                            –B公司项目(LongCode:1.2.1)</p><p>​                        –…</p><p>要求：汇总每个子公司下所有项目（包括孙公司的项目）信息，层级关系通过LongCode确定。</p><p>​            并且返回多条汇总信息。</p></blockquote><p><strong>解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Create Proc P_GetCompanyNewSign </span><br><span class="line">AS </span><br><span class="line">Begin</span><br><span class="line">--判断有没有临时表有的话先删除</span><br><span class="line">if OBJECT_ID(&#39;tempdb..#tblTmp&#39;) is not null drop table #tblTmp;</span><br><span class="line">--创建存储返回数据的临时表</span><br><span class="line">create table #tblTmp(</span><br><span class="line">    Name nvarchar(100),FinishedInvestAmount decimal(30,6),ShortName nvarchar(100),EpsProjLongCode nvarchar(100)</span><br><span class="line">)</span><br><span class="line">--声明临时变量用来存储循环的LongCode</span><br><span class="line">Declare @temp varchar(50)</span><br><span class="line">--声明游标</span><br><span class="line">declare mycursor cursor</span><br><span class="line">--获取需要循环的子公司LongC0de</span><br><span class="line">for(select LongCode from XX where  Name &#x3D; &#39;子公司&#39;)</span><br><span class="line">--开启游标</span><br><span class="line">open mycursor</span><br><span class="line">--获取下一个传给临时变量，相当于for循环中的i变量</span><br><span class="line">fetch next from mycursor into @temp</span><br><span class="line">--假如检索到了数据继续执行</span><br><span class="line">while @@FETCH_STATUS &#x3D; 0</span><br><span class="line">Begin</span><br><span class="line">--将一个子公司的数据插入临时表</span><br><span class="line">insert into #tblTmp select * from XX where LongCode&#x3D;&#39;1.1&#39;</span><br><span class="line">--获取下一个传给临时变量，相当于for循环中的i变量</span><br><span class="line">fetch next from mycursor into @temp</span><br><span class="line">End</span><br><span class="line">--关闭释放游标</span><br><span class="line">close mycursor</span><br><span class="line">deallocate mycursor</span><br><span class="line">--查询临时表中的结果集</span><br><span class="line">select * from #tblTmp;</span><br><span class="line">--使用完删除临时表</span><br><span class="line">if OBJECT_ID(&#39;tempdb..#tblTmp&#39;) is not null drop table #tblTmp;</span><br><span class="line">End</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> SqlServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SqlServer </tag>
            
            <tag> 存储过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlServer 备份还原</title>
      <link href="/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-Sql%20Server-sqlserver%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/"/>
      <url>/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-Sql%20Server-sqlserver%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="SqlServer-备份"><a href="#SqlServer-备份" class="headerlink" title="SqlServer 备份"></a>SqlServer 备份</h2><ol><li><p>右键数据库，选择任务–&gt;备份</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725120751.jpg" alt="备份"></p></li><li><p>在常规选项中，选择要备份的文件路径及名称</p><ul><li>清空原先备份的文件路径</li><li>点击添加，选择磁盘文件目录</li><li>可先选中一个备份文件，然后再修改文件名</li></ul><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725130924.png" alt="备份2"></p></li><li><p>确定后会添加到图中选中部分，点击确定，备份完成。</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725103541.jpg" alt="备份3"></p><h2 id="SqlServer还原"><a href="#SqlServer还原" class="headerlink" title="SqlServer还原"></a>SqlServer还原</h2><ol><li><p>将还原的.bak文件拷贝至服务器</p></li><li><p>右键要还原的数据库，选择任务–&gt;还原–&gt;数据库</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725110916.png" alt="还原"></p></li><li><p>左边选择常规，源选择设备，添加文件，选择刚才拷贝的备份文件</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725111102.jpg" alt="备份2"></p></li><li><p>如果已经存在数据库，直接左边选择选项，勾选覆盖现有数据库，确定即可。</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190725111200.jpg" alt="备份3"></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> SqlServer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SqlServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔记</title>
      <link href="/2019/07/20/Java-Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/20/Java-Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Java基础笔记"><a href="#Java基础笔记" class="headerlink" title="Java基础笔记"></a>Java基础笔记</h1><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h2><h3 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h3><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p><p><strong>特点：关键字中所字母都为小写</strong></p><p>具体如下：</p><ul><li><p>用于定义数据类型的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>class</td><td>interface</td><td>enum</td><td>byte</td><td>short</td></tr><tr><td>int</td><td>long</td><td>float</td><td>double</td><td>char</td></tr><tr><td>boolean</td><td>void</td><td></td><td></td><td></td></tr></tbody></table></li><li><p>用于定义流程控制的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>if</td><td>else</td><td>switch</td><td>case</td><td>default</td></tr><tr><td>while</td><td>do</td><td>for</td><td>break</td><td>continue</td></tr><tr><td>return</td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>用于定义访问权限修饰符的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>private</td><td>protected</td><td>public</td><td></td><td></td></tr></tbody></table></li><li><p>用于定义类、函数、变量修饰符的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abstract</td><td>final</td><td>static</td><td>synchronized</td><td></td></tr></tbody></table></li><li><p>用于定义类与类之间关系的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>extents</td><td>implements</td><td></td><td></td><td></td></tr></tbody></table></li><li><p>用于定义建立实例及引用实例、判断实例的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>new</td><td>this</td><td>super</td><td>instanceof</td><td></td></tr></tbody></table></li><li><p>用于异常处理的关键字</p><table><thead><tr><th>关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>try</td><td>catch</td><td>finally</td><td>throw</td><td>throws</td></tr></tbody></table></li></ul><h3 id="1-2保留字"><a href="#1-2保留字" class="headerlink" title="1.2保留字"></a>1.2保留字</h3><p>goto、const</p><h3 id="1-3标识符"><a href="#1-3标识符" class="headerlink" title="1.3标识符"></a>1.3标识符</h3><p>定义：凡是自己可以起名字的地方都叫标识符</p><p>涉及到的结构：包名、类名、接口名、变量名、方法名、常量名</p><p>规则：</p><ul><li><strong>由26个英文字母大小写，0-9，_或$组成</strong></li><li><strong>数字不可以开头</strong></li><li><strong>不可以使用关键字和保留字，但能包含关键字和保留字</strong></li><li><strong>Java中严格区分大小写，长度无限制</strong></li><li><strong>标识符不能包含空格</strong></li></ul><p>规范：</p><ul><li>包名：多单词组成时所有字符都小写</li><li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li><li>变量名、方法名：多单词组成时，第一个单词的首字母小写，第二个单词开始每个单词首字母大写：XxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li></ul><h3 id="1-4变量"><a href="#1-4变量" class="headerlink" title="1.4变量"></a>1.4变量</h3><ol><li><p>变量的分类</p><ol><li><p>按数据类型分类</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522100724.png"></p></li><li><p>详细说明</p><ol><li>整型：byte(1字节=8bit) \ short(2字节) \ int(4字节) \ long(8字节)<ul><li>① byte范围：-128 ~ 127</li><li>② 声明long型变量，必须以”l”或”L”结尾</li><li>③ 通常，定义整型变量时，使用int型。</li><li>④整型的常量，默认类型是：int型</li></ul></li><li>浮点型：float(4字节) \ double(8字节)<ul><li>① 浮点型，表示带小数点的数值</li><li>② float表示数值的范围比long还大</li><li>③ 定义float类型变量时，变量要以”f”或”F”结尾</li><li>④ 通常，定义浮点型变量时，使用double型。</li><li>⑤ 浮点型的常量，默认类型为：double</li></ul></li><li>字符型：char (1字符=2字节)<ul><li>① 定义char型变量，通常使用一对’’,内部只能写一个字符</li><li>② 表示方式：1.声明一个字符 2.转义字符 3.直接使用 Unicode 值来表示字符型常量</li></ul></li><li>布尔型：boolean<ul><li>① 只能取两个值之一：true 、 false</li><li>② 常常在条件判断、循环结构中使用</li></ul></li></ol></li><li><p>按声明的位置分类</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522123945.png"></p></li></ol></li><li><p>定义变量的格式</p><p> 数据类型  变量名 = 变量值;<br> 数据类型  变量名;<br> 变量名 = 变量值;</p></li><li><p>变量使用的注意点</p><ul><li>变量必须先声明，后使用</li><li>变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了</li><li>同一个作用域内，不可以声明两个同名的变量</li></ul></li><li><p>基本数据类型变量间运算规则</p><ol><li><p>涉及到的基本数据类型：除了boolean之外的其他7种</p></li><li><p>自动类型转换(只涉及7种基本数据类型）</p><p> 结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果<strong>自动提升为容量大</strong>的数据类型。</p><blockquote><p>byte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double </p><p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p><p><strong>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</strong></p></blockquote></li><li><p>强制类型转换(只涉及7种基本数据类型）：<strong>自动类型提升运算的逆运算</strong>。</p><ol><li>需要使用强转符：(类型)</li><li>注意点：强制类型转换，可能导致精度损失。</li></ol></li><li><p>String与8种基本数据类型间的运算</p><ol><li><p>String属于引用数据类型，翻译为：字符串</p></li><li><p>声明String类型变量时，使用一对””</p></li><li><p>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</p></li><li><p>运算的结果仍然是String类型</p></li></ol><p>   避免：</p><p>   String s = 123;//编译错误</p><p>   String s1 = “123”;</p><p>   int i = (int)s1;//编译错误</p></li></ol></li></ol><h3 id="1-5运算符"><a href="#1-5运算符" class="headerlink" title="1.5运算符"></a>1.5运算符</h3><ol><li><p>算数运算符： + - * / % (前)++ (后)++ (前)– (后)– </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="comment">//除号：/</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> result1 = num1 / num2;</span><br><span class="line">System.out.println(result1);<span class="comment">//2</span></span><br><span class="line"><span class="comment">// %:取余运算</span></span><br><span class="line"><span class="comment">//结果的符号与被模数的符号相同</span></span><br><span class="line"><span class="comment">//开发中，经常使用%来判断能否被除尽的情况。</span></span><br><span class="line"><span class="keyword">int</span> m1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m1 % n1 = &quot;</span> + m1 % n1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m2 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m2 % n2 = &quot;</span> + m2 % n2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m3 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n3 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m3 % n3 = &quot;</span> + m3 % n3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m4 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n4 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m4 % n4 = &quot;</span> + m4 % n4);</span><br><span class="line"><span class="comment">//(前)++ :先自增1，后运算</span></span><br><span class="line"><span class="comment">//(后)++ :先运算，后自增1</span></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = ++a1;</span><br><span class="line">System.out.println(<span class="string">&quot;a1 = &quot;</span> + a1 + <span class="string">&quot;,b1 = &quot;</span> + b1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = a2++;</span><br><span class="line">System.out.println(<span class="string">&quot;a2 = &quot;</span> + a2 + <span class="string">&quot;,b2 = &quot;</span> + b2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">++a3;<span class="comment">//a3++;</span></span><br><span class="line"><span class="keyword">int</span> b3 = a3;</span><br><span class="line"><span class="comment">//(前)-- :先自减1，后运算</span></span><br><span class="line"><span class="comment">//(后)-- :先运算，后自减1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b4 = a4--;<span class="comment">//int b4 = --a4;</span></span><br><span class="line">System.out.println(<span class="string">&quot;a4 = &quot;</span> + a4 + <span class="string">&quot;,b4 = &quot;</span> + b4);</span><br><span class="line"></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span><span class="comment">//(前)++ :先自增1，后运算</span></span><br><span class="line"> <span class="comment">//(后)++ :先运算，后自增1</span></span><br><span class="line"><span class="number">2.</span><span class="comment">//(前)-- :先自减1，后运算</span></span><br><span class="line">  <span class="comment">//(后)-- :先运算，后自减1</span></span><br><span class="line"><span class="number">3.</span>连接符：+：只能使用在String与其他数据类型变量之间使用。</span><br></pre></td></tr></table></figure></li><li><p>赋值运算符：=  +=  -=  *=  /=  %= </p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i2,j2;</span><br><span class="line"><span class="comment">//连续赋值</span></span><br><span class="line">i2 = j2 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//***************</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">10</span>,j3 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">num1 += <span class="number">2</span>;<span class="comment">//num1 = num1 + 2;</span></span><br><span class="line">System.out.println(num1);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">12</span>;</span><br><span class="line">num2 %= <span class="number">5</span>;<span class="comment">//num2 = num2 % 5;</span></span><br><span class="line">System.out.println(num2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//s1 = s1 + 2;//编译失败</span></span><br><span class="line">s1 += <span class="number">2</span>;<span class="comment">//结论：不会改变变量本身的数据类型</span></span><br><span class="line">System.out.println(s1);</span><br><span class="line"></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span>运算的结果不会改变变量本身的数据类型</span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="comment">//开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 2;</span></span><br><span class="line"><span class="comment">//方式二：num += 2; (推荐)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 1;</span></span><br><span class="line"><span class="comment">//方式二：num += 1; </span></span><br><span class="line"><span class="comment">//方式三：num++; (推荐)</span></span><br></pre></td></tr></table></figure></li><li><p>比较运算符： == != &gt;  &lt;  &gt;=  &lt;=  instanceof</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line">System.out.println(i = j);<span class="comment">//20</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(b2 == b1);<span class="comment">//false</span></span><br><span class="line">System.out.println(b2 = b1);<span class="comment">//true</span></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span>比较运算符的结果是<span class="keyword">boolean</span>类型</span><br><span class="line"><span class="number">2.</span>&gt;  &lt;  &gt;=  &lt;= :只能使用在数值类型的数据之间。</span><br><span class="line"><span class="number">3.</span> == 和 !=: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</span><br><span class="line">Account acct1 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">Account acct2 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">boolean</span> b1 = (acct1 == acct2);<span class="comment">//比较两个Account是否是同一个账户。</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = (acct1 != acct2);<span class="comment">//</span></span><br></pre></td></tr></table></figure></li><li><p>逻辑运算符：&amp; &amp;&amp;  |  || !  ^</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="comment">//区分&amp; 与 &amp;&amp;</span></span><br><span class="line"><span class="comment">//相同点1：&amp; 与  &amp;&amp; 的运算结果相同</span></span><br><span class="line"><span class="comment">//相同点2：当符号左边是true时，二者都会执行符号右边的运算</span></span><br><span class="line"><span class="comment">//不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</span></span><br><span class="line"><span class="comment">//开发中，推荐使用&amp;&amp;</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">b1 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b1 &amp; (num1++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">true</span>;</span><br><span class="line">b2 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b2 &amp;&amp; (num2++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line"><span class="comment">// 区分：| 与 || </span></span><br><span class="line"><span class="comment">//相同点1：| 与  || 的运算结果相同</span></span><br><span class="line"><span class="comment">//相同点2：当符号左边是false时，二者都会执行符号右边的运算</span></span><br><span class="line"><span class="comment">//不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</span></span><br><span class="line"><span class="comment">//开发中，推荐使用||</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = <span class="keyword">false</span>;</span><br><span class="line">b3 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b3 | (num3++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num3 = &quot;</span> + num3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b4 = <span class="keyword">false</span>;</span><br><span class="line">b4 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num4 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b4 || (num4++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num4 = &quot;</span> + num4);</span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span>逻辑运算符操作的都是<span class="keyword">boolean</span>类型的变量。而且结果也是<span class="keyword">boolean</span>类型</span><br></pre></td></tr></table></figure></li><li><p>位运算符：&lt;&lt;  &gt;&gt; &gt;&gt;&gt; &amp;  |  ^  ~</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">21</span>;</span><br><span class="line">i = -<span class="number">21</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;i &lt;&lt; 2 :&quot;</span> + (i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;i &lt;&lt; 3 :&quot;</span> + (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;i &lt;&lt; 27 :&quot;</span> + (i &lt;&lt; <span class="number">27</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m &amp; n :&quot;</span> + (m &amp; n));</span><br><span class="line">System.out.println(<span class="string">&quot;m | n :&quot;</span> + (m | n));</span><br><span class="line">System.out.println(<span class="string">&quot;m ^ n :&quot;</span> + (m ^ n));</span><br><span class="line">【面试题】 你能否写出最高效的<span class="number">2</span> * <span class="number">8</span>的实现方式？ </span><br><span class="line">答案：<span class="number">2</span> &lt;&lt; <span class="number">3</span>  或  <span class="number">8</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span> 位运算符操作的都是整型的数据</span><br><span class="line"><span class="number">2.</span> &lt;&lt; ：在一定范围内，每向左移<span class="number">1</span>位，相当于 * <span class="number">2</span></span><br><span class="line">   &gt;&gt; :在一定范围内，每向右移<span class="number">1</span>位，相当于 / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">典型题目：</span><br><span class="line"><span class="number">1.</span>交换两个变量的值。</span><br><span class="line"><span class="number">2.</span>实现<span class="number">60</span>的二进制到十六进制的转换</span><br></pre></td></tr></table></figure></li><li><p>三元运算符：(条件表达式)? 表达式1 : 表达式2</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="number">1.</span>获取两个整数的较大值</span><br><span class="line"><span class="number">2.</span>获取三个数的最大值</span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span> 说明</span><br><span class="line">① 条件表达式的结果为<span class="keyword">boolean</span>类型</span><br><span class="line">② 根据条件表达式真或假，决定执行表达式<span class="number">1</span>，还是表达式<span class="number">2.</span></span><br><span class="line">  如果表达式为<span class="keyword">true</span>，则执行表达式<span class="number">1</span>。</span><br><span class="line">  如果表达式为<span class="keyword">false</span>，则执行表达式<span class="number">2</span>。</span><br><span class="line">③ 表达式<span class="number">1</span> 和表达式<span class="number">2</span>要求是一致的。</span><br><span class="line">④ 三元运算符可以嵌套使用</span><br><span class="line"><span class="number">2.</span> 凡是可以使用三元运算符的地方，都可以改写为<span class="keyword">if</span>-<span class="keyword">else</span>，反之，不成立。</span><br><span class="line"><span class="number">3.</span> 如果程序既可以使用三元运算符，又可以使用<span class="keyword">if</span>-<span class="keyword">else</span>结构，那么优先选择三元运算符。原因：简洁、执行效率高。</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-6流程控制"><a href="#1-6流程控制" class="headerlink" title="1.6流程控制"></a>1.6流程控制</h3><ol><li><p>分支结构</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">if</span>-<span class="keyword">else</span>条件判断结构</span><br><span class="line"><span class="number">1.1</span>.</span><br><span class="line">结构一：</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构二：二选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构三：n选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span>.说明：</span><br><span class="line"><span class="number">1.</span> <span class="keyword">else</span> 结构是可选的。</span><br><span class="line"><span class="number">2.</span> 针对于条件表达式：</span><br><span class="line">   &gt; 如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。</span><br><span class="line">   &gt; 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。</span><br><span class="line">   &gt; 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。</span><br><span class="line"><span class="number">3.</span> <span class="keyword">if</span>-<span class="keyword">else</span>结构是可以相互嵌套的。</span><br><span class="line"><span class="number">4.</span> 如果<span class="keyword">if</span>-<span class="keyword">else</span>结构中的执行语句只有一行时，对应的一对&#123;&#125;可以省略的。但是，不建议大家省略。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="keyword">switch</span>-<span class="keyword">case</span>选择结构</span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">执行语句n;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>说明：</span><br><span class="line">① 根据<span class="keyword">switch</span>表达式中的值，依次匹配各个<span class="keyword">case</span>中的常量。一旦匹配成功，则进入相应<span class="keyword">case</span>结构中，调用其执行语句。</span><br><span class="line">  当调用完执行语句以后，则仍然继续向下执行其他<span class="keyword">case</span>结构中的执行语句，直到遇到<span class="keyword">break</span>关键字或此<span class="keyword">switch</span>-<span class="keyword">case</span>结构</span><br><span class="line">  末尾结束为止。</span><br><span class="line">② <span class="keyword">break</span>,可以使用在<span class="keyword">switch</span>-<span class="keyword">case</span>结构中，表示一旦执行到此关键字，就跳出<span class="keyword">switch</span>-<span class="keyword">case</span>结构</span><br><span class="line">③ <span class="keyword">switch</span>结构中的表达式，只能是如下的<span class="number">6</span>种数据类型之一：</span><br><span class="line">   <span class="keyword">byte</span> 、<span class="keyword">short</span>、<span class="keyword">char</span>、<span class="keyword">int</span>、枚举类型(JDK5<span class="number">.0</span>新增)、String类型(JDK7<span class="number">.0</span>新增)</span><br><span class="line">④ <span class="keyword">case</span> 之后只能声明常量。不能声明范围。</span><br><span class="line">⑤ <span class="keyword">break</span>关键字是可选的。</span><br><span class="line">⑥ <span class="keyword">default</span>:相当于<span class="keyword">if</span>-<span class="keyword">else</span>结构中的<span class="keyword">else</span>.  </span><br><span class="line">  <span class="keyword">default</span>结构是可选的，而且位置是灵活的。</span><br><span class="line"><span class="number">3.</span>如果<span class="keyword">switch</span>-<span class="keyword">case</span>结构中的多个<span class="keyword">case</span>的执行语句相同，则可以考虑进行合并。</span><br><span class="line"><span class="number">4.</span><span class="keyword">break</span>在<span class="keyword">switch</span>-<span class="keyword">case</span>中是可选的</span><br></pre></td></tr></table></figure></li><li><p>循环结构</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>循环结构的四要素</span><br><span class="line">① 初始化条件</span><br><span class="line">② 循环条件  ---&gt;是<span class="keyword">boolean</span>类型</span><br><span class="line">③ 循环体</span><br><span class="line">④ 迭代条件</span><br><span class="line">说明：通常情况下，循环结束都是因为②中循环条件返回<span class="keyword">false</span>了。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>三种循环结构：</span><br><span class="line"><span class="number">2.1</span> <span class="keyword">for</span>循环结构</span><br><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">③</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"><span class="number">2.2</span> <span class="keyword">while</span>循环结构</span><br><span class="line">①</span><br><span class="line"><span class="keyword">while</span>(②)&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line">说明：</span><br><span class="line">写<span class="keyword">while</span>循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>和<span class="keyword">while</span>循环总结：</span><br><span class="line"><span class="number">1.</span> 开发中，基本上我们都会从<span class="keyword">for</span>、<span class="keyword">while</span>中进行选择，实现循环结构。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">for</span>循环和<span class="keyword">while</span>循环是可以相互转换的！ </span><br><span class="line">  区别：<span class="keyword">for</span>循环和<span class="keyword">while</span>循环的初始化条件部分的作用范围不同。</span><br><span class="line"><span class="number">3.</span> 我们写程序，要避免出现死循环。</span><br><span class="line"><span class="number">2.3</span> <span class="keyword">do</span>-<span class="keyword">while</span>循环结构</span><br><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br><span class="line">执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="number">1.</span><span class="keyword">do</span>-<span class="keyword">while</span>循环至少会执行一次循环体！</span><br><span class="line"><span class="number">2.</span>开发中，使用<span class="keyword">for</span>和<span class="keyword">while</span>更多一些。较少使用<span class="keyword">do</span>-<span class="keyword">while</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>“无限循环”结构: <span class="keyword">while</span>(<span class="keyword">true</span>) 或 <span class="keyword">for</span>(;;)</span><br><span class="line">总结：如何结束一个循环结构？</span><br><span class="line">方式一：当循环条件是<span class="keyword">false</span>时</span><br><span class="line">方式二：在循环体中，执行<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>嵌套循环</span><br><span class="line"><span class="number">1.</span>嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环</span><br><span class="line">  内层循环：循环结构A</span><br><span class="line">  外层循环：循环结构B</span><br><span class="line"><span class="number">2.</span>说明：</span><br><span class="line">① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</span><br><span class="line">② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次</span><br><span class="line">③ 外层循环控制行数，内层循环控制列数</span><br><span class="line">【典型练习】</span><br><span class="line"><span class="comment">//练习一：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">4</span>;j++ )&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">6</span>;i++)&#123;</span><br><span class="line">System.out.print(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//练习二：</span></span><br><span class="line"><span class="comment">/*i(行号)j(*的个数)</span></span><br><span class="line"><span class="comment">*11</span></span><br><span class="line"><span class="comment">**22</span></span><br><span class="line"><span class="comment">***33</span></span><br><span class="line"><span class="comment">****44</span></span><br><span class="line"><span class="comment">*****55</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;<span class="comment">//控制行数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)&#123;<span class="comment">//控制列数</span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//练习三：九九乘法表</span></span><br><span class="line"><span class="comment">//练习四：100以内的质数</span></span><br><span class="line"></span><br><span class="line">补充:衡量一个功能代码的优劣：</span><br><span class="line"><span class="number">1.</span>正确性</span><br><span class="line"><span class="number">2.</span>可读性</span><br><span class="line"><span class="number">3.</span>健壮性</span><br><span class="line"><span class="number">4.</span>高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</span><br><span class="line"></span><br><span class="line">如何理解流程控制的练习：</span><br><span class="line">流程控制结构的使用 + 算法逻辑</span><br></pre></td></tr></table></figure></li><li><p>关键字：break和continue</p><table><thead><tr><th></th><th>使用范围</th><th>循环中使用的作用(不同点)</th><th>相同点</th></tr></thead><tbody><tr><td>break</td><td>switch-case循环结构中</td><td>结束当前循环</td><td>关键字后面不能声明执行语句</td></tr><tr><td>continue</td><td>循环结构中</td><td>结束当次循环</td><td>关键字后面不能声明执行语句</td></tr></tbody></table><p> 补充：带标签的break和continue的使用</p><p> ​            return在方法中使用。</p></li><li><p>补充：Scanner类的使用</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何从键盘获取不同类型的变量：需要使用Scanner类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">具体实现步骤：</span></span><br><span class="line"><span class="comment">1.导包：import java.util.Scanner;</span></span><br><span class="line"><span class="comment">2.Scanner的实例化:Scanner scan = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">3.调用Scanner类的相关方法（next() / nextXxx()），来获取指定类型的变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException</span></span><br><span class="line"><span class="comment">导致程序终止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.导包：import java.util.Scanner;</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//2.Scanner的实例化</span></span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.调用Scanner类的相关方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的姓名：&quot;</span>);</span><br><span class="line">String name = scan.next();</span><br><span class="line">System.out.println(name);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的芳龄：&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> age = scan.nextInt();</span><br><span class="line">System.out.println(age);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的体重：&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> weight = scan.nextDouble();</span><br><span class="line">System.out.println(weight);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;你是否相中我了呢？(true/false)&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> isLove = scan.nextBoolean();</span><br><span class="line">System.out.println(isLove);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的性别：(男/女)&quot;</span>);</span><br><span class="line">String gender = scan.next();<span class="comment">//&quot;男&quot;</span></span><br><span class="line"><span class="keyword">char</span> genderChar = gender.charAt(<span class="number">0</span>);<span class="comment">//获取索引为0位置上的字符</span></span><br><span class="line">System.out.println(genderChar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h3 id="2-1一维数组"><a href="#2-1一维数组" class="headerlink" title="2.1一维数组"></a>2.1一维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>一维数组的声明与初始化</span><br><span class="line">正确的方式：</span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//声明</span></span><br><span class="line">num = <span class="number">10</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">1001</span>;<span class="comment">//声明 + 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line"><span class="comment">//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line"><span class="comment">//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">String[] names = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">错误的方式：</span><br><span class="line"><span class="comment">//int[] arr1 = new int[];</span></span><br><span class="line"><span class="comment">//int[5] arr2 = new int[5];</span></span><br><span class="line"><span class="comment">//int[] arr3 = new int[3]&#123;1,2,3&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>一维数组元素的引用：通过角标的方式调用。</span><br><span class="line"><span class="comment">//数组的角标（或索引从0开始的，到数组的长度-1结束。</span></span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;王铭&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;王赫&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;张学良&quot;</span>;</span><br><span class="line">names[<span class="number">3</span>] = <span class="string">&quot;孙居龙&quot;</span>;</span><br><span class="line">names[<span class="number">4</span>] = <span class="string">&quot;王宏志&quot;</span>;<span class="comment">//charAt(0)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数组的属性：length</span><br><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br><span class="line">System.out.println(ids.length);</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">数组一旦初始化，其长度就是确定的。arr.length</span><br><span class="line">数组长度一旦确定，就不可修改。</span><br><span class="line"><span class="number">4.</span>一维数组的遍历</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; names.length;i++)&#123;</span><br><span class="line">System.out.println(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>一维数组元素的默认初始化值</span><br><span class="line">&gt; 数组元素是整型：<span class="number">0</span></span><br><span class="line"> * &gt; 数组元素是浮点型：<span class="number">0.0</span></span><br><span class="line"> * &gt; 数组元素是<span class="keyword">char</span>型：<span class="number">0</span>或<span class="string">&#x27;\u0000&#x27;</span>，而非<span class="string">&#x27;0&#x27;</span></span><br><span class="line"> * &gt; 数组元素是<span class="keyword">boolean</span>型：<span class="keyword">false</span></span><br><span class="line"> * </span><br><span class="line"> * &gt; 数组元素是引用数据类型：<span class="keyword">null</span></span><br><span class="line"><span class="number">6.</span>一维数组的内存解析</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130221.png"></p><h3 id="2-2二维数组"><a href="#2-2二维数组" class="headerlink" title="2.2二维数组"></a>2.2二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>如何理解二维数组？</span><br><span class="line">数组属于引用数据类型</span><br><span class="line">数组的元素也可以是引用数据类型</span><br><span class="line">一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>二维数组的声明与初始化</span><br><span class="line">正确的方式：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一维数组</span></span><br><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//动态初始化1</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//动态初始化2</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];</span><br><span class="line"><span class="comment">//也是正确的写法：</span></span><br><span class="line"><span class="keyword">int</span>[] arr4[] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;<span class="comment">//类型推断</span></span><br><span class="line">错误的方式：</span><br><span class="line"><span class="comment">//String[][] arr4 = new String[][4];</span></span><br><span class="line"><span class="comment">//String[4][3] arr5 = new String[][];</span></span><br><span class="line"><span class="comment">//int[][] arr6 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span></span><br><span class="line"><span class="number">3.</span>如何调用二维数组元素:</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>]);<span class="comment">//</span></span><br><span class="line"><span class="number">4.</span>二维数组的属性：</span><br><span class="line">System.out.println(arr4.length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">0</span>].length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">1</span>].length);<span class="comment">//4</span></span><br><span class="line"><span class="number">5.</span>遍历二维数组元素</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr4.length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr4[i].length;j++)&#123;</span><br><span class="line">System.out.print(arr4[i][j] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>二维数组元素的默认初始化值</span><br><span class="line"> * 规定：二维数组分为外层数组的元素，内层数组的元素</span><br><span class="line"> * <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"> * 外层元素：arr[<span class="number">0</span>],arr[<span class="number">1</span>]等</span><br><span class="line"> * 内层元素：arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">2</span>]等</span><br><span class="line"> * </span><br><span class="line"> *   ⑤ 数组元素的默认初始化值 </span><br><span class="line"> *   针对于初始化方式一：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"> *      外层元素的初始化值为：地址值</span><br><span class="line"> *      内层元素的初始化值为：与一维数组初始化情况相同</span><br><span class="line"> *      </span><br><span class="line"> *   针对于初始化方式二：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line"> *   外层元素的初始化值为：<span class="keyword">null</span></span><br><span class="line"> *      内层元素的初始化值为：不能调用，否则报错。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>二维数组的内存结构</span><br></pre></td></tr></table></figure><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130249.png"></p><h3 id="2-3常见算法"><a href="#2-3常见算法" class="headerlink" title="2.3常见算法"></a>2.3常见算法</h3><ol><li><p>数组的创建与元素赋值：</p><p> 杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p></li><li><p>针对于数值型的数组：</p><p> 最大值、最小值、总和、平均数等</p></li><li><p>数组的赋值与复制</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1,array2;</span><br><span class="line">array1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p> 3.1 赋值：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2 = array1;</span><br></pre></td></tr></table></figure><p> 如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130448.png"><br> 3.2 复制：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2 = <span class="keyword">new</span> <span class="keyword">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array2.length;i++)&#123;</span><br><span class="line">array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130705.png"></p><p> 如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</p></li><li><p>数组元素的反转</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length / <span class="number">2</span>;i++)&#123;</span><br><span class="line">    String temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">    arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">    String temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组中指定元素的查找：搜索、检索</p><p> 5.1 线性查找： </p><p> 实现思路：通过遍历的方式，一个一个的数据进行比较、查找。</p><p> 适用性：具有普遍适用性。</p><p> 5.2 二分法查找：</p><p> 实现思路：每次比较中间值，折半的方式检索。</p><p> 适用性：（前提：数组必须有序）</p></li><li><p>数组的排序算法</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130852.png"></p><p> 理解：</p><p> 1）衡量排序算法的优劣：时间复杂度、空间复杂度、稳定性</p><p> 2）排序的分类：内部排序 与 外部排序（需要借助于磁盘）</p><p> 3）不同排序算法的时间复杂度</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130927.png"></p><p> 4）手写冒泡排序</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">43</span>,<span class="number">32</span>,<span class="number">76</span>,-<span class="number">98</span>,<span class="number">0</span>,<span class="number">64</span>,<span class="number">33</span>,-<span class="number">21</span>,<span class="number">32</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-4Arrays工具类"><a href="#2-4Arrays工具类" class="headerlink" title="2.4Arrays工具类"></a>2.4Arrays工具类</h3><ol><li><p>理解：</p><p> ① 定义在java.util包下。</p><p> ② Arrays:提供了很多操作数组的方法。</p></li><li><p>使用：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.boolean equals(int[] a,int[] b):判断两个数组是否相等。</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> isEquals = Arrays.equals(arr1, arr2);</span><br><span class="line">System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.String toString(int[] a):输出数组信息。</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.void fill(int[] a,int val):将指定值填充到数组之中。</span></span><br><span class="line">Arrays.fill(arr1,<span class="number">10</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.void sort(int[] a):对数组进行排序。</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.int binarySearch(int[] a,int key)</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(arr3, <span class="number">210</span>);</span><br><span class="line"><span class="keyword">if</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-5常见异常"><a href="#2-5常见异常" class="headerlink" title="2.5常见异常"></a>2.5常见异常</h3><ol><li><p>数组角标越界异常：ArrayIndexOutOfBoundsException</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(arr[-<span class="number">2</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>空指针异常：NullPointerException</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line"><span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">System.out.println(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况三：</span></span><br><span class="line">String[] arr3 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>].toString());</span><br></pre></td></tr></table></figure><p> 小知识：一旦程序出现异常，未处理时，就终止执行。</p></li></ol><h2 id="3-面向对象（上）"><a href="#3-面向对象（上）" class="headerlink" title="3.面向对象（上）"></a>3.面向对象（上）</h2><h3 id="3-1类与对象"><a href="#3-1类与对象" class="headerlink" title="3.1类与对象"></a>3.1类与对象</h3><ol><li><p>面向对象学习的三条主线：</p><ol><li>Java类及类的成员：属性、方法、构造器；代码块、内部类</li><li>面向对象的大特征：封装性、继承性、多态性、(抽象性)</li><li>其它关键字：this、super、static、final、abstract、interface、package、import等</li></ol></li><li><p>面向对象与面向过程（理解）</p><ol><li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li><li>面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li></ol></li><li><p>完成一个项目（或功能）的思路：</p><ul><li>根据问题需要，选择问题所针对的现实世界中的实体</li><li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类</li><li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。</li><li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。</li></ul></li><li><p>面向对象中两个重要的概念：</p><p> 类：对一类事物的描述，是抽象的、概念上的定义</p><p> 对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)</p><p> ​            面向对象程序设计的重点是类的设计，设计类，就是设计类的成员。</p><p> 二者的关系：对象，是由类new出来的，派生出来的。</p></li><li><p>面向对象思想落地实现的规则一</p><ol><li>创建类，设计类的成员</li><li>创建类的对象</li><li>通过“对象.属性”或“对象.方法”调用对象的结构</li></ol><p> 补充：几个概念的使用说明</p><ol><li>属性 = 成员变量 = field = 域、字段</li><li>方法 = 成员方法 = 函数 = method</li><li>创建类的对象 = 类的实例化 = 实例化类</li></ol></li><li><p>对象的创建与对象的内存解析</p><p> 典型代码：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p3 = p1;<span class="comment">//没有新创建一个对象，共用一个堆空间中的对象实体。</span></span><br></pre></td></tr></table></figure><p> 说明：</p><p> ​        如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）<br> 意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</p><p> 内存解析：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522151443.png"></p><p> <img src="E:\GitHubBlog\fangchenyong.github.io\Hexo\source_posts\基础.assets\1590131692254.png" alt="1590131692254"></p></li><li><p>匿名对象:我们创建的对象，没显式的赋给一个变量名。即为匿名对象</p><p> 特点：匿名对象只能调用一次。</p><p> 举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line"><span class="keyword">new</span> Phone().playGame();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">new</span> Phone().showPrice();<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure><p> 应用场景：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象的使用</span></span><br><span class="line">mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">其中，</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">phone.sendEmail();</span><br><span class="line">phone.playGame();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>理解”万事万物皆对象”</p><ol><li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构<ul><li>Scanner,String等</li><li>文件：File</li><li>网络资源：URL</li></ul></li><li>涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</li></ol></li><li><p>JVM内存结构简述</p><p> 编译完源程序以后，生成一个或多个字节码文件。</p><p> 我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节</p><p> 码文件对应的类加载到内存中，涉及到内存解析。</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522151721.png"></p><p> 虚拟机栈：即为平时提到的栈结构。</p><p> 我们将局部变量存储在栈结构中堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。</p><p> 补充：对象的属性（非static的）加载在堆空间中。</p><p> 方法区：类的加载信息、常量池、静态域</p></li></ol><h3 id="3-2类的结构之一：属性"><a href="#3-2类的结构之一：属性" class="headerlink" title="3.2类的结构之一：属性"></a>3.2类的结构之一：属性</h3><p>对比：属性  vs  局部变量</p><ul><li><p>相同点</p><ol><li>定义变量的格式：数据类型  变量名 = 变量值</li><li>先声明，后使用</li><li>变量都其对应的作用域</li></ol></li><li><p>不同点</p><ol><li><p>在类中声明的位置的不同</p><ul><li>属性：直接定义在类的一对{}内</li><li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li></ul></li><li><p>关于权限修饰符的不同</p><ul><li><p>属性：可以在声明属性时，指明其权限，使用权限修饰符。</p><p>  ​            常用的权限修饰符：private、public、缺省、protected  —&gt;封装性</p></li><li><p>局部变量：不可以使用权限修饰符。</p></li></ul></li><li><p>默认初始化值的情况：</p><ul><li><p>属性：类的属性，根据其类型，都默认初始化值。</p><ul><li>整型（byte、short、int、long：0）</li><li>浮点型（float、double：0.0）</li><li>字符型（char：0  （或’\u0000’））</li><li>布尔型（boolean：false）</li><li>引用数据类型（类、数组、接口：null）</li></ul></li><li><p>局部变量：没默认初始化值。</p><p>  ​                    意味着，我们在调用局部变量之前，一定要显式赋值。</p><p>  ​                    特别地：形参在调用时，我们赋值即可。</p></li></ul></li><li><p>在内存中加载的位置：</p><ul><li>属性：加载到堆空间中   （非static）</li><li>局部变量：加载到栈空间</li></ul></li></ol></li></ul><h3 id="3-3类的结构之二：方法"><a href="#3-3类的结构之二：方法" class="headerlink" title="3.3类的结构之二：方法"></a>3.3类的结构之二：方法</h3><ol><li><p>方法的声明：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法的声明：权限修饰符  返回值类型  方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关键字：return</p><ul><li>使用范围：使用在方法体中</li><li>作用：<ul><li> 结束方法</li><li> 针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</li></ul></li><li>注意点：return关键字后面不可以声明执行语句。</li></ul></li><li><p>方法的重载</p><ol><li><p>概念</p><p> 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p><p> <strong>总结：”两同一不同”:同一个类、相同方法名</strong></p><p> ​            <strong>参数列表不同：参数个数不同，参数类型不同</strong></p></li><li><p>构成重载的举例：</p><p> 举例一：Arrays类中重载的sort() / binarySearch()；PrintStream中的println()</p><p> 举例二：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如下的4个方法构成了重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">double</span> d1,<span class="keyword">double</span> d2)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(String s ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,String s)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何判断是否构成方法的重载？</p><p> 严格按照定义判断：两同一不同。</p><p> <strong>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</strong></p></li><li><p>如何确定类中某一个方法的调用：</p><p> 方法名 —&gt; 参数列表</p><p> 面试题：方法的重载与重写的区别？</p><blockquote><p>throws\throw<br>String\StringBuffer\StringBuilder<br>Collection\Collections<br>final\finally\finalize<br>…</p></blockquote><blockquote><p>抽象类、接口<br>sleep() / wait()</p></blockquote></li></ol></li><li><p>可变个数形参的方法</p><ol><li><p>使用说明：</p><ol><li>jdk 5.0新增的内容</li><li>具体使用：<ul><li>可变个数形参的格式：数据类型 … 变量名</li><li>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</li><li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li><li>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</li><li>可变个数形参在方法的形参中，必须声明在末尾</li><li>可变个数形参在方法的形参中,最多只能声明一个可变形参。</li></ul></li></ol></li><li><p>举例说明</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String ... strs)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String ... strs)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用时：</span></span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">test.show();</span><br><span class="line"></span><br><span class="line">test.show(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>java 的值传递机制</p><ol><li><p>针对于方法内变量的赋值举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;***********基本数据类型：****************&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n = m;</span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;***********引用数据类型：****************&quot;</span>);</span><br><span class="line">Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">o1.orderId = <span class="number">1001</span>;</span><br><span class="line">Order o2 = o1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br><span class="line"></span><br><span class="line">o2.orderId = <span class="number">1002</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br></pre></td></tr></table></figure><p> 规则：</p><p> ​        如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</p><p> ​        如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p></li><li><p>针对于方法的参数概念</p><p> 形参：方法定义时，声明的小括号内的参数</p><p> 实参：方法调用时，实际传递给形参的数据</p></li><li><p>java中参数传递机制：值传递</p><p> 规则：</p><p> ​        如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</p><p> ​        如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</p></li><li><p>典型例题与内存解析：</p><ul><li><p>【例题1】</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522155534.png"></p></li><li><p>【例题2】</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522155539.png"></p></li></ul></li></ol></li><li><p>递归方法</p><ol><li><p>定义：递归方法：一个方法体内调用它自身。</p></li><li><p>如何理解递归方法？</p><ul><li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</li><li>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</li></ul></li><li><p>举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="3-4面向对象的特征一：封装性"><a href="#3-4面向对象的特征一：封装性" class="headerlink" title="3.4面向对象的特征一：封装性"></a>3.4面向对象的特征一：封装性</h3><ol><li><p>为什么要引入封装性？</p><p> 我们程序设计追求“高内聚，低耦合”。</p><ul><li><p>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</p></li><li><p>低耦合 ：仅对外暴露少量的方法用于使用。</p></li></ul><p> 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p></li><li><p>问题引入：</p><p> 当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).</p><p> 此时，针对于属性就体现了封装性。</p></li><li><p>封装性思想具体的代码体现：</p><ul><li><p>体现一：将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>体现二：不对外暴露的私有的方法</p></li><li><p>体现三：单例模式（将构造器私有化）</p></li><li><p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的。</p></li></ul></li><li><p>Java规定的四种权限修饰符</p><ol><li><p>权限从小到大顺序为：private &lt;  缺省 &lt; protected &lt; public</p></li><li><p>具体的修饰范围：</p><table><thead><tr><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr><tr><td>（缺省）</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table></li><li><p>权限修饰符可用来修饰的结构说明：</p><p> 4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p><p> 修饰类的话，只能使用：缺省、public</p></li></ol></li></ol><h3 id="3-5类的结构之三：构造器"><a href="#3-5类的结构之三：构造器" class="headerlink" title="3.5类的结构之三：构造器"></a>3.5类的结构之三：构造器</h3><ol><li><p>构造器（或构造方法）：Constructor</p><p> 构造器的作用：</p><ul><li>1.创建对象</li><li>2.初始化对象的信息</li></ul></li><li><p>使用说明：</p><ul><li>1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</li><li>2.定义构造器的格式：权限修饰符  类名(形参列表){}</li><li>3.一个类中定义的多个构造器，彼此构成重载</li><li>4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li><li>5.一个类中，至少会有一个构造器。</li></ul></li><li><p>举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person().....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性赋值顺序</p><ol><li>默认初始化</li><li>显式初始化</li><li>构造器中初始化</li><li>通过”对象.方法” 或 “对象.属性”的方式，赋值</li></ol><p> 以上操作的先后顺序：① - ② - ③ - ④ </p></li><li><p>JavaBean的概念</p><p> 所谓JavaBean，是指符合如下标准的Java类：</p><ul><li>类是公共的</li><li>一个无参的公共的构造器</li><li>属性，且对应的get、set方法</li></ul></li></ol><h3 id="3-6关键词：this"><a href="#3-6关键词：this" class="headerlink" title="3.6关键词：this"></a>3.6关键词：this</h3><ol><li><p>可以调用的结构：属性、方法；构造器</p></li><li><p>this调用属性、方法：</p><p> this理解为：当前对象  或 当前正在创建的对象</p><ul><li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li><li>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li></ul></li><li><p>this调用构造器：</p><ol><li>我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器</li><li>构造器中不能通过”this(形参列表)”方式调用自己</li><li>如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</li><li>规定：”this(形参列表)”必须声明在当前构造器的首行</li><li>构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器</li></ol></li></ol><h3 id="3-7关键词：package-import"><a href="#3-7关键词：package-import" class="headerlink" title="3.7关键词：package/import"></a>3.7关键词：package/import</h3><p><strong>package</strong></p><ol><li><p>使用说明：</p><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用package声明类或接口所属的包，声明在源文件的首行</li><li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li><li>每”.”一次，就代表一层文件目录。</li></ol></li><li><p>举例：</p><ul><li><p>举例一：</p><p>  某航运软件系统包括：一组域对象、GUI和reports子系统</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161002.png"></p></li><li><p>举例二：MVC设计模式</p><p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161017.png"></p></li></ul></li><li><p>JDK中的主要包介绍：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161042.png"></p></li></ol><p><strong>import</strong></p><h2 id="4-面向对象（中）"><a href="#4-面向对象（中）" class="headerlink" title="4.面向对象（中）"></a>4.面向对象（中）</h2><h3 id="4-1面向对象的特征二：继承性"><a href="#4-1面向对象的特征二：继承性" class="headerlink" title="4.1面向对象的特征二：继承性"></a>4.1面向对象的特征二：继承性</h3><ol><li><p>为什么要有类的继承性？(继承性的好处）</p><ol><li>减少了代码的冗余，提高了代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用，提供了前提</li></ol><p> 图示：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161542.png"></p></li><li><p>继承性的格式：</p><p> <code>class A extends B&#123;&#125;</code></p><p> A:子类、派生类、subclass</p><p> B:父类、超类、基类、superclass</p></li><li><p>子类继承父类以后有哪些不同？</p><ul><li><p>体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。</p><p>  特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。</p></li><li><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。</p><p>  子类和父类的关系，不同于子集和集合的关系。</p><p>  extends：延展、扩展</p></li></ul></li><li><p>Java中继承性的说明</p><ol><li>一个类可以被多个子类继承。</li><li>Java中类的单继承性：一个类只能有一个父类</li><li>子父类是相对的概念。</li><li>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</li><li>子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</li></ol><p> 图示：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161347.png"></p></li><li><p>java.lang.Object类的理解</p><ol><li>如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li><li>所有的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类</li><li>意味着，所的java类具有java.lang.Object类声明的功能。</li></ol></li></ol><h3 id="4-2方法的重写"><a href="#4-2方法的重写" class="headerlink" title="4.2方法的重写"></a>4.2方法的重写</h3><ol><li><p>什么是方法的重写(override 或 overwrite)？</p><p> 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。</p></li><li><p>应用：</p><p> 重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p></li><li><p>举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> <span class="keyword">extends</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求表面积</span></span><br><span class="line">&#125;</span><br><span class="line">***************</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckAccount</span> <span class="keyword">extends</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写的规则：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法的声明： 权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p><ol><li><p>① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</p></li><li><p>② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</p><p> 特殊情况：子类不能重写父类中声明为private权限的方法</p></li><li><p>返回值类型：</p><ul><li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li><li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li><li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</li></ul></li><li><p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p></li></ol><p> 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。</p></li><li><p>面试题：</p><p> 区分方法的重写和重载？</p><p> 答：</p><ol><li><p>二者的概念：</p></li><li><p>重载和重写的具体规则</p></li><li><p>重载：不表现为多态性。</p><p> 重写：表现为多态性。</p></li></ol><p> 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p><p> 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</p><p> 而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 </p><p> 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</p></li></ol><h3 id="4-3关键字：super"><a href="#4-3关键字：super" class="headerlink" title="4.3关键字：super"></a>4.3关键字：super</h3><ol><li>super 关键字可以理解为：父类的</li><li>可以用来调用的结构：属性、方法、构造器</li><li>super调用属性、方法：<ol><li>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</li><li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li><li>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li></ol></li><li>super调用构造器：<ol><li>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li><li>“super(形参列表)”的使用，必须声明在子类构造器的首行！</li><li>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二一，不能同时出现</li><li>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</li><li>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</li></ol></li></ol><h3 id="4-4子类对象实例化全过程"><a href="#4-4子类对象实例化全过程" class="headerlink" title="4.4子类对象实例化全过程"></a>4.4子类对象实例化全过程</h3><ol><li><p>从结果上看：继承性</p><ul><li>子类继承父类以后，就获取了父类中声明的属性或方法。</li><li>创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</li></ul></li><li><p>从过程上看：</p><p> 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</p><p> 图示：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164236.png"></p></li><li><p>强调说明：</p><p> 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164256.png"></p></li></ol><h3 id="4-5面向对象的特征三：多态性"><a href="#4-5面向对象的特征三：多态性" class="headerlink" title="4.5面向对象的特征三：多态性"></a>4.5面向对象的特征三：多态性</h3><ol><li><p>多态性的理解：可以理解为一个事物的多种形态。</p></li><li><p>何为多态性：</p><p> 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p><p> 举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Man();</span><br><span class="line">Object obj = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure></li><li><p>多态性的使用：虚拟方法调用</p><p> 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p><p> <strong>总结：编译，看左边；运行，看右边。</strong></p></li><li><p>多态性的使用前提：</p><ol><li>类的继承关系</li><li>方法的重写</li></ol></li><li><p>多态性的应用举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例一：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal animal)</span></span>&#123;<span class="comment">//Animal animal = new Dog();</span></span><br><span class="line">animal.eat();</span><br><span class="line">animal.shout();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//举例二：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//举例三：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doData</span><span class="params">(Connection conn)</span></span>&#123;<span class="comment">//conn = new MySQlConnection(); / conn = new OracleConnection();</span></span><br><span class="line"><span class="comment">//规范的步骤去操作数据</span></span><br><span class="line"><span class="comment">//conn.method1();</span></span><br><span class="line"><span class="comment">//conn.method2();</span></span><br><span class="line"><span class="comment">//conn.method3();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多态性使用的注意点：</p><p> <strong>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</strong></p></li><li><p>关于向上转型与向下转型：</p><ol><li><p>向上转型：多态</p></li><li><p>向下转型：</p><ol><li><p>为什么使用向下转型：</p><p> 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。</p></li><li><p>如何实现向下转型：</p><p> 使用强制类型转换符：()</p></li><li><p>使用时的注意点：</p><ol><li>使用强转时，可能出现ClassCastException的异常。</li><li>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</li></ol></li><li><p>instanceof的使用：</p><ol><li>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</li><li>如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。</li><li>要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</li></ol></li><li><p>图示：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164521.png"></p></li></ol></li></ol></li><li><p>面试题：</p><ol><li><p>谈谈你对多态性的理解？</p><ul><li><p>实现代码的通用性。</p></li><li><p>Object类中定义的public boolean equals(Object obj){  }</p><p>  JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)</p></li><li><p>抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</p></li></ul></li><li><p>多态是编译时行为还是运行时行为？</p></li></ol></li></ol><h3 id="4-6Object类的使用"><a href="#4-6Object类的使用" class="headerlink" title="4.6Object类的使用"></a>4.6Object类的使用</h3><ol><li><p>java.lang.Object类的说明：</p><ol><li><p>Object类是所Java类的根父类</p></li><li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 </p></li><li><p>Object类中的功能(属性、方法)就具通用性。</p><p>属性：无</p><p>方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()</p><p>wait() 、 notify()、notifyAll()</p></li><li><p>Object类只声明了一个空参的构造器</p></li></ol></li><li><p>equals()方法</p><ol><li><p>equals()的使用：</p><ol><li><p>是一个方法，而非运算符</p></li><li><p>只能适用于引用数据类型</p></li><li><p>Object类中equals()的定义：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p></li><li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是</p><p> 两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p></li><li><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相</p><p> 同。那么，我们就需要对Object类中的equals()进行重写.</p><p> 重写的原则：比较两个对象的实体内容是否相同.</p></li></ol></li><li><p>如何重写equals()</p><p> 手动重写举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//重写其equals()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">this</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">User u = (User)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == u.age &amp;&amp; <span class="keyword">this</span>.name.equals(u.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回顾 == 运算符的使用：</p><p> == ：运算符</p><ul><li><p>可以使用在基本数据类型变量和引用数据类型变量中</p></li><li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p><p>  如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p></li></ul><p> 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。</p></li></ol></li><li><p>toString()方法</p><ol><li><p>toString()的使用：</p><ol><li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p></li><li><p>Object类中toString()的定义：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息</p></li><li><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p></li></ol></li><li><p>如何重写toString()</p><p> 举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Customer [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>面试题：</p><ul><li>final、finally、finalize的区别？</li><li>== 和 equals() 区别</li></ul></li></ol><h3 id="4-7单元测试方法"><a href="#4-7单元测试方法" class="headerlink" title="4.7单元测试方法"></a>4.7单元测试方法</h3><p>Java中的JUnit单元测试</p><p>步骤：</p><ol><li><p>选中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步</p></li><li><p>创建Java类，进行单元测试。</p><p> 此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p></li><li><p>此类中声明单元测试方法。</p><p> 此时的单元测试方法：方法的权限是public,没返回值，没形参</p></li><li><p>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p></li><li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p></li><li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p></li></ol><p>说明：</p><ol><li>如果执行结果没任何异常：绿条</li><li>如果执行结果出现异常：红条</li></ol><h3 id="4-8包装类的使用"><a href="#4-8包装类的使用" class="headerlink" title="4.8包装类的使用"></a>4.8包装类的使用</h3><ol><li><p>为什么要有包装类(或封装类）</p><p> 为了使基本数据类型的变量具有类的特征，引入包装类。</p></li><li><p>基本数据类型与对应的包装类：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522165706.png"></p></li><li><p>需要掌握的类型间的转换：（基本数据类型、包装类、String）</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522165718.png"></p><p> 简易版：</p><ul><li><p>基本数据类型&lt;—&gt;包装类：JDK 5.0 新特性：自动装箱 与自动拆箱</p></li><li><p>基本数据类型、包装类—&gt;String:调用String重载的valueOf(Xxx xxx)</p></li><li><p>String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)</p><p>   注意：转换时，可能会报NumberFormatException</p></li></ul><p> 应用场景举例：</p><p> ​        Vector类中关于添加元素，只定义了形参为Object类型的方法：</p><p> v.addElement(Object obj);   //基本数据类型 —&gt;包装类 —&gt;使用多态</p></li></ol><h2 id="5-面向对象（下）"><a href="#5-面向对象（下）" class="headerlink" title="5.面向对象（下）"></a>5.面向对象（下）</h2><h3 id="5-1关键字：static"><a href="#5-1关键字：static" class="headerlink" title="5.1关键字：static"></a>5.1关键字：static</h3><ol><li><p>可以用来修饰的结构：主要用来修饰类的内部结构</p><p> 属性、方法、代码块、内部类</p></li><li><p>static修饰属性：静态变量（或类变量）</p><ul><li><p>属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)</p><ul><li><p>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</p></li><li><p>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p></li></ul></li><li><p>static修饰属性的其他说明：</p><ol><li><p>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</p></li><li><p>静态变量的加载要早于对象的创建。</p></li><li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p></li><li><table><thead><tr><th></th><th>类变量</th><th>实例变量</th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table></li></ol></li><li><p>静态属性举例：System.out; Math.PI;</p></li></ul></li><li><p>静态变量内存解析：</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200529173043.png"></p></li><li><p>static修饰方法：静态方法、类方法</p><ol><li><p>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</p></li><li><table><thead><tr><th></th><th>静态方法</th><th>非静态方法</th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table></li><li><p>静态方法中，只能调用静态的方法或属性</p><p> 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p></li></ol></li><li><p>static的注意点：</p><ol><li>在静态的方法内，不能使用this关键字、super关键字</li><li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</li></ol></li><li><p>如何判定属性和方法应该使用static关键字：</p><ol><li>关于属性<ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li><li>类中的常量也常常声明为static</li></ul></li><li>关于方法<ul><li>操作静态属性的方法，通常设置为static的</li><li>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li></ul></li></ol></li><li><p>使用举例：</p><ol><li><p> 举例一：Arrays、Math、Collections等工具类</p></li><li><p>举例二：单例模式</p></li><li><p>举例三：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//自动赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = init++;</span><br><span class="line">        total++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="comment">//id = init++;</span></span><br><span class="line">        <span class="comment">//total++;</span></span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total;<span class="comment">//记录创建的圆的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> init = <span class="number">1001</span>;<span class="comment">//static声明的属性被所对象所共享</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>涉及设计模式–&gt;单例模式</p><ol><li><p>设计模式</p><ol><li><p>设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。</p></li><li><p>常用设计模式  — 23种经典的设计模式  GOF</p><blockquote><p>创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 </p></blockquote></li></ol></li><li><p>单例模式</p><ol><li><p>要解决的问题</p><p> 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p></li><li><p>具体代码的实现</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">饿汉式<span class="number">1</span>：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.内部创建类的对象</span></span><br><span class="line"><span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">饿汉式<span class="number">2</span>：使用了静态代码块</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Order();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">懒汉式：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">instance = <span class="keyword">new</span> Order();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两种方式的对比</p><ul><li>饿汉式：<ul><li>坏处：对象加载时间过长。</li><li>好处：饿汉式是线程安全的</li></ul></li><li>懒汉式：<ul><li>好处：延迟对象的创建。</li><li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li></ul></li></ul></li></ol></li></ol></li></ol><h3 id="5-2main-的使用说明"><a href="#5-2main-的使用说明" class="headerlink" title="5.2main()的使用说明"></a>5.2main()的使用说明</h3><blockquote><ul><li><ol><li>main()方法作为程序的入口</li></ol></li><li><ol start="2"><li>main()方法也是一个普通的静态方法</li></ol></li><li><ol start="3"><li>main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</li></ol></li></ul><p>如何将控制台获取的数据传给形参：String[] args?<br>  运行时：java 类名 “Tom” “Jerry” “123” “true”</p><p>sysout(args[0]);//“Tom”<br>sysout(args[3]);//“true”  –&gt;Boolean.parseBoolean(args[3]);<br>sysout(args[4]);//报异常</p></blockquote><h3 id="5-3类的结构：代码块"><a href="#5-3类的结构：代码块" class="headerlink" title="5.3类的结构：代码块"></a>5.3类的结构：代码块</h3><ol><li><p>代码块的作用：用来初始化类、对象的信息</p></li><li><p>分类：代码块要是使用修饰符，只能使用static</p><p> 分类：静态代码块  vs 非静态代码块</p></li><li><p>静态代码块：</p><blockquote><p>内部可以输出语句<br>随着类的加载而执行,而且只执行一次<br>作用：初始化类的信息<br>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>静态代码块的执行要优先于非静态代码块的执行<br>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p></blockquote><p> 非静态代码块：</p><blockquote><p>内部可以输出语句<br>随着对象的创建而执行<br>每创建一个对象，就执行一次非静态代码块<br>作用：可以在创建对象时，对对象的属性等进行初始化<br>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p></blockquote></li><li><p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：</p><p> 由父及子，静态先行。</p></li><li><p>属性的赋值顺序</p><blockquote><ul><li>①默认初始化</li><li>②显式初始化/⑤在代码块中赋值</li><li>③构造器中初始化</li><li>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</li><li></li><li></li><li>执行的先后顺序：① - ② / ⑤ - ③ - ④</li></ul></blockquote></li></ol><h3 id="5-4关键字：final"><a href="#5-4关键字：final" class="headerlink" title="5.4关键字：final"></a>5.4关键字：final</h3><ol><li><p>可以用来修饰：类、方法、变量</p></li><li><p>具体的：</p><ol><li><p>final 用来修饰一个类:此类不能被其他类所继承。</p><p> 比如：String类、System类、StringBuffer类</p></li><li><p>final 用来修饰方法：表明此方法不可以被重写</p><p> 比如：Object类中getClass();</p></li><li><p>final 用来修饰变量：此时的”变量”就称为是一个常量</p><ul><li>final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li></ul></li></ol><p> static final 用来修饰属性：全局常量</p></li></ol><h3 id="5-5关键字：abstract"><a href="#5-5关键字：abstract" class="headerlink" title="5.5关键字：abstract"></a>5.5关键字：abstract</h3><ol><li><p>可以用来修饰：类、方法</p></li><li><p>具体的：</p><ul><li>abstract修饰类：抽象类<ul><li>此类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</li></ul></li><li>abstract修饰方法：抽象方法<ul><li>抽象方法只方法的声明，没方法体</li><li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li><li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li><li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li></ul></li></ul></li><li><p>注意点：</p><ol><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract不能用来修饰私方法、静态方法、final的方法、final的类</li></ol></li><li><p>abstract的应用举例：</p><ol><li><p>举例一：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GeometricObject</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">GeometricObject</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>举例二：IO流中设计到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部定义了抽象的read()、write()方法。</p></li></ol></li><li><p>涉及设计模式–&gt;模板方法</p><ol><li><p>解决的问题</p><p> 在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变<br> 部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p></li><li><p>举例</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.code();<span class="comment">//不确定的部分、易变的部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">isFlag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用场景</p><p> 模板方法设计模式是编程中经常用的到的模式。各个框架、类库中都有用到，比如常见的有：</p><ul><li>数据库访问的封装</li><li>Junit单元测试</li><li>JavaWeb的Servlet中关于doGet/doPost方法调用</li><li>Hibernate中模板程序</li><li>Spring中的JDBCTemplate、HibernateTemplate等</li></ul></li></ol></li></ol><h3 id="5-6关键字：interface"><a href="#5-6关键字：interface" class="headerlink" title="5.6关键字：interface"></a>5.6关键字：interface</h3><ol><li><p>使用说明：</p><ol><li><p>接口使用interface来定义</p></li><li><p>Java中，接口和类是并列的两个结构</p></li><li><p>如何定义接口：定义接口中的成员</p><ol><li>JDK7及以前：只能定义全局常量和抽象方法<ul><li>全局常量：public static final的.但是书写时，可以省略不写</li><li>抽象方法：public abstract的</li></ul></li><li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略</li></ol></li><li><p>接口中不能定义构造器的！意味着接口不可以实例化</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p><p> 如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</p><p> 如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</p></li><li><p>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性</p><p> 格式：class AA extends BB implements CC,DD,EE</p></li><li><p>接口与接口之间可以继承，而且可以多继承</p></li><li><p>接口的具体使用，体现多态性</p></li><li><p>接口，实际上可以看做是一种规范</p></li></ol></li><li><p>举例：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span></span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">usb.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line"></span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 体会：</p><ul><li>1.接口使用上也满足多态性</li><li>2.接口，实际上就是定义了一种规范</li><li>3.开发中，体会面向接口编程！</li></ul></li><li><p>体会面向接口编程的思想</p><p> 面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个<br> 数据库厂商的API。</p></li><li><p>Java8中关于接口的新规范</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//知识点1：接口中定义的静态方法，只能通过接口来调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class="line"><span class="comment">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class="line"><span class="comment">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class="line"><span class="comment">//那么在实现类没重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class="line"><span class="comment">//这就需要我们必须在实现类中重写此方法</span></span><br><span class="line"><span class="comment">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">    <span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">    CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>面试题：</p><p> 抽象类和接口的异同？</p><ul><li><p>相同点：不能实例化；都可以包含抽象方法的。</p></li><li><p>不同点：</p><ul><li>1）把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明</li><li>2）类：单继承性 ，接口：多继承，类与接口：多实现</li></ul></li></ul></li><li><p>涉及设计模式–&gt;代理模式、工厂模式</p><ol><li><p>代理模式</p><ol><li><p>解决的问题</p><p> 代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 </p></li><li><p>举例</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.work = work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;联网之前的检查工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">check();</span><br><span class="line">work.browse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用场景</p><ul><li><p>应用场景：</p><ul><li>安全代理：屏蔽对真实角色的直接访问</li><li>远程代理：通过代理类处理远程方法调用（RMI）</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li></ul></li><li><p>分类</p><ul><li><p>静态代理（静态定义代理类）</p></li><li><p>动态代理（动态生成代理类）</p><p>  JDK自带的动态代理，需要反射等知识</p></li></ul></li></ul></li></ol></li><li><p>工厂模式</p><ol><li><p>解决的问题</p><p> 实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p></li><li><p>具体模式</p><ul><li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li><li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</li><li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</li></ul></li></ol></li></ol></li></ol><h3 id="5-7类的结构：内部类"><a href="#5-7类的结构：内部类" class="headerlink" title="5.7类的结构：内部类"></a>5.7类的结构：内部类</h3><ol><li><p>定义：Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.</p></li><li><p>内部类的分类：</p><p> 成员内部类（静态、非静态 ） vs 局部内部类(方法内、代码块内、构造器内)</p></li><li><p>成员内部类的理解：</p><p> 一方面，作为外部类的成员：</p><ul><li>调用外部类的结构</li><li>可以被static修饰</li><li>可以被4种不同的权限修饰</li></ul><p> 另一方面，作为一个类：</p><ul><li>类内可以定义属性、方法、构造器等</li><li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li><li>可以被abstract修饰</li></ul></li><li><p>成员内部类：</p><ol><li><p>如何创建成员内部类的对象？(静态的，非静态的)</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">//Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>如何在成员内部类中调用外部类的结构？</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">String name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">String name = <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line"><span class="comment">//Person.this.eat();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>局部内部类的使用：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//class MyComparable implements Comparable&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//return new MyComparable();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意点：</p><p> 在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。</p><ul><li><strong>jdk 7及之前版本：要求此局部变量显式的声明为final的</strong></li><li><strong>jdk 8及之后的版本：可以省略final的声明</strong></li></ul><p> 总结：</p><p> 成员内部类和局部内部类，在编译以后，都会生成字节码文件。</p><p> 格式：</p><ul><li>成员内部类：外部类$内部类名.class    </li><li>局部内部类：外部类$数字 内部类名.class</li></ul></li></ol><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h2><h3 id="6-1异常"><a href="#6-1异常" class="headerlink" title="6.1异常"></a>6.1异常</h3><ol><li><p>异常的体系结构</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">|-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">|-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">|------编译时异常(checked)</span><br><span class="line">|-----IOException</span><br><span class="line">|-----FileNotFoundException</span><br><span class="line">|-----ClassNotFoundException</span><br><span class="line">|------运行时异常(unchecked,RuntimeException)</span><br><span class="line">|-----NullPointerException</span><br><span class="line">|-----ArrayIndexOutOfBoundsException</span><br><span class="line">|-----ClassCastException</span><br><span class="line">|-----NumberFormatException</span><br><span class="line">|-----InputMismatchException</span><br><span class="line">|-----ArithmeticException</span><br></pre></td></tr></table></figure><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522172127.png"></p></li><li><p>从程序执行过程，看编译时异常和运行时异常</p><p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522171550.png"></p><p> 编译时异常：执行javac.exe命名时，可能出现的异常</p><p> 运行时异常：执行java.exe命名时，出现的异常</p></li><li><p>常见的异常类型，请举例说明：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> score = scanner.nextInt();</span><br><span class="line">    System.out.println(score);</span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">    String str = (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">    <span class="comment">//int[] arr = new int[10];</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[10]);</span></span><br><span class="line">    <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">    String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//int[] arr = null;</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[3]);</span></span><br><span class="line">    String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    str = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line">    <span class="comment">//FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//int data = fis.read();</span></span><br><span class="line">    <span class="comment">//while(data != -1)&#123;</span></span><br><span class="line">    <span class="comment">//System.out.print((char)data);</span></span><br><span class="line">    <span class="comment">//data = fis.read();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//fis.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-2异常的处理"><a href="#6-2异常的处理" class="headerlink" title="6.2异常的处理"></a>6.2异常的处理</h3><ol><li><p>异常处理的抓抛模型</p><ol><li><p>“抓”</p><p> 可以理解为异常的处理方式：</p><ul><li>try-catch-finally </li><li>throws</li></ul></li><li><p>”抛“</p><p> 程序在正常执行的过程中，一旦出现异常，就会中异常代码处生成一个异常对象，并将此对象抛出。</p><p> 异常对象的产生：</p><ul><li>系统自动生成的异常对象</li><li>手动生成的一个异常对象，并抛出（throw）</li></ul></li></ol></li><li><p>异常处理方式：try-catch-finally</p></li><li><p>方法重写的规则之一：</p><p> 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p></li></ol><h3 id="6-3手动抛出异常对象"><a href="#6-3手动抛出异常对象" class="headerlink" title="6.3手动抛出异常对象"></a>6.3手动抛出异常对象</h3><ol><li><p>使用说明</p><p> 在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。</p></li><li><p>面试题</p><p> throw 和  throws区别：</p><p> throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。</p><p> throws 属于异常处理的一种方式，声明在方法的声明处。</p></li><li><p>典型例题</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//手动抛出异常对象</span></span><br><span class="line"><span class="comment">//throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="comment">//throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-4自定义异常类"><a href="#6-4自定义异常类" class="headerlink" title="6.4自定义异常类"></a>6.4自定义异常类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何自定义异常类？</span></span><br><span class="line"><span class="comment"> * 1. 继承于现的异常结构：RuntimeException 、Exception</span></span><br><span class="line"><span class="comment"> * 2. 提供全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment"> * 3. 提供重载的构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-多线程"><a href="#7-多线程" class="headerlink" title="7.多线程"></a>7.多线程</h2><p>程序、进程、线程的理解</p><p>并行和并发</p><p>创建多线程的两种方式</p><p>Thread类中的常用方法</p><p>Thread的生命周期</p><p>线程的同步机制</p><p>​    线程安全的单例模式（懒汉式）</p><p>​    死锁问题</p><p>线程通信</p><p>JDK5.0新增线程创建的方式</p><h2 id="8-常用类"><a href="#8-常用类" class="headerlink" title="8.常用类"></a>8.常用类</h2><p>String类</p><p>StringBuffer、StringBuilder</p><p>JDK8之前日期时间API</p><p>JDK8中新日期时间API</p><p>Java比较器</p><p>其他类</p><h2 id="9-枚举类和注解"><a href="#9-枚举类和注解" class="headerlink" title="9.枚举类和注解"></a>9.枚举类和注解</h2><p>枚举类的使用</p><p>注解类的使用</p><h2 id="10-集合"><a href="#10-集合" class="headerlink" title="10.集合"></a>10.集合</h2><p>数组与集合</p><p>Collection接口</p><p>Iterator接口与foreach循环 </p><p>Collection子接口：List接口</p><p>Collection子接口：Set接口</p><p>Map接口</p><p>Collections工具类的使用</p><p>数据结构简述</p><h2 id="11-泛型"><a href="#11-泛型" class="headerlink" title="11.泛型"></a>11.泛型</h2><p>泛型的理解</p><p>泛型在集合中的使用</p><p>自定义泛型类、泛型接口、泛型方法</p><p>泛型在继承上的体现</p><p>通配符</p><h2 id="12-IO流"><a href="#12-IO流" class="headerlink" title="12.IO流"></a>12.IO流</h2><p>File类的使用</p><p>IO流概述</p><p>节点流（或文件流）</p><p>缓冲流的使用</p><p>转换流的使用</p><p>​    编码集</p><p>其它的流的使用</p><p>对象流的使用</p><p>RandomAccessFile的使用</p><p>Path、Paths、Files的使用</p><h2 id="13-网络编程"><a href="#13-网络编程" class="headerlink" title="13.网络编程"></a>13.网络编程</h2><p>InetAddress类的使用</p><p>TCP网络编程</p><p>UDP网络编程</p><p>URL编程</p><h2 id="14-反射机制"><a href="#14-反射机制" class="headerlink" title="14.反射机制"></a>14.反射机制</h2><p>反射的概述</p><p>Class类的理解与获取Class的实例</p><p>了解ClassLoader</p><p>反射应用一：创建运行时类的对象</p><p>反射应用二：获取运行时类的完整结构</p><p>反射应用三：调用运行时类的指定结构</p><p>反射应用四：动态代理</p><h2 id="15-Java8的其他新特性"><a href="#15-Java8的其他新特性" class="headerlink" title="15.Java8的其他新特性"></a>15.Java8的其他新特性</h2><h2 id="16-Java9、10、11新特性"><a href="#16-Java9、10、11新特性" class="headerlink" title="16.Java9、10、11新特性"></a>16.Java9、10、11新特性</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>​        当一个数组中大部分元素为0，或者为同一值的数组时，可研使用稀疏数组来保存该数组。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h2><ol><li>记录数组一共有几行几列，有多少个不同的值。</li><li>把具有不同值的元素的行列及值记录在小规模的数组中，从而缩小程序的规模。</li></ol><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200709221603.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: SparseArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * 二维数组转稀疏数组思路</span></span><br><span class="line"><span class="comment"> * 1. 遍历原始的二维数组，得到有效数据的个数count</span></span><br><span class="line"><span class="comment"> * 2. 根据count就可以创建 稀疏数组 sparseArr   int[count + 1] [3]</span></span><br><span class="line"><span class="comment"> * 3. 将二维数组的有效数据数据存入到 稀疏数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 10136</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/9 22:20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个原始的二维数组11*11</span></span><br><span class="line">        <span class="comment">//0表示没有棋子，1表示黑子，2表示蓝子</span></span><br><span class="line">        <span class="keyword">int</span> chessOriginArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessOriginArr[<span class="number">1</span>][<span class="number">2</span>]= <span class="number">1</span>;</span><br><span class="line">        chessOriginArr[<span class="number">2</span>][<span class="number">3</span>]= <span class="number">2</span>;</span><br><span class="line">        chessOriginArr[<span class="number">5</span>][<span class="number">2</span>]= <span class="number">2</span>;</span><br><span class="line">        chessOriginArr[<span class="number">2</span>][<span class="number">4</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出原始数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessOriginArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1. 遍历原始的二维数组，得到有效数据的个数count</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessOriginArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data!=<span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(count);//2</span></span><br><span class="line">        <span class="comment">//2. 根据count就可以创建 稀疏数组 sparseArr   int[count + 1] [3]</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//3. 将二维数组的有效数据数据存入到 稀疏数组</span></span><br><span class="line">        <span class="comment">//第一行存储原始数组的行数，列数以及有效数字数量</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line">        <span class="keyword">int</span> rowNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(chessOriginArr[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    rowNum++;</span><br><span class="line">                    sparseArr[rowNum][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[rowNum][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[rowNum][<span class="number">2</span>] = chessOriginArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:sparseArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//稀疏数组还原为原始数组</span></span><br><span class="line">        <span class="keyword">int</span> chessOriginBackArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessOriginBackArr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessOriginBackArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00021000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00200000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">------------------------------------</span><br><span class="line">11114</span><br><span class="line">121</span><br><span class="line">232</span><br><span class="line">241</span><br><span class="line">522</span><br><span class="line">------------------------------------</span><br><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00021000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00200000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
          <category> 稀疏数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 稀疏数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组模拟环形队列</title>
      <link href="/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"/>
      <url>/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><ol><li>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li><li>遵循<strong>先进先出</strong>的原则。即：先进入队列的数据，要先取出。后进入的要后取出</li></ol><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h2><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200709225933.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 环形队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 环形队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="/2019/07/18/Java-Java%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/18/Java-Java%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="java基础笔记"><a href="#java基础笔记" class="headerlink" title="java基础笔记"></a>java基础笔记</h2><ol><li><h4 id="基本数据类型和包装类型"><a href="#基本数据类型和包装类型" class="headerlink" title="基本数据类型和包装类型"></a>基本数据类型和包装类型</h4><blockquote><p>基本数据类型：short、int、long、double、float、char、string、boolean</p><p>包装类型：Short、Integer、Long、Double、Float、Char、String、Boolean</p><p>装箱：1. 手动装箱：Integer.valueOf(1) ;    2. 自动装箱：Integer i = 1;</p><p>拆箱：1. 手动拆箱：int j = i.intValue() ;    2. 自动拆箱：int j = i ;</p><p>JDK1.5开始为什么要引入包装类型：java是面向对象的语言，而基本的数据类型不具备面向对象的特性。</p><p>例：用Integer和int分别表示一个类的ID，进行非空判断的时候，Integer只要判断是否为null，int还要判断是否为0；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer num1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer num2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;num1==num2 &quot;</span> + (num1 == num2));</span><br><span class="line"></span><br><span class="line">Integer num3 = <span class="number">100</span>;</span><br><span class="line">Integer num4 = <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;num3==num4 &quot;</span> +(num3 == num4));</span><br><span class="line"></span><br><span class="line">Integer num5 = <span class="number">128</span>;</span><br><span class="line">Integer num6 = <span class="number">128</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;num5==num6 &quot;</span> + (num5 == num6));</span><br><span class="line"></span><br><span class="line">Integer num7 = <span class="number">100</span>;</span><br><span class="line">Integer num8 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;num7==num8 &quot;</span> + (num7 == num8));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num9 = <span class="number">100</span>;</span><br><span class="line">Integer num10 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer num11 = <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;num9==num10 &quot;</span> + (num9 == num10));</span><br><span class="line">System.out.println(<span class="string">&quot;num9==num11 &quot;</span> + (num9 == num11));</span><br><span class="line"></span><br><span class="line">结果：num1==num2 <span class="keyword">false</span>  </span><br><span class="line"> num3==num4 <span class="keyword">true</span></span><br><span class="line"> num5==num6 <span class="keyword">false</span></span><br><span class="line"> num7==num8 <span class="keyword">false</span></span><br><span class="line"> num9==num10 <span class="keyword">true</span></span><br><span class="line"> num9==num11 <span class="keyword">true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">源码：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">分析：</span><br><span class="line"><span class="number">1.</span>==对于对象来说比较的是对象的地址，两个新<span class="keyword">new</span>的对象地址不同，输出<span class="keyword">false</span>。</span><br><span class="line"><span class="number">2.</span>jvm在初始化的时候，会将低值（-<span class="number">128</span>）到高值（默认<span class="number">127</span>）之间的数字加载到内存中。低值是固定的，高值是可变的。在java程序执行的时候加上 -XX:AutoBoxCacheMax=&lt;size&gt; 的参数即可。缓如果初始化的数字是-<span class="number">128</span>~<span class="number">127</span>之间就会引用内存中的地址，输出<span class="keyword">true</span>。</span><br><span class="line"><span class="number">3.</span>同上。</span><br><span class="line"><span class="number">4.</span>num7是引用的本地内存地址，而num8是<span class="keyword">new</span>出来的，所以地址不同，输出<span class="keyword">false</span>。</span><br><span class="line"><span class="number">5.</span>包装类Integer和基本数据类型<span class="keyword">int</span>类型比较时，会自动拆箱为<span class="keyword">int</span>类型比较，实际上就变成两个基本的数据类型<span class="keyword">int</span>类型进行比较，而基本类型==比较的是值而不是地址，所以输出<span class="keyword">true</span>。</span><br><span class="line"><span class="number">6.</span>同上，即使是新<span class="keyword">new</span>出来的地址不同，但是最终拆箱为<span class="keyword">int</span>类型比较值是否相等，所以输出<span class="keyword">true</span>。</span><br></pre></td></tr></table></figure></blockquote></li><li><p>“==”和“equals()” 方法区别</p><blockquote><p><strong>变量分为基本数据类型和引用数据类型</strong></p><p>1）对于==，比较的是值是否相等</p><p>​    如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p><p>　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p><p>2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象</p><p>　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p><p>　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p></blockquote></li><li><p>String、StringBuilder、StringBuffer区别</p><blockquote><p>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>String底层使用<span class="keyword">final</span>关键字修饰的数组，因此不可变</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="number">2.</span>StringBuilder继承AbstractStringBuilder抽象类使用的是普通数组所以可以改变。</span><br><span class="line">     <span class="comment">/** The value is used for character storage.*/</span></span><br><span class="line">     <span class="keyword">char</span>[] value;</span><br><span class="line"><span class="number">3.</span>StringBuffer继承AbstractStringBuilder抽象类使用的是普通数组所以可以改变。并且与StringBuilder重写的方法不同，方法添加了<span class="keyword">synchronized</span>关键字，线程安全但是效率低。</span><br></pre></td></tr></table></figure><blockquote><p>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</p><p>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p></blockquote></li><li><h4 id="java中的集合"><a href="#java中的集合" class="headerlink" title="java中的集合"></a>java中的集合</h4><blockquote><p>java中的集合分类存储value（继承Collection接口）和存储key-value（继承）形式。</p><p><strong>存储值：</strong>List、Set</p><blockquote><p>List是有序的，可以重复的。</p><p>Set是无序的，不可以重复的。根据equals和hascode判断，也就是如果一个对象要存储在Set中，必须重写equals和hasCode方法。</p></blockquote><p><strong>存储键值：</strong>Map</p></blockquote></li><li><h4 id="ArrayList和LinkedList的区别和使用场景"><a href="#ArrayList和LinkedList的区别和使用场景" class="headerlink" title="ArrayList和LinkedList的区别和使用场景"></a>ArrayList和LinkedList的区别和使用场景</h4><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>ArrayList底层使用的是数组。</span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="number">2.</span>LinkedList底层使用的是链表。</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>区别：</strong></p><p>数组查询特定元素快，而插入、删除和修改比较慢，因为数组在内存中是一块连续的内存，如果是插入或删除需要移动内存。</p><p>链表在内存中是不连续的，在当前元素中存放的是下一个或者上一个元素的地址。查询时需要从头部开始查找至尾部，效率低。而插入时不需要移动内存，只需要改变节点指针即可。所以插入或删除效率高。</p><p><strong>使用场景：</strong></p><p>ArrayList使用在查询比较多，但是插入和删除比较少的情况，</p><p>LinkedList使用在查询比较少，但是插入和删除比较多的情况。</p></blockquote></li><li><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h4><blockquote><p><strong>相同点：</strong>都可以用来存储Key-Value类型数据</p><p><strong>不同点：</strong></p><ol><li><p>HashMap可以使用null值作为key或者value，而Hashtable不行。</p></li><li><p>HashMap是线程不安全的，效率高。而Hashtable是线程安全的，效率低。</p></li><li><p>HashMap继承了AbstractMap抽象类同时实现Map, Cloneable, Serializable接口，而Hashtable继承了Dictionary抽象类同时实现Map, Cloneable, Serializable接口。</p></li></ol><p><strong>线程安全又要效率高？ConcurrentHashMap</strong></p><p>通过把整个Map分为N个Segment（类似于Hashtable）,可以提供相关的线程安全，又可以提升效率，默认提升16倍。</p></blockquote></li><li><h4 id="实现一个拷贝文件的工具类使用字节流还是字符流"><a href="#实现一个拷贝文件的工具类使用字节流还是字符流" class="headerlink" title="实现一个拷贝文件的工具类使用字节流还是字符流"></a>实现一个拷贝文件的工具类使用字节流还是字符流</h4><blockquote><p>我们拷贝的文件不确定是只包含字符流，有可能有字节流（图片、声音、图像等），为考虑到通用性，要使用字节流。</p></blockquote></li><li><h4 id="线程的几种实现方式"><a href="#线程的几种实现方式" class="headerlink" title="线程的几种实现方式"></a>线程的几种实现方式</h4><blockquote><ol><li><p>通过继承Thread类实现一个线程</p></li><li><p>通过实现Runnable接口实现一个线程</p></li><li><p>通过实现callable接口，重写call函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =======  创建线程方式一  开始 (Thread是一个类继承了Runnable接口) =======</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法中写我们业务代码</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1000毫秒(就是1秒)</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//打印当前线程名称</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;创建线程方式一,打印线程名称: &quot;</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//打印当前线程名称,这里采用this来获取,在某些时候这里并不适用,推荐使用上面一种方式</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;创建线程方式一,通过this调用getName方法,打印线程名称: &quot;</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();<span class="comment">//启动线程</span></span><br><span class="line">        <span class="comment">// =======  创建线程方式一  结束  =======</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// =======  创建线程方式二开始  (Runnable是一个接口)=======</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法中写我们业务代码</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1000毫秒(就是1秒)</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//打印当前线程名称</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;创建线程方式二,打印线程名称: &quot;</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//TODO 这种方式就不适合上面打印2的方式通过this来调用获取当前线程名称的方法</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread2.start();<span class="comment">//启动线程</span></span><br><span class="line">        <span class="comment">// =======  创建线程方式二  结束  =======</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// =======  创建线程方式三 开始  =======</span></span><br><span class="line">        FutureTask&lt;Integer&gt; thread3 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> count =<span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;  </span><br><span class="line">                    count=count+i;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">//打印当前线程名称</span></span><br><span class="line">                System.out.println(<span class="string">&quot;创建线程方式三,打印线程名称: &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">return</span> count; <span class="comment">//返回值   </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(thread3,<span class="string">&quot;这是线程名称&quot;</span>).start();<span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建线程方式三,打印返回值:&quot;</span>+ thread3.get());<span class="comment">//打印返回值</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">     <span class="comment">// =======  创建线程方式三 结束  =======</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong></p><ul><li><p>采用继承Thread类方式：</p><p>​    优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。</p><p>​    缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。</p></li><li><p>采用实现Runnable接口方式：</p><p>​    优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p><p>​    缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。</p></li></ul></li></ol></blockquote></li><li><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><blockquote><ol><li><strong>newCachedThreadPool</strong></li></ol><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>这种类型的线程池特点是：</p><ul><li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li><li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li><li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>newFixedThreadPool</strong></li></ol><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p><p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(index);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置如Runtime.getRuntime().availableProcessors()</p><ol start="3"><li><strong>newSingleThreadExecutor</strong></li></ol><p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(index);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="4"><li><strong>newScheduleThreadPool</strong></li></ol><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p><p>延迟3秒执行，延迟执行示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;delay 3 seconds&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示延迟1秒后每3秒执行一次，定期执行示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;delay 1 seconds, and excute every 3 seconds&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><h4 id="使用线程池的风险，为什么使用线程池"><a href="#使用线程池的风险，为什么使用线程池" class="headerlink" title="使用线程池的风险，为什么使用线程池"></a>使用线程池的风险，为什么使用线程池</h4></li></ol><blockquote><p><strong>风险：</strong></p><ol><li>死锁</li><li>资源不足</li><li>并发错误</li><li>线程泄漏</li><li>请求过载</li></ol><p><strong>作用：</strong>（连接池同理）</p><ol><li>限定线程的个数，不会由于线程过多而导致系统运行缓慢或崩溃</li><li>线程池不需要每次去创建或销毁，节约资源，响应速度快</li></ol></blockquote><ol start="11"><li><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><blockquote><p><strong>常用的设计模式：</strong></p><ol><li><p>单例模式（饱汉模式、饿汉模式）：</p><p>（1）构造方法私有化，在除了自己类中其他地方都不能创建</p><p>（2）在自己的类中创建一个单实例（饱汉模式是一出来就创建单实例，而饿汉模式需要用到的时候才创建）</p><p>（3）提供一个方法或获取该实例对象（创建时需要进行方法同步）</p></li><li><p>工厂模式：SpringIOC使用的就是工厂模式，对象的创建交给一个工厂  创建。</p></li><li><p>代理模式：SpringAOP使用的就是动态代理。</p></li></ol></blockquote></li></ol><h2 id="javaWeb笔记"><a href="#javaWeb笔记" class="headerlink" title="javaWeb笔记"></a>javaWeb笔记</h2><ol><li><h4 id="Http-Get和Post请求的区别"><a href="#Http-Get和Post请求的区别" class="headerlink" title="Http Get和Post请求的区别"></a>Http Get和Post请求的区别</h4><blockquote><p><strong>相同点：</strong></p><p>Get和Post请求都是Http请求方式，用户通过不同的Http请求对资源实现不同的操作。GET，POST，PUT，DELETE对应着对资源的查，改，增，删4个操作，GET一般用于获取/查询资源信息，而POST用于更新资源信息。</p><p><strong>区别：</strong></p><ol><li>GET请求提交的数据会在地址栏显示出来，而POST请求地址栏不会改变，数据放置在HTTP包体中。</li><li>传输数据的大小不同，GET由于浏览器对地址长度的限制导致传输的数据有限制，而POST不会。</li><li>GET提交的数据会在地址中显示出来，安全性较低，而POST则不会。</li></ol></blockquote></li><li><h4 id="servlet的理解"><a href="#servlet的理解" class="headerlink" title="servlet的理解"></a>servlet的理解</h4><blockquote><p>Servlet 是用java编写的服务器端程序，而这些Servlet都要实现Servlet接口。主要用于交互式地浏览和修改数据，生成动态Web内容。Servlet运行于支持java的web容器中。</p><p>HttpServlet重写doGet和doPost方法或者service方法完成对get和post请求的响应。</p></blockquote></li><li><h4 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h4><blockquote><ol><li>加载Servlet的class</li><li>实例化Servlet</li><li>调用Servlet的init完成实例化</li><li>运行service方法，响应doGet或doPost请求</li><li>调用destory方法销毁实例</li></ol></blockquote></li><li><h4 id="Servlet-API中forward-和redirect-区别"><a href="#Servlet-API中forward-和redirect-区别" class="headerlink" title="Servlet API中forward() 和redirect()区别"></a>Servlet API中forward() 和redirect()区别</h4><blockquote><p>forward：转发，地址不变，服务端跳转</p><p>redirect：重定向，地址改变，客户端跳转</p></blockquote></li><li><h4 id="Session和Cookie区别"><a href="#Session和Cookie区别" class="headerlink" title="Session和Cookie区别"></a>Session和Cookie区别</h4><blockquote><p><strong>相同点：</strong></p><p>Session和cookie都是会话跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务端记录信息确定用户身份。但是Session是实现依赖于Cookie，sessionId（session的唯一标识需要存放在客户端）</p><p><strong>区别：</strong></p><ol><li><p>Cookie数据存放在客户端浏览器，Session存放在服务器上</p></li><li><p>Cookie安全性较Session差</p></li><li><p>Session运行时间久会占用较多服务器内存，影响服务器性能</p></li><li><p>单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie</p></li><li><p>登录信息等重要信息存放在Session中，安全性较高</p><p>其他信息如果需要保留，存在Cookie中（比如购物车的实现，但是Cookie在客户端是可以禁用的，所以可以采用cookie+数据库方式实现）</p></li></ol></blockquote></li><li><h4 id="MVC的各部分都有哪些技术来实现"><a href="#MVC的各部分都有哪些技术来实现" class="headerlink" title="MVC的各部分都有哪些技术来实现"></a>MVC的各部分都有哪些技术来实现</h4><blockquote><ul><li>M（Model） 模型     javabean……</li><li>V（View）     视图     html、jsp、freemarker、thymeleaf……</li><li>C（Control）控制器 Servlet、Action……</li></ul></blockquote></li></ol><h2 id="数据库笔记"><a href="#数据库笔记" class="headerlink" title="数据库笔记"></a>数据库笔记</h2><ol><li><h4 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h4><blockquote><ul><li><p>关系型数据库</p><blockquote><p> MySql、Oracle、SqlServer……</p></blockquote></li><li><p>非关系型数据库</p><blockquote><p>redis、memcache、mogodb、hadoop……</p></blockquote></li></ul></blockquote></li><li><h4 id="关系型数据库三范式"><a href="#关系型数据库三范式" class="headerlink" title="关系型数据库三范式"></a>关系型数据库三范式</h4><blockquote><ol><li><p>第一范式（1NF)所谓第一范式（1NF）是指<strong>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</strong>。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。理解注释：列不可分。</p></li><li><p>第二范式（2NF)第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求<strong>数据库表中的每个实例或行必须可以被惟一的区分</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。要求实体的属性完全依赖于主关键字。理解注释：不能部分依赖。即：一张表存在组合主键时，其他非主键字段不能部分依赖。</p></li><li><p>第三范式（3NF)满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求<strong>一个数据库表中不包含已在其它表中已包含的非主关键字信息</strong>。在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。理解注释：不能存在传递依赖。即：除主键外，其他字段必须依赖主键。</p></li></ol></blockquote></li><li><h4 id="事务四个基本特征ACID特性"><a href="#事务四个基本特征ACID特性" class="headerlink" title="事务四个基本特征ACID特性"></a>事务四个基本特征ACID特性</h4><blockquote><p>​    事务是并发控制的单位，使用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）.这是可靠数据库所应具备的几个特性.</p><ul><li><p>原子性</p><blockquote><p>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></blockquote></li><li><p>一致性</p><blockquote><p>在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p></blockquote></li><li><p>隔离性</p><blockquote><p>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p></blockquote></li><li><p>持久性</p><blockquote><p>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p></blockquote></li></ul></blockquote></li><li><h4 id="MySql数据库默认的最大连接数"><a href="#MySql数据库默认的最大连接数" class="headerlink" title="MySql数据库默认的最大连接数"></a>MySql数据库默认的最大连接数</h4><blockquote><p>特定服务器上的数据库只能支持一定数目同时连接，这时候需要我们设置最大连接数（最多同时服务多少连接），在my.ini中查看设置</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The maximum amount of concurrent sessions the MySQL server will</span></span><br><span class="line"><span class="comment"># allow. One of these connections will be reserved for a user with</span></span><br><span class="line"><span class="comment"># SUPER privileges to allow the administrator to login even if the</span></span><br><span class="line"><span class="comment"># connection limit has been reached.</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">151</span></span><br></pre></td></tr></table></figure></blockquote></li><li><h4 id="MySql分页、Oracle分页和SqlServer分页"><a href="#MySql分页、Oracle分页和SqlServer分页" class="headerlink" title="MySql分页、Oracle分页和SqlServer分页"></a><del>MySql分页、Oracle分页和SqlServer分页</del></h4><blockquote><p>MySql使用limit关键字来分页</p><p>Oracle使用rownum</p><p>SqlServer使用top</p></blockquote></li><li><h4 id="触发器使用场景"><a href="#触发器使用场景" class="headerlink" title="触发器使用场景"></a><strong>触发器使用场景</strong></h4><blockquote></blockquote></li></ol><h2 id="前端笔记"><a href="#前端笔记" class="headerlink" title="前端笔记"></a>前端笔记</h2><h2 id="框架笔记"><a href="#框架笔记" class="headerlink" title="框架笔记"></a>框架笔记</h2><ol><li><h4 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h4><blockquote><ol><li>用户向服务器发送请求，请求被Spring前端控制器DispatcherServlet拦截</li><li>DispatcherServlet对请求的URL进行解析，得到请求资源标识符（URL）。然后根据URI调用HandlerMapping获的该Handler配置的所有相关对象，最后以HandlerExecutionChain对象的形式返回</li><li>DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter适配器，提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller），Handler执行完成后，向DispatcherServlet返回一个ModelAndVIew对象</li><li>DispatcherServlet根据返回的ModelAndVIew，选择一个合适的ViewResolver视图解析器</li><li>通过ViewResolver结合Model和View。来渲染视图，DispatcherServlet将渲染结果返回给客户端</li></ol></blockquote></li><li><h4 id="Struts2和SpringMVC区别"><a href="#Struts2和SpringMVC区别" class="headerlink" title="Struts2和SpringMVC区别"></a>Struts2和SpringMVC区别</h4><blockquote><ol><li>Struts2的前端控制器是Filter，SpringMVC是Servlet</li><li>SpringMVC是基于方法设计，而Struts2是基于对象</li><li>SpringMVC属于Spring大家族中的一员，Spring对于SpringMVC的控制器管理更加方便，而Struts2采用XML配置参数来管理</li><li>Struts2中自身提供多种参数接收，其实都是通过ValueStack进行传递和赋值，而SpringMVC是通过方法的参数进行接收</li><li>Struts2拥有较多的技术点，比如拦截器、值栈和OGNL表达式，学习成本较高，而SpringMVC相对比较简单</li><li>Struts有自己的interceptor拦截机制，SpringMVC使用的是独立的AOP</li><li>SpringMVC处理Ajax请求，直接通过返回数据，方法中使用注解@ResponseBody直接转为JSON对象返回，而Struts2是通过插件的方式处理</li></ol></blockquote></li><li><h4 id="Spring中的两大核心"><a href="#Spring中的两大核心" class="headerlink" title="Spring中的两大核心"></a>Spring中的两大核心</h4><blockquote><ol><li><p>IOC（Inversion of Control）或DI（Dependency Injection）</p><blockquote><p><strong>IOC控制反转：</strong></p><p>在spring中BeanFactory是IOC容器的核心接口，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。XmlBeanFactory实现BeanFactory接口，通过获取xml配置文件数据，组成应用对象及对象间的依赖关系。</p><p>Spring中有三种注入方式：set注入、接口注入、构造方法注入</p><p>核心原理：配置文件+反射+容器</p></blockquote></li><li><p>AOP面向切面编程：</p><blockquote><p>使用动态代理的方式在执行前后或出现异常后执行相关逻辑</p><p>主要用于：事务、日志、权限校验</p></blockquote></li></ol></blockquote></li><li><h4 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h4><blockquote><p>为了解决面向对象与关系数据库存在的互不匹配的现象的框架</p></blockquote></li><li><h4 id="Mybatis和Hibernate区别"><a href="#Mybatis和Hibernate区别" class="headerlink" title="Mybatis和Hibernate区别"></a>Mybatis和Hibernate区别</h4><blockquote><p><strong>相同点：</strong></p><p>​    都是java中的ORM框架、屏蔽了jdbc api的底层访问细节。</p><p>​    mybatis：专注sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis也可以实现映射（输入映射，输出映射）</p><p>​    应用场景：适用需求变化较多的项目，比如：互联网项目。</p><p>​    hibernate:是一个标准的ORM框架（对象关系映射）。入门门槛较高，不需要写sql，sql语句自动生成，对sql语句进行优化、修改比较困难。</p><p>​    应用场景：适用需求变化不多的中小型项目，比如：后台管理系统，erp，orm，oa等</p></blockquote></li><li><h4 id="Hibernate映射对象的状态"><a href="#Hibernate映射对象的状态" class="headerlink" title="Hibernate映射对象的状态"></a>Hibernate映射对象的状态</h4><blockquote><ol><li>临时状态(transient)(瞬态)：刚用new 语句创建，还没有被持久化，并且不处于Sesssion 的缓存中。处于临时状态的Java 对象被称为临时对象。</li><li>持久化状态(persistent)：已经被持久化，并且加入到Session 的缓存中。处于持久化状态的Java 对象被称为持久化对象。</li><li>删除状态(removed)：不再处于Session 的缓存中，并且Session 已经计划将其从数据库中删除。处于删除状态的Java 对象被称为删除对象。</li><li>游离状态(detached)：已经被持久化，但不再处于Session 的缓存中。处于游离状态的Java 对象被称为游离对象。</li></ol><p>下面以具体的代码来说明这四种状态:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SessionFactory sessionFactory=HibernateUtil.getSessionFactory();  </span><br><span class="line">        Session session=sessionFactory.openSession(); <span class="comment">// 生成一个session  </span></span><br><span class="line">        session.beginTransaction(); <span class="comment">// 开启事务  </span></span><br><span class="line">          </span><br><span class="line">        Person p1=<span class="keyword">new</span> Person(<span class="string">&quot;天天&quot;</span>,<span class="string">&quot;18&quot;</span>,<span class="string">&quot;3009&quot;</span>); <span class="comment">// 临时对象1  </span></span><br><span class="line">        Person p2=<span class="keyword">new</span> Person(<span class="string">&quot;小李&quot;</span>,<span class="string">&quot;23&quot;</span>,<span class="string">&quot;4009&quot;</span>); <span class="comment">// 临时对象1   </span></span><br><span class="line">        session.save(p1); <span class="comment">// 持久化对象  </span></span><br><span class="line">        session.save(p2); <span class="comment">// 持久化对象  </span></span><br><span class="line">          </span><br><span class="line">        session.delete(p2); <span class="comment">// 删除对象  </span></span><br><span class="line">          </span><br><span class="line">        session.getTransaction().commit(); <span class="comment">// 提交事务  </span></span><br><span class="line">        session.close(); <span class="comment">// 关闭session  </span></span><br><span class="line">          </span><br><span class="line">        System.out.println(p1.getName()); <span class="comment">// 游离对象  </span></span><br><span class="line">        System.out.println(p2.getName()); <span class="comment">// 删除对象  </span></span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></blockquote></li><li><h4 id="Hibernate缓存机制"><a href="#Hibernate缓存机制" class="headerlink" title="Hibernate缓存机制"></a>Hibernate缓存机制</h4><blockquote><p>​    使用缓存是为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能</p><p>​    Hibernate缓存分为一级缓存和二级缓存，一级缓存就是Session级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。</p><p>什么样的数据适合存放到第二级缓存中？ 　　</p><p>​    1) 很少被修改的数据 　帖子的最后回复时间　</p><p>​    2) 经常被查询的数据   电商的地点</p><p>​    3) 不是很重要的数据，允许出现偶尔并发的数据 　　</p><p>​    4) 不会被并发访问的数据 　　</p><p>​    5) 常量数据 </p><p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用memcahe,redis等中央缓存来代替二级缓存。</p></blockquote></li><li><h4 id="webservice使用场景"><a href="#webservice使用场景" class="headerlink" title="webservice使用场景"></a>webservice使用场景</h4><blockquote><p>​    webservice是一个SOA（面向服务的编程）的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过Internet进行基于Http协议的网络应用间的交互。</p><ol><li><p>异构系统(不同语言)的整合</p></li><li><p>不同客户端的整合，浏览器、手机端(android,ios.塞班)、微信端、PC端等终端来访问</p></li><li><p>实实在在的列子：</p><p>天气预报：可以通过实现webservice客户端调用远程天气服务实的。 </p><p>单点登录：一个服务是所有系统的登录</p></li></ol></blockquote></li></ol><h2 id="服务器及优化"><a href="#服务器及优化" class="headerlink" title="服务器及优化"></a>服务器及优化</h2><ol><li><h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><blockquote><p>常用：</p><p>​    Pwd 获取当前路径</p><p>​    Cd 跳转到目录</p><p>​    Su -u 切换到管理员</p><p>​    Ls ls 列举目录</p><p>文件操作命令：</p><p>​    文件</p><p>​           tail 查看</p><p>​           rm -rf </p><p>​           vi</p><p>​    文件夹</p><p>​           mkdir </p><p>​           rm -r</p></blockquote></li><li><h4 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h4><blockquote><p>做过mysql数据库的优化、其他数据库类似</p><p>定位：查找、定位慢查询</p><p>优化手段：</p><p>​    a) 创建索引：创建合适的索引，我们就可以现在索引中查询，查询到以后直接找对应的记录。</p><p>​    b) 分表：当一张表的数据比较多或者一张表的某些字段的值比较多并且很少使用时，采用水平分表和垂直分表来优化</p><p>​    c) 读写分离：当一台服务器不能满足需求时，采用读写分离的方式进行集群。</p><p>​    d) 缓存：使用redis来进行缓存</p><p>​    e) 一些常用优化技巧</p><p><a href="http://www.cnblogs.com/luyucheng/p/6323477.html">优化</a></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方兴商城笔记</title>
      <link href="/2019/06/29/%E9%A1%B9%E7%9B%AE-FangXingMallNote/"/>
      <url>/2019/06/29/%E9%A1%B9%E7%9B%AE-FangXingMallNote/</url>
      
        <content type="html"><![CDATA[<h1 id="方兴商城"><a href="#方兴商城" class="headerlink" title="方兴商城"></a>方兴商城</h1><h2 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h2><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="系统架构图"></p><h2 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h2><table><thead><tr><th><strong>表名称</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>tb_brand</td><td>品牌</td></tr><tr><td>tb_specification</td><td>规格</td></tr><tr><td>tb_specification_option</td><td>规格选项</td></tr><tr><td>tb_type_template</td><td>类型模板：用于关联品牌和规格</td></tr><tr><td>tb_item_cat</td><td>商品分类</td></tr><tr><td>tb_seller</td><td>商家</td></tr><tr><td>tb_goods</td><td>商品</td></tr><tr><td>tb_goods_desc</td><td>商品详情</td></tr><tr><td>tb_item</td><td>商品明细</td></tr><tr><td>tb_content</td><td>内容（广告）</td></tr><tr><td>tb_content_category</td><td>内容（广告）类型</td></tr><tr><td>tb_user</td><td>用户</td></tr><tr><td>tb_order</td><td>订单</td></tr><tr><td>tb_order_item</td><td>订单明细</td></tr><tr><td>tb_pay_log</td><td>支付日志</td></tr></tbody></table><h2 id="系统框架组合"><a href="#系统框架组合" class="headerlink" title="系统框架组合"></a>系统框架组合</h2><ul><li>前端<ul><li>AngularJS(基础指令学习)</li><li>BootStrap</li></ul></li><li>后端<ul><li>Spring</li><li>SpringMVC</li><li>SpringSecurity</li><li>Mybatis</li><li>Dubbox</li></ul></li></ul><h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h2><ol><li>创建父工程fangxingmall-parent（POM）</li><li>创建实体类模块fangxingmall-pojo</li><li>创建数据访问模块fangxingmall-dao</li><li>创建商家商品服务接口模块fangxingmall-sellergoods-interface</li><li>创建商家商品服务模块fangxingmall-sellergoods-service</li><li>创建运营商管理后台模块fangxingmall-manager-web</li><li>创建商家管理后台模块fangxingmall-shop-web</li></ol><h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><ol><li><p>服务器安装软件</p><ul><li><p>安装zookeeper</p><ol><li><p>服务器安装JDK</p></li><li><p>上传zookeeper压缩包到服务器</p></li><li><p>解压缩</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# tar -zxvf zookeeper-3.4.6.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>进入zookeeper-3.4.6目录创建data文件夹</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# mkdir data</span><br></pre></td></tr></table></figure></li><li><p>进入conf目录，重命名zoo_sample.cfg为zoo.cfg</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></li><li><p>打开zoo.cfg文件，修改data存储路径为你解压缩新建的data路径，pwd查看当前路径直接复制</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# vim zoo.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash">dataDir=/usr/dubbo/zookeeper-3.4.6/data</span></span><br></pre></td></tr></table></figure></li><li><p>进入bin目录，启动服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# ./zkServer.sh start</span><br></pre></td></tr></table></figure></li><li><p>关闭服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# ./zkServer.sh stop</span><br></pre></td></tr></table></figure></li><li><p>查看服务状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# ./zkServer.sh status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /usr/dubbo/zookeeper-3.4.6/bin/../conf/zoo.cfg</span><br><span class="line">Mode: standalonexxxxxxxxxx [root@VM_90_242_centos bin]# ./zkServer.sh statusJMX enabled by defaultUsing config: /usr/dubbo/zookeeper-3.4.6/bin/../conf/zoo.cfgMode: standalone./zkServer.sh statusshell</span><br></pre></td></tr></table></figure></li></ol></li><li><p>安装Dubbox</p><ol><li><p>手动安装Dubbox的jar包到本地仓库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=d:\setup\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar</span><br></pre></td></tr></table></figure></li><li><p>配置离线约束</p><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190918105912.png" alt="配置离线约束"></p></li></ol></li><li><p><a href="https://fangchenyong.top/2019/07/23/install_ActiveMQ/">安装activemq</a></p></li></ul></li><li><p>修改</p><ol><li><p>数据库连接修改</p><blockquote><p>/fangxingmall-dao/src/main/resources/properties/db.properties</p></blockquote></li><li><p>redis配置修改</p><blockquote><p>/fangxingmall-common/src/main/resources/properties/redis-config.properties</p></blockquote></li><li><p>日志文件配置修改</p><blockquote><p>/fangxingmall-sellergoods-service/src/main/resources/log4j.properties</p></blockquote></li><li><p>dubbo连接修改</p><blockquote><p>/fangxingmall-sellergoods-service/src/main/resources/spring/applicationContext-service.xml</p><p>/fangxingmall-shop-web/src/main/resources/spring/springmvc.xml</p><p>/fangxingmall-shop-web/src/main/resources/spring/spring-security.xml</p><p>/fangxingmall-manager-web/src/main/resources/spring/springmvc.xml</p><p>/fangxingmall-content-service/src/main/resources/spring/applicationContext-service.xml</p><p>/fangxingmall-portal-web/src/main/resources/spring/springmvc.xml</p><p>/fangxingmall-search-web/src/main/resources/spring/springmvc.xml</p></blockquote></li><li><p>FastDFS配置</p></li><li><p>solr配置</p><blockquote><p>/fangxingmall-solr-util/src/main/resources/spring/applicationContext-solr.xml</p></blockquote></li><li></li></ol></li><li><p>启动模块（MavenBulid tomcat7:run）</p><ol><li>fangxingmall-sellergoods-service，端口9001</li><li>fangxingmall-manager-web，端口9101</li><li>fangxingmall-content-service，端口9002</li><li>fangxingmall-shop-web，端口9102</li><li>fangxingmall-portal-web，端口9103</li><li>fangxingmall-search-service，端口9004</li><li>fangxingmall-search-web，端口9104</li><li>fangxingmall-page-service，端口9005</li><li>fangxingmall-page-web，端口9105</li></ol></li><li><p>开发进度</p><ul><li><p>新增、修改、删除商品分类</p></li><li><p>安装Fast DFS服务器</p></li><li><p>TO DO 图片上传</p></li><li><p>按销量、评价排序</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 方兴商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
