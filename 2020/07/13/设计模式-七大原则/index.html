<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>设计模式-七大设计原则 | Joey</title><meta name="description" content="设计模式-七大设计原则"><meta name="keywords" content="设计模式,设计原则"><meta name="author" content="fangchenyong"><meta name="copyright" content="fangchenyong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://fangchenyong.top/2020/07/13/设计模式-七大原则/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="设计模式-七大设计原则"><meta name="twitter:description" content="设计模式-七大设计原则"><meta name="twitter:image" content="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/6C4819608FCCD2B5E6F8F1B1C583429F.png"><meta property="og:type" content="article"><meta property="og:title" content="设计模式-七大设计原则"><meta property="og:url" content="http://fangchenyong.top/2020/07/13/设计模式-七大原则/"><meta property="og:site_name" content="Joey"><meta property="og:description" content="设计模式-七大设计原则"><meta property="og:image" content="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/6C4819608FCCD2B5E6F8F1B1C583429F.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="设计模式-创建型模式-单例模式" href="http://fangchenyong.top/2020/07/13/设计模式-创建型模式-单例模式/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://github.com/fangchenyong","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#设计模式-七大设计原则"><span class="toc-text">设计模式-七大设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1）、单一职责原则（Single-Responsibility）"><span class="toc-text">1）、单一职责原则（Single Responsibility）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2）、接口隔离原则（Interface-Segregation）"><span class="toc-text">2）、接口隔离原则（Interface Segregation）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3）、依赖倒转原则（Dependence-Inversion）"><span class="toc-text">3）、依赖倒转原则（Dependence Inversion）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4）、里氏替换原则（Liskov-Substitution）"><span class="toc-text">4）、里氏替换原则（Liskov Substitution）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5）、开闭原则（Open-Closed）"><span class="toc-text">5）、开闭原则（Open Closed）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6）、迪米特法则（Demeter）"><span class="toc-text">6）、迪米特法则（Demeter）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7）、合成复用原则（Composite-Reuse）"><span class="toc-text">7）、合成复用原则（Composite Reuse）</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_5954.JPG)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Joey</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/6C4819608FCCD2B5E6F8F1B1C583429F.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">设计模式-七大设计原则</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-13<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-14</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/设计模式/">设计模式</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/设计模式/设计原则/">设计原则</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 12 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="设计模式-七大设计原则"><a href="#设计模式-七大设计原则" class="headerlink" title="设计模式-七大设计原则"></a>设计模式-七大设计原则</h1><p>==<strong>三种类型</strong>==</p>
<ol>
<li><strong>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</strong></li>
<li><strong>结构性模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</strong></li>
<li><strong>行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式</strong></li>
</ol>
<p>==<strong>核心思想</strong>==</p>
<ol>
<li><strong>代码重用性（即：相同功能的代码，不用多次编写）</strong></li>
<li><strong>可读性（即：编程规范性，便于其他程序员的阅读和理解）</strong></li>
<li><strong>可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）</strong></li>
<li><strong>可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</strong></li>
<li><strong>使程序呈现高内聚，低耦合的特性</strong></li>
</ol>
<h2 id="1）、单一职责原则（Single-Responsibility）"><a href="#1）、单一职责原则（Single-Responsibility）" class="headerlink" title="1）、单一职责原则（Single Responsibility）"></a>1）、单一职责原则（Single Responsibility）</h2><p><strong>目的：</strong>降低代码复杂度、系统解耦合、提高可读性</p>
<p>​        对类来说，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。</p>
<ol>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性。</li>
<li>降低变更引起的风险。</li>
<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责；只有类中方法数量足够少，可以在方法级别保持单一职责原则。</li>
</ol>
<p><strong>==快速记忆：各司其职，降低耦合==</strong></p>
<h2 id="2）、接口隔离原则（Interface-Segregation）"><a href="#2）、接口隔离原则（Interface-Segregation）" class="headerlink" title="2）、接口隔离原则（Interface Segregation）"></a>2）、接口隔离原则（Interface Segregation）</h2><p><strong>目的：</strong>避免接口过于臃肿</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类A通过Interface1会依赖（使用）类B</span></span><br><span class="line"><span class="comment">//但是A只会用到接口的fun1(),fun2(),fun3()三个方法</span></span><br><span class="line"><span class="comment">//类C通过Interface1会依赖（使用）类D</span></span><br><span class="line"><span class="comment">//但是C只会用到接口的fun1(),fun4(),fun5()三个方法</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>类A通过Interface1会依赖（使用）类B（<strong>比如：在control层调用service层实现方法时</strong>），类C通过Interface1会依赖（使用）类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。</p>
</li>
<li><p>将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
</li>
<li><p>接口Interface1中出现的方法，根据实际情况拆分为三个接口</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface3</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>==快速记忆：利用接口的多实现，拆分粒度尽量小，避免实现类重写不需要的方法==</strong></p>
</li>
</ol>
<h2 id="3）、依赖倒转原则（Dependence-Inversion）"><a href="#3）、依赖倒转原则（Dependence-Inversion）" class="headerlink" title="3）、依赖倒转原则（Dependence Inversion）"></a>3）、依赖倒转原则（Dependence Inversion）</h2><p><strong>目的：</strong>避免需求变化导致过多的维护工作</p>
<ol>
<li><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象，低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。</p>
</li>
<li><p>抽象不应该依赖细节，细节应该依赖抽象。</p>
</li>
<li><p>依赖倒转（倒置）的中心思想是面向接口编程。</p>
</li>
<li><p>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。</p>
</li>
<li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展示细节的任务交给他们的实现类去完成。</p>
</li>
<li><p>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。</p>
</li>
<li><p>继承时遵循里氏替换原则。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependenceInversion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">        person.receive(<span class="keyword">new</span> WeChat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Receive Email"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeChat</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Receive WeChat"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person 接受信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Info info)</span> </span>&#123;</span><br><span class="line">        System.out.println(info.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>依赖关系的传递方式：</strong></p>
<ul>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方式传递</li>
</ul>
<p> <strong>==快速记忆：面向接口编程，这就是为什么service 要多写个接口，然后才是实现类==</strong></p>
</li>
</ol>
<h2 id="4）、里氏替换原则（Liskov-Substitution）"><a href="#4）、里氏替换原则（Liskov-Substitution）" class="headerlink" title="4）、里氏替换原则（Liskov Substitution）"></a>4）、里氏替换原则（Liskov Substitution）</h2><p><strong>目的：</strong>避免系统继承体系被破坏</p>
<ol>
<li><p>里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院一位姓里的女士提出。</p>
</li>
<li><p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p>
</li>
<li><p>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p>
</li>
<li><p>继承实际上让两个类耦合性增强了，给程序带来侵入性。在适当的情况下，可以通过聚合，组合，依赖来解决问题。</p>
</li>
<li><p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiskovSubstitution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">"2-1="</span> + a.func1(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">"2+1="</span> + b.func1(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"2+1+9="</span> + b.func2(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"B类使用A类方法：2-1="</span> + b.func3(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把基础方法和成员抽取成基类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public int func1(int num1, int num2) &#123;</span></span><br><span class="line"><span class="comment">//        return num1 - num2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// TODO 类 B `无意` 重写了父类 A 方法，造成原有方法发生改变。</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int func1(int num1, int num2) &#123;</span></span><br><span class="line"><span class="comment">//        return num1 + num2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(num1, num2) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();<span class="comment">//组合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 A 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>==快速记忆：子类可以扩展父类的功能，但不能改变父类原有的功能==</strong></p>
</li>
</ol>
<h2 id="5）、开闭原则（Open-Closed）"><a href="#5）、开闭原则（Open-Closed）" class="headerlink" title="5）、开闭原则（Open Closed）"></a>5）、开闭原则（Open Closed）</h2><p><strong>目的：</strong>提高扩展性、便于维护</p>
<ol>
<li><p>开闭原则(Open Closed Principle) 是编程中最基础、最重要的设计原则。</p>
</li>
<li><p>一个软件实体，比如类，模块和函数应该对==提供方扩展开放==，对==使用方修改关闭==。用抽象构建框架，用实现扩展细节。</p>
</li>
<li><p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
</li>
<li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenClosed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Use use = <span class="keyword">new</span> Use();</span><br><span class="line">        use.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">        use.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        use.drawShape(<span class="keyword">new</span> OtherGraphics());<span class="comment">//只需要让 此类继承 抽象类，子类实现具体方法  OCP原则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Use</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类实现具体功能：三角形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类实现具体功能：圆形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphics</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类实现具体功能：任何形状"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>==快速记忆：比如你作为开发可以修改程序，但用户无法修改。即 类，模块和函数提供方开放修改，调用方关闭修改==</strong></p>
</li>
</ol>
<h2 id="6）、迪米特法则（Demeter）"><a href="#6）、迪米特法则（Demeter）" class="headerlink" title="6）、迪米特法则（Demeter）"></a>6）、迪米特法则（Demeter）</h2><p><strong>目的：</strong>降低类与类之间的耦合</p>
<ol>
<li><p>一个对象应该对其他对象保持最少的了解（最少知道原则 LKP）。</p>
</li>
<li><p>类与类关系越密切，耦合度越大。要求降低类之间耦合，而不是完全解耦。</p>
</li>
<li><p>迪米特法则(Demeter Principle)，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息。</p>
</li>
<li><p>迪米特法则更简单的定义：只与直接的朋友通信。</p>
</li>
<li><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    B b;<span class="comment">//全局变量 - 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">m1</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//方法返回值 - 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(B b)</span></span>&#123;&#125;<span class="comment">//方法入参 - 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B b1 = <span class="keyword">new</span> B();<span class="comment">// 局部变量 非直接朋友</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工 //TODO CollegeEmployee 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10 个员工到list ，</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">"学院员工id "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCollegeEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">"---学院员工----"</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//TODO 直接朋友 Employee CollegeManager</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SchoolEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SchoolEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SchoolEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到list</span></span><br><span class="line">            SchoolEmployee emp = <span class="keyword">new</span> SchoolEmployee();</span><br><span class="line">            emp.setId(<span class="string">"学校总部员工id= "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        <span class="comment">//TODO 非直接朋友 CollegeEmployee  应该提取到  CollegeManager</span></span><br><span class="line"><span class="comment">//        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span></span><br><span class="line"><span class="comment">//        System.out.println("---学院员工----");</span></span><br><span class="line"><span class="comment">//        for (CollegeEmployee e : list1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e.getId());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        sub.printCollegeEmployee();<span class="comment">//只提供方法，不把具体实现放在其他类里面。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;SchoolEmployee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">"------学校总部员工------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (SchoolEmployee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>==快速记忆：只与直接的朋友通信。校长管老师，老师管学生。校长找学生不会直接去找，而是通过老师去找。==</strong></p>
</li>
</ol>
<h2 id="7）、合成复用原则（Composite-Reuse）"><a href="#7）、合成复用原则（Composite-Reuse）" class="headerlink" title="7）、合成复用原则（Composite Reuse）"></a>7）、合成复用原则（Composite Reuse）</h2><p><strong>目的：</strong>防止类的体系庞大</p>
<ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>为了交互对象之间的松耦合设计而努力。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeReuse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------依赖------"</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.Operation1(<span class="keyword">new</span> A());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------聚合------"</span>);</span><br><span class="line">        b.setA(<span class="keyword">new</span> A());</span><br><span class="line">        b.Operation2();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------组合------"</span>);</span><br><span class="line">        b.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A Operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A Operation2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A Operation3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只是需要用到 A类的方法，尽量不要使用继承。而是使用，依赖，聚合，组合的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">(A a)</span> </span>&#123;<span class="comment">//TODO 依赖</span></span><br><span class="line">        a.Operation1();</span><br><span class="line">        a.Operation2();</span><br><span class="line">        a.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================================================</span></span><br><span class="line">    A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;<span class="comment">//TODO 聚合</span></span><br><span class="line">        a.Operation1();</span><br><span class="line">        a.Operation2();</span><br><span class="line">        a.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================================================</span></span><br><span class="line">    A a1 = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span> </span>&#123;<span class="comment">//TODO 组合</span></span><br><span class="line">        a1.Operation1();</span><br><span class="line">        a1.Operation2();</span><br><span class="line">        a1.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>==快速记忆：当类与类之间的关系是”Is-A”时，用继承；当类与类之间的关系是”Has-A”时，用组合。==</strong></p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/设计模式/">设计模式    </a><a class="post-meta__tags" href="/tags/设计原则/">设计原则    </a></div><div class="post_share"><div class="social-share" data-image="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/6C4819608FCCD2B5E6F8F1B1C583429F.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/07/13/设计模式-创建型模式-单例模式/"><img class="next_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/B3402E0D-8544-4AFD-BB48-88F3D7F7466C.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_6261.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_6923.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/F07254A8-F2DA-4308-9464-88E9E471FD6C.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_5519.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/FC43A5A0-16A7-411A-877A-C3F4C3D8C890.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_7755.JPG" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>设计模式-创建型模式-单例模式</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/13/设计模式-创建型模式-单例模式/" title="设计模式-创建型模式-单例模式"><img class="relatedPosts_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/B3402E0D-8544-4AFD-BB48-88F3D7F7466C.JPG"><div class="relatedPosts_title">设计模式-创建型模式-单例模式</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By fangchenyong</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">仅供学习使用。</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>