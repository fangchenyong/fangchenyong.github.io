<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Joey</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Joey">
<meta property="og:url" content="http://fangchenyong.top/index.html">
<meta property="og:site_name" content="Joey">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joey">
  
    <link rel="alternate" href="/atom.xml" title="Joey" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Joey</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">首页</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://fangchenyong.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-The Road To Bald Man!" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/13/The Road To Bald Man!/" class="article-date">
  <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/My-Java-Life/">My Java Life</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/13/The Road To Bald Man!/">The Road To Bald Man!</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="The-Road-To-Bald-Man！"><a href="#The-Road-To-Bald-Man！" class="headerlink" title="The Road To Bald Man！"></a>The Road To Bald Man！</h1><h2 id="一、编程基础"><a href="#一、编程基础" class="headerlink" title="一、编程基础"></a>一、编程基础</h2><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ul>
<li>基础语法</li>
<li>面向对象</li>
<li>接口</li>
<li>容器</li>
<li>异常</li>
<li>泛型</li>
<li>反射</li>
<li>注解</li>
<li>I/O</li>
<li>图形化</li>
<li>集合框架（源码）<ul>
<li>List<ul>
<li>ArrayList</li>
<li>LInkedList</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet</li>
<li>TreeSet</li>
</ul>
</li>
<li>Map<ul>
<li>HashMap （JDK 8 的实现与之前的版本不同）</li>
<li>TreeMap</li>
<li>ConcurrentHashMap</li>
</ul>
</li>
<li>Queue<ul>
<li>ConcurrentLinkedQueue</li>
</ul>
</li>
<li>Stack</li>
<li>Collections的SynchronizedXXX方法</li>
</ul>
</li>
<li>高级特性<ul>
<li>泛型</li>
<li>多态的实现原理</li>
<li>Lambda</li>
<li>并发编程<ul>
<li>Executor框架</li>
<li>Fork/join</li>
<li>数据结构<ul>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
</ul>
</li>
<li>线程池</li>
<li>线程状态</li>
<li>Lock/syschronized</li>
<li>原子操作类</li>
<li>并发工具类<ul>
<li>CountDownLatch</li>
<li>Semaphore</li>
<li>CyclicBarrier</li>
<li>Exchanger</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>网络编程<ul>
<li>Socket</li>
</ul>
</li>
<li>IO<ul>
<li>BIO</li>
<li>NIO</li>
<li>AIO</li>
</ul>
</li>
<li>序列化<ul>
<li>JDK自带</li>
<li>Google protobuf</li>
</ul>
</li>
<li>RPC<ul>
<li>RMI</li>
<li>Thrift</li>
<li>Dubbo</li>
<li>gRpc</li>
</ul>
</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li>认识Java虚拟机（默认HotSpot实现）</li>
<li>类加载机制（知道双亲委派模型）</li>
<li>字节码执行机制</li>
<li>内存模型</li>
<li>GC<ul>
<li>回收算法</li>
<li>垃圾收集器</li>
</ul>
</li>
<li>jvm性能监控与故障定位</li>
<li>调优</li>
<li>工具<ul>
<li>jstack</li>
<li>jmap</li>
<li>jconsole</li>
</ul>
</li>
</ul>
<h3 id="并发、多线程"><a href="#并发、多线程" class="headerlink" title="并发、多线程"></a>并发、多线程</h3><ul>
<li>并发编程基础</li>
<li>线程池</li>
<li>锁</li>
<li>并发容器</li>
<li>原子类</li>
<li>juc并发工具类</li>
</ul>
<h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p>字符串</p>
<ul>
<li>查找匹配（KMP）</li>
<li>正则</li>
</ul>
</li>
<li><p>数组</p>
</li>
<li><p>链表</p>
</li>
<li><p>栈</p>
</li>
<li><p>队列</p>
</li>
<li><p>树</p>
<ul>
<li>二叉树<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
</li>
</ul>
</li>
<li><p>B Tree/B+Tree</p>
</li>
<li><p>红黑树</p>
</li>
<li><p>哈希</p>
<ul>
<li>哈希冲突</li>
<li>k-v</li>
</ul>
</li>
<li><p>图</p>
<ul>
<li>BFS</li>
<li>DFS</li>
</ul>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>查找</li>
<li>动态规划</li>
<li>分治</li>
<li>回溯</li>
<li>排序<ul>
<li>内部排序<ul>
<li>插入排序<ul>
<li>直接插入排序</li>
<li>希尔排序</li>
</ul>
</li>
</ul>
</li>
<li>选择排序<ul>
<li>简单选择排序</li>
<li>堆排序</li>
</ul>
</li>
</ul>
</li>
<li>交换排序<ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li>归并排序</li>
<li>基数排序</li>
<li>桶排序</li>
<li>外部排序</li>
<li>贪心</li>
</ul>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul>
<li>TCP、UDP</li>
<li>ARP</li>
<li>IP、ICMP</li>
<li>DNS、HTTP、HTTPS</li>
<li>OAuth2.0</li>
<li>REST</li>
<li>Session、Cookie</li>
</ul>
<h3 id="数据库-SQL"><a href="#数据库-SQL" class="headerlink" title="数据库/SQL"></a>数据库/SQL</h3><ul>
<li>关系型数据库<ul>
<li>MySql<ul>
<li>引擎<ul>
<li>InnoDB（支持事务）</li>
<li>MyISAM（支持全文索引）</li>
</ul>
</li>
</ul>
</li>
<li>分库分表<ul>
<li>Cobar</li>
<li>Mycat</li>
</ul>
</li>
</ul>
</li>
<li>SQL优化<ul>
<li>索引<ul>
<li>主键索引</li>
<li>组合索引</li>
</ul>
</li>
</ul>
</li>
<li>explain</li>
<li>存储过程</li>
<li>SQL注入<ul>
<li>使用#而不使用$</li>
</ul>
</li>
<li>事务隔离级别（ACID）<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
</li>
<li>锁<ul>
<li>表锁</li>
<li>行锁</li>
<li>乐观锁</li>
<li>悲观锁</li>
</ul>
</li>
<li>Oracle</li>
<li>SQL sever</li>
<li>数据库设计<ul>
<li>范式<ul>
<li>第一范式</li>
<li>第二范式</li>
<li>第三范式</li>
</ul>
</li>
</ul>
</li>
<li>E-R图</li>
<li>NoSql<ul>
<li>Memcached<ul>
<li>文档模型</li>
<li>分片</li>
</ul>
</li>
</ul>
</li>
<li>Redis</li>
<li>MongoDB</li>
<li>HBase</li>
<li>JDBC</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>七大原则<ul>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ul>
</li>
<li>23种设计模式<ul>
<li>创建型模式：<ol>
<li>单例模式</li>
<li>抽象工厂模式</li>
<li>原型模式</li>
<li>建造者模式</li>
<li>工厂模式</li>
</ol>
</li>
<li>结构性模式：<ol>
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ol>
</li>
<li>行为型模式：<ol>
<li>模板方法模式</li>
<li>命令模式</li>
<li>访问者模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>职责链模式</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li>线程、进程</li>
<li>并发、锁</li>
<li>内存管理和调度</li>
<li>I/O原理</li>
</ul>
<h2 id="二、开发工具"><a href="#二、开发工具" class="headerlink" title="二、开发工具"></a>二、开发工具</h2><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul>
<li>IDEA</li>
<li>Eclipse</li>
<li>VSCode</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="发行版（Server）"><a href="#发行版（Server）" class="headerlink" title="发行版（Server）"></a>发行版（Server）</h4><ul>
<li>Ubuntu</li>
<li>RedHat</li>
<li>CentOS</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>1、查看正则执行的进程</li>
<li>2、查询指定的进程ID打开的文件</li>
<li>3、杀死指定PID的进程</li>
<li>4、计算文件的行数、字数或字符数</li>
<li>5、显示进程信息，并实时更新</li>
<li>6、调用top命令的&quot;-H&quot;选项，该选项会列出所有的Linux线程</li>
<li>7、查看用户username的进程所打开的文件</li>
<li>8、在ps命令中，&quot;-T&quot;选项可以开启线程查看，下面的命令列出了由进程号为进程创建的所有线程</li>
<li>9、比较两个文件</li>
<li>10、后台执行、通过在shell中输入exit来退出终端</li>
<li>11、查看正在执行的任务</li>
<li>12、多线程执行</li>
<li>13、查看进程和线程的树形结构关系</li>
<li>14、ps命令-L参数显示进程，并尽量显示其LWP（线程ID）和NLWP（线程的个数）</li>
<li>15、ps命令查看线程在哪个CPU上运行</li>
<li>16、取出文件的前面几行</li>
<li>17、动态查看文件变化</li>
<li>18、退出 tail -f</li>
<li>19、tail程序放到后台去等处理完其他事情，再用fg命令将tail命令转到前台来</li>
<li>20、查看文件夹和子目录的大小</li>
<li>21、设置定时任务</li>
<li>22、重命名文件和文件夹</li>
<li>23、复制、剪切、清空和删除</li>
<li>24、Linux通信</li>
</ul>
<h3 id="代码管理工具"><a href="#代码管理工具" class="headerlink" title="代码管理工具"></a>代码管理工具</h3><ul>
<li>Git</li>
<li>SVN</li>
</ul>
<h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><ul>
<li>Maven</li>
<li>Gradle</li>
</ul>
<h2 id="三、前端技术"><a href="#三、前端技术" class="headerlink" title="三、前端技术"></a>三、前端技术</h2><h3 id="HTML、CSS、JavaScript"><a href="#HTML、CSS、JavaScript" class="headerlink" title="HTML、CSS、JavaScript"></a>HTML、CSS、JavaScript</h3><h3 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h3><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h3 id="JSP、JSTL"><a href="#JSP、JSTL" class="headerlink" title="JSP、JSTL"></a>JSP、JSTL</h3><h3 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h3><h3 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h3><h3 id="VUE、React"><a href="#VUE、React" class="headerlink" title="VUE、React"></a>VUE、React</h3><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><h2 id="四、技术框架"><a href="#四、技术框架" class="headerlink" title="四、技术框架"></a>四、技术框架</h2><h3 id="Spring全家桶"><a href="#Spring全家桶" class="headerlink" title="Spring全家桶"></a>Spring全家桶</h3><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul>
<li>IOC</li>
<li>AOP</li>
<li>Transaction<ul>
<li>声明式事务底层原理</li>
<li>Spring事务处理机制</li>
<li>事务的传播与监控</li>
<li>基于Springjdbc手写Orm框架</li>
</ul>
</li>
<li>常用注解<ul>
<li>@Component：标识该类需要Spring初始化时自动装配，可以时一个普通的Bean</li>
<li>@Resource：被该注释修饰的字段或方法，Spring会通过by-name的方式自动注入</li>
<li>@Required：应用于bean属性的setter方法，它表明受影响的bean属性在配置时必须放在XML配置文件中，否则容器就会抛出一个BeanInitializationException异常</li>
<li>@Autowired：可以在setter方法中被用于自动连接bean</li>
<li>@Value：可以为普通方法和构造方法中的参数或者字段指定一个默认的值</li>
<li>@Qualifer：指定哪个真正的bean将会被装配，应用于一个接口有多个实现类的情况</li>
<li>@Service：标注一个业务逻辑处理类</li>
<li>@Repository：标注一个DAO组件类</li>
<li>＠RequestMapping：指定请求路径</li>
<li>＠Controller：标注一个控制器组件类</li>
<li>＠ResponseBody：返回json结果数据</li>
</ul>
</li>
<li>设计模式<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>单例模式</li>
<li>原型模式</li>
<li>代理模式<ul>
<li>jdk动态代理模式</li>
<li>cglib动态代理模式</li>
</ul>
</li>
</ul>
</li>
<li>组合模式</li>
</ul>
<h4 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h4><ul>
<li>MVC原理介绍</li>
<li>与IOC容器整合原理</li>
<li>Handlermapping实现原理</li>
<li>Handleradapter实现原理</li>
<li>Viewresolver实现原理</li>
<li>Controller调用原理</li>
<li>动态参数匹配原理</li>
<li>SpringMVC与Struts2对比分析</li>
<li>手写实现SpringMVC框架</li>
</ul>
<h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><ul>
<li>自动配置、开箱即用</li>
<li>整合Web</li>
<li>整合数据库（事务问题）</li>
<li>整合权限<ul>
<li>Shiro</li>
<li>SpringSecurity</li>
</ul>
</li>
<li>整合各种中间件<ul>
<li>缓存</li>
<li>MQ</li>
<li>RPC框架</li>
<li>NIO框架</li>
<li>等。。。</li>
</ul>
</li>
</ul>
<h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><h3 id="服务器软件"><a href="#服务器软件" class="headerlink" title="服务器软件"></a>服务器软件</h3><h4 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h4><ul>
<li>Nginx</li>
</ul>
<h4 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h4><ul>
<li>Tomcat</li>
<li>Jetty</li>
<li>Undertow</li>
</ul>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul>
<li>Redis<ul>
<li>5大数据类型</li>
<li>事务</li>
<li>消息通知</li>
<li>管道</li>
<li>持久化</li>
<li>集群</li>
</ul>
</li>
<li>Memcached</li>
</ul>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul>
<li>RocketMQ</li>
<li>RabbitMQ</li>
<li>Kafka</li>
</ul>
<h4 id="RPC架构"><a href="#RPC架构" class="headerlink" title="RPC架构"></a>RPC架构</h4><ul>
<li>Dubbo</li>
<li>GRPC</li>
<li>Thrift</li>
<li>Netty</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="ORM层框架"><a href="#ORM层框架" class="headerlink" title="ORM层框架"></a>ORM层框架</h4><ul>
<li>MyBatis<ul>
<li>逆向工程</li>
<li>一对多，多对多嵌套查询</li>
<li>一级缓存、二级缓存使用场景及选择策略</li>
<li>与Spring继承Spring-Mybatis.Jar分析</li>
<li>Spring继承下的Sqlsession与Mapper</li>
<li>Mybaits事务</li>
<li>分析Mybatis动态代理的真正实现</li>
<li>手写实现Mybatis<ul>
<li>实现配置文件加载流程</li>
<li>实现封装jdbc的执行流程</li>
</ul>
</li>
<li>设计模式<ul>
<li>构建者模式</li>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>单例模式</li>
</ul>
</li>
</ul>
</li>
<li>Hibernate</li>
<li>JPA</li>
</ul>
<h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><ul>
<li>Druid</li>
<li>HikariCP</li>
<li>C3P0</li>
</ul>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><ul>
<li>MyCat</li>
<li>Sharding-JDBC</li>
<li>Sharding-Sphere</li>
</ul>
<h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul>
<li>Solr</li>
<li>ElasticSearch</li>
</ul>
<h3 id="分布式微服务"><a href="#分布式微服务" class="headerlink" title="分布式微服务"></a>分布式微服务</h3><ul>
<li>服务发现/注册<ul>
<li>Eureka</li>
<li>Consul</li>
<li>Zookeeper</li>
<li>Nacos</li>
</ul>
</li>
<li>网关<ul>
<li>Zuul</li>
<li>Gateway</li>
</ul>
</li>
<li>服务调用（负载均衡）<ul>
<li>Ribbon</li>
<li>Feign</li>
</ul>
</li>
<li>熔断/降级<ul>
<li>Hystrix</li>
</ul>
</li>
<li>配置中心<ul>
<li>Config</li>
<li>Apollo</li>
<li>Nacos</li>
</ul>
</li>
<li>认证和鉴权<ul>
<li>Shiro</li>
<li>SpringSecurity</li>
<li>OAuth2</li>
<li>SSO</li>
</ul>
</li>
<li>分布式事务<ul>
<li>JTA接口<ul>
<li>Atomikos组件</li>
</ul>
</li>
</ul>
</li>
<li>2PC、3PC</li>
<li>XA模式</li>
<li>TCC模式<ul>
<li>tcc-transaction</li>
<li>ByteTCC</li>
<li>EasyTransaction</li>
<li>Seata</li>
</ul>
</li>
<li>SAGA模式<ul>
<li>ServiceComb</li>
<li>Seata</li>
</ul>
</li>
<li>LCN模式<ul>
<li>tx-lcn</li>
</ul>
</li>
<li>任务调度<ul>
<li>Quartz</li>
<li>Elastic-Job</li>
</ul>
</li>
<li>链路追踪与监控<ul>
<li>Zipkin</li>
<li>Sleuth</li>
<li>Skywalking</li>
</ul>
</li>
<li>日志分析与监控<ul>
<li>ELK<ul>
<li>ElasticSearch</li>
<li>Logstash</li>
<li>Kibana</li>
</ul>
</li>
</ul>
</li>
<li>虚拟化/容器化<ul>
<li>容器技术<ul>
<li>Docker</li>
</ul>
</li>
</ul>
</li>
<li>容器编排技术<ul>
<li>Kubernetes</li>
<li>Swarm</li>
</ul>
</li>
</ul>
<h2 id="五、运维"><a href="#五、运维" class="headerlink" title="五、运维"></a>五、运维</h2><h4 id="Web服务器-1"><a href="#Web服务器-1" class="headerlink" title="Web服务器"></a>Web服务器</h4><ul>
<li>Nginx</li>
</ul>
<h4 id="应用服务器-1"><a href="#应用服务器-1" class="headerlink" title="应用服务器"></a>应用服务器</h4><ul>
<li>Tomcat</li>
<li>Jetty</li>
<li>Undertow</li>
</ul>
<h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><h4 id="持续集成-持续发布"><a href="#持续集成-持续发布" class="headerlink" title="持续集成/持续发布"></a>持续集成/持续发布</h4><ul>
<li>Jenkins</li>
</ul>
<h4 id="代码质量检查"><a href="#代码质量检查" class="headerlink" title="代码质量检查"></a>代码质量检查</h4><ul>
<li>sonar</li>
</ul>
<h4 id="日志收集-分析"><a href="#日志收集-分析" class="headerlink" title="日志收集/分析"></a>日志收集/分析</h4><ul>
<li>ELK</li>
</ul>
<h2 id="六、安全加密"><a href="#六、安全加密" class="headerlink" title="六、安全加密"></a>六、安全加密</h2><h4 id="单项散列算法"><a href="#单项散列算法" class="headerlink" title="单项散列算法"></a>单项散列算法</h4><ul>
<li>MD5</li>
<li>SHA</li>
</ul>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ul>
<li>DES</li>
</ul>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ul>
<li>RSA</li>
<li>HTTPS</li>
</ul>
<h2 id="七、业务解决方案"><a href="#七、业务解决方案" class="headerlink" title="七、业务解决方案"></a>七、业务解决方案</h2><h2 id="八、源码"><a href="#八、源码" class="headerlink" title="八、源码"></a>八、源码</h2><h2 id="九、植发"><a href="#九、植发" class="headerlink" title="九、植发"></a>九、植发</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2021/03/13/The Road To Bald Man!/" data-id="ckmh9ucla00673oum1543r4fe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/My-Java-Life/">My Java Life</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面试-集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/20/面试-集合/" class="article-date">
  <time datetime="2021-03-19T16:00:00.000Z" itemprop="datePublished">2021-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/面试题/">面试题</a>►<a class="article-category-link" href="/categories/面试题/集合/">集合</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/20/面试-集合/">面试题-集合框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java集合容器概述"><a href="#Java集合容器概述" class="headerlink" title="Java集合容器概述"></a>Java集合容器概述</h1><h2 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h2><ul>
<li>集合就是一个放数据的容器，准确的说是放数据对象引用的容器。</li>
<li>集合类存放的都是对象的引用，而不是对象的本身。</li>
<li>集合类型主要有3种：set(集）、list(列表）和map(映射)。</li>
</ul>
<h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><p>主要有如下两点：==存储对象，长度可变==</p>
<ul>
<li>集合用于存储对象的容器，对象是用来封装数据，对象多了也需要存储集中式管理。</li>
<li>和数组对比对象的大小不确定。因为集合是可变长度的。数组需要提前定义大小。</li>
</ul>
<h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h2><ul>
<li><p>数组是固定长度的；集合可变长度的。</p>
</li>
<li><p>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</p>
</li>
<li><p>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</p>
</li>
</ul>
<h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h2><ul>
<li>容量自增长。</li>
<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量。</li>
<li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li>
<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li>
</ul>
<h2 id="常见的集合类有哪些"><a href="#常见的集合类有哪些" class="headerlink" title="常见的集合类有哪些"></a>常见的集合类有哪些</h2><p>Map接口和Collection接口是所有集合框架的父接口：</p>
<ul>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ul>
<h2 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h2><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616168692363.png" alt></p>
<ul>
<li>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</li>
<li>Collection集合主要有List和Set两大接口<ul>
<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>
<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及TreeSet。</li>
</ul>
</li>
<li>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。<ul>
<li>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li>
</ul>
</li>
</ul>
<h2 id="框架底层数据结构"><a href="#框架底层数据结构" class="headerlink" title="框架底层数据结构"></a>框架底层数据结构</h2><ul>
<li>Collection<ol>
<li>List<ul>
<li>Arraylist： Object数组</li>
<li>Vector： Object数组</li>
<li>LinkedList： 双向循环链表</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素。</li>
<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)。</li>
</ul>
</li>
</ol>
</li>
<li>Map<ul>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>
</ul>
</li>
</ul>
<h2 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h2><ul>
<li>Vector：就比Arraylist多了个 synchronized （线程安全），因为效率较低，现在已经不太建议使用。</li>
<li>Hashtable：就比hashMap多了个synchronized (线程安全)，不建议使用。</li>
<li>ConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）</li>
</ul>
<h2 id="Java集合的快速失败机制-fail-fast"><a href="#Java集合的快速失败机制-fail-fast" class="headerlink" title="Java集合的快速失败机制(fail-fast)"></a>Java集合的快速失败机制(fail-fast)</h2><ul>
<li>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast 机制。</li>
<li>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li>
<li>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>解决办法：<ol>
<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li>
<li>使用CopyOnWriteArrayList来替换ArrayList</li>
</ol>
</li>
</ul>
<h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？"></a>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？</h2><ul>
<li>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。</li>
</ul>
<h2 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h2><ul>
<li><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只 读 集 合 ， 这 样 改 变 集 合 的 任 何 操 作 都 会 抛 出 Java. lang.UnsupportedOperationException 异常。</p>
</li>
<li><p>示例代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"x"</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);</span><br><span class="line">clist.add(<span class="string">"y"</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System.out.println(list. size());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h3 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h3><ul>
<li>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</li>
</ul>
<h3 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h3><ul>
<li><p>Iterator 使用代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	String obj = it.next();</span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
</li>
</ul>
<h3 id="如何边遍历边移除-Collection-中的元素？"><a href="#如何边遍历边移除-Collection-中的元素？" class="headerlink" title="如何边遍历边移除 Collection 中的元素？"></a>如何边遍历边移除 Collection 中的元素？</h3><ul>
<li><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    *<span class="comment">// do something*</span></span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一种最常见的错误代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">	list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p>
</li>
</ul>
<h3 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h3><ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<h3 id="遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List遍历的最佳实践是什么？"><a href="#遍历一个-List-有哪些不同的方式？每种方法的实现原理是什么？Java-中-List遍历的最佳实践是什么？" class="headerlink" title="遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List遍历的最佳实践是什么？"></a>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List遍历的最佳实践是什么？</h3><ul>
<li>遍历方式有以下几种：<ul>
<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li>
<li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li>
<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>
</ul>
</li>
<li>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。<ul>
<li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li>
<li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li>
<li>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或foreach 遍历。</li>
</ul>
</li>
</ul>
<h3 id="说一下-ArrayList-的优缺点"><a href="#说一下-ArrayList-的优缺点" class="headerlink" title="说一下 ArrayList 的优缺点"></a>说一下 ArrayList 的优缺点</h3><ul>
<li>ArrayList的优点如下：<ul>
<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li>
<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>
</ul>
</li>
<li>ArrayList 的缺点如下：<ul>
<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li>
<li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li>
</ul>
</li>
<li>ArrayList 比较适合顺序添加、随机访问的场景。</li>
</ul>
<h3 id="如何实现数组和-List-之间的转换？转换完还能继续增加元素吗？"><a href="#如何实现数组和-List-之间的转换？转换完还能继续增加元素吗？" class="headerlink" title="如何实现数组和 List 之间的转换？转换完还能继续增加元素吗？"></a>如何实现数组和 List 之间的转换？转换完还能继续增加元素吗？</h3><ul>
<li><p>数组转 List：使用 Arrays.asList(array) 进行转换。</p>
<p>  List 转数组：使用 List 自带的 toArray() 方法。</p>
<p>  代码示例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list. add(<span class="string">"123"</span>);</span><br><span class="line">list. add(<span class="string">"456"</span>);</span><br><span class="line">list. toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"123"</span>,<span class="string">"456"</span>&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能增加元素，会报<code>Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList(E[] array) &#123;</span><br><span class="line">    a = Objects.requireNonNull(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  由于返回的ArrayList并不是java.util.ArrayList类，没有重写add()方法，所以不能新增</p>
</li>
</ul>
<h3 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h3><ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
<li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>
<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li>
<li>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</li>
</ul>
<h3 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h3><ul>
<li>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合<ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
</li>
<li>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</li>
<li>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</li>
</ul>
<h3 id="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList 的存储性能和特性？"></a>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList 的存储性能和特性？</h3><ul>
<li>ArrayList和Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li>
<li>Vector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。</li>
<li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。</li>
</ul>
<h3 id="多线程场景下如何使用-ArrayList"><a href="#多线程场景下如何使用-ArrayList" class="headerlink" title="多线程场景下如何使用 ArrayList"></a>多线程场景下如何使用 ArrayList</h3><ul>
<li>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">"aaa"</span>);</span><br><span class="line">synchronizedList.add(<span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">	System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h3><ul>
<li><p>ArrayList 中的数组定义如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再看一下 ArrayList 的定义：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">java.io.IOException</span>&#123;</span><br><span class="line">	*<span class="comment">// Write out element count, and any hidden stuff*</span></span><br><span class="line">	<span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">	s.defaultWriteObject();</span><br><span class="line">    *<span class="comment">// Write out array length*</span></span><br><span class="line">    s.writeInt(elementData.length);</span><br><span class="line">    *<span class="comment">// Write out all elements in the proper order.*</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    	s.writeObject(elementData[i]);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>
</li>
</ul>
<h3 id="ArrayList-默认大小是多少，是如何扩容的？"><a href="#ArrayList-默认大小是多少，是如何扩容的？" class="headerlink" title="ArrayList 默认大小是多少，是如何扩容的？"></a>ArrayList 默认大小是多少，是如何扩容的？</h3><ul>
<li>Jdk1.7 之前 ArrayList 默认大小是 10，JDK1.7 之后是 0，JDK 差异，每次约按 1.5 倍扩容。</li>
</ul>
<h3 id="List-和-Set-的区别"><a href="#List-和-Set-的区别" class="headerlink" title="List 和 Set 的区别"></a>List 和 Set 的区别</h3><ul>
<li>List , Set 都是继承自Collection 接口</li>
<li>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>
<li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及<br>  TreeSet。</li>
<li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li>
<li>Set和List对比<ul>
<li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li>
<li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起<br>  其他元素位置改变</li>
</ul>
</li>
</ul>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h3 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h3><ul>
<li>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</li>
</ul>
<h3 id="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"><a href="#HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="headerlink" title="HashSet如何检查重复？HashSet是如何保证数据不可重复的？"></a>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h3><ul>
<li><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p>
</li>
<li><p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p>
</li>
<li><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p>
</li>
<li><p>以下是HashSet 部分源码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>hashCode（）与equals（）的相关规定：</strong></p>
<ol>
<li><p>如果两个对象相等，则hashcode一定也是相同的，hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值</p>
</li>
<li><p>两个对象相等,对两个equals方法返回true</p>
</li>
<li><p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
</li>
<li><p>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</p>
</li>
<li><p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>
</li>
</ol>
<p>  <strong>==与equals的区别</strong></p>
<ol>
<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>
</ol>
</li>
</ul>
<ol start="2">
<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li>
</ol>
<h3 id="HashSet与HashMap的区别"><a href="#HashSet与HashMap的区别" class="headerlink" title="HashSet与HashMap的区别"></a>HashSet与HashMap的区别</h3><table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody><tr>
<td>实现了Map接口</td>
<td>实现了Set接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>存储对象</td>
</tr>
<tr>
<td>调用put（）向map中添加元素</td>
<td>调用add（）方法向Set中添加元素</td>
</tr>
<tr>
<td>HashMap使用键Key计算Hashcode</td>
<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>
</tr>
<tr>
<td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td>
<td>HashSet较HashMap来说比较慢</td>
</tr>
</tbody></table>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h2 id="什么是Hash算法"><a href="#什么是Hash算法" class="headerlink" title="什么是Hash算法"></a>什么是Hash算法</h2><ul>
<li>哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</li>
</ul>
<h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><ul>
<li>链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能。</li>
<li>链表大致分为单链表和双向链表<ol>
<li>单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针</li>
<li>双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针</li>
</ol>
</li>
<li>链表的优点<ul>
<li>插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加、删除元素）</li>
<li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）</li>
<li>大小没有固定，拓展很灵活。</li>
</ul>
</li>
<li>链表的缺点<ul>
<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ul>
</li>
</ul>
<h2 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h2><ul>
<li><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
</li>
<li><p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。</p>
<p>  HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
</li>
<li><p>HashMap 基于 Hash 算法实现的</p>
<ol>
<li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p>
</li>
<li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p>
<p>(1)如果key相同，则覆盖原始值；</p>
</li>
</ol>
<p>(2)如果key不同（出现冲突），则将当前的key-value放入链表中</p>
<ol start="3">
<li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p>
</li>
<li><p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
<p>==需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过8个之后，并且数组长度超过64，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)==</p>
</li>
</ol>
</li>
</ul>
<h2 id="HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？HashMap的底层实现" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h2><ul>
<li>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。</li>
</ul>
<p><strong>HashMap JDK1.8之前</strong></p>
<ul>
<li>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li>
</ul>
<p><strong>HashMap JDK1.8之后</strong></p>
<ul>
<li>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li>
</ul>
<p><strong>JDK1.7 VS JDK1.8 比较</strong></p>
<ul>
<li>JDK1.8主要解决或优化了一下问题：<ol>
<li>resize 扩容优化</li>
<li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li>
<li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>不同</th>
<th>JDK 1.7</th>
<th>JDK 1.8</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>初始化方式</td>
<td>单独函数： inflateTable()</td>
<td>直接集成到了扩容函数 resize() 中</td>
</tr>
<tr>
<td>hash值<br>计算方式</td>
<td>扰动处理 = <br>9次扰动 = 4次位运算 + 5次异或运算</td>
<td>扰动处理 = <br>2次扰动 = 1次位运算 + 1次异或运算</td>
</tr>
<tr>
<td>存放数据的规则</td>
<td>无冲突时，存放数组；<br>冲突时，存放链表</td>
<td>无冲突时，存放数组；<br>冲突 &amp; 链表长度 &lt;8：存放单链表；<br>冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>
</tr>
<tr>
<td>插入数据方式</td>
<td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>
<td>尾插法<br>（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td>全部按照原来方法进行计算<br>（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td>按照扩容后的规律计算<br>（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>
</tr>
</tbody></table>
<h2 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h2><p><strong>说到红黑树先讲什么是二叉树</strong></p>
<p>​    二叉树简单来说就是 每一个节上可以关联俩个子节点</p>
<p><strong>红黑树</strong></p>
<ul>
<li>红黑树是一种特殊的二叉查找树。红黑树的每个结点上都有存储位表示结点的颜色，可以是红(Red)或黑(Black)。</li>
<li>红黑树的每个结点是黑色或者红色。当是不管怎么样他的根结点是黑色。每个叶子结点（叶子结点代表终结、结尾的节点）也是黑色 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]。</li>
<li>如果一个结点是红色的，则它的子结点必须是黑色的。</li>
<li>每个结点到叶子结点NIL所经过的黑色结点的个数一样的。[确保没有一条路径会比其他路径长出俩倍，所以红黑树是相对接近平衡的二叉树的！]</li>
<li>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的结点之后，红黑树的结构就发生了变化，可能不满足上面三条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转和变色，可以使这颗树重新成为红黑树。简单点说，旋转和变色的目的是让树保持红黑树的特性。</li>
</ul>
<h2 id="HashMap的put-方法的具体流程？"><a href="#HashMap的put-方法的具体流程？" class="headerlink" title="HashMap的put()方法的具体流程？"></a>HashMap的put()方法的具体流程？</h2><ul>
<li><p>当我们put的时候，首先计算 key 的 hash 值，这里调用了 hash 方法， hash 方法实际是让<br>  key.hashCode() 与 key.hashCode()&gt;&gt;&gt;16 进行异或操作，高16bit补0，一个数和0异或不变，<br>  所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标 index = (table.length - 1) &amp;<br>  hash ，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p>
</li>
<li><p>putVal()方法执行流程图如下</p>
<p>  <img src="%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88.assets/1616205167185.png" alt></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key 键经过扰动的哈希值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key 键</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value the value to put 值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value 如果要放入的位置为空才放入，不进行替换</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//tab表示当前HashMap的table，p是table的旧的元素，n是散列表的长度，i是路由寻址结果</span></span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//如果table为空，调用resize()方法，初始化table，在第一次用到的时候初始化</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//1.如果要放入的位置刚好为null就直接放入，寻址算法：用与运算替代取模提升性能</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//e 存放table中需要修改的元素，k也是需要修改元素的key</span></span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//2.当前位置还是数组，放入的位置和你要存的值，键相同，需要进行覆盖操作，将旧值p临时存放到e中</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="comment">//3.如果当前位置已经树化了</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="comment">//4.当前位置成为链表</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//循环查找元素</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">//4.1 查到最后一个元素了也没有找到匹配的</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   	<span class="comment">//最后一个元素再指向新的元素，尾插法，新元素成为末尾节点</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//循环值从0开始，所以判断值是否达到树化阈值（条件之一）</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//4.2 找到key一致的元素，需要进行覆盖，break结束循环，此时e等于需要替换的元素</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="comment">//4.3 查找过程中，没找到对应的也没循环结束。把下一个元素赋给p，继续查找</span></span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果找到了需要与插入的元素 key一致的，也就是位置一致的元素</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">           	<span class="comment">//存放旧元素的值</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="comment">//先判断参数，不为空是否允许修改</span></span><br><span class="line">               <span class="comment">//如果不为空不允许修改，那么取反就是false，那就看后面的元素值是不是null，空的化就可以修改，妙啊~</span></span><br><span class="line">               <span class="comment">//如果不为空允许修改，那么取反就是true，那就不管空不空都会修改</span></span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               <span class="comment">//为LinkedHashMap预留</span></span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="comment">//返回旧值</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//table结构修改次数+1,不包括值替换</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">//如果元素大小超过阈值时调用resize()方法</span></span><br><span class="line">       <span class="comment">//threshold在第一次put的时候调用过resize()已经计算过</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="comment">//没有旧值返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="HashMap的扩容操作是怎么实现的？"><a href="#HashMap的扩容操作是怎么实现的？" class="headerlink" title="HashMap的扩容操作是怎么实现的？"></a>HashMap的扩容操作是怎么实现的？</h2><ol>
<li><p>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p>
</li>
<li><p>每次扩展的时候，都是扩展2倍；</p>
</li>
<li><p>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>
<p> 在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p>
</li>
</ol>
<h2 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h2><ul>
<li><p><strong>什么是哈希？</strong></p>
<p>  Hash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</p>
</li>
<li><p><strong>什么是哈希冲突？</strong></p>
<p>  当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p>
</li>
<li><p><strong>HashMap的数据结构</strong></p>
<ul>
<li><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。</p>
<ul>
<li>数组的特点是：寻址容易，插入和删除困难；</li>
<li>链表的特点是：寻址困难，但插入和删除容易；</li>
</ul>
</li>
<li><p>所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用俩种方式：链地址法和开放地址法可以解决哈希冲突：</p>
</li>
<li><p>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；<br>  开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</p>
</li>
<li><p>但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 （即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</p>
</li>
</ul>
</li>
<li><p>hash()函数</p>
<ul>
<li><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：<ul>
<li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li>
<li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="能否使用任何类作为-Map-的-key？"><a href="#能否使用任何类作为-Map-的-key？" class="headerlink" title="能否使用任何类作为 Map 的 key？"></a>能否使用任何类作为 Map 的 key？</h2><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p>
<ul>
<li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li>
<li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li>
<li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li>
<li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<h2 id="为什么HashMap中String、Integer这样的包装类适合作为Key？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为Key？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为Key？"></a>为什么HashMap中String、Integer这样的包装类适合作为Key？</h2><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减<br>少Hash碰撞的几率</p>
<ul>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了 equals() 、 hashCode() 等方法，遵守了HashMap内部的规范（不清楚可以<br>  去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li>
</ul>
<h2 id="如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办呢？"></a>如果使用Object作为HashMap的Key，应该怎么办呢？</h2><p>重写 hashCode() 和 equals() 方法</p>
<ol>
<li>重写 hashCode() 是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中<br> 排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>
<li>重写 equals() 方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用<br> 值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</li>
</ol>
<h2 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2><ul>
<li><p>hashCode() 方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过 hashCode() 计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
</li>
<li><p><strong>那怎么解决呢？</strong></p>
<ul>
<li>HashMap自己实现了自己的 hash() 方法，通过两次扰动使得它自己的哈希值高低位自行进<br>  行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li>
</ul>
<ol start="2">
<li>在保证数组长度为2的幂次方的时候，使用 hash() 运算之后的值与运算（&amp;）（数组长度 -<br>1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li>
</ol>
</li>
</ul>
<h2 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h2><ul>
<li>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</li>
<li>这个算法应该如何设计呢？<ul>
<li>我们首先可能会想到采用%取余的操作来实现。</li>
<li>但是，重点来了：取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。</li>
<li>并且采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li>
</ul>
</li>
<li>那为什么是两次扰动呢？<ul>
<li>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</li>
</ul>
</li>
</ul>
<h2 id="HashMap-与-HashTable-有什么区别？"><a href="#HashMap-与-HashTable-有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h2><ol>
<li>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li>
<li>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li>
<li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li>
<li>初始容量大小和每次扩充容量大小的不同 ：<ol>
<li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li>
<li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li>
</ol>
</li>
<li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
</ol>
<h2 id="什么是TreeMap"><a href="#什么是TreeMap" class="headerlink" title="什么是TreeMap"></a>什么是TreeMap</h2><ul>
<li>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。</li>
<li>TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li>
<li>TreeMap是线程非同步的。</li>
</ul>
<h2 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h2><ul>
<li>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</li>
</ul>
<h2 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h2><ol>
<li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li>
<li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li>
</ol>
<h2 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h2><ul>
<li><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；<br>  实现线程安全的方式：<ol>
<li>在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li>Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ol>
</li>
</ul>
</li>
<li><p>两者的对比图：</p>
<ul>
<li><p>HashTable:</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212819917.png" alt></p>
</li>
<li><p>JDK1.7的ConcurrentHashMap：</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212846206.png" alt></p>
</li>
<li><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212860845.png" alt></p>
</li>
</ul>
</li>
<li><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题使用了synchronized 关键字，所以 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>
</li>
</ul>
<h2 id="ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h2><ul>
<li><p><strong>JDK1.7</strong></p>
<ul>
<li><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
</li>
<li><p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p>
<p>  一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212945385.png" alt></p>
</li>
</ul>
<ol>
<li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当<br>锁的角色；</li>
<li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元<br>素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>
</ol>
</li>
<li><p><strong>JDK1.8</strong></p>
<ul>
<li><p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。<br>  结构如下：</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/1616212987126.png" alt></p>
</li>
<li><p>插入元素过程（==需要看源码，未完待续==）：</p>
</li>
<li><p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">	<span class="keyword">break</span>; <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">    	K ek;</span><br><span class="line">    	<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">    		((ek = e.key) == key ||</span><br><span class="line">    		(ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">    		oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	Node&lt;K,V&gt; pred = e;</span><br><span class="line">    	<span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li>
<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="辅助工具类"><a href="#辅助工具类" class="headerlink" title="辅助工具类"></a>辅助工具类</h1><h2 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h2><ul>
<li><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</p>
</li>
<li><p>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p>
</li>
<li><p>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList有。</p>
<p>  <code>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</code></p>
</li>
</ul>
<h2 id="Comparable-和-Comparator-接口是干什么的？列出它们的区别。"><a href="#Comparable-和-Comparator-接口是干什么的？列出它们的区别。" class="headerlink" title="Comparable 和 Comparator 接口是干什么的？列出它们的区别。"></a><strong>Comparable 和 Comparator 接口是干什么的？列出它们的区别。</strong></h2><ul>
<li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li>
<li>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</li>
</ul>
<h2 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><ul>
<li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li>
<li>Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li>
<li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li>
<li>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</li>
</ul>
<h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2021/03/20/面试-集合/" data-id="ckmh9ucmq008s3oumlaz179li" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集合/">集合</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试题/">面试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-框架-Maven-配置标签详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/21/框架-Maven-配置标签详解/" class="article-date">
  <time datetime="2020-07-20T16:00:00.000Z" itemprop="datePublished">2020-07-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Maven/">Maven</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/21/框架-Maven-配置标签详解/">Maven配置标签详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Maven配置标签详解"><a href="#Maven配置标签详解" class="headerlink" title="Maven配置标签详解"></a>Maven配置标签详解</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 </span></span><br><span class="line"><span class="comment">        version。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 </span></span><br><span class="line"><span class="comment">            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asia.banseon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 </span></span><br><span class="line"><span class="comment">        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 </span></span><br><span class="line"><span class="comment">        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span>jira<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目持续集成信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--传送通知的途径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生错误时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建失败时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建成功时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生警告时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">address</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--扩展配置项 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--邮件的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">post</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http:/hi.baidu.com/banseon/demo/dev/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目开发者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的全名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的email --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.baidu.com/banseon<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dept</span>&gt;</span>No<span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>-5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--license用于法律上的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache 2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">comments</span>&gt;</span>A business-friendly OSS license<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class="line">        <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织的全名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织主页的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scriptSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testOutputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--描述使用到的构建扩展。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的groupId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的artifactId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 </span></span><br><span class="line"><span class="comment">                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--profile默认是否激活的标志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                    ......</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                ......</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    ......</span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencyManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见distributionManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见properties元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--true，则，网站不包括默认的报表。这包括"项目信息"菜单中的报表。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的group ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件的配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon maven2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Banseon-maven2 Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>business api website<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class="line">            <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的版本号 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 </span></span><br><span class="line"><span class="comment">            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">status</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2020/07/21/框架-Maven-配置标签详解/" data-id="ckmh9ucmi008f3oump0nci6d0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Maven/">Maven</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-七大原则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/13/设计模式-七大原则/" class="article-date">
  <time datetime="2020-07-12T16:00:00.000Z" itemprop="datePublished">2020-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>►<a class="article-category-link" href="/categories/设计模式/设计原则/">设计原则</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/13/设计模式-七大原则/">设计模式-七大设计原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="设计模式-七大设计原则"><a href="#设计模式-七大设计原则" class="headerlink" title="设计模式-七大设计原则"></a>设计模式-七大设计原则</h1><p>==<strong>三种类型</strong>==</p>
<ol>
<li><strong>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</strong></li>
<li><strong>结构性模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</strong></li>
<li><strong>行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式</strong></li>
</ol>
<p>==<strong>核心思想</strong>==</p>
<ol>
<li><strong>代码重用性（即：相同功能的代码，不用多次编写）</strong></li>
<li><strong>可读性（即：编程规范性，便于其他程序员的阅读和理解）</strong></li>
<li><strong>可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）</strong></li>
<li><strong>可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</strong></li>
<li><strong>使程序呈现高内聚，低耦合的特性</strong></li>
</ol>
<h2 id="1）、单一职责原则（Single-Responsibility）"><a href="#1）、单一职责原则（Single-Responsibility）" class="headerlink" title="1）、单一职责原则（Single Responsibility）"></a>1）、单一职责原则（Single Responsibility）</h2><p><strong>目的：</strong>降低代码复杂度、系统解耦合、提高可读性</p>
<p>​        对类来说，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。</p>
<ol>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性。</li>
<li>降低变更引起的风险。</li>
<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责；只有类中方法数量足够少，可以在方法级别保持单一职责原则。</li>
</ol>
<p><strong>==快速记忆：各司其职，降低耦合==</strong></p>
<h2 id="2）、接口隔离原则（Interface-Segregation）"><a href="#2）、接口隔离原则（Interface-Segregation）" class="headerlink" title="2）、接口隔离原则（Interface Segregation）"></a>2）、接口隔离原则（Interface Segregation）</h2><p><strong>目的：</strong>避免接口过于臃肿</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类A通过Interface1会依赖（使用）类B</span></span><br><span class="line"><span class="comment">//但是A只会用到接口的fun1(),fun2(),fun3()三个方法</span></span><br><span class="line"><span class="comment">//类C通过Interface1会依赖（使用）类D</span></span><br><span class="line"><span class="comment">//但是C只会用到接口的fun1(),fun4(),fun5()三个方法</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>类A通过Interface1会依赖（使用）类B（<strong>比如：在control层调用service层实现方法时</strong>），类C通过Interface1会依赖（使用）类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。</p>
</li>
<li><p>将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
</li>
<li><p>接口Interface1中出现的方法，根据实际情况拆分为三个接口</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface3</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>==快速记忆：利用接口的多实现，拆分粒度尽量小，避免实现类重写不需要的方法==</strong></p>
</li>
</ol>
<h2 id="3）、依赖倒转原则（Dependence-Inversion）"><a href="#3）、依赖倒转原则（Dependence-Inversion）" class="headerlink" title="3）、依赖倒转原则（Dependence Inversion）"></a>3）、依赖倒转原则（Dependence Inversion）</h2><p><strong>目的：</strong>避免需求变化导致过多的维护工作</p>
<ol>
<li><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象，低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。</p>
</li>
<li><p>抽象不应该依赖细节，细节应该依赖抽象。</p>
</li>
<li><p>依赖倒转（倒置）的中心思想是面向接口编程。</p>
</li>
<li><p>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。</p>
</li>
<li><p>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展示细节的任务交给他们的实现类去完成。</p>
</li>
<li><p>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。</p>
</li>
<li><p>继承时遵循里氏替换原则。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependenceInversion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">        person.receive(<span class="keyword">new</span> WeChat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Receive Email"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeChat</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Receive WeChat"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person 接受信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Info info)</span> </span>&#123;</span><br><span class="line">        System.out.println(info.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>依赖关系的传递方式：</strong></p>
<ul>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方式传递</li>
</ul>
<p> <strong>==快速记忆：面向接口编程，这就是为什么service 要多写个接口，然后才是实现类==</strong></p>
</li>
</ol>
<h2 id="4）、里氏替换原则（Liskov-Substitution）"><a href="#4）、里氏替换原则（Liskov-Substitution）" class="headerlink" title="4）、里氏替换原则（Liskov Substitution）"></a>4）、里氏替换原则（Liskov Substitution）</h2><p><strong>目的：</strong>避免系统继承体系被破坏</p>
<ol>
<li><p>里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院一位姓里的女士提出。</p>
</li>
<li><p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</p>
</li>
<li><p>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。</p>
</li>
<li><p>继承实际上让两个类耦合性增强了，给程序带来侵入性。在适当的情况下，可以通过聚合，组合，依赖来解决问题。</p>
</li>
<li><p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiskovSubstitution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">"2-1="</span> + a.func1(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">"2+1="</span> + b.func1(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"2+1+9="</span> + b.func2(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"B类使用A类方法：2-1="</span> + b.func3(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把基础方法和成员抽取成基类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public int func1(int num1, int num2) &#123;</span></span><br><span class="line"><span class="comment">//        return num1 - num2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// TODO 类 B `无意` 重写了父类 A 方法，造成原有方法发生改变。</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int func1(int num1, int num2) &#123;</span></span><br><span class="line"><span class="comment">//        return num1 + num2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(num1, num2) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();<span class="comment">//组合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 A 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>==快速记忆：子类可以扩展父类的功能，但不能改变父类原有的功能==</strong></p>
</li>
</ol>
<h2 id="5）、开闭原则（Open-Closed）"><a href="#5）、开闭原则（Open-Closed）" class="headerlink" title="5）、开闭原则（Open Closed）"></a>5）、开闭原则（Open Closed）</h2><p><strong>目的：</strong>提高扩展性、便于维护</p>
<ol>
<li><p>开闭原则(Open Closed Principle) 是编程中最基础、最重要的设计原则。</p>
</li>
<li><p>一个软件实体，比如类，模块和函数应该对==提供方扩展开放==，对==使用方修改关闭==。用抽象构建框架，用实现扩展细节。</p>
</li>
<li><p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
</li>
<li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenClosed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Use use = <span class="keyword">new</span> Use();</span><br><span class="line">        use.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">        use.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        use.drawShape(<span class="keyword">new</span> OtherGraphics());<span class="comment">//只需要让 此类继承 抽象类，子类实现具体方法  OCP原则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Use</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类实现具体功能：三角形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类实现具体功能：圆形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphics</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类实现具体功能：任何形状"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>==快速记忆：比如你作为开发可以修改程序，但用户无法修改。即 类，模块和函数提供方开放修改，调用方关闭修改==</strong></p>
</li>
</ol>
<h2 id="6）、迪米特法则（Demeter）"><a href="#6）、迪米特法则（Demeter）" class="headerlink" title="6）、迪米特法则（Demeter）"></a>6）、迪米特法则（Demeter）</h2><p><strong>目的：</strong>降低类与类之间的耦合</p>
<ol>
<li><p>一个对象应该对其他对象保持最少的了解（最少知道原则 LKP）。</p>
</li>
<li><p>类与类关系越密切，耦合度越大。要求降低类之间耦合，而不是完全解耦。</p>
</li>
<li><p>迪米特法则(Demeter Principle)，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息。</p>
</li>
<li><p>迪米特法则更简单的定义：只与直接的朋友通信。</p>
</li>
<li><p>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    B b;<span class="comment">//全局变量 - 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">m1</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//方法返回值 - 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(B b)</span></span>&#123;&#125;<span class="comment">//方法入参 - 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B b1 = <span class="keyword">new</span> B();<span class="comment">// 局部变量 非直接朋友</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工 //TODO CollegeEmployee 直接朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10 个员工到list ，</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">"学院员工id "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCollegeEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">"---学院员工----"</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//TODO 直接朋友 Employee CollegeManager</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SchoolEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SchoolEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SchoolEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到list</span></span><br><span class="line">            SchoolEmployee emp = <span class="keyword">new</span> SchoolEmployee();</span><br><span class="line">            emp.setId(<span class="string">"学校总部员工id= "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        <span class="comment">//TODO 非直接朋友 CollegeEmployee  应该提取到  CollegeManager</span></span><br><span class="line"><span class="comment">//        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span></span><br><span class="line"><span class="comment">//        System.out.println("---学院员工----");</span></span><br><span class="line"><span class="comment">//        for (CollegeEmployee e : list1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e.getId());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        sub.printCollegeEmployee();<span class="comment">//只提供方法，不把具体实现放在其他类里面。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;SchoolEmployee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">"------学校总部员工------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (SchoolEmployee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>==快速记忆：只与直接的朋友通信。校长管老师，老师管学生。校长找学生不会直接去找，而是通过老师去找。==</strong></p>
</li>
</ol>
<h2 id="7）、合成复用原则（Composite-Reuse）"><a href="#7）、合成复用原则（Composite-Reuse）" class="headerlink" title="7）、合成复用原则（Composite Reuse）"></a>7）、合成复用原则（Composite Reuse）</h2><p><strong>目的：</strong>防止类的体系庞大</p>
<ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>为了交互对象之间的松耦合设计而努力。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeReuse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------依赖------"</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.Operation1(<span class="keyword">new</span> A());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------聚合------"</span>);</span><br><span class="line">        b.setA(<span class="keyword">new</span> A());</span><br><span class="line">        b.Operation2();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------组合------"</span>);</span><br><span class="line">        b.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A Operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A Operation2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A Operation3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只是需要用到 A类的方法，尽量不要使用继承。而是使用，依赖，聚合，组合的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">(A a)</span> </span>&#123;<span class="comment">//TODO 依赖</span></span><br><span class="line">        a.Operation1();</span><br><span class="line">        a.Operation2();</span><br><span class="line">        a.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================================================</span></span><br><span class="line">    A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;<span class="comment">//TODO 聚合</span></span><br><span class="line">        a.Operation1();</span><br><span class="line">        a.Operation2();</span><br><span class="line">        a.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================================================</span></span><br><span class="line">    A a1 = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span> </span>&#123;<span class="comment">//TODO 组合</span></span><br><span class="line">        a1.Operation1();</span><br><span class="line">        a1.Operation2();</span><br><span class="line">        a1.Operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>==快速记忆：当类与类之间的关系是”Is-A”时，用继承；当类与类之间的关系是”Has-A”时，用组合。==</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2020/07/13/设计模式-七大原则/" data-id="ckmh9ucm0007m3oum0ld975am" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计原则/">设计原则</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式-创建型模式-单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/13/设计模式-创建型模式-单例模式/" class="article-date">
  <time datetime="2020-07-12T16:00:00.000Z" itemprop="datePublished">2020-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>►<a class="article-category-link" href="/categories/设计模式/创建型模式/">创建型模式</a>►<a class="article-category-link" href="/categories/设计模式/创建型模式/单例模式/">单例模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/13/设计模式-创建型模式-单例模式/">设计模式-创建型模式-单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="设计模式-创建型模式-单例模式"><a href="#设计模式-创建型模式-单例模式" class="headerlink" title="设计模式-创建型模式-单例模式"></a>设计模式-创建型模式-单例模式</h1><h2 id="1）、饿汉式（静态常量）"><a href="#1）、饿汉式（静态常量）" class="headerlink" title="1）、饿汉式（静态常量）"></a>1）、饿汉式（静态常量）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">		System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点说明：</strong></p>
<ol>
<li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</li>
<li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</li>
<li>这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果</li>
<li>结论：这种单例模式可用，可能造成内存浪费。</li>
</ol>
<h2 id="2）、饿汉式（静态代码块）"><a href="#2）、饿汉式（静态代码块）" class="headerlink" title="2）、饿汉式（静态代码块）"></a>2）、饿汉式（静态代码块）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">		System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123; <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line">		instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点说明：</strong></p>
<ol>
<li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</li>
<li>结论：这种单例模式可用，但是可能造成内存浪费。</li>
</ol>
<h2 id="3）、懒汉式（线程不安全）"><a href="#3）、懒汉式（线程不安全）" class="headerlink" title="3）、懒汉式（线程不安全）"></a>3）、懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"懒汉式1 ， 线程不安全~"</span>);</span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">		System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点说明：</strong></p>
<ol>
<li>起到了 Lazy Loading 的效果，但是只能在单线程下使用。</li>
<li>如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li>
<li>结论：在实际开发中，不要使用这种方式. </li>
</ol>
<h2 id="4）、懒汉式（线程安全，同步方法）"><a href="#4）、懒汉式（线程安全，同步方法）" class="headerlink" title="4）、懒汉式（线程安全，同步方法）"></a>4）、懒汉式（线程安全，同步方法）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"懒汉式2 ， 线程安全~"</span>);</span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">		System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点说明：</strong></p>
<ol>
<li>解决了线程安全问题</li>
<li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低</li>
<li>结论：在实际开发中，不推荐使用这种方式</li>
</ol>
<h2 id="5）、懒汉式（线程安全，同步代码块）"><a href="#5）、懒汉式（线程安全，同步代码块）" class="headerlink" title="5）、懒汉式（线程安全，同步代码块）"></a>5）、懒汉式（线程安全，同步代码块）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            	instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>开发中不能使用</strong></p>
<h2 id="6）、双重检查"><a href="#6）、双重检查" class="headerlink" title="6）、双重检查"></a>6）、双重检查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"双重检查"</span>);</span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">		System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重检查</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">	<span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点说明：</strong></p>
<ol>
<li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这样就可以保证线程安全了。</li>
<li>这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步. </li>
<li>线程安全；延迟加载；效率较高</li>
<li>结论：在实际开发中，推荐使用这种单例设计模式</li>
</ol>
<h2 id="7）、静态内部类"><a href="#7）、静态内部类" class="headerlink" title="7）、静态内部类"></a>7）、静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest07</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"使用静态内部类完成单例模式"</span>);</span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		System.out.println(instance == instance2); <span class="comment">// true</span></span><br><span class="line">		System.out.println(<span class="string">"instance.hashCode="</span> + instance.hashCode());</span><br><span class="line">		System.out.println(<span class="string">"instance2.hashCode="</span> + instance2.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器私有化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点说明：</strong></p>
<ol>
<li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li>
<li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。</li>
<li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li>
<li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高。</li>
<li>结论：推荐使用。</li>
</ol>
<h2 id="8）、枚举"><a href="#8）、枚举" class="headerlink" title="8）、枚举"></a>8）、枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest08</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Singleton instance = Singleton.INSTANCE;</span><br><span class="line">		Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">		System.out.println(instance == instance2);</span><br><span class="line">		</span><br><span class="line">		System.out.println(instance.hashCode());</span><br><span class="line">		System.out.println(instance2.hashCode());</span><br><span class="line">		</span><br><span class="line">		instance.sayOK();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">	INSTANCE; <span class="comment">//属性</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ok~"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优缺点说明：</strong></p>
<ol>
<li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li>
<li>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式</li>
<li>结论：推荐使用</li>
</ol>
<h2 id="9）、单例模式在JDK应用的源码分析"><a href="#9）、单例模式在JDK应用的源码分析" class="headerlink" title="9）、单例模式在JDK应用的源码分析"></a>9）、单例模式在JDK应用的源码分析</h2><p>例如：在JDK 中，<strong>java.lang.Runtime</strong> 就是经典的单例模式(饿汉式)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Runtime &#123;</span><br><span class="line">	//类加载直接生成对象</span><br><span class="line">    private static Runtime currentRuntime = new Runtime();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the runtime object associated with the current Java application.</span><br><span class="line">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="line">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="line">     *</span><br><span class="line">     * @return  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="line">     *          Java application.</span><br><span class="line">     */</span><br><span class="line">    public static Runtime getRuntime() &#123;</span><br><span class="line">        return currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Don&apos;t let anyone else instantiate this class */</span><br><span class="line">    private Runtime() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10）、单例模式注意事项和细节说明"><a href="#10）、单例模式注意事项和细节说明" class="headerlink" title="10）、单例模式注意事项和细节说明"></a>10）、单例模式注意事项和细节说明</h2><ol>
<li><strong>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使</strong><br> <strong>用单例模式可以提高系统性能</strong></li>
<li><strong>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</strong></li>
<li><strong>单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级</strong><br> <strong>对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session</strong></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2020/07/13/设计模式-创建型模式-单例模式/" data-id="ckmh9uclf006e3oump2eeu5y4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/创建型模式/">创建型模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单例模式/">单例模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库-MySQL-MySQL高级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/19/数据库-MySQL-MySQL高级/" class="article-date">
  <time datetime="2020-04-18T16:00:00.000Z" itemprop="datePublished">2020-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/数据库-MySQL-MySQL高级/">MySQL高级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-MySQL的结构介绍"><a href="#1-MySQL的结构介绍" class="headerlink" title="1.MySQL的结构介绍"></a>1.MySQL的结构介绍</h1><h2 id="1-1MySQL简介"><a href="#1-1MySQL简介" class="headerlink" title="1.1MySQL简介"></a>1.1MySQL简介</h2><h3 id="1-1-1-概述"><a href="#1-1-1-概述" class="headerlink" title="1.1.1 概述"></a>1.1.1 概述</h3><h3 id="1-1-2-高级MYSQL"><a href="#1-1-2-高级MYSQL" class="headerlink" title="1.1.2 高级MYSQL"></a>1.1.2 高级MYSQL</h3><ul>
<li>mysql内核</li>
<li>sql优化工程师</li>
<li>mysql服务器的优化</li>
<li>查询语句优化</li>
<li>主重复制</li>
<li>软硬件升级</li>
<li>容灾备份</li>
<li>sql编程</li>
</ul>
<h2 id="1-2MySQL-Linux版安装"><a href="#1-2MySQL-Linux版安装" class="headerlink" title="1.2MySQL-Linux版安装"></a>1.2MySQL-Linux版安装</h2><p><a href="https://fangchenyong.top/2019/07/23/install_MySql5.7/">CentOS 7.2 安装MySql 5.7</a></p>
<h2 id="1-3MySQL主要配置文件"><a href="#1-3MySQL主要配置文件" class="headerlink" title="1.3MySQL主要配置文件"></a>1.3MySQL主要配置文件</h2><h3 id="1-3-1-二进制日志log-bin"><a href="#1-3-1-二进制日志log-bin" class="headerlink" title="1.3.1 二进制日志log-bin"></a>1.3.1 二进制日志log-bin</h3><ul>
<li>主从复制</li>
</ul>
<h3 id="1-3-2-错误日志log-error"><a href="#1-3-2-错误日志log-error" class="headerlink" title="1.3.2 错误日志log-error"></a>1.3.2 错误日志log-error</h3><ul>
<li>默认是关闭的,记录严重的警告和错误信息,每次启动和关闭的详细信息等.</li>
</ul>
<h3 id="1-3-3-查询日志log"><a href="#1-3-3-查询日志log" class="headerlink" title="1.3.3 查询日志log"></a>1.3.3 查询日志log</h3><ul>
<li>默认关闭,记录查询的sql语句，如果开启会减低mysql的整体性能，因为记录日志也是需要消耗系统资源的</li>
</ul>
<h3 id="1-3-4-数据文件"><a href="#1-3-4-数据文件" class="headerlink" title="1.3.4  数据文件"></a>1.3.4  数据文件</h3><ul>
<li>两个系统<ul>
<li>windows<ul>
<li>D:\ProgramFiles\MySQL\MySQLServer5.5\data目录下可以挑选很多库</li>
</ul>
</li>
<li>linux<ul>
<li>看看当前系统中的全部库后再进去</li>
<li>默认路径：/var/lib/mysql</li>
</ul>
</li>
</ul>
</li>
<li>frm文件<ul>
<li>存放表结构</li>
</ul>
</li>
<li>myd文件<ul>
<li>存放表数据</li>
</ul>
</li>
<li>myi文件<ul>
<li>存放表索引</li>
</ul>
</li>
</ul>
<h3 id="1-3-5-如何配置"><a href="#1-3-5-如何配置" class="headerlink" title="1.3.5 如何配置"></a>1.3.5 如何配置</h3><ul>
<li>windows<ul>
<li>my.ini文件</li>
</ul>
</li>
<li>Linux<ul>
<li>/etc/my.cnf文件</li>
</ul>
</li>
</ul>
<h2 id="1-4Mysql逻辑架构介绍"><a href="#1-4Mysql逻辑架构介绍" class="headerlink" title="1.4Mysql逻辑架构介绍"></a>1.4Mysql逻辑架构介绍</h2><ul>
<li><p>总体概览</p>
<blockquote>
<p>1.Connectors<br>指的是不同语言中与SQL的交互<br>2 Management Serveices &amp; Utilities： <br>系统管理和控制工具<br>3 Connection Pool: 连接池<br>管理缓冲用户连接，线程处理等需要缓存的需求。<br>负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，<br>接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。<br>4 SQL Interface: SQL接口。…</p>
</blockquote>
</li>
<li><p>查询说明</p>
</li>
</ul>
<h2 id="1-5Mysql存储引擎"><a href="#1-5Mysql存储引擎" class="headerlink" title="1.5Mysql存储引擎"></a>1.5Mysql存储引擎</h2><ul>
<li>查看命令</li>
<li>MyISAM和InnoDB</li>
<li>阿里巴巴，淘宝用哪个</li>
</ul>
<h1 id="2-索引优化分析"><a href="#2-索引优化分析" class="headerlink" title="2.索引优化分析"></a>2.索引优化分析</h1><h2 id="2-1-性能下降SQL慢-执行时间长-等待时间长"><a href="#2-1-性能下降SQL慢-执行时间长-等待时间长" class="headerlink" title="2.1 性能下降SQL慢 执行时间长 等待时间长"></a>2.1 性能下降SQL慢 执行时间长 等待时间长</h2><h3 id="2-1-1查询语句写的烂"><a href="#2-1-1查询语句写的烂" class="headerlink" title="2.1.1查询语句写的烂"></a>2.1.1查询语句写的烂</h3><h3 id="2-1-2索引失效"><a href="#2-1-2索引失效" class="headerlink" title="2.1.2索引失效"></a>2.1.2索引失效</h3><ul>
<li>单值</li>
<li>复合</li>
</ul>
<h3 id="2-1-3关联查询太多join-设计缺陷或不得已的需求"><a href="#2-1-3关联查询太多join-设计缺陷或不得已的需求" class="headerlink" title="2.1.3关联查询太多join(设计缺陷或不得已的需求)"></a>2.1.3关联查询太多join(设计缺陷或不得已的需求)</h3><h3 id="2-1-4服务器调优及各个参数设置-缓冲-线程数等"><a href="#2-1-4服务器调优及各个参数设置-缓冲-线程数等" class="headerlink" title="2.1.4服务器调优及各个参数设置(缓冲\线程数等)"></a>2.1.4服务器调优及各个参数设置(缓冲\线程数等)</h3><h2 id="2-2-常见通用的join查询"><a href="#2-2-常见通用的join查询" class="headerlink" title="2.2 常见通用的join查询"></a>2.2 常见通用的join查询</h2><h3 id="2-2-1-SQL执行顺序"><a href="#2-2-1-SQL执行顺序" class="headerlink" title="2.2.1 SQL执行顺序"></a>2.2.1 SQL执行顺序</h3><ul>
<li>手写</li>
<li>机读</li>
<li>总结</li>
</ul>
<h3 id="2-2-2-Join图"><a href="#2-2-2-Join图" class="headerlink" title="2.2.2 Join图"></a>2.2.2 Join图</h3><h3 id="2-2-3-建表SQL"><a href="#2-2-3-建表SQL" class="headerlink" title="2.2.3 建表SQL"></a>2.2.3 建表SQL</h3><h3 id="2-2-4-7种Join"><a href="#2-2-4-7种Join" class="headerlink" title="2.2.4 7种Join"></a>2.2.4 7种Join</h3><h2 id="2-3-索引简介"><a href="#2-3-索引简介" class="headerlink" title="2.3 索引简介"></a>2.3 索引简介</h2><p>2.3.1 是什么</p>
<ul>
<li>MySQL官方对索引的定义为：索引(Index)是帮助MySQL高校获取数据的数据结构。<br>  可以得到索引的本质：索引是数据结构</li>
<li>你可以简单理解为”排好序的快速查找数据结构”。</li>
<li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上</li>
<li>我们平时所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引，次要索引，覆盖索引，<br>  复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然,除了B+树这种类型的索引之外，还有哈希索引(hash index)等。</li>
</ul>
<p>2.3.2 优势</p>
<ul>
<li>类似大学图书馆建书目索引，提高数据检索效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗</li>
</ul>
<p>2.3.3 劣势</p>
<ul>
<li>实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录,所以索引列也是要占用空间的</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度,如果对表INSERT,UPDATE和DELETE。<br>  因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，<br>  都会调整因为更新所带来的键值变化后的索引信息</li>
<li>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句</li>
</ul>
<p>2.3.4 mysql索引分类</p>
<ul>
<li><p>单值索引</p>
<ul>
<li><p>即一个索引只包含单个列，一个表可以有多个单列索引</p>
<blockquote>
<p>建议一张表索引不要超过5个<br>优先考虑复合索引</p>
</blockquote>
</li>
</ul>
</li>
<li><p>唯一索引</p>
<ul>
<li>索引列的值必须唯一，但允许有空值</li>
</ul>
</li>
<li><p>复合索引</p>
<ul>
<li>即一个索引包含多个列</li>
</ul>
</li>
<li><p>基本语法</p>
<ul>
<li>创建<ul>
<li>CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));</li>
<li>ALTER mytable ADD [UNIQUE] INDEX [indexName] ON(columnname(length));</li>
</ul>
</li>
<li>删除<ul>
<li>DROP INDEX [indexName] ON mytable;</li>
</ul>
</li>
<li>查看<ul>
<li>SHOW INDEX FROM table_name\G</li>
</ul>
</li>
<li>使用ALTER命令</li>
</ul>
</li>
</ul>
<p>2.3.5 mysql索引结构</p>
<ul>
<li><p>BTree索引</p>
<blockquote>
<p>Btree索引(或Balanced Tree)，是一种很普遍的数据库索引结构，oracle默认的索引类型（本文也主要依据oracle来讲）。其特点是定位高效、利用率高、自我平衡，特别适用于高基数字段，定位单条或小范围数据非常高效。理论上，使用Btree在亿条数据与100条数据中定位记录的花销相同。<br> <br>数据结构利用率高、定位高效<br>Btree索引的数据结构如下：<br><br>结构看起来Btree索引与Binary Tree相似，但在细节上有所不同，上图中用不同颜色的标示出了Btree索引的几个主要特点：<br> <br>树形结构：由根节(root)、分支(branches)、叶(leaves)三级节点组成，其中分支节点可以有多层。…</p>
</blockquote>
</li>
<li><p>Hash索引</p>
<blockquote>
<p>了解</p>
</blockquote>
</li>
<li><p>full-text全文索引</p>
<blockquote>
<p>了解</p>
</blockquote>
</li>
<li><p>R-Tree索引</p>
<blockquote>
<p>了解</p>
</blockquote>
</li>
</ul>
<p>2.3.6 哪些情况需要创建索引</p>
<ul>
<li><p>1.主键自动建立唯一索引</p>
</li>
<li><p>2.频繁作为查询的条件的字段应该创建索引</p>
</li>
<li><p>3.查询中与其他表关联的字段，外键关系建立索引</p>
</li>
<li><p>4.频繁更新的字段不适合创建索引</p>
<blockquote>
<p>因为每次更新不单单是更新了记录还会更新索引，加重IO负担</p>
</blockquote>
</li>
<li><p>5.Where条件里用不到的字段不创建索引</p>
</li>
<li><p>6.单间/组合索引的选择问题，who？（在高并发下倾向创建组合索引）</p>
</li>
<li><p>7.查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度</p>
</li>
<li><p>8.查询中统计或者分组字段</p>
</li>
</ul>
<p>2.3.7 哪些情况不要创建索引</p>
<ul>
<li>1.表记录太少</li>
<li>2.经常增删改的表</li>
<li>3.数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。<br>  注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li>
</ul>
<h2 id="2-4-性能分析"><a href="#2-4-性能分析" class="headerlink" title="2.4 性能分析"></a>2.4 性能分析</h2><h2 id="2-5-索引优化"><a href="#2-5-索引优化" class="headerlink" title="2.5 索引优化"></a>2.5 索引优化</h2><h1 id="3-查询截取分析"><a href="#3-查询截取分析" class="headerlink" title="3.查询截取分析"></a>3.查询截取分析</h1><h1 id="4-MySQL锁机制"><a href="#4-MySQL锁机制" class="headerlink" title="4.MySQL锁机制"></a>4.MySQL锁机制</h1><h1 id="5-主从复制"><a href="#5-主从复制" class="headerlink" title="5.主从复制"></a>5.主从复制</h1>

	<div class="row">
    <embed src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/pdf/%E5%B0%9A%E7%A1%85%E8%B0%B7MySQL%E9%AB%98%E7%BA%A7_JAVA%E7%89%88.pdf" width="100%" height="550" type="application/pdf">
	</div>


 


      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2020/04/19/数据库-MySQL-MySQL高级/" data-id="ckmh9ucit000q3oumgbzvr861" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-中间件-Redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/01/中间件-Redis/" class="article-date">
  <time datetime="2020-03-31T16:00:00.000Z" itemprop="datePublished">2020-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/中间件-Redis/">Redis命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-redis入门"><a href="#1-redis入门" class="headerlink" title="1.redis入门"></a>1.redis入门</h1><h2 id="1-1-redis简介"><a href="#1-1-redis简介" class="headerlink" title="1.1 redis简介"></a>1.1 redis简介</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h3 id="1-1-1-Redis-优势"><a href="#1-1-1-Redis-优势" class="headerlink" title="1.1.1 Redis 优势"></a>1.1.1 Redis 优势</h3><ul>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<h3 id="1-1-2-Redis与其他key-value存储有什么不同？"><a href="#1-1-2-Redis与其他key-value存储有什么不同？" class="headerlink" title="1.1.2 Redis与其他key-value存储有什么不同？"></a>1.1.2 Redis与其他key-value存储有什么不同？</h3><ul>
<li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>
<li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li>
</ul>
<h3 id="1-1-3-应用"><a href="#1-1-3-应用" class="headerlink" title="1.1.3 应用"></a>1.1.3 应用</h3><ul>
<li>Tips 1：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 </li>
<li>Tips 2：redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 </li>
<li>Tips 3：redis应用于各种结构型和非结构型高热度数据访问加速 </li>
<li>Tips 4：redis 应用于购物车数据存储设计 </li>
<li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 </li>
<li>Tips 6：redis 应用于具有操作先后顺序的数据控制 </li>
<li>Tips 7：redis 应用于最新消息展示 </li>
<li>Tips 8：redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等 </li>
<li>Tips 9：redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 </li>
<li>Tips 10：redis 应用于同类型不重复数据的合并、取交集操作 </li>
<li>Tips 11：redis 应用于同类型数据的快速去重 </li>
<li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制 </li>
<li>Tips 13：redis 应用于计数器组合排序功能对应的排名 </li>
<li>Tips 14：redis 应用于定时任务执行顺序管理或任务过期管理 </li>
<li>Tips 15：redis 应用于及时任务/消息队列执行管理 </li>
<li>Tips 16：redis 应用于按次结算的服务控制 </li>
<li>Tips 17：redis 应用于基于时间顺序的数据操作，而不关注具体时间</li>
</ul>
<h2 id="1-2-redis的下载与安装"><a href="#1-2-redis的下载与安装" class="headerlink" title="1.2 redis的下载与安装"></a>1.2 redis的下载与安装</h2><p><strong>参考链接：</strong><a href="https://fangchenyong.top/2019/07/23/install_Redis5.0.3/#9-SpringBoot连接redis">Centos 7.2 安装目前最新版Redis5.0.3</a></p>
<h2 id="1-3-redis配置"><a href="#1-3-redis配置" class="headerlink" title="1.3 redis配置"></a>1.3 redis配置</h2><p>Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。</p>
<h3 id="1-3-1-查看配置"><a href="#1-3-1-查看配置" class="headerlink" title="1.3.1 查看配置"></a>1.3.1 查看配置</h3><p>你可以通过 <strong>CONFIG</strong> 命令查看或设置配置项。</p>
<p><strong>语法</strong></p>
<p>Redis CONFIG 命令格式如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET loglevel</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"loglevel"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"notice"</span></span><br></pre></td></tr></table></figure>

<p>使用 ***** 号获取所有配置项：</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET *</span><br><span class="line"> </span><br><span class="line">  <span class="number">1</span>) <span class="string">"dbfilename"</span></span><br><span class="line">  <span class="number">2</span>) <span class="string">"dump.rdb"</span></span><br><span class="line">  <span class="number">3</span>) <span class="string">"requirepass"</span></span><br><span class="line">  <span class="number">4</span>) <span class="string">""</span></span><br><span class="line">  <span class="number">5</span>) <span class="string">"masterauth"</span></span><br><span class="line">  <span class="number">6</span>) <span class="string">""</span></span><br><span class="line">  <span class="number">7</span>) <span class="string">"unixsocket"</span></span><br><span class="line">  <span class="number">8</span>) <span class="string">""</span></span><br><span class="line">  <span class="number">9</span>) <span class="string">"logfile"</span></span><br><span class="line"> <span class="number">10</span>) <span class="string">""</span></span><br><span class="line"> <span class="number">11</span>) <span class="string">"pidfile"</span></span><br><span class="line"> <span class="number">12</span>) <span class="string">"/var/run/redis.pid"</span></span><br><span class="line"> <span class="number">13</span>) <span class="string">"maxmemory"</span></span><br><span class="line"> <span class="number">14</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">15</span>) <span class="string">"maxmemory-samples"</span></span><br><span class="line"> <span class="number">16</span>) <span class="string">"3"</span></span><br><span class="line"> <span class="number">17</span>) <span class="string">"timeout"</span></span><br><span class="line"> <span class="number">18</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">19</span>) <span class="string">"tcp-keepalive"</span></span><br><span class="line"> <span class="number">20</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">21</span>) <span class="string">"auto-aof-rewrite-percentage"</span></span><br><span class="line"> <span class="number">22</span>) <span class="string">"100"</span></span><br><span class="line"> <span class="number">23</span>) <span class="string">"auto-aof-rewrite-min-size"</span></span><br><span class="line"> <span class="number">24</span>) <span class="string">"67108864"</span></span><br><span class="line"> <span class="number">25</span>) <span class="string">"hash-max-ziplist-entries"</span></span><br><span class="line"> <span class="number">26</span>) <span class="string">"512"</span></span><br><span class="line"> <span class="number">27</span>) <span class="string">"hash-max-ziplist-value"</span></span><br><span class="line"> <span class="number">28</span>) <span class="string">"64"</span></span><br><span class="line"> <span class="number">29</span>) <span class="string">"list-max-ziplist-entries"</span></span><br><span class="line"> <span class="number">30</span>) <span class="string">"512"</span></span><br><span class="line"> <span class="number">31</span>) <span class="string">"list-max-ziplist-value"</span></span><br><span class="line"> <span class="number">32</span>) <span class="string">"64"</span></span><br><span class="line"> <span class="number">33</span>) <span class="string">"set-max-intset-entries"</span></span><br><span class="line"> <span class="number">34</span>) <span class="string">"512"</span></span><br><span class="line"> <span class="number">35</span>) <span class="string">"zset-max-ziplist-entries"</span></span><br><span class="line"> <span class="number">36</span>) <span class="string">"128"</span></span><br><span class="line"> <span class="number">37</span>) <span class="string">"zset-max-ziplist-value"</span></span><br><span class="line"> <span class="number">38</span>) <span class="string">"64"</span></span><br><span class="line"> <span class="number">39</span>) <span class="string">"hll-sparse-max-bytes"</span></span><br><span class="line"> <span class="number">40</span>) <span class="string">"3000"</span></span><br><span class="line"> <span class="number">41</span>) <span class="string">"lua-time-limit"</span></span><br><span class="line"> <span class="number">42</span>) <span class="string">"5000"</span></span><br><span class="line"> <span class="number">43</span>) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line"> <span class="number">44</span>) <span class="string">"10000"</span></span><br><span class="line"> <span class="number">45</span>) <span class="string">"latency-monitor-threshold"</span></span><br><span class="line"> <span class="number">46</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">47</span>) <span class="string">"slowlog-max-len"</span></span><br><span class="line"> <span class="number">48</span>) <span class="string">"128"</span></span><br><span class="line"> <span class="number">49</span>) <span class="string">"port"</span></span><br><span class="line"> <span class="number">50</span>) <span class="string">"6379"</span></span><br><span class="line"> <span class="number">51</span>) <span class="string">"tcp-backlog"</span></span><br><span class="line"> <span class="number">52</span>) <span class="string">"511"</span></span><br><span class="line"> <span class="number">53</span>) <span class="string">"databases"</span></span><br><span class="line"> <span class="number">54</span>) <span class="string">"16"</span></span><br><span class="line"> <span class="number">55</span>) <span class="string">"repl-ping-slave-period"</span></span><br><span class="line"> <span class="number">56</span>) <span class="string">"10"</span></span><br><span class="line"> <span class="number">57</span>) <span class="string">"repl-timeout"</span></span><br><span class="line"> <span class="number">58</span>) <span class="string">"60"</span></span><br><span class="line"> <span class="number">59</span>) <span class="string">"repl-backlog-size"</span></span><br><span class="line"> <span class="number">60</span>) <span class="string">"1048576"</span></span><br><span class="line"> <span class="number">61</span>) <span class="string">"repl-backlog-ttl"</span></span><br><span class="line"> <span class="number">62</span>) <span class="string">"3600"</span></span><br><span class="line"> <span class="number">63</span>) <span class="string">"maxclients"</span></span><br><span class="line"> <span class="number">64</span>) <span class="string">"4064"</span></span><br><span class="line"> <span class="number">65</span>) <span class="string">"watchdog-period"</span></span><br><span class="line"> <span class="number">66</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">67</span>) <span class="string">"slave-priority"</span></span><br><span class="line"> <span class="number">68</span>) <span class="string">"100"</span></span><br><span class="line"> <span class="number">69</span>) <span class="string">"min-slaves-to-write"</span></span><br><span class="line"> <span class="number">70</span>) <span class="string">"0"</span></span><br><span class="line"> <span class="number">71</span>) <span class="string">"min-slaves-max-lag"</span></span><br><span class="line"> <span class="number">72</span>) <span class="string">"10"</span></span><br><span class="line"> <span class="number">73</span>) <span class="string">"hz"</span></span><br><span class="line"> <span class="number">74</span>) <span class="string">"10"</span></span><br><span class="line"> <span class="number">75</span>) <span class="string">"no-appendfsync-on-rewrite"</span></span><br><span class="line"> <span class="number">76</span>) <span class="string">"no"</span></span><br><span class="line"> <span class="number">77</span>) <span class="string">"slave-serve-stale-data"</span></span><br><span class="line"> <span class="number">78</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">79</span>) <span class="string">"slave-read-only"</span></span><br><span class="line"> <span class="number">80</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">81</span>) <span class="string">"stop-writes-on-bgsave-error"</span></span><br><span class="line"> <span class="number">82</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">83</span>) <span class="string">"daemonize"</span></span><br><span class="line"> <span class="number">84</span>) <span class="string">"no"</span></span><br><span class="line"> <span class="number">85</span>) <span class="string">"rdbcompression"</span></span><br><span class="line"> <span class="number">86</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">87</span>) <span class="string">"rdbchecksum"</span></span><br><span class="line"> <span class="number">88</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">89</span>) <span class="string">"activerehashing"</span></span><br><span class="line"> <span class="number">90</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">91</span>) <span class="string">"repl-disable-tcp-nodelay"</span></span><br><span class="line"> <span class="number">92</span>) <span class="string">"no"</span></span><br><span class="line"> <span class="number">93</span>) <span class="string">"aof-rewrite-incremental-fsync"</span></span><br><span class="line"> <span class="number">94</span>) <span class="string">"yes"</span></span><br><span class="line"> <span class="number">95</span>) <span class="string">"appendonly"</span></span><br><span class="line"> <span class="number">96</span>) <span class="string">"no"</span></span><br><span class="line"> <span class="number">97</span>) <span class="string">"dir"</span></span><br><span class="line"> <span class="number">98</span>) <span class="string">"/home/deepak/Downloads/redis-2.8.13/src"</span></span><br><span class="line"> <span class="number">99</span>) <span class="string">"maxmemory-policy"</span></span><br><span class="line"><span class="number">100</span>) <span class="string">"volatile-lru"</span></span><br><span class="line"><span class="number">101</span>) <span class="string">"appendfsync"</span></span><br><span class="line"><span class="number">102</span>) <span class="string">"everysec"</span></span><br><span class="line"><span class="number">103</span>) <span class="string">"save"</span></span><br><span class="line"><span class="number">104</span>) <span class="string">"3600 1 300 100 60 10000"</span></span><br><span class="line"><span class="number">105</span>) <span class="string">"loglevel"</span></span><br><span class="line"><span class="number">106</span>) <span class="string">"notice"</span></span><br><span class="line"><span class="number">107</span>) <span class="string">"client-output-buffer-limit"</span></span><br><span class="line"><span class="number">108</span>) <span class="string">"normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60"</span></span><br><span class="line"><span class="number">109</span>) <span class="string">"unixsocketperm"</span></span><br><span class="line"><span class="number">110</span>) <span class="string">"0"</span></span><br><span class="line"><span class="number">111</span>) <span class="string">"slaveof"</span></span><br><span class="line"><span class="number">112</span>) <span class="string">""</span></span><br><span class="line"><span class="number">113</span>) <span class="string">"notify-keyspace-events"</span></span><br><span class="line"><span class="number">114</span>) <span class="string">""</span></span><br><span class="line"><span class="number">115</span>) <span class="string">"bind"</span></span><br><span class="line"><span class="number">116</span>) <span class="string">""</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-编辑配置"><a href="#1-3-2-编辑配置" class="headerlink" title="1.3.2 编辑配置"></a>1.3.2 编辑配置</h3><p>你可以通过修改 redis.conf 文件或使用 <strong>CONFIG set</strong> 命令来修改配置。</p>
<p><strong>语法</strong></p>
<p><strong>CONFIG SET</strong> 命令基本语法：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG SET loglevel <span class="string">"notice"</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; CONFIG GET loglevel</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"loglevel"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"notice"</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-参数说明"><a href="#1-3-3-参数说明" class="headerlink" title="1.3.3 参数说明"></a>1.3.3 参数说明</h3><p>redis.conf 配置项说明如下：</p>
<ol>
<li><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize no</span><br></pre></td></tr></table></figure>
</li>
<li><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pidfile /var/run/redis.pid</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定的主机地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loglevel verbose</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logfile stdout</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据库的数量，默认数据库为0，可以使用SELECT <code>&lt;dbid&gt;</code>命令在连接上指定数据库id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br></pre></td></tr></table></figure>

<p>Redis默认配置文件中提供了三个条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1  	#900秒（15分钟）内有1个更改</span><br><span class="line">save 300 10     #300秒（5分钟）内有10个更改</span><br><span class="line">save 60 10000	#60秒内有10000个更改</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定本地数据库文件名，默认值为dump.rdb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定本地数据库存放目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir ./</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当master服务设置了密码保护时，slav服务连接master的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <code>&lt;password&gt;</code>命令提供密码，默认关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requirepass foobared</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxclients 128</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定更新日志文件名，默认为appendonly.aof</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定更新日志条件，共有3个可选值：     <strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）     <strong>always</strong>：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）     <strong>everysec</strong>：表示每秒同步一次（折衷，默认值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-enabled no</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-swap-file /tmp/redis.swap</span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-max-memory 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-page-size 32</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-pages 134217728</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm-max-threads 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">glueoutputbuf yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash-max-zipmap-entries 64</span><br><span class="line">hash-max-zipmap-value 512</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include /path/to/local.conf</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-4-redis数据类型"><a href="#1-4-redis数据类型" class="headerlink" title="1.4 redis数据类型"></a>1.4 redis数据类型</h2><h3 id="1-4-1-String（字符串）"><a href="#1-4-1-String（字符串）" class="headerlink" title="1.4.1 String（字符串）"></a>1.4.1 String（字符串）</h3><p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SET name <span class="string">"redis.net.cn"</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET name</span><br><span class="line"><span class="string">"redis.net.cn"</span></span><br></pre></td></tr></table></figure>

<p>在以上实例中我们使用了 Redis 的 <strong>SET</strong> 和 <strong>GET</strong> 命令。键为 name，对应的值为redis.net.cn。</p>
<p><strong>注意：</strong>一个键最大能存储512MB。</p>
<h3 id="1-4-2-Hash（哈希）"><a href="#1-4-2-Hash（哈希）" class="headerlink" title="1.4.2 Hash（哈希）"></a>1.4.2 Hash（哈希）</h3><p>Redis hash 是一个键值对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HMSET user:<span class="number">1</span> username redis.net.cn password redis.net.cn points <span class="number">200</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGETALL user:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"username"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redis.net.cn"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"password"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"redis.net.cn"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"points"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"200"</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<p>以上实例中 hash 数据类型存储了包含用户脚本信息的用户对象。 实例中我们使用了 Redis <strong>HMSET, HEGTALL</strong> 命令，<strong>user:1</strong> 为键值。</p>
<p>每个 hash 可以存储 2^(32 - 1)键值对（40多亿）。</p>
<h3 id="1-4-3-List（列表）"><a href="#1-4-3-List（列表）" class="headerlink" title="1.4.3 List（列表）"></a>1.4.3 List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush redis.net.cn redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush redis.net.cn mongodb</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lpush redis.net.cn rabitmq</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; lrange redis.net.cn <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"rabitmq"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<h3 id="1-4-4-Set（集合）"><a href="#1-4-4-Set（集合）" class="headerlink" title="1.4.4 Set（集合）"></a>1.4.4 Set（集合）</h3><p>Redis的Set是string类型的无序集合。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p><strong>sadd 命令</strong></p>
<p>添加一个string元素到,key对应的set集合中，成功返回1,如果元素以及在集合中返回0,key对应的set不存在返回错误。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sadd key member</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn rabitmq</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; sadd redis.net.cn rabitmq</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; smembers redis.net.cn</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"rabitmq"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-5-zset-sorted-set：有序集合"><a href="#1-4-5-zset-sorted-set：有序集合" class="headerlink" title="1.4.5 zset(sorted set：有序集合)"></a>1.4.5 zset(sorted set：有序集合)</h3><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>zset的成员是唯一的,但分数(score)却可以重复。</p>
<p><strong>zadd 命令</strong></p>
<p>添加元素到集合，元素在集合中存在则更新对应score</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">zadd key score member</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> rabitmq</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd redis.net.cn <span class="number">0</span> rabitmq</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGEBYSCORE redis.net.cn <span class="number">0</span> <span class="number">1000</span></span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"redis"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"rabitmq"</span></span><br></pre></td></tr></table></figure>

<h1 id="2-redis命令"><a href="#2-redis命令" class="headerlink" title="2.redis命令"></a>2.<a href="http://doc.redisfans.com" target="_blank" rel="noopener">redis命令</a></h1><h2 id="2-1-如何执行命令"><a href="#2-1-如何执行命令" class="headerlink" title="2.1 如何执行命令"></a>2.1 如何执行命令</h2><h3 id="2-1-1-在本地连接执行命令"><a href="#2-1-1-在本地连接执行命令" class="headerlink" title="2.1.1 在本地连接执行命令"></a>2.1.1 在本地连接执行命令</h3><p>Redis 命令用于在 redis 服务上执行操作。</p>
<p>要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</p>
<p><strong>语法</strong></p>
<p>Redis 客户端的基本语法为：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<p>以下实例讲解了如何启动 redis 客户端：</p>
<p>启动 redis 客户端，打开终端并输入命令 <strong>redis-cli</strong>。该命令会连接本地的 redis 服务。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$redis</span>-cliredis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PING PONG</span><br></pre></td></tr></table></figure>

<p>在以上实例中我们连接到本地的 redis 服务并执行 <strong>PING</strong> 命令，该命令用于检测 redis 服务是否启动。</p>
<hr>
<h3 id="2-2-2-在远程服务上执行命令"><a href="#2-2-2-在远程服务上执行命令" class="headerlink" title="2.2.2 在远程服务上执行命令"></a>2.2.2 在远程服务上执行命令</h3><p>如果需要在远程 redis 服务上执行命令，同样我们使用的也是 <strong>redis-cli</strong> 命令。</p>
<p><strong>语法</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<p>以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$redis</span>-cli -h <span class="number">127.0</span>.<span class="number">0.1</span> -p <span class="number">6379</span> -a <span class="string">"mypass"</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PING</span><br><span class="line"> </span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<h2 id="2-2-key（键）"><a href="#2-2-key（键）" class="headerlink" title="2.2 key（键）"></a>2.2 key（键）</h2><p>Redis 键命令用于管理 redis 的键。</p>
<p><strong>语法</strong></p>
<p>Redis 键命令的基本语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SET mykey redis</span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; DEL mykey</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在以上实例中 <strong>DEL</strong> 是一个命令， <strong>mykey</strong> 是一个键。 如果键被删除成功，命令执行后输出 <strong>(integer) 1</strong>，否则将输出 <strong>(integer) 0</strong></p>
<p><strong>下表给出了与 Redis 键相关常用的基本命令：</strong></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>语法(可用版本)</strong></th>
<th><strong>返回值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>DEL</strong></td>
<td><strong><font size="2" color="red">DEL KEY_NAME（&gt;= 1.0.0）</font></strong></td>
<td><strong><font size="2">被删除 <code>key</code> 的数量。</font></strong></td>
<td><strong><font size="2">删除存在的<code>key</code>，不存在就忽略。</font></strong></td>
</tr>
<tr>
<td><strong>DUMP</strong></td>
<td><font size="2" color="red"><strong>DUMP KEY_NAME（&gt;= 2.6.0）</strong></font></td>
<td><strong><font size="2"><code>key</code>不存在，返回 <code>nil</code> 。否则，返回序列化之后的值。</font></strong></td>
<td><strong><font size="2">序列化给定 <code>key</code> 并返回值</font></strong></td>
</tr>
<tr>
<td><strong>EXISTS</strong></td>
<td><font size="2" color="red"><strong>EXISTS KEY_NAME（&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">存在返回 <code>1</code>，否则返回 <code>0</code>。</font></strong></td>
<td><strong><font size="2">检查给定<code>key</code>是否存在。</font></strong></td>
</tr>
<tr>
<td><strong>EXPIRE</strong></td>
<td><font size="2" color="red"><strong>EXPIRE KEY_NAME         TIME_IN_SECONDS         （&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">设置成功返回 <code>1</code> 。 不存在或者不能设置过期时间时(低于 2.1.3 版本)返回 <code>0</code>。</font></strong></td>
<td><strong><font size="2">设置<code>key</code>的过期时间，<code>key</code> 过期后将不再可用。</font></strong></td>
</tr>
<tr>
<td><strong>EXPIREAT</strong></td>
<td><font size="2" color="red"><strong>EXPIREAT KEY_NAME TIME_IN_UNIX_TIMESTAMP（&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">设置成功返回<code>1</code>。 不存在或者不能设置过期时间时(低于 2.1.3 版本)返回<code>0</code>。</font></strong></td>
<td><strong><font size="2">以 UNIX 时间戳(unix timestamp)格式设置<code>key</code>的过期时间。过期后将不再可用。</font></strong></td>
</tr>
<tr>
<td><strong>KEYS</strong></td>
<td><font size="2" color="red"><strong>KEYS PATTERN（&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">符合给定模式的 <code>key</code>列表 (Array)。</font></strong></td>
<td><strong><font size="2">用于查找所有符合给定模式 <code>pattern</code> 的 <code>key</code></font></strong></td>
</tr>
<tr>
<td><strong>MIGRATE</strong></td>
<td><font size="2" color="red"><strong>MIGRATE HOST PORT KEY_NAME DESTINATION-DB TIMEOUT [COPY] [REPLACE]（&gt;= 2.6.0）</strong></font></td>
<td><strong><font size="2">迁移成功时返回 <code>OK</code>，否则返回相应的错误。</font></strong></td>
<td><strong><font size="2">将 <code>key</code>原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， <code>key</code> 保证会出现在目标实例上，而当前实例上的 <code>key</code>会被删除。</font></strong></td>
</tr>
<tr>
<td><strong>MOVE</strong></td>
<td><font size="2" color="red"><strong>MOVE KEY_NAME DESTINATION_DATABASE （&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">移动成功返回 <code>1</code>，失败则返回<code>0</code>。</font></strong></td>
<td><strong><font size="2">将当前数据库的<code>key</code> 移动到给定的数据库<code>db</code>当中。</font></strong></td>
</tr>
<tr>
<td><strong>PERSIST</strong></td>
<td><font size="2" color="red"><strong>PERSIST KEY_NAME（&gt;= 2.2.0）</strong></font></td>
<td><strong><font size="2">当过期时间移除成功时，返回 <code>1</code>。 如果<code>key</code>不存在或 <code>key</code> 没有设置过期时间，返回<code>0</code>。</font></strong></td>
<td><strong><font size="2">移除给定 <code>key</code> 的过期时间，使得 key 永不过期。</font></strong></td>
</tr>
<tr>
<td><strong>PEXPIRE</strong></td>
<td><font size="2" color="red"><strong>PEXPIREAT KEY_NAME TIME_IN_MILLISECONDS_IN_UNIX_TIMESTAMP （&gt;= 2.6.0）</strong></font></td>
<td><strong><font size="2">设置成功返回<code>1</code>。 当<code>key</code>不存在或者不能为 <code>key</code>设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 <code>key</code> 的过期时间)返回 <code>0</code> 。</font></strong></td>
<td><strong><font size="2">用于设置 <code>key</code> 的过期时间，以毫秒记。<code>key</code>过期后将不再可用。</font></strong></td>
</tr>
<tr>
<td><strong>PEXPIREAT</strong></td>
<td><font size="2" color="red"><strong>PEXPIREAT KEY_NAME TIME_IN_MILLISECONDS_IN_UNIX_TIMESTAMP （&gt;= 2.6.0）</strong></font></td>
<td><strong><font size="2">设置成功返回 <code>1</code> 。 当 <code>key</code> 不存在或者不能为<code>key</code> 设置过期时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 <code>key</code>的过期时间)返回 <code>0</code>。</font></strong></td>
<td><strong><font size="2">用于设置<code>key</code> 的过期时间，以毫秒记。<code>key</code>过期后将不再可用。</font></strong></td>
</tr>
<tr>
<td><strong>PTTL</strong></td>
<td><font size="2" color="red"><strong>PTTL KEY_NAME（&gt;= 2.6.0）</strong></font></td>
<td><strong><font size="2">当 <code>key</code>不存在时，返回 <code>-2</code>。 当 <code>key</code>存在但没有设置剩余生存时间时，返回 <code>-1</code>。 否则，以毫秒为单位，返回的剩余生存时间。</font></strong></td>
<td><strong><font size="2">以毫秒为单位返回 <code>key</code> 的剩余过期时间。<br>注意：在 Redis 2.8 以前，当 <code>key</code> 不存在，或者 <code>key</code> 没有设置剩余生存时间时，命令都返回<code>-1</code>。</font></strong></td>
</tr>
<tr>
<td><strong>RANDOMKEY</strong></td>
<td><font size="2" color="red"><strong>RANDOMKEY（&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">当数据库不为空时，返回一个<code>key</code> 。 当数据库为空时，返回<code>nil</code>。</font></strong></td>
<td><strong><font size="2">从当前数据库中随机返回一个 <code>key</code>。</font></strong></td>
</tr>
<tr>
<td><strong>RENAME</strong></td>
<td><font size="2" color="red"><strong>RENAME OLD_KEY_NAME NEW_KEY_NAME （&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">改名成功时返回<code>OK</code>，失败时候返回一个错误。当 <code>OLD_KEY_NAME</code>和 <code>NEW_KEY_NAME</code> 相同，或者 <code>OLD_KEY_NAME</code>不存在时，返回一个错误。 当 <code>NEW_KEY_NAME</code> 已经存在时， <code>RENAME</code> 命令将覆盖旧值。</font></strong></td>
<td><strong><font size="2">用于修改<code>key</code>的名称 </font></strong></td>
</tr>
<tr>
<td><strong>RENAMENX</strong></td>
<td><font size="2" color="red"><strong>RENAMENX OLD_KEY_NAME NEW_KEY_NAME（&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">修改成功时，返回 <code>1</code> 。 如果 <code>NEW_KEY_NAME</code>已经存在，返回<code>0</code>。</font></strong></td>
<td><strong><font size="2">用于在新的 <code>key</code>不存在时修改<code>key</code>的名称 。</font></strong></td>
</tr>
<tr>
<td><strong>SORT</strong></td>
<td><font size="2" color="red"><strong>SORT KEY [BY PATTERN] [LIMIT OFFSET COUNT] [GET PATTERN [GET PATTERN …]] [ASC|DESC] [ALPHA] [STORE DESTINATION]</strong></font></td>
<td><strong><a href="http://doc.redisfans.com/key/sort.html" target="_blank" rel="noopener">较为复杂见文档</a></strong></td>
<td><strong><a href="http://doc.redisfans.com/key/sort.html" target="_blank" rel="noopener">较为复杂见文档</a></strong></td>
</tr>
<tr>
<td><strong>TTL</strong></td>
<td><font size="2" color="red"><strong>TTL KEY_NAME （&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">当 <code>key</code>不存在时，返回<code>-2</code> 。 当 <code>key</code>存在但没有设置剩余生存时间时，返回 <code>-1</code>。 否则，以秒为单位，返回剩余生存时间。</font></strong></td>
<td><strong><font size="2">以秒为单位返回 <code>key</code>的剩余过期时间。<br>注意：在 Redis 2.8 以前，当 <code>key</code>不存在，或者<code>key</code>没有设置剩余生存时间时，命令都返回 <code>-1</code>。</font></strong></td>
</tr>
<tr>
<td><strong>TYPE</strong></td>
<td><font size="2" color="red"><strong>TYPE KEY_NAME （&gt;= 1.0.0）</strong></font></td>
<td><strong><font size="2">返回数据类型有：<code>none</code> (key不存在) <code>string</code>(字符串)       <code>list</code>(列表)                 <code>set</code>(集合)             <code>zset</code> (有序集)          <code>hash</code>(哈希表)</font></strong></td>
<td><font size="2"><strong>返回<code>key</code>所储存的值的类型</strong>。</font></td>
</tr>
</tbody></table>
<h2 id="2-3-String（字符串）"><a href="#2-3-String（字符串）" class="headerlink" title="2.3 String（字符串）"></a>2.3 String（字符串）</h2><p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：</p>
<p><strong>语法</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SET mykey redis </span><br><span class="line">OK </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET mykey </span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure>

<p>在以上实例中我们使用了 <strong>SET</strong> 和 <strong>GET</strong> 命令，键为 mykey。</p>
<p><strong>下表给出了与 Redis字符串相关常用的基本命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>APPEND</strong></td>
<td><font size="2" color="red"><strong>APPEND KEY_NAME NEW_VALUE（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>追加指定值之后，<code>key</code> 中字符串的长度。</strong></font></td>
<td><font size="2"><strong>如果 <code>key</code>已经存在并且是一个字符串， <code>APPEND</code>命令将<code>value</code>追加到 <code>key</code>原来的值的末尾。                                        如果 <code>key</code>不存在， <code>APPEND</code> 就简单地将给定 <code>key</code> 设为 <code>value</code>，就像执行 <code>SET key value</code>一样。</strong></font></td>
</tr>
<tr>
<td><strong>BITCOUNT</strong></td>
<td><font size="2" color="red"><strong>BITCOUNT key [start] [end]（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>被设置为 <code>1</code> 的位的数量。</strong></font></td>
<td><font size="2"><strong>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行。不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 <code>0</code> 。</strong></font></td>
</tr>
<tr>
<td><strong>BITOP</strong></td>
<td><font size="2" color="red"><strong>BITOP operation destkey key [key …]（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>保存到 <code>destkey</code> 的字符串的长度，和输入 <code>key</code> 中最长的字符串长度相等。</strong></font></td>
<td><font size="2"><strong>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。</strong></font></td>
</tr>
<tr>
<td><strong>DECR</strong></td>
<td><font size="2" color="red"><strong>DECR KEY_NAME（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>执行命令之后 <code>key</code> 的值。</strong></font></td>
<td><font size="2"><strong>将 <code>key</code>中储存的数字值减一。             如果 <code>key</code> 不存在，<code>key</code> 的值会先被初始化为<code>0</code> ，然后再执行 <code>DECR</code>操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td>
</tr>
<tr>
<td><strong>DECRBY</strong></td>
<td><font size="2" color="red"><strong>DECRBY KEY_NAME DECREMENT_AMOUNT （&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>减去指定减量值之后，<code>key</code>的值。</strong></font></td>
<td><font size="2"><strong>将 <code>key</code>所储存的值减去指定的减量值。如果 <code>key</code>不存在，<code>key</code>的值会先被初始化为 <code>0</code> ，然后再执行 <code>DECRBY</code> 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td>
</tr>
<tr>
<td><strong>GET</strong></td>
<td><font size="2" color="red"><strong>GET KEY_NAME（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>返回<code>key</code> 的值，如果 <code>key</code> 不存在时，返回 <code>nil</code>。 如果 <code>key</code> 不是字符串类型，那么返回一个错误。</strong></font></td>
<td><font size="2"><strong>获取指定 <code>key</code> 的值。 如果 <code>key</code> 不存在，返回 <code>nil</code>。 如果<code>key</code>储存的值不是字符串类型，返回一个错误。</strong></font></td>
</tr>
<tr>
<td><strong>GETBIT</strong></td>
<td><font size="2" color="red"><strong>GETBIT KEY_NAME OFFSET（&gt;=2.4.0）</strong></font></td>
<td><font size="2"><strong>字符串值指定偏移量上的位(bit)。当偏移量 <code>OFFSET</code> 比字符串值的长度大，或者 <code>key</code>不存在时，返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>对 <code>key</code>所储存的字符串值，获取指定偏移量上的位(bit)。</strong></font></td>
</tr>
<tr>
<td><strong>GETRANGE</strong></td>
<td><font size="2" color="red"><strong>GETRANGE KEY_NAME START END（&gt;=2.4.0）</strong></font></td>
<td><font size="2"><strong>截取得到的子字符串。</strong></font></td>
<td><font size="2"><strong>获取存储在指定 <code>key</code>中字符串的子字符串。字符串的截取范围由 <code>start</code>和<code>end</code>两个偏移量决定(包括 <code>start</code>和 <code>end</code> 在内)。</strong></font></td>
</tr>
<tr>
<td><strong>GETSET</strong></td>
<td><font size="2" color="red"><strong>GETSET KEY_NAME VALUE（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>返回给定 <code>key</code>的旧值。 当 <code>key</code> 没有旧值时，即<code>key</code>不存在时，返回 <code>nil</code> 。当 <code>key</code>存在但不是字符串类型时，返回一个错误。</strong></font></td>
<td><font size="2"><strong>设置指定<code>key</code> 的值，并返回 <code>key</code>旧的值。</strong></font></td>
</tr>
<tr>
<td><strong>INCR</strong></td>
<td><font size="2" color="red"><strong>INCR KEY_NAME（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>执行 <code>INCR</code> 命令之后 <code>key</code>的值。</strong></font></td>
<td><font size="2"><strong>将 <code>key</code>中储存的数字值增一。如果 <code>key</code> 不存在，那么 <code>key</code>的值会先被初始化为 <code>0</code> ，然后再执行 <code>INCR</code> 操作。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td>
</tr>
<tr>
<td><strong>INCRBY</strong></td>
<td><font size="2" color="red"><strong>INCRBY KEY_NAME INCR_AMOUNT（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>加上指定的增量值之后，<code>key</code>的值。</strong></font></td>
<td><font size="2"><strong>将 <code>key</code>中储存的数字加上指定的增量值。如果 <code>key</code> 不存在，那么 <code>key</code> 的值会先被初始化为 <code>0</code>，然后再执行 <code>INCRBY</code> 命令。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</strong></font></td>
</tr>
<tr>
<td><strong>INCRBYFLOAT</strong></td>
<td><font size="2" color="red"><strong>INCRBYFLOAT KEY_NAME INCR_AMOUNT（&gt;=2.6.0）</strong></font></td>
<td><font size="2"><strong>执行命令之后 <code>key</code>的值。</strong></font></td>
<td><font size="2"><strong>为 <code>key</code> 中所储存的值加上指定的浮点数增量值。如果 <code>key</code>不存在，那么 <code>INCRBYFLOAT</code> 会先将 <code>key</code> 的值设为 <code>0</code>，再执行加法操作。</strong></font></td>
</tr>
<tr>
<td><strong>MGET</strong></td>
<td><font size="2" color="red"><strong>MGET KEY1 KEY2 .. KEYN（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>一个包含所有给定 <code>key</code> 的值的列表。</strong></font></td>
<td><font size="2"><strong>如果给定的 <code>key</code>里面，有某个<code>key</code> 不存在，那么这个<code>key</code> 返回特殊值 <code>nil</code> 。</strong></font></td>
</tr>
<tr>
<td><strong>MSET</strong></td>
<td><font size="2" color="red"><strong>MSET key1 value1 key2 value2 .. keyN valueN（&gt;=1.0.1）</strong></font></td>
<td><font size="2"><strong>总是返回 <code>OK</code> 。</strong></font></td>
<td><font size="2"><strong>同时设置一个或多个 <code>key</code>-<code>value</code> 对。</strong></font></td>
</tr>
<tr>
<td><strong>MSETNX</strong></td>
<td><font size="2" color="red"><strong>MSETNX key1 value1 key2 value2 .. keyN valueN（&gt;=1.0.1）</strong></font></td>
<td><font size="2"><strong>当所有<code>key</code>都成功设置，返回 <code>1</code> 。 如果所有给定 <code>key</code>都设置失败(至少有一个<code>key</code> 已经存在)，那么返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>所有给定 <code>key</code>都不存在时，同时设置一个或多个 <code>key</code>-<code>value</code> 对。</strong></font></td>
</tr>
<tr>
<td><strong>PSETEX</strong></td>
<td><font size="2" color="red"><strong>PSETEX key1 EXPIRY_IN_MILLISECONDS value1 （&gt;=2.6.0）</strong></font></td>
<td><font size="2"><strong>总是返回 <code>OK</code> 。</strong></font></td>
<td><font size="2"><strong>以毫秒为单位设置<code>key</code> 的生存时间。</strong></font></td>
</tr>
<tr>
<td><strong>SET</strong></td>
<td><font size="2" color="red"><strong>SET KEY_NAME VALUE（&gt;=1.0.0）</strong></font></td>
<td><strong><font size="2">在 2.6.12 以前版本， <code>SET</code>命令总是返回 <code>OK</code> 。从 Redis 2.6.12 版本开始， <code>SET</code> 在设置操作成功完成时，才返回 <code>OK</code> </font></strong></td>
<td><font size="2"><strong>用于设置给定<code>key</code> 的值。如果 <code>key</code>已经存储其他值， <code>SET</code>就覆写旧值，且无视类型。</strong></font></td>
</tr>
<tr>
<td><strong>SETBIT</strong></td>
<td><font size="2" color="red"><strong>Setbit KEY_NAME OFFSET（&gt;=2.2.0）</strong></font></td>
<td><font size="2"><strong>指定偏移量原来储存的位。</strong></font></td>
<td><font size="2"><strong>对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</strong></font></td>
</tr>
<tr>
<td><strong>SETEX</strong></td>
<td><font size="2" color="red"><strong>SETEX KEY_NAME TIMEOUT VALUE（&gt;=2.0.0）</strong></font></td>
<td><font size="2"><strong>成功返回 <code>OK</code> 。</strong></font></td>
<td><font size="2"><strong>为指定的 <code>key</code>设置值及其过期时间。如果 <code>key</code> 已经存在， <code>SETEX</code> 命令将会替换旧的值。</strong></font></td>
</tr>
<tr>
<td><strong>SETNX</strong></td>
<td><font size="2" color="red"><strong>SETNX KEY_NAME VALUE（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>成功返回 <code>1</code> 。  失败返回<code>0</code> 。</strong></font></td>
<td><font size="2"><strong><code>Setnx</code>（SET if Not eXists） 命令在指定的<code>key</code>不存在时，为 <code>key</code> 设置指定的值。</strong></font></td>
</tr>
<tr>
<td><strong>SETRANGE</strong></td>
<td><font size="2" color="red"><strong>SETRANGE KEY_NAME OFFSET VALUE（&gt;=2.2.0）</strong></font></td>
<td><font size="2"><strong>被修改后的字符串长度。</strong></font></td>
<td><font size="2"><strong>用指定的字符串覆盖给定 <code>key</code> 所储存的字符串值，覆盖的位置从偏移量 <code>offset</code> 开始。</strong></font></td>
</tr>
<tr>
<td><strong>STRLEN</strong></td>
<td><font size="2" color="red"><strong>STRLEN KEY_NAME（&gt;=2.2.0）</strong></font></td>
<td><font size="2"><strong>字符串值的长度。 当<code>key</code> 不存在时，返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>用于获取指定 <code>key</code> 所储存的字符串值的长度。当 <code>key</code> 储存的不是字符串值时，返回一个错误。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-4-Hash（哈希）"><a href="#2-4-Hash（哈希）" class="headerlink" title="2.4 Hash（哈希）"></a>2.4 Hash（哈希）</h2><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>Redis 中每个 hash 可以存储 2^(32 - 1 )键值对（40多亿）。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HMSET mykey name <span class="string">"redis tutorial"</span> description <span class="string">"redis basic commands for caching"</span> likes <span class="number">20</span> visitors <span class="number">23000</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; HGETALL mykey</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"name"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redis tutorial"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"description"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"redis basic commands for caching"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"likes"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"20"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"visitors"</span></span><br><span class="line"><span class="number">8</span>) <span class="string">"23000"</span></span><br></pre></td></tr></table></figure>

<p>在以上实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 mykey 中。</p>
<p><strong>下表给出了与 Redis哈希相关常用的基本命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HDEL</strong></td>
<td><font size="2" color="red"><strong>HDEL KEY_NAME FIELD1.. FIELDN      （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>被成功删除字段的数量，不包括被忽略的字段。</strong></font></td>
<td><font size="2"><strong>用于删除哈希表<code>key</code>中的一个或多个指定字段，不存在的字段将被忽略。</strong></font></td>
</tr>
<tr>
<td><strong>HEXISTS</strong></td>
<td><font size="2" color="red"><strong>HEXISTS KEY_NAME FIELD_NAME   （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>如果哈希表含有给定字段，返回 <code>1</code>。 如果哈希表不含有给定字段，或 key 不存在，返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>查看哈希表的指定字段是否存在。</strong></font></td>
</tr>
<tr>
<td><strong>HGET</strong></td>
<td><font size="2" color="red"><strong>HGET KEY_NAME FIELD_NAME    （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>返回给定字段的值。如果给定的字段或 <code>key</code>不存在时，返回 <code>nil</code> 。</strong></font></td>
<td><font size="2"><strong>返回哈希表中指定字段的值。</strong></font></td>
</tr>
<tr>
<td><strong>HGETALL</strong></td>
<td><font size="2" color="red"><strong>HGETALL KEY_NAME        （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>以列表形式返回哈希表的字段及字段值。 若 <code>key</code>不存在，返回空列表。</strong></font></td>
<td><font size="2"><strong>返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。</strong></font></td>
</tr>
<tr>
<td><strong>HINCRBY</strong></td>
<td><font size="2" color="red"><strong>HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER  （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>执行 <code>HINCRBY</code> 命令之后，哈希表中字段的值。</strong></font></td>
<td><font size="2"><strong>用于为哈希表中的字段值加上指定增量值。增量也可以为负数，相当于对指定字段进行减法操作。如果哈希表的 <code>key</code> 不存在，一个新的哈希表被创建并执行 <code>HINCRBY</code> 命令。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 <code>0</code>。对一个储存字符串值的字段执行 <code>HINCRBY</code> 命令将造成一个错误。本操作的值被限制在 64 位(bit)有符号数字表示之内。</strong></font></td>
</tr>
<tr>
<td><strong>HINCRBYFLOAT</strong></td>
<td><font size="2" color="red"><strong>HINCRBYFLOAT KEY_NAME FIELD_NAME INCR_BY_NUMBER （&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>执行 <code>Hincrbyfloat</code>命令之后，哈希表中字段的值。</strong></font></td>
<td><font size="2"><strong>为哈希表中的字段值加上指定浮点数增量值。如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 <code>0</code> 。</strong></font></td>
</tr>
<tr>
<td><strong>HKEYS</strong></td>
<td><font size="2" color="red"><strong>HKEYS KEY_NAME FIELD_NAME INCR_BY_NUMBER （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>包含哈希表中所有字段的列表。  <code>key</code> 不存在时，返回空列表。</strong></font></td>
<td><font size="2"><strong>获取哈希表中的所有字段名。</strong></font></td>
</tr>
<tr>
<td><strong>HLEN</strong></td>
<td><font size="2" color="red"><strong>HLEN KEY_NAME （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>哈希表中字段的数量。 <code>key</code>不存在时，返回 0 。</strong></font></td>
<td><font size="2"><strong>获取哈希表中字段的数量。</strong></font></td>
</tr>
<tr>
<td><strong>HMGET</strong></td>
<td><font size="2" color="red"><strong>HMGET KEY_NAME FIELD1…FIELDN （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。</strong></font></td>
<td><font size="2"><strong>返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 <code>nil</code>值。</strong></font></td>
</tr>
<tr>
<td><strong>HMSET</strong></td>
<td><font size="2" color="red"><strong>HMSET KEY_NAME FIELD1 VALUE1 …FIELDN VALUEN （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>如果命令执行成功，返回 <code>OK</code> 。</strong></font></td>
<td><font size="2"><strong>同时将多个 <code>field</code>-<code>value</code> (字段-值)对设置到哈希表中。此命令会覆盖哈希表中已存在的字段。如果哈希表不存在，会创建一个空哈希表，并执行 <code>HMSET</code> 操作。</strong></font></td>
</tr>
<tr>
<td><strong>HSET</strong></td>
<td><font size="2" color="red"><strong>HSET KEY_NAME FIELD VALUE     （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>如果字段是哈希表中的一个新建字段，并且值设置成功，返回 <code>1</code> 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 <code>0</code> 。</strong></font></td>
<td><font size="2"><strong>为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 <code>HSET</code>操作。如果字段已经存在于哈希表中，旧值将被覆盖。</strong></font></td>
</tr>
<tr>
<td><strong>HSETNX</strong></td>
<td><font size="2" color="red"><strong>HSETNX KEY_NAME FIELD VALUE                  （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>设置成功返回 <code>1</code> 。 如果给定字段已经存在且没有操作被执行，返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>为哈希表中不存在的的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 <code>HSET</code>操作。如果字段已经存在于哈希表中，操作无效。如果 <code>key</code> 不存在，一个新哈希表被创建并执行 <code>HSETNX</code> 命令。</strong></font></td>
</tr>
<tr>
<td><strong>HVALS</strong></td>
<td><font size="2" color="red"><strong>HVALS KEY_NAME FIELD VALUE      （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>一个包含哈希表中所有值的表。 当 <code>key</code> 不存在时，返回一个空表。</strong></font></td>
<td><font size="2"><strong>返回哈希表所有字段的值。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-5-List（列表）"><a href="#2-5-List（列表）" class="headerlink" title="2.5 List（列表）"></a>2.5 List（列表）</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 2^(32 - 1) 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH mykey redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH mykey mongodb</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LPUSH mykey mysql</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; LRANGE mykey <span class="number">0</span> <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"mysql"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure>

<p>在以上实例中我们使用了 <strong>LPUSH</strong> 将三个值插入了名为 mykey 的列表当中。</p>
<p><strong>下表给出了与 Redis列表相关常用的基本命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BLPOP</strong></td>
<td><font size="2" color="red"><strong>BLPOP LIST1 LIST2 .. LISTN TIMEOUT（&gt;=2.0.0）</strong></font></td>
<td><font size="2"><strong>假如在指定时间内没有任何元素被弹出，则返回一个 <code>nil</code> 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <code>key</code> ，第二个元素是被弹出元素的值。</strong></font></td>
<td><font size="2"><strong>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></font></td>
</tr>
<tr>
<td><strong>BRPOP</strong></td>
<td><font size="2" color="red"><strong>BRPOP LIST1 LIST2 .. LISTN TIMEOUT（&gt;=2.0.0）</strong></font></td>
<td><font size="2"><strong>假如在指定时间内没有任何元素被弹出，则返回一个 <code>nil</code> 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <code>key</code> ，第二个元素是被弹出元素的值。</strong></font></td>
<td><font size="2"><strong>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></font></td>
</tr>
<tr>
<td><strong>BRPOPLPUSH</strong></td>
<td><font size="2" color="red"><strong>BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT（&gt;=2.0.0）</strong></font></td>
<td><font size="2"><strong>假如在指定时间内没有任何元素被弹出，则返回一个<code>nil</code>和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</strong></font></td>
<td><font size="2"><strong>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></font></td>
</tr>
<tr>
<td><strong>LINDEX</strong></td>
<td><font size="2" color="red"><strong>LINDEX KEY_NAME INDEX_POSITION         （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>列表中下标为指定索引值的元素。 如果指定索引值不在列表的区间范围内，返回<code>nil</code>。</strong></font></td>
<td><font size="2"><strong>通过索引获取列表中的元素。你也可以使用负数下标，以 <code>-1</code> 表示列表的最后一个元素，<code>-2</code> 表示列表的倒数第二个元素，以此类推。</strong></font></td>
</tr>
<tr>
<td><strong>LINSERT</strong></td>
<td><font size="2" color="red"><strong>LINSERT KEY_NAME BEFORE EXISTING_VALUE NEW_VALUE                 （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 <code>-1</code>。 如果 key 不存在或为空列表，返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>在列表的元素前或者后插入元素。 当指定元素不存在于列表中时，不执行任何操作。 当列表不存在时，被视为空列表，不执行任何操作。 如果<code>key</code> 不是列表类型，返回一个错误。</strong></font></td>
</tr>
<tr>
<td><strong>LLEN</strong></td>
<td><font size="2" color="red"><strong>LLEN KEY_NAME           （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>列表的长度。</strong></font></td>
<td><font size="2"><strong>返回列表的长度。 如果列表 <code>key</code>不存在，则<code>key</code>被解释为一个空列表，返回 <code>0</code> 。 如果 <code>key</code> 不是列表类型，返回一个错误。</strong></font></td>
</tr>
<tr>
<td><strong>LPOP</strong></td>
<td><font size="2" color="red"><strong>LLEN KEY_NAME             （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>列表的第一个元素。 当列表 <code>key</code> 不存在时，返回<code>nil</code>。</strong></font></td>
<td><font size="2"><strong>移除并返回列表的第一个元素。</strong></font></td>
</tr>
<tr>
<td><strong>LPUSH</strong></td>
<td><font size="2" color="red"><strong>LPUSH KEY_NAME VALUE1.. VALUEN              （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>执行 <code>LPUSH</code> 命令后，列表的长度。</strong></font></td>
<td><font size="2"><strong>将一个或多个值插入到列表头部。 如果 <code>key</code>不存在，一个空列表会被创建并执行 <code>LPUSH</code> 操作。 当 <code>key</code>存在但不是列表类型时，返回一个错误。注意：在Redis 2.4版本以前的 <code>LPUSH</code>命令，都只接受单个 <code>value</code>值。</strong></font></td>
</tr>
<tr>
<td><strong>LPUSHX</strong></td>
<td><font size="2" color="red"><strong>LPUSHX KEY_NAME VALUE1.. VALUEN         （&gt;= 2.2.0）</strong></font></td>
<td><font size="2"><strong><code>LPUSHX</code>命令执行之后，列表的长度。</strong></font></td>
<td><font size="2"><strong>将一个或多个值插入到已存在的列表头部，列表不存在时操作无效。</strong></font></td>
</tr>
<tr>
<td><strong>LRANGE</strong></td>
<td><font size="2" color="red"><strong>LRANGE KEY_NAME START END                   （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>一个列表，包含指定区间内的元素。</strong></font></td>
<td><font size="2"><strong>返回列表中指定区间内的元素，区间以偏移量<code>START</code> 和<code>END</code> 指定。 其中 <code>0</code>表示列表的第一个元素， <code>1</code> 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 <code>-1</code>表示列表的最后一个元素， <code>-2</code> 表示列表的倒数第二个元素，以此类推。</strong></font></td>
</tr>
<tr>
<td><strong>LREM</strong></td>
<td><font size="2" color="red"><strong>LREM KEY_NAME COUNT VALUE （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>被移除元素的数量。 列表不存在返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>根据参数 <code>COUNT</code> 的值，移除列表中与参数 <code>VALUE</code>相等的元素。<code>COUNT</code> 的值可以是以下几种：count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 <code>COUNT</code> 。 count &lt; 0 : 从表尾开始向表头搜索，移除与 <code>VALUE</code> 相等的元素，数量为 <code>COUNT</code> 的绝对值。count = 0 : 移除表中所有与<code>VALUE</code>相等的值。</strong></font></td>
</tr>
<tr>
<td><strong>LSET</strong></td>
<td><font size="2" color="red"><strong>LSET KEY_NAME INDEX VALUE（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>操作成功返回 <code>ok</code>，否则返回错误信息。</strong></font></td>
<td><font size="2"><strong>通过索引来设置元素的值。当索引参数超出范围，或对一个空列表进行 <code>LSET</code> 时，返回一个错误。</strong></font></td>
</tr>
<tr>
<td><strong>LTRIM</strong></td>
<td><font size="2" color="red"><strong>LTRIM KEY_NAME START STOP （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>命令执行成功时，返回 <code>ok</code>。</strong></font></td>
<td><font size="2"><strong>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标 <code>0</code>表示列表的第一个元素，以 <code>1</code> 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以<code>-1</code> 表示列表的最后一个元素，<code>-2</code>表示列表的倒数第二个元素，以此类推。</strong></font></td>
</tr>
<tr>
<td><strong>RPOP</strong></td>
<td><font size="2" color="red"><strong>RPOP KEY_NAME           （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>列表的最后一个元素。 当列表不存在时，返回 <code>nil</code>。</strong></font></td>
<td><font size="2"><strong>用于移除并返回列表的最后一个元素。</strong></font></td>
</tr>
<tr>
<td><strong>RPOPLPUSH</strong></td>
<td><font size="2" color="red"><strong>RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>被弹出的元素。</strong></font></td>
<td><font size="2"><strong>用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</strong></font></td>
</tr>
<tr>
<td><strong>RPUSH</strong></td>
<td><font size="2" color="red"><strong>RPUSH KEY_NAME VALUE1..VALUEN        （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>执行 <code>RPUSH</code>操作后，列表的长度。</strong></font></td>
<td><font size="2"><strong>用于将一个或多个值插入到列表的尾部(最右边)。如果列表不存在，一个空列表会被创建并执行 <code>RPUSH</code> 操作。 当列表存在但不是列表类型时，返回一个错误。<br>注意：在 Redis 2.4 版本以前的 <code>RPUSH</code>命令，都只接受单个<code>value</code>值。</strong></font></td>
</tr>
<tr>
<td><strong>RPUSHX</strong></td>
<td><font size="2" color="red"><strong>RPUSHX KEY_NAME VALUE1..VALUEN              （&gt;= 2.2.0）</strong></font></td>
<td><font size="2"><strong>执行 <code>RPUSHX</code>操作后，列表的长度。</strong></font></td>
<td><font size="2"><strong>将一个或多个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-6-Set（集合）"><a href="#2-6-Set（集合）" class="headerlink" title="2.6 Set（集合）"></a>2.6 Set（集合）</h2><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey mysql</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD mykey mysql</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS mykey</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"mysql"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure>

<p>在以上实例中我们通过 <strong>SADD</strong> 命令向名为 mykey 的集合插入的三个元素。</p>
<p><strong>下表给出了与 Redis集合相关常用的基本命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SADD</strong></td>
<td><font size="2" color="red"><strong>SADD KEY_NAME VALUE1..VALUEN（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>被添加到集合中的新元素的数量，不包括被忽略的元素。</strong></font></td>
<td><font size="2"><strong>将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。假如集合 <code>key</code>不存在，则创建一个只包含添加的元素作成员的集合。当集合 <code>key</code>不是集合类型时，返回一个错误。注意：在Redis2.4版本以前，<code>SADD</code> 只接受单个成员值。</strong></font></td>
</tr>
<tr>
<td><strong>SCARD</strong></td>
<td><font size="2" color="red"><strong>SCARD KEY_NAME （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>集合的数量。 当集合 <code>key</code>不存在时，返回 0 。</strong></font></td>
<td><font size="2"><strong>返回集合中元素的数量。</strong></font></td>
</tr>
<tr>
<td><strong>SDIFF</strong></td>
<td><font size="2" color="red"><strong>SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>包含差集成员的列表。</strong></font></td>
<td><font size="2"><strong>返回给定集合之间的差集。不存在的集合 <code>key</code>将视为空集。</strong></font></td>
</tr>
<tr>
<td><strong>SDIFFSTORE</strong></td>
<td><font size="2" color="red"><strong>SDIFFSTORE DESTINATION_KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>结果集中的元素数量。</strong></font></td>
<td><font size="2"><strong>将给定集合之间的差集存储在指定的集合中。如果指定的集合 <code>key</code>已存在，则会被覆盖。</strong></font></td>
</tr>
<tr>
<td><strong>SINTER</strong></td>
<td><font size="2" color="red"><strong>SINTER KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>交集成员的列表。</strong></font></td>
<td><font size="2"><strong>返回给定所有给定集合的交集。 不存在的集合 <code>key</code> 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</strong></font></td>
</tr>
<tr>
<td><strong>SINTERSTORE</strong></td>
<td><font size="2" color="red"><strong>SINTERSTORE DESTINATION_KEY KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>交集成员的列表。</strong></font></td>
<td><font size="2"><strong>将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖。</strong></font></td>
</tr>
<tr>
<td><strong>SISMEMBER</strong></td>
<td><font size="2" color="red"><strong>SISMEMBER KEY VALUE（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>如果成员元素是集合的成员，返回 <code>1</code> 。 如果成员元素不是集合的成员，或 <code>key</code> 不存在，返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>判断成员元素是否是集合的成员。</strong></font></td>
</tr>
<tr>
<td><strong>SMEMBERS</strong></td>
<td><font size="2" color="red"><strong>SMEMBERS KEY VALUE （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>集合中的所有成员。</strong></font></td>
<td><font size="2"><strong>返回集合中的所有的成员。 不存在的集合 <code>key</code> 被视为空集合。</strong></font></td>
</tr>
<tr>
<td><strong>SMOVE</strong></td>
<td><font size="2" color="red"><strong>SMOVE SOURCE DESTINATION MEMBER（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>如果成员元素被成功移除，返回 <code>1</code> 。 如果成员元素不是 <code>source</code>集合的成员，并且没有任何操作对 <code>destination</code> 集合执行，那么返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>将指定成员 <code>member</code>元素从 <code>source</code>集合移动到 <code>destination</code> 集合。<code>SMOVE</code>是原子性操作。如果 <code>source</code> 集合不存在或不包含指定的 <code>member</code> 元素，则 <code>SMOVE</code>命令不执行任何操作，仅返回<code>0</code>。否则， <code>member</code> 元素从 <code>source</code> 集合中被移除，并添加到 <code>destination</code> 集合中去。当 <code>destination</code> 集合已经包含 <code>member</code> 元素时， <code>SMOVE</code> 命令只是简单地将 <code>source</code> 集合中的 <code>member</code> 元素删除。当 <code>source</code> 或 <code>destination</code> 不是集合类型时，返回一个错误。</strong></font></td>
</tr>
<tr>
<td><strong>SPOP</strong></td>
<td><font size="2" color="red"><strong>SPOP KEY（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>被移除的随机元素。 当集合不存在或是空集时，返回 <code>nil</code> 。</strong></font></td>
<td><font size="2"><strong>移除并返回集合中的一个随机元素。</strong></font></td>
</tr>
<tr>
<td><strong>SRANDMEMBER</strong></td>
<td><font size="2" color="red"><strong>SRANDMEMBER KEY [count]（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>只提供集合 <code>key</code> 参数时，返回一个元素；如果集合为空，返回 <code>nil</code>。 如果提供了 <code>count</code>参数，那么返回一个数组；如果集合为空，返回空数组。</strong></font></td>
<td><font size="2"><strong>返回集合中的一个随机元素。从 Redis 2.6 版本开始， <code>Srandmember</code> 命令接受可选的<code>count</code>参数：如果 <code>count</code>为正数，且小于集合基数，那么命令返回一个包含 <code>count</code>个元素的数组，数组中的元素各不相同。如果 <code>count</code>大于等于集合基数，那么返回整个集合。如果<code>count</code> 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 <code>count</code> 的绝对值。该操作和 <code>SPOP</code> 相似，但 <code>SPOP</code> 将随机元素从集合中移除并返回，而 <code>Srandmember</code> 则仅仅返回随机元素，而不对集合进行任何改动。</strong></font></td>
</tr>
<tr>
<td><strong>SREM</strong></td>
<td><font size="2" color="red"><strong>SREM KEY MEMBER1..MEMBERN            （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>被成功移除的元素的数量，不包括被忽略的元素。</strong></font></td>
<td><font size="2"><strong>移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。当 <code>key</code>不是集合类型，返回一个错误。在 Redis 2.4 版本以前， <code>SREM</code> 只接受单个成员值。</strong></font></td>
</tr>
<tr>
<td><strong>SUNION</strong></td>
<td><font size="2" color="red"><strong>SUNION KEY KEY1..KEYN           （&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>并集成员的列表。</strong></font></td>
<td><font size="2"><strong>返回给定集合的并集。不存在的集合 <code>key</code> 被视为空集。</strong></font></td>
</tr>
<tr>
<td><strong>SUNIONSTORE</strong></td>
<td><font size="2" color="red"><strong>SUNIONSTORE DESTINATION KEY KEY1..KEYN（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>结果集中的元素数量。</strong></font></td>
<td><font size="2"><strong>将给定集合的并集存储在指定的集合<code>destination</code>中。</strong></font></td>
</tr>
<tr>
<td><strong>SSCAN</strong></td>
<td><font size="2" color="red"><strong>SSCAN KEY [MATCH pattern] [COUNT count]（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>数组列表。</strong></font></td>
<td><font size="2"><strong>迭代集合键中的元素。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-7-zset-sorted-set：有序集合"><a href="#2-7-zset-sorted-set：有序集合" class="headerlink" title="2.7 zset(sorted set：有序集合)"></a>2.7 zset(sorted set：有序集合)</h2><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">1</span> redis</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">2</span> mongodb</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">3</span> mysql</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">3</span> mysql</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZADD mykey <span class="number">4</span> mysql</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ZRANGE mykey <span class="number">0</span> <span class="number">10</span> WITHSCORES</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"redis"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"mongodb"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"mysql"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"4"</span></span><br></pre></td></tr></table></figure>

<p>在以上实例中我们通过命令 <strong>ZADD</strong> 向 redis 的有序集合中添加了三个值并关联上分数。</p>
<p><strong>下表给出了与 Redis有序集合相关常用的基本命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ZADD</strong></td>
<td><font size="2" color="red"><strong>ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN    （&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</strong></font></td>
<td><font size="2"><strong>将一个或多个成员元素及其分数值加入到有序集当中。如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。如果有序集合 <code>key</code> 不存在，则创建一个空的有序集并执行 <code>ZADD</code> 操作。当<code>key</code> 存在但不是有序集类型时，返回一个错误。<br>注意： 在 Redis 2.4 版本以前， <code>ZADD</code>每次只能添加一个元素。</strong></font></td>
</tr>
<tr>
<td><strong>ZCARD</strong></td>
<td><font size="2" color="red"><strong>ZCARD KEY_NAME     （&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong>当 <code>key</code>存在且是有序集类型时，返回有序集的基数。 当 <code>key</code> 不存在时，返回 <code>0</code>。</strong></font></td>
<td><font size="2"><strong>计算集合中元素的数量。</strong></font></td>
</tr>
<tr>
<td><strong>ZCOUNT</strong></td>
<td><font size="2" color="red"><strong>ZCOUNT key min max（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>分数值在 <code>min</code>和 <code>max</code> 之间的成员的数量。</strong></font></td>
<td><font size="2"><strong>计算有序集合中指定分数区间的成员数量。</strong></font></td>
</tr>
<tr>
<td><strong>ZINCRBY</strong></td>
<td><font size="2" color="red"><strong>ZINCRBY key increment member（&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong><code>member</code> 成员的新分数值，以字符串形式表示。</strong></font></td>
<td><font size="2"><strong>对有序集合中指定成员的分数加上增量<code>increment</code>可以通过传递一个负数值 <code>increment</code> ，让分数减去相应的值，比如 <code>ZINCRBY key -5 member</code>，就是让 <code>member</code>的 <code>score</code> 值减去 <code>5</code>。当 <code>key</code>不存在，或分数不是 key 的成员时， <code>ZINCRBY key increment member</code> 等同于 <code>ZADD key increment member</code>。当 <code>key</code> 不是有序集类型时，返回一个错误。分数值可以是整数值或双精度浮点数。</strong></font></td>
</tr>
<tr>
<td><strong>ZINTERSTORE</strong></td>
<td><font size="2" color="red"><strong>ZINTERSTORE DESTINATION NUMKEYS KEY [KEY …] [WEIGHTS WEIGHT [WEIGHT …]] [AGGREGATE SUM|MIN|MAX]    （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>保存到目标结果集的的成员数量。</strong></font></td>
<td><font size="2"><strong>计算给定的一个或多个有序集的交集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code> 参数指定，并将该交集(结果集)储存到 <code>destination</code>。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。</strong></font></td>
</tr>
<tr>
<td><strong>ZLEXCOUNT</strong></td>
<td><font size="2" color="red"><strong>ZLEXCOUNT KEY MIN MAX（&gt;= 2.8.9）</strong></font></td>
<td><font size="2"><strong>指定区间内的成员数量。</strong></font></td>
<td><font size="2"><strong>计算有序集合中指定字典区间内成员数量。</strong></font></td>
</tr>
<tr>
<td><strong>ZRANGE</strong></td>
<td><font size="2" color="red"><strong>ZRANGE key start stop [WITHSCORES]（&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong>指定区间内，带有分数值(可选)的有序集成员的列表。</strong></font></td>
<td><font size="2"><strong>返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order )来排列。如果你需要成员按值递减(从大到小)来排列，请使用 ZREVRANGE 命令。下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</strong></font></td>
</tr>
<tr>
<td><strong>ZRANGEBYLEX</strong></td>
<td><font size="2" color="red"><strong>ZRANGEBYLEX KEY MIN MAX [LIMIT OFFSET COUNT]    （&gt;= 2.8.9）</strong></font></td>
<td><font size="2"><strong>指定区间内的元素列表。</strong></font></td>
<td><font size="2"><strong>通过字典区间返回有序集合的成员。</strong></font></td>
</tr>
<tr>
<td><strong>ZRANGEBYSCORE</strong></td>
<td><font size="2" color="red"><strong>ZRANGEBYSCORE KEY MIN MAX [WITHSCORES] [LIMIT OFFSET COUNT]     （&gt;= 1.0.5）</strong></font></td>
<td><font size="2"><strong>指定区间内，带有分数值(可选)的有序集成员的列表。</strong></font></td>
<td><font size="2"><strong>返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</strong></font></td>
</tr>
<tr>
<td><strong>ZRANK</strong></td>
<td><font size="2" color="red"><strong>ZRANK KEY MEMBER（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>如果成员是有序集<code>key</code> 的成员，返回 <code>member</code> 的排名。 如果成员不是有序集<code>key</code>的成员，返回 <code>nil</code> 。</strong></font></td>
<td><font size="2"><strong>返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。</strong></font></td>
</tr>
<tr>
<td><strong>ZREM</strong></td>
<td><font size="2" color="red"><strong>ZREM KEY MEMBER [MEMBER …]          （&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong>被成功移除的成员的数量，不包括被忽略的成员。</strong></font></td>
<td><font size="2"><strong>移除有序集中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。<br>注意： 在 Redis 2.4 版本以前， <code>ZREM</code>每次只能删除一个元素。</strong></font></td>
</tr>
<tr>
<td><strong>ZREMRANGEBYLEX</strong></td>
<td><font size="2" color="red"><strong>ZREMRANGEBYLEX KEY MIN MAX       （&gt;= 2.8.9）</strong></font></td>
<td><font size="2"><strong>被成功移除的成员的数量，不包括被忽略的成员。</strong></font></td>
<td><font size="2"><strong>移除有序集合中给定的字典区间的所有成员。</strong></font></td>
</tr>
<tr>
<td><strong>ZREMRANGEBYRANK</strong></td>
<td><font size="2" color="red"><strong>ZREMRANGEBYRANK KEY START STOP      （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>被移除成员的数量。</strong></font></td>
<td><font size="2"><strong>用于移除有序集中，指定排名(rank)区间内的所有成员。</strong></font></td>
</tr>
<tr>
<td><strong>ZREMRANGEBYSCORE</strong></td>
<td><font size="2" color="red"><strong>ZREMRANGEBYSCORE KEY MIN MAX        （&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong>被移除成员的数量。</strong></font></td>
<td><font size="2"><strong>移除有序集中，指定分数（score）区间内的所有成员。</strong></font></td>
</tr>
<tr>
<td><strong>ZREVRANGE</strong></td>
<td><font size="2" color="red"><strong>ZREVRANGE KEY START STOP [WITHSCORES]                （&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong>指定区间内，带有分数值(可选)的有序集成员的列表。</strong></font></td>
<td><font size="2"><strong>返回有序集中，指定区间内的成员。其中成员的位置按分数值递减(从大到小)来排列。具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按分数值递减的次序排列这一点外， <code>ZREVRANGE</code> 命令的其他方面和 <code>ZRANGE</code> 命令一样。</strong></font></td>
</tr>
<tr>
<td><strong>ZREVRANK</strong></td>
<td><font size="2" color="red"><strong>ZREVRANK KEY MEMBER（&gt;= 2.2.0）</strong></font></td>
<td><font size="2"><strong>如果成员是有序集 <code>key</code> 的成员，返回成员的排名。 如果成员不是有序集 <code>key</code> 的成员，返回 <code>nil</code>。</strong></font></td>
<td><font size="2"><strong>返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。排名以 <code>0</code>为底，也就是说， 分数值最大的成员排名为<code>0</code> 。使用 <code>ZRANK</code> 命令可以获得成员按分数值递增(从小到大)排列的排名。</strong></font></td>
</tr>
<tr>
<td><strong>ZSCAN</strong></td>
<td><font size="2" color="red"><strong>ZSCAN KEY CURSOR [MATCH PATTERN] [COUNT COUNT]        （&gt;= 2.8.0）</strong></font></td>
<td><font size="2"><strong>返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</strong></font></td>
<td><font size="2"><strong>迭代有序集合中的元素（包括元素成员和元素分值）</strong></font></td>
</tr>
<tr>
<td><strong>ZSCORE</strong></td>
<td><font size="2" color="red"><strong>ZSCORE KEY MEMBER（&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong>成员的分数值，以字符串形式表示。</strong></font></td>
<td><font size="2"><strong>返回有序集中，成员的分数值。 如果成员元素不是有序集 <code>key</code>的成员，或 <code>key</code>不存在，返回 <code>nil</code> 。</strong></font></td>
</tr>
<tr>
<td><strong>ZUNIONSTORE</strong></td>
<td><font size="2" color="red"><strong>ZUNIONSTORE DESTINATION NUMKEYS KEY [KEY …] [WEIGHTS WEIGHT [WEIGHT …]] [AGGREGATE SUM|MIN|MAX]（&gt;=2.0.0）</strong></font></td>
<td><font size="2"><strong>保存到 <code>destination</code>的结果集的成员数量。</strong></font></td>
<td><font size="2"><strong>计算给定的一个或多个有序集的并集，其中给定 <code>key</code> 的数量必须以 <code>numkeys</code>参数指定，并将该并集(结果集)储存到 <code>destination</code>。默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和 。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-8-HyperLogLog"><a href="#2-8-HyperLogLog" class="headerlink" title="2.8 HyperLogLog"></a>2.8 HyperLogLog</h2><p>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据。</p>
<p>核心是基数估算算法，最终数值存在一定误差。</p>
<p>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值。</p>
<p>耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数。</p>
<p>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大。</p>
<p>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少 。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFADD  databases  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"MySQL"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFCOUNT  databases</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFADD  databases  <span class="string">"Redis"</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFADD  databases  <span class="string">"PostgreSQL"</span>    <span class="comment"># 添加一个不存在的元素</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis  <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>下表给出了与 Redis HyperLogLog相关常用的基本命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PFADD</strong></td>
<td><font size="2" color="red"><strong>PFADD key element [element …]（&gt;= 2.8.9）</strong></font></td>
<td><font size="2"><strong>整型，如果至少有个元素被添加返回<code>1</code>， 否则返回<code>0</code>。</strong></font></td>
<td><font size="2"><strong>将所有元素参数添加到 <code>HyperLogLog</code> 数据结构中</strong></font></td>
</tr>
<tr>
<td><strong>PFCOUNT</strong></td>
<td><font size="2" color="red"><strong>PFCOUNT key [key …]        （&gt;= 2.8.9）</strong></font></td>
<td><font size="2"><strong>整数，返回给定 <code>HyperLogLog</code>的基数值，如果多个 <code>HyperLogLog</code> 则返回基数估值之和。</strong></font></td>
<td><font size="2"><strong>返回给定 HyperLogLog 的基数估算值。</strong></font></td>
</tr>
<tr>
<td><strong>PFMERGE</strong></td>
<td><font size="2" color="red"><strong>PFMERGE destkey sourcekey [sourcekey …]（&gt;= 2.8.9）</strong></font></td>
<td><font size="2"><strong>返回<code>OK</code>。</strong></font></td>
<td><font size="2"><strong>将多个 <code>HyperLogLog</code>合并为一个 <code>HyperLogLog</code> ，合并后的 <code>HyperLogLog</code> 的基数估算值是通过对所有 给定 <code>HyperLogLog</code>进行并集计算得出的。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-9-GEO（地理位置）"><a href="#2-9-GEO（地理位置）" class="headerlink" title="2.9 GEO（地理位置）"></a>2.9 GEO（地理位置）</h2><p>支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> <span class="string">"Palermo"</span> <span class="number">15.087269</span> <span class="number">37.502669</span> <span class="string">"Catania"</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">"166274.15156960039"</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GEORADIUS Sicily <span class="number">15</span> <span class="number">37</span> <span class="number">100</span> km</span><br><span class="line"><span class="number">1</span>) <span class="string">"Catania"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily <span class="number">15</span> <span class="number">37</span> <span class="number">200</span> km</span><br><span class="line"><span class="number">1</span>) <span class="string">"Palermo"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"Catania"</span></span><br></pre></td></tr></table></figure>

<p><strong>下表给出了与 Redis GEO相关常用的基本命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GEOADD</strong></td>
<td><font size="2" color="red"><strong>GEOADD key longitude latitude member [longitude latitude member …]（&gt;= 3.2.0）</strong></font></td>
<td><font size="2"><strong>新添加到键里面的空间元素数量， 不包括那些已经存在但是被更新的元素。</strong></font></td>
<td><font size="2"><strong>将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 <code>GEORADIUS</code> 和 <code>GEORADIUSBYMEMBER</code> 这样的命令可以在之后通过位置查询取得这些元素。</strong></font></td>
</tr>
<tr>
<td><strong>GEOPOS</strong></td>
<td><font size="2" color="red"><strong>GEOPOS key member [member …]             （&gt;= 3.2.0）</strong></font></td>
<td><font size="2"><strong><code>GEOPOS</code> 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。 当给定的位置元素不存在时， 对应的数组项为空值。</strong></font></td>
<td><font size="2"><strong>从键里面返回所有给定位置元素的位置（经度和纬度）。因为 <code>GEOPOS</code> 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复。</strong></font></td>
</tr>
<tr>
<td><strong>GEODIST</strong></td>
<td><font size="2" color="red"><strong>GEODIST key member1 member2 [unit]          （&gt;= 3.2.0）</strong></font></td>
<td><font size="2"><strong>计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值。</strong></font></td>
<td><font size="2"><strong>返回两个给定位置之间的距离。如果两个位置之间的其中一个不存在， 那么命令返回空值。</strong></font></td>
</tr>
<tr>
<td><strong>GEORADIUS</strong></td>
<td><font size="2" color="red"><strong>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]（&gt;= 3.2.0）</strong></font></td>
<td><font size="2"><strong><a href="http://redisdoc.com/geo/georadius.html" target="_blank" rel="noopener">复杂见文档</a></strong></font></td>
<td><font size="2"><strong><a href="http://redisdoc.com/geo/georadius.html" target="_blank" rel="noopener">复杂见文档</a></strong></font></td>
</tr>
<tr>
<td><strong>GEORADIUSBYMEMBER</strong></td>
<td><font size="2" color="red"><strong>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]（&gt;= 3.2.0）</strong></font></td>
<td><font size="2"><strong>一个数组， 数组中的每个项表示一个范围之内的位置元素。</strong></font></td>
<td><font size="2"><strong>这个命令和 <code>GEORADIUS</code> 命令一样， 都可以找出位于指定范围内的元素， 但是 <code>GEORADIUSBYMEMBER</code> 的中心点是由给定的位置元素决定的， 而不是像 <code>GEORADIUS</code> 那样， 使用输入的经度和纬度来决定中心点。</strong></font></td>
</tr>
<tr>
<td><strong>GEOHASH</strong></td>
<td><font size="2" color="red"><strong>GEOHASH key member [member …]                （&gt;= 3.2.0）</strong></font></td>
<td><font size="2"><strong>一个数组， 数组的每个项都是一个<code>geohash</code>。 命令返回的 <code>geohash</code>的位置与用户给定的位置元素的位置一一对应。</strong></font></td>
<td><font size="2"><strong>返回一个或多个位置元素的 <code>Geohash</code> 表示。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-10-BitMap（位图）"><a href="#2-10-BitMap（位图）" class="headerlink" title="2.10 BitMap（位图）"></a>2.10 BitMap（位图）</h2><p>BitMap，即位图，其实也就是 byte 数组，用二进制表示，只有 0 和 1 两个数字。可以用于实现用户上线次数统计。</p>
<p><strong>实例</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SETBIT bit <span class="number">10086</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GETBIT bit <span class="number">10086</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GETBIT bit <span class="number">100</span>   <span class="comment"># bit 默认被初始化为 0</span></span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>下表给出了与 Redis BitMap相关常用的基本命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SETBIT</strong></td>
<td><font size="2" color="red"><strong>SETBIT key offset value（&gt;=2.2.0）</strong></font></td>
<td><font size="2"><strong>指定偏移量原来储存的位。</strong></font></td>
<td><font size="2"><strong>对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。位的设置或清除取决于 <code>value</code> 参数，可以是 <code>0</code> 也可以是 <code>1</code> 。当 <code>key</code> 不存在时，自动生成一个新的字符串值。字符串会进行伸展(grown)以确保它可以将 <code>value</code> 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 <code>0</code> 填充。<code>offset</code> 参数必须大于或等于 <code>0</code> ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</strong></font></td>
</tr>
<tr>
<td><strong>GETBIT</strong></td>
<td><font size="2" color="red"><strong>GETBIT key offset（&gt;=2.2.0）</strong></font></td>
<td><font size="2"><strong>字符串值指定偏移量上的位(bit)。</strong></font></td>
<td><font size="2"><strong>对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。当 <code>offset</code> 比字符串值的长度大，或者 <code>key</code> 不存在时，返回 <code>0</code> 。</strong></font></td>
</tr>
<tr>
<td><strong>BITCOUNT</strong></td>
<td><font size="2" color="red"><strong>BITCOUNT key [start] [end]（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>被设置为 <code>1</code> 的位的数量。</strong></font></td>
<td><font size="2"><strong>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行。<code>start</code> 和 <code>end</code> 参数的设置都可以使用负数值： 比如 <code>-1</code> 表示最后一个字节， <code>-2</code> 表示倒数第二个字节，以此类推。不存在的 <code>key</code> 被当成是空字符串来处理，因此对一个不存在的 <code>key</code> 进行 <code>BITCOUNT</code> 操作，结果为 <code>0</code> 。</strong></font></td>
</tr>
<tr>
<td><strong>BITPOS</strong></td>
<td><font size="2" color="red"><strong>BITPOS key bit [start] [end]（&gt;= 2.8.7）</strong></font></td>
<td><font size="2"><strong>整数回复。</strong></font></td>
<td><font size="2"><strong>返回位图中第一个值为 <code>bit</code> 的二进制位的位置。在默认情况下， 命令将检测整个位图， 但用户也可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。</strong></font></td>
</tr>
<tr>
<td><strong>BITOP</strong></td>
<td><font size="2" color="red"><strong>BITOP operation destkey key [key …]（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>保存到 <code>destkey</code> 的字符串的长度，和输入 <code>key</code> 中最长的字符串长度相等。</strong></font></td>
<td><font size="2"><strong>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。<code>operation</code> 可以是 <code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 、 <code>XOR</code> 这四种操作中的任意一种：<br><code>BITOP AND destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑并，并将结果保存到 <code>destkey</code> 。<br><code>BITOP OR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑或，并将结果保存到 <code>destkey</code> 。<br><code>BITOP XOR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑异或，并将结果保存到 <code>destkey</code> 。<br><code>BITOP NOT destkey key</code> ，对给定 <code>key</code> 求逻辑非，并将结果保存到 <code>destkey</code> 。<br>除了 <code>NOT</code> 操作之外，其他操作都可以接受一个或多个 <code>key</code> 作为输入。<br>当 <code>BITOP</code>处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</strong></font></td>
</tr>
<tr>
<td><strong>BITFIELD</strong></td>
<td><font size="2" color="red"><strong>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]（&gt;= 3.2.0）</strong></font></td>
<td><font size="2"><strong><a href="http://redisdoc.com/bitmap/bitfield.html" target="_blank" rel="noopener">复杂见文档</a></strong></font></td>
<td><font size="2"><strong><a href="http://redisdoc.com/bitmap/bitfield.html" target="_blank" rel="noopener">复杂见文档</a></strong></font></td>
</tr>
</tbody></table>
<h2 id="2-11-Pub-Sub（发布-订阅）"><a href="#2-11-Pub-Sub（发布-订阅）" class="headerlink" title="2.11 Pub/Sub（发布/订阅）"></a>2.11 Pub/Sub（发布/订阅）</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p><strong>实例</strong></p>
<p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 <strong>redisChat</strong>:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SUBSCRIBE redisChat</span><br><span class="line"></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redisChat"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH redisChat <span class="string">"Redis is a great caching technique"</span></span><br><span class="line"> </span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PUBLISH redisChat <span class="string">"Learn redis by w3cschool.cc"</span></span><br><span class="line"> </span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 订阅者的客户端会显示如下消息</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"message"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redisChat"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"Redis is a great caching technique"</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"message"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"redisChat"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"Learn redis by w3cschool.cc"</span></span><br></pre></td></tr></table></figure>

<p><strong>下表列出了 redis 发布订阅常用命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PSUBSCRIBE</strong></td>
<td><font size="2" color="red"><strong>PSUBSCRIBE pattern [pattern …]（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>接收到的信息。</strong></font></td>
<td><font size="2"><strong>订阅一个或多个符合给定模式的频道。每个模式以 * 作为匹配符，比如 it* 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)。 news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类。</strong></font></td>
</tr>
<tr>
<td><strong>PUBSUB</strong></td>
<td><font size="2" color="red"> <strong>PUBSUB <subcommand> [argument [argument …]]（&gt;= 2.8.0）</subcommand></strong></font></td>
<td><font size="2"><strong>由活跃频道组成的列表。</strong></font></td>
<td><font size="2"><strong>用于查看订阅与发布系统状态，它由数个不同格式的子命令组成。</strong></font></td>
</tr>
<tr>
<td><strong>PUBLISH</strong></td>
<td><font size="2" color="red"><strong>PUBLISH channel message（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>接收到信息的订阅者数量。</strong></font></td>
<td><font size="2"><strong>用于将信息发送到指定的频道。</strong></font></td>
</tr>
<tr>
<td><strong>PUNSUBSCRIBE</strong></td>
<td><font size="2" color="red"><strong>PUNSUBSCRIBE [pattern [pattern …]]（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>这个命令在不同的客户端中有不同的表现。</strong></font></td>
<td><font size="2"><strong>用于退订所有给定模式的频道。</strong></font></td>
</tr>
<tr>
<td><strong>SUBSCRIBE</strong></td>
<td><font size="2" color="red"><strong>SUBSCRIBE channel [channel …]（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>接收到的信息。</strong></font></td>
<td><font size="2"><strong>用于订阅给定的一个或多个频道的信息。</strong></font></td>
</tr>
<tr>
<td><strong>UNSUBSCRIBE</strong></td>
<td><font size="2" color="red"><strong>UNSUBSCRIBE channel [channel …]（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>这个命令在不同的客户端中有不同的表现。</strong></font></td>
<td><font size="2"><strong>用于退订给定的一个或多个频道的信息。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-12-Transaction（事务）"><a href="#2-12-Transaction（事务）" class="headerlink" title="2.12 Transaction（事务）"></a>2.12 Transaction（事务）</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<p><strong>实例</strong></p>
<p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SET book-name <span class="string">"Mastering C++ in 21 days"</span></span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SADD tag <span class="string">"C++"</span> <span class="string">"Programming"</span> <span class="string">"Mastering Series"</span></span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"> </span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) <span class="string">"Mastering C++ in 21 days"</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">3</span></span><br><span class="line"><span class="number">4</span>) <span class="number">1</span>) <span class="string">"Mastering Series"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"C++"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"Programming"</span></span><br></pre></td></tr></table></figure>

<p><strong>下表列出了 redis 事务的相关命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DISCARD</strong></td>
<td><font size="2" color="red"><strong>DISCARD（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于取消事务，放弃执行事务块内的所有命令。</strong></font></td>
</tr>
<tr>
<td><strong>EXEC</strong></td>
<td><font size="2" color="red"><strong>EXEC（&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong>事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</strong></font></td>
<td><font size="2"><strong>用于执行所有事务块内的命令。</strong></font></td>
</tr>
<tr>
<td><strong>MULTI</strong></td>
<td><font size="2" color="red"><strong>MULTI（&gt;= 1.2.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 <code>EXEC</code>命令原子性(atomic)地执行。</strong></font></td>
</tr>
<tr>
<td><strong>UNWATCH</strong></td>
<td><font size="2" color="red"><strong>UNWATCH（&gt;= 2.2.0）</strong> </font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于取消 <code>WATCH</code> 命令对所有 key 的监视。</strong></font></td>
</tr>
<tr>
<td><strong>WATCH</strong></td>
<td><font size="2" color="red"><strong>WATCH（&gt;= 2.2.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于监视一个(或多个)<code>key</code> ，如果在事务执行之前这个(或这些)<code>key</code>被其他命令所改动，那么事务将被打断。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-13-Script（脚本）"><a href="#2-13-Script（脚本）" class="headerlink" title="2.13 Script（脚本）"></a>2.13 Script（脚本）</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Reids 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong>。</p>
<p><strong>实例</strong></p>
<p>以下实例演示了 redis 脚本工作过程：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; EVAL <span class="string">"return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"</span> <span class="number">2</span> key1 key2 first second</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>) <span class="string">"key1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"key2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"second"</span></span><br></pre></td></tr></table></figure>

<p><strong>下表列出了 redis 脚本的相关命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>EVAL</strong></td>
<td><font size="2" color="red"><strong>EVAL script numkeys key [key …] arg [arg …]（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>无</strong></font></td>
<td><font size="2"><strong>使用 Lua 解释器执行脚本。<br>参数说明：<br>script： 参数是一段 Lua 5.1 脚本程序。脚本不必(也不应该)定义为一个 Lua 函数。 numkeys： 用于指定键名参数的个数。 key [key …]： 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。 arg [arg …]： 附加参数，在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</strong></font></td>
</tr>
<tr>
<td><strong>EVALSHA</strong></td>
<td><font size="2" color="red"><strong>EVALSHA sha1 numkeys key [key …] arg [arg …]（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>无</strong></font></td>
<td><font size="2"><strong>根据给定的 sha1 校验码，执行缓存在服务器中的脚本。参数说明同上</strong></font></td>
</tr>
<tr>
<td><strong>SCRIPT EXISTS</strong></td>
<td><font size="2" color="red"><strong>SCRIPT EXISTS scripts（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>一个列表，包含 <code>0</code>和<code>1</code>，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。列表中的元素和给定的 <code>SHA1</code>校验和保持对应关系，比如列表的第三个元素的值就表示第三个 <code>SHA1</code>校验和所指定的脚本在缓存中的状态。</strong></font></td>
<td><font size="2"><strong>用于校验指定的脚本是否已经被保存在缓存当中。</strong></font></td>
</tr>
<tr>
<td><strong>SCRIPT FLUSH</strong></td>
<td><font size="2" color="red"><strong>SCRIPT FLUSH（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK。</strong></font></td>
<td><font size="2"><strong>用于清除所有 Lua 脚本缓存。</strong></font></td>
</tr>
<tr>
<td><strong>SCRIPT KILL</strong></td>
<td><font size="2" color="red"><strong>SCRIPT KILL（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK</strong></font></td>
<td><font size="2"><strong>用于杀死当前正在运行的 <code>Lua</code>脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限循环的脚本。<code>SCRIPT KILL</code> 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 EVAL 命令的阻塞当中退出，并收到一个错误作为返回值。</strong></font></td>
</tr>
<tr>
<td><strong>SCRIPT LOAD</strong></td>
<td><font size="2" color="red"><strong>SCRIPT LOAD script（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>给定脚本的 <code>SHA1</code>校验和</strong></font></td>
<td><font size="2"><strong>用于将脚本 <code>script</code>添加到脚本缓存中，但并不立即执行这个脚本。<code>EVAL</code>命令也会将脚本添加到脚本缓存中，但是它会立即对输入的脚本进行求值。如果给定的脚本已经在缓存里面了，那么不执行任何操作。在脚本被加入到缓存之后，通过 <code>EVALSHA</code>命令，可以使用脚本的 SHA1 校验和来调用这个脚本。脚本可以在缓存中保留无限长的时间，直到执行 <code>SCRIPT FLUSH</code> 为止。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-14-Connection（连接）"><a href="#2-14-Connection（连接）" class="headerlink" title="2.14 Connection（连接）"></a>2.14 Connection（连接）</h2><p>Redis 连接命令主要是用于连接 redis 服务。</p>
<p><strong>实例</strong></p>
<p>以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; AUTH <span class="string">"password"</span></span><br><span class="line">OK</span><br><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<p><strong>下表列出了 redis 连接的基本命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AUTH</strong></td>
<td><font size="2" color="red"><strong>AUTH PASSWORD（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>密码匹配时返回 OK ，否则返回一个错误。</strong></font></td>
<td><font size="2"><strong>用于检测给定的密码和配置文件中的密码是否相符。</strong></font></td>
</tr>
<tr>
<td><strong>ECHO</strong></td>
<td><font size="2" color="red"><strong>ECHO message（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>返回字符串本身。</strong></font></td>
<td><font size="2"><strong>用于打印给定的字符串。</strong></font></td>
</tr>
<tr>
<td><strong>PING</strong></td>
<td><font size="2" color="red"><strong>PING （&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>如果连接正常就返回一个 PONG ，否则返回一个连接错误。</strong></font></td>
<td><font size="2"><strong>使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。</strong></font></td>
</tr>
<tr>
<td><strong>QUIT</strong></td>
<td><font size="2" color="red"><strong>QUIT（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于关闭与当前客户端与redis服务的连接。一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</strong></font></td>
</tr>
<tr>
<td><strong>SELECT</strong></td>
<td><font size="2" color="red"><strong>SELECT index（&gt;=1.0.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。</strong></font></td>
</tr>
</tbody></table>
<h2 id="2-15-Server（服务器）"><a href="#2-15-Server（服务器）" class="headerlink" title="2.15 Server（服务器）"></a>2.15 Server（服务器）</h2><p>Redis 服务器命令主要是用于管理 redis 服务。</p>
<p><strong>实例</strong></p>
<p>以下实例演示了如何获取 redis 服务器的统计信息：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; INFO</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line"><span class="comment"># Redis 服务器版本</span></span><br><span class="line">redis_version:<span class="number">2.8</span>.<span class="number">13</span></span><br><span class="line"><span class="comment"># Git SHA1</span></span><br><span class="line">redis_git_sha1:<span class="number">00000000</span></span><br><span class="line"><span class="comment"># Git dirty flag</span></span><br><span class="line">redis_git_dirty:<span class="number">0</span></span><br><span class="line">redis_build_id:c2238b38b1edb0e2</span><br><span class="line">redis_mode:standalone</span><br><span class="line"><span class="comment"># Redis 服务器的宿主操作系统</span></span><br><span class="line">os:Linux <span class="number">3.5</span>.<span class="number">0</span>-<span class="number">48</span>-generic x86_64</span><br><span class="line"><span class="comment"># 架构（32 或 64 位）</span></span><br><span class="line">arch_bits:<span class="number">64</span></span><br><span class="line"><span class="comment"># Redis 所使用的事件处理机制</span></span><br><span class="line">multiplexing_api:epoll</span><br><span class="line"><span class="comment"># 编译 Redis 时所使用的 GCC 版本</span></span><br><span class="line">gcc_version:<span class="number">4.7</span>.<span class="number">2</span></span><br><span class="line"><span class="comment"># 服务器进程的 PID</span></span><br><span class="line">process_id:<span class="number">3856</span></span><br><span class="line"><span class="comment"># Redis 服务器的随机标识符（用于 Sentinel 和集群）</span></span><br><span class="line">run_id:<span class="number">0</span>e61abd297771de3fe812a3c21027732ac9f41fe</span><br><span class="line"><span class="comment"># TCP/IP 监听端口</span></span><br><span class="line">tcp_port:<span class="number">6379</span></span><br><span class="line"><span class="comment"># 自 Redis 服务器启动以来，经过的秒数</span></span><br><span class="line">uptime_in_seconds:<span class="number">11554</span></span><br><span class="line"><span class="comment"># 自 Redis 服务器启动以来，经过的天数</span></span><br><span class="line">uptime_in_days:<span class="number">0</span></span><br><span class="line">hz:<span class="number">10</span></span><br><span class="line"><span class="comment"># 以分钟为单位进行自增的时钟，用于 LRU 管理</span></span><br><span class="line">lru_clock:<span class="number">16651447</span></span><br><span class="line">config_file:</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line"><span class="comment"># 已连接客户端的数量（不包括通过从属服务器连接的客户端）</span></span><br><span class="line">connected_clients:<span class="number">1</span></span><br><span class="line"><span class="comment"># 当前连接的客户端当中，最长的输出列表</span></span><br><span class="line">client-longest_output_list:<span class="number">0</span></span><br><span class="line"><span class="comment"># 当前连接的客户端当中，最大输入缓存</span></span><br><span class="line">client-biggest_input_buf:<span class="number">0</span></span><br><span class="line"><span class="comment"># 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</span></span><br><span class="line">blocked_clients:<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line"><span class="comment"># 由 Redis 分配器分配的内存总量，以字节（byte）为单位</span></span><br><span class="line">used_memory:<span class="number">589016</span></span><br><span class="line"><span class="comment"># 以人类可读的格式返回 Redis 分配的内存总量</span></span><br><span class="line">used_memory_human:<span class="number">575.21</span>K</span><br><span class="line"><span class="comment"># 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</span></span><br><span class="line">used_memory_rss:<span class="number">2461696</span></span><br><span class="line"><span class="comment"># Redis 的内存消耗峰值（以字节为单位）</span></span><br><span class="line">used_memory_peak:<span class="number">667312</span></span><br><span class="line"><span class="comment"># 以人类可读的格式返回 Redis 的内存消耗峰值</span></span><br><span class="line">used_memory_peak_human:<span class="number">651.67</span>K</span><br><span class="line"><span class="comment"># Lua 引擎所使用的内存大小（以字节为单位）</span></span><br><span class="line">used_memory_lua:<span class="number">33792</span></span><br><span class="line"><span class="comment"># used_memory_rss 和 used_memory 之间的比率</span></span><br><span class="line">mem_fragmentation_ratio:<span class="number">4.18</span></span><br><span class="line"><span class="comment"># 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。</span></span><br><span class="line">mem_allocator:jemalloc-<span class="number">3.6</span>.<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Persistence RDB 和 AOF 的相关信息</span></span><br><span class="line">loading:<span class="number">0</span></span><br><span class="line">rdb_changes_since_last_save:<span class="number">3</span></span><br><span class="line">rdb_bgsave_in_progress:<span class="number">0</span></span><br><span class="line">rdb_last_save_time:<span class="number">1409158561</span></span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:<span class="number">0</span></span><br><span class="line">rdb_current_bgsave_time_sec:-<span class="number">1</span></span><br><span class="line">aof_enabled:<span class="number">0</span></span><br><span class="line">aof_rewrite_in_progress:<span class="number">0</span></span><br><span class="line">aof_rewrite_scheduled:<span class="number">0</span></span><br><span class="line">aof_last_rewrite_time_sec:-<span class="number">1</span></span><br><span class="line">aof_current_rewrite_time_sec:-<span class="number">1</span></span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Stats 一般统计信息</span></span><br><span class="line">total_connections_received:<span class="number">24</span></span><br><span class="line">total_commands_processed:<span class="number">294</span></span><br><span class="line">instantaneous_ops_per_sec:<span class="number">0</span></span><br><span class="line">rejected_connections:<span class="number">0</span></span><br><span class="line">sync_full:<span class="number">0</span></span><br><span class="line">sync_partial_ok:<span class="number">0</span></span><br><span class="line">sync_partial_err:<span class="number">0</span></span><br><span class="line">expired_keys:<span class="number">0</span></span><br><span class="line">evicted_keys:<span class="number">0</span></span><br><span class="line">keyspace_hits:<span class="number">41</span></span><br><span class="line">keyspace_misses:<span class="number">82</span></span><br><span class="line">pubsub_channels:<span class="number">0</span></span><br><span class="line">pubsub_patterns:<span class="number">0</span></span><br><span class="line">latest_fork_usec:<span class="number">264</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Replication 主/从复制信息</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_repl_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_active:<span class="number">0</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_histlen:<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># CPU CPU计算量统计信息</span></span><br><span class="line">used_cpu_sys:<span class="number">10.49</span></span><br><span class="line">used_cpu_user:<span class="number">4.96</span></span><br><span class="line">used_cpu_sys_children:<span class="number">0.00</span></span><br><span class="line">used_cpu_user_children:<span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#commandstats : Redis 命令统计信息</span></span><br><span class="line"><span class="comment">#cluster : Redis 集群信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace 数据库相关的统计信息</span></span><br><span class="line">db0:keys=<span class="number">94</span>,expires=<span class="number">1</span>,avg_ttl=<span class="number">41638810</span></span><br><span class="line">db1:keys=<span class="number">1</span>,expires=<span class="number">0</span>,avg_ttl=<span class="number">0</span></span><br><span class="line">db3:keys=<span class="number">1</span>,expires=<span class="number">0</span>,avg_ttl=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>下表列出了 redis 服务器的相关命令:</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>语法(可用版本)</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BGREWRITEAOF</strong></td>
<td><font size="2" color="red"><strong>BGREWRITEAOF（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>反馈信息。</strong></font></td>
<td><font size="2"><strong>用于异步执行一个 AOF（AppendOnly File） 文件重写操作。重写会创建一个当前 AOF 文件的体积优化版本。即使 Bgrewriteaof 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 Bgrewriteaof 成功之前不会被修改。<br>注意：<br>从 Redis 2.4 开始， AOF 重写由 Redis 自行触发， BGREWRITEAOF 仅仅用于手动触发重写操作。</strong></font></td>
</tr>
<tr>
<td><strong>BGSAVE</strong></td>
<td><font size="2" color="red"><strong>BGSAVE（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>反馈信息。</strong></font></td>
<td><font size="2"><strong>用于在后台异步保存当前数据库的数据到磁盘。BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</strong></font></td>
</tr>
<tr>
<td><strong>CLIENT KILL</strong></td>
<td><font size="2" color="red"><strong>CLIENT KILL ip:port（&gt;= 2.4.0）</strong></font></td>
<td><font size="2"><strong>成功关闭时，返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于关闭客户端连接。</strong></font></td>
</tr>
<tr>
<td><strong>CLIENT LIST</strong></td>
<td><font size="2" color="red"><strong>CLIENT LIST（&gt;= 2.4.0）</strong></font></td>
<td><font size="2"><strong>命令返回多行字符串，这些字符串按以下形式被格式化：每个已连接客户端对应一行（以 LF 分割） 每行字符串由一系列 属性=值 形式的域组成，每个域之间以空格分开</strong></font></td>
<td><font size="2"><strong>用于返回所有连接到服务器的客户端信息和统计数据。</strong></font></td>
</tr>
<tr>
<td><strong>CLIENT GETNAME</strong></td>
<td><font size="2" color="red"><strong>CLIENT GETNAME（&gt;= 2.6.9）</strong></font></td>
<td><font size="2"><strong>如果连接没有设置名字，那么返回空白回复； 如果有设置名字，那么返回名字。</strong></font></td>
<td><font size="2"><strong>用于返回 CLIENT SETNAME 命令为连接设置的名字。 因为新创建的连接默认是没有名字的， 对于没有名字的连接， CLIENT GETNAME 返回空白回复。</strong></font></td>
</tr>
<tr>
<td><strong>CLIENT PAUSE</strong></td>
<td><font size="2" color="red"><strong>CLIENT PAUSE timeout（&gt;= 2.9.50）</strong></font></td>
<td><font size="2"><strong>返回 OK。如果 timeout 参数是非法的返回错误。</strong></font></td>
<td><font size="2"><strong>用于阻塞客户端命令一段时间（以毫秒计）。</strong></font></td>
</tr>
<tr>
<td><strong>CLIENT SETNAME</strong></td>
<td><font size="2" color="red"><strong>CLIENT SETNAME connection-name（&gt;= 2.6.9）</strong></font></td>
<td><font size="2"><strong>设置成功时返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于指定当前连接的名称。这个名字会显示在 CLIENT LIST命令的结果中， 用于识别当前正在与服务器进行连接的客户端。</strong></font></td>
</tr>
<tr>
<td><strong>CLUSTER SLOTS</strong></td>
<td><font size="2" color="red"><strong>CLUSTER SLOTS（&gt;= 3.0.0）</strong></font></td>
<td><font size="2"><strong>IP/端口嵌套的列表数组。</strong></font></td>
<td><font size="2"><strong>用于当前的集群状态，以数组形式展示。</strong></font></td>
</tr>
<tr>
<td><strong>COMMAND</strong></td>
<td><font size="2" color="red"><strong>COMMAND（&gt;= 2.8.13）</strong></font></td>
<td><font size="2"><strong>嵌套的Redis命令的详细信息列表。列表顺序是随机的。</strong></font></td>
<td><font size="2"><strong>用于返回所有的Redis命令的详细信息，以数组形式展示。</strong></font></td>
</tr>
<tr>
<td><strong>COMMAND COUNT</strong></td>
<td><font size="2" color="red"><strong>COMMAND COUNT（&gt;= 2.8.13）</strong></font></td>
<td><font size="2"><strong>redis 命令数。</strong></font></td>
<td><font size="2"><strong>用于统计 redis 命令的个数。</strong></font></td>
</tr>
<tr>
<td><strong>COMMAND GETKEYS</strong></td>
<td><font size="2" color="red"><strong>COMMAND GETKEYS（&gt;= 2.8.13）</strong></font></td>
<td><font size="2"><strong>key 的列表。</strong></font></td>
<td><font size="2"><strong>用于获取所有 key。</strong></font></td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td><font size="2" color="red"><strong>TIME（&gt;= 2.6.0）</strong></font></td>
<td><font size="2"><strong>一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒</strong></font></td>
<td><font size="2"><strong>用于返回当前服务器时间。</strong></font></td>
</tr>
<tr>
<td><strong>COMMAND INFO</strong></td>
<td><font size="2" color="red"><strong>COMMAND INFO command-name [command-name …]（&gt;= 2.8.13）</strong></font></td>
<td><font size="2"><strong>命令描述信息的嵌套列表。</strong></font></td>
<td><font size="2"><strong>用于获取 redis 命令的描述信息。</strong></font></td>
</tr>
<tr>
<td><strong>CONFIG GET</strong></td>
<td><font size="2" color="red"><strong>CONFIG GET parameter（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>给定配置参数的值。</strong></font></td>
<td><font size="2"><strong>用于获取 redis 服务的配置参数。在 Redis 2.4 版本中， 有部分参数没有办法用 CONFIG GET 访问，但是在最新的 Redis 2.6 版本中，所有配置参数都已经可以用 CONFIG GET 访问了。</strong></font></td>
</tr>
<tr>
<td><strong>CONFIG REWRITE</strong></td>
<td><font size="2" color="red"><strong>CONFIG REWRITE parameter（&gt;= 2.8.0）</strong></font></td>
<td><font size="2"><strong>一个状态值：如果配置重写成功则返回 OK ，失败则返回一个错误。</strong></font></td>
<td><font size="2"><strong>对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写。对服务器的当前配置进行修改， 而修改后的配置可能和 redis.conf 文件中所描述的配置不一样， CONFIG REWRITE 的作用就是通过尽可能少的修改， 将服务器当前所使用的配置记录到 redis.conf 文件中。</strong></font></td>
</tr>
<tr>
<td><strong>CONFIG SET</strong></td>
<td><font size="2" color="red"> <strong>CONFIG SET parameter value （&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>当设置成功时返回 OK ，否则返回一个错误。</strong></font></td>
<td><font size="2"><strong>可以动态地调整 Redis 服务器的配置(configuration)而无须重启。可以使用它修改配置参数，或者改变 Redis 的持久化(Persistence)方式。</strong></font></td>
</tr>
<tr>
<td><strong>CONFIG RESETSTAT</strong></td>
<td><font size="2" color="red"><strong>CONFIG RESETSTAT（&gt;= 2.0.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于重置 INFO命令中的某些统计数据，包括：Keyspace hits (键空间命中次数)、Keyspace misses (键空间不命中次数)、Number of commands processed (执行命令的次数)、Number of connections received (连接服务器的次数)、Number of expired keys (过期key的数量)、Number of rejected connections (被拒绝的连接数量)、Latest fork(2) time(最后执行 fork(2) 的时间)、The <code>aof_delayed_fsync</code> counter(<code>aof_delayed_fsync</code> 计数器的值)</strong></font></td>
</tr>
<tr>
<td><strong>DBSIZE</strong></td>
<td><font size="2" color="red"><strong>DBSIZE（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>当前数据库的 key 的数量。</strong></font></td>
<td><font size="2"><strong>用于返回当前数据库的 key 的数量。</strong></font></td>
</tr>
<tr>
<td><strong>DEBUG OBJECT</strong></td>
<td><font size="2" color="red"><strong>DEBUG OBJECT key（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>当 key 存在时，返回有关信息。 当 key 不存在时，返回一个错误。</strong></font></td>
<td><font size="2"><strong>是一个调试命令，它不应被客户端所使用。</strong></font></td>
</tr>
<tr>
<td><strong>DEBUG SEGFAULT</strong></td>
<td><font size="2" color="red"><strong>DEBUG SEGFAULT（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>无</strong></font></td>
<td><font size="2"><strong>执行一个非法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 调试。</strong></font></td>
</tr>
<tr>
<td><strong>FLUSHALL</strong></td>
<td><font size="2" color="red"><strong>FLUSHALL（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。</strong></font></td>
</tr>
<tr>
<td><strong>FLUSHDB</strong></td>
<td><font size="2" color="red"><strong>FLUSHDB（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于清空当前数据库中的所有 key。</strong></font></td>
</tr>
<tr>
<td><strong>INFO</strong></td>
<td><font size="2" color="red"><strong>INFO [section]（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>字符串，文本行的集合。</strong></font></td>
<td><font size="2"><strong>以一种易于理解和阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。通过给定可选的参数 section ，可以让命令只返回某一部分的信息。</strong></font></td>
</tr>
<tr>
<td><strong>LASTSAVE</strong></td>
<td><font size="2" color="red"><strong>LASTSAVE（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>字符串，文本行的集合。</strong></font></td>
<td><font size="2"><strong>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。</strong></font></td>
</tr>
<tr>
<td><strong>MONITOR</strong></td>
<td><font size="2" color="red"><strong>MONITOR（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>用于实时打印出 Redis 服务器接收到的命令，调试用。</strong></font></td>
</tr>
<tr>
<td><strong>ROLE</strong></td>
<td><font size="2" color="red"><strong>ROLE（&gt;= 2.8.12）</strong></font></td>
<td><font size="2"><strong>返回一个数组：第一个参数是 master, slave, sentinel 三个中的一个。</strong></font></td>
<td><font size="2"><strong>查看主从实例所属的角色，角色有master, slave, sentinel。</strong></font></td>
</tr>
<tr>
<td><strong>SAVE</strong></td>
<td><font size="2" color="red"><strong>SAVE（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>保存成功时返回 OK 。</strong></font></td>
<td><font size="2"><strong>执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。</strong></font></td>
</tr>
<tr>
<td><strong>SHUTDOWN</strong></td>
<td><font size="2" color="red"><strong>SHUTDOWN [NOSAVE] [SAVE]（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>执行失败时返回错误。 执行成功时不返回任何信息，服务器和客户端的连接断开，客户端自动退出。</strong></font></td>
<td><font size="2"><strong>停止所有客户端。如果有至少一个保存点在等待，执行 SAVE 命令。如果 AOF 选项被打开，更新 AOF 文件。关闭 redis 服务器(server)。</strong></font></td>
</tr>
<tr>
<td><strong>SLAVEOF</strong></td>
<td><font size="2" color="red"><strong>SLAVEOF host port（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>总是返回 OK 。</strong></font></td>
<td><font size="2"><strong>可以将当前服务器转变为指定服务器的从属服务器(slave server)。如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行 SLAVEOF host port 将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。另外，对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。利用『 SLAVEOF NO ONE 不会丢弃同步所得数据集』这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</strong></font></td>
</tr>
<tr>
<td><strong>SLOWLOG</strong></td>
<td><font size="2" color="red"><strong>SLOWLOG subcommand [argument]（&gt;= 2.2.12）</strong></font></td>
<td><font size="2"><strong>取决于不同命令，返回不同的值。</strong></font></td>
<td><font size="2"><strong>用来记录查询执行时间的日志系统。查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</strong></font></td>
</tr>
<tr>
<td><strong>SYNC</strong></td>
<td><font size="2" color="red"><strong>SYNC（&gt;= 1.0.0）</strong></font></td>
<td><font size="2"><strong>不明确。</strong></font></td>
<td><font size="2"><strong>用于同步主从服务器。</strong></font></td>
</tr>
</tbody></table>
<h1 id="3-文档"><a href="#3-文档" class="headerlink" title="3.文档"></a>3.文档</h1><h2 id="3-1-KeySpace-Notification（键空间通知）"><a href="#3-1-KeySpace-Notification（键空间通知）" class="headerlink" title="3.1 KeySpace Notification（键空间通知）"></a>3.1 KeySpace Notification（键空间通知）</h2><h2 id="3-2-Transation（-事务）"><a href="#3-2-Transation（-事务）" class="headerlink" title="3.2 Transation（ 事务）"></a>3.2 Transation（ 事务）</h2><p><code>MULTI</code> 、 <code>EXEC</code>、 <code>DISCARD</code> 和 <code>WATCH</code>是 Redis 事务的基础。</p>
<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p><code>EXEC</code> 命令负责触发并执行事务中的所有命令：</p>
<ul>
<li>如果客户端在使用 <code>MULTI</code>  开启了一个事务之后，却因为断线而没有成功执行 <code>EXEC</code> ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 <code>EXEC</code> ，那么事务中的所有命令都会被执行。</li>
</ul>
</li>
</ul>
<h2 id="3-3-Pub-Sub（发布与订阅）"><a href="#3-3-Pub-Sub（发布与订阅）" class="headerlink" title="3.3 Pub/Sub（发布与订阅）"></a>3.3 Pub/Sub（发布与订阅）</h2><h2 id="3-4-Replication（主从复制）"><a href="#3-4-Replication（主从复制）" class="headerlink" title="3.4  Replication（主从复制）"></a>3.4  Replication（主从复制）</h2><h2 id="3-5-Protocol（通信协议）"><a href="#3-5-Protocol（通信协议）" class="headerlink" title="3.5 Protocol（通信协议）"></a>3.5 Protocol（通信协议）</h2><h2 id="3-6-Persistence（持久化）"><a href="#3-6-Persistence（持久化）" class="headerlink" title="3.6 Persistence（持久化）"></a>3.6 Persistence（持久化）</h2><h2 id="3-7-Sentinel（哨兵）"><a href="#3-7-Sentinel（哨兵）" class="headerlink" title="3.7 Sentinel（哨兵）"></a>3.7 Sentinel（哨兵）</h2><h2 id="3-8-Cluster（集群）"><a href="#3-8-Cluster（集群）" class="headerlink" title="3.8 Cluster（集群）"></a>3.8 Cluster（集群）</h2><h2 id="3-9-集群规范"><a href="#3-9-集群规范" class="headerlink" title="3.9 集群规范"></a>3.9 集群规范</h2><h1 id="4-jedis"><a href="#4-jedis" class="headerlink" title="4.jedis"></a>4.jedis</h1><h2 id="4-1-Jedis简介"><a href="#4-1-Jedis简介" class="headerlink" title="4.1 Jedis简介"></a>4.1 Jedis简介</h2><h2 id="4-2-HelloWordl-Jedis版"><a href="#4-2-HelloWordl-Jedis版" class="headerlink" title="4.2 HelloWordl(Jedis版)"></a>4.2 HelloWordl(Jedis版)</h2><ol>
<li><p>jar包导入</p>
<blockquote>
<p>下载地址：<a href="https://mvnrepository.com/artifact/redis.clients/jedis" target="_blank" rel="noopener">https://mvnrepository.com/artifact/redis.clients/jedis</a> </p>
</blockquote>
</li>
<li><p>基于maven</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt; </span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接redis</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>, <span class="number">6379</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作redis</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"itheima"</span>); jedis.get(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭redis连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>API文档</p>
<p><a href="http://xetorthio.github.io/jedis/" target="_blank" rel="noopener">http://xetorthio.github.io/jedis/</a> </p>
</li>
</ol>
<h2 id="4-3-Jedis读写redis数据"><a href="#4-3-Jedis读写redis数据" class="headerlink" title="4.3 Jedis读写redis数据"></a>4.3 Jedis读写redis数据</h2><h2 id="4-4-Jedis简易工具类开发"><a href="#4-4-Jedis简易工具类开发" class="headerlink" title="4.4 Jedis简易工具类开发"></a>4.4 Jedis简易工具类开发</h2><h2 id="4-5-可视化客户端"><a href="#4-5-可视化客户端" class="headerlink" title="4.5 可视化客户端"></a>4.5 可视化客户端</h2><h1 id="5-删除策略"><a href="#5-删除策略" class="headerlink" title="5. 删除策略"></a>5. 删除策略</h1><p><strong>数据删除策略</strong></p>
<ol>
<li><p>定时删除</p>
<blockquote>
<p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 </p>
<p>优点：</p>
<p>​        节约内存，到时就删除，快速释放掉不必要的内存占用 </p>
<p>缺点：</p>
<p>​        CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 </p>
<p>总结：</p>
<p>​        用处理器性能换取存储空间 （拿时间换空间） </p>
</blockquote>
</li>
<li><p>惰性删除</p>
<blockquote>
<p>数据到达过期时间，不做处理。等下次访问该数据时 </p>
<ul>
<li>如果未过期，返回数据 </li>
<li>发现已过期，删除，返回不存在 </li>
</ul>
<p>优点：</p>
<p>​        节约CPU性能，发现必须删除的时候才删除 </p>
<p>缺点：</p>
<p>​        内存压力很大，出现长期占用内存的数据 </p>
<p>总结：</p>
<p>​        用存储空间换取处理器性能 （拿时间换空间） </p>
</blockquote>
</li>
<li><p>定期删除</p>
<blockquote>
<p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 </p>
<p>特点1：</p>
<p>​        CPU性能占用设置有峰值，检测频度可自定义设置 </p>
<p>特点2：</p>
<p>​        内存压力不是很大，长期占用内存的冷数据会被持续清理 </p>
<p>总结：</p>
<p>​        周期性抽查存储空间 （随机抽查，重点抽查） </p>
</blockquote>
</li>
</ol>
<p><strong>三种策略对比</strong></p>
<table>
<thead>
<tr>
<th>策略</th>
<th>内存</th>
<th>CPU</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>节约内存，无占用</td>
<td>不分时段占用CPU资源，频度高</td>
<td>时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>内存占用严重</td>
<td>延时执行，CPU利用率高</td>
<td>空间换时间</td>
</tr>
<tr>
<td>定期删除</td>
<td>内存定期随机清理</td>
<td>每秒花费固定的COU资源维护内存</td>
<td>随机抽查，重点抽查</td>
</tr>
</tbody></table>
<h1 id="6-redis高可用"><a href="#6-redis高可用" class="headerlink" title="6. redis高可用"></a>6. redis高可用</h1><h2 id="6-1-主从模式"><a href="#6-1-主从模式" class="headerlink" title="6.1 主从模式"></a>6.1 主从模式</h2><h3 id="6-1-1-作用"><a href="#6-1-1-作用" class="headerlink" title="6.1.1 作用"></a>6.1.1 作用</h3><ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数 量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 </li>
</ul>
<h3 id="6-1-2主从复制工作流程"><a href="#6-1-2主从复制工作流程" class="headerlink" title="6.1.2主从复制工作流程"></a>6.1.2主从复制工作流程</h3><ol>
<li><p>建立连接阶段（即准备阶段）</p>
<blockquote>
<p>建立slave到master的连接，使master能够识别slave，并保存slave端口号 </p>
</blockquote>
<ul>
<li>步骤1：设置master的地址和端口，保存master信息</li>
<li>步骤2：建立socket连接 </li>
<li>步骤3：发送ping命令（定时器任务） </li>
<li>步骤4：身份验证 </li>
<li>步骤5：发送slave端口信息</li>
</ul>
<table>
<thead>
<tr>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>①发送指令：slaveof  ip  port</td>
</tr>
<tr>
<td>②接收到指令，响应对方</td>
<td></td>
</tr>
<tr>
<td></td>
<td>③保存master的IP与端口     masterhost     masterport</td>
</tr>
<tr>
<td></td>
<td>④根据保存的信息创建连接master的socket</td>
</tr>
<tr>
<td></td>
<td>⑤周期性发送命令：ping</td>
</tr>
<tr>
<td>⑥响应pong</td>
<td></td>
</tr>
<tr>
<td></td>
<td>⑦发送指令：auth  password</td>
</tr>
<tr>
<td>⑧验证授权</td>
<td></td>
</tr>
<tr>
<td></td>
<td>⑨发送指令：replconf listening-port <port-number></port-number></td>
</tr>
<tr>
<td>⑩保存slave的端口号</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li><p>主从连接（slave连接master）</p>
<ul>
<li><p>方式一：客户端发送命令</p>
<blockquote>
<p><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>
</blockquote>
</li>
<li><p>方式二：启动服务器参数 </p>
<blockquote>
<p><code>redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>
</blockquote>
</li>
<li><p>方式三：服务器配置 </p>
<blockquote>
<p><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>
</blockquote>
</li>
<li><p>slave系统信息 </p>
<ol>
<li>master_link_down_since_seconds </li>
<li>masterhost </li>
<li>masterport </li>
</ol>
</li>
<li><p>master系统信息</p>
<ol>
<li>slave_listening_port(多个) </li>
</ol>
</li>
</ul>
</li>
<li><p>主从断开连接</p>
<ul>
<li><p>客户端发送命令 </p>
<blockquote>
<p> <code>slaveof no one</code></p>
</blockquote>
</li>
<li><p>说明</p>
<blockquote>
<p>slave断开连接后，不会删除已有数据，只是不再接受master发送的数据 </p>
</blockquote>
</li>
</ul>
</li>
<li><p>授权访问</p>
<ul>
<li><p>master客户端发送命令设置密码 </p>
<blockquote>
<p><code>requirepass &lt;password&gt;</code></p>
</blockquote>
</li>
<li><p>master配置文件设置密码 </p>
<blockquote>
<p><code>config set requirepass &lt;password&gt;</code></p>
<p><code>config get requirepass</code></p>
</blockquote>
</li>
<li><p>slave客户端发送命令设置密码 </p>
<blockquote>
<p><code>auth &lt;password&gt;</code></p>
</blockquote>
</li>
<li><p>slave配置文件设置密码 </p>
<blockquote>
<p><code>masterauth &lt;password&gt;</code></p>
</blockquote>
</li>
<li><p>slave启动服务器设置密码 </p>
<blockquote>
<p><code>redis-server –a &lt;password&gt;</code></p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li><p>数据同步阶段</p>
<blockquote>
<p>在slave初次连接master后，复制master中的所有数据到slave</p>
<p>将slave的数据库状态更新成master当前的数据库状态 </p>
</blockquote>
<ul>
<li>步骤1：请求同步数据 </li>
<li>步骤2：创建RDB同步数据 </li>
<li>步骤3：恢复RDB同步数据 </li>
<li>步骤4：请求部分同步数据 </li>
<li>步骤5：恢复部分同步数据</li>
</ul>
<table>
<thead>
<tr>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>①发送指令：psync2</td>
</tr>
<tr>
<td>②执行bgsave</td>
<td></td>
</tr>
<tr>
<td>③第一个slave连接时， 创建命令缓冲区</td>
<td></td>
</tr>
<tr>
<td>④生成RDB文件，通过 socket发送给slave</td>
<td></td>
</tr>
<tr>
<td></td>
<td>⑤接收RDB，清空数据，执行RDB文件恢复过程</td>
</tr>
<tr>
<td></td>
<td>⑥发送命令告知RDB恢复已经完成完成</td>
</tr>
<tr>
<td>⑦发送复制缓冲区信息</td>
<td></td>
</tr>
<tr>
<td></td>
<td>⑧接收信息，执行bgrewriteaof，恢复数据</td>
</tr>
<tr>
<td></td>
<td>⑨发送指令：？？？</td>
</tr>
<tr>
<td>⑩接收到指令，响应对方</td>
<td></td>
</tr>
<tr>
<td>1-5:全量复制</td>
<td>6-8部分复制</td>
</tr>
</tbody></table>
<ol>
<li><p>数据同步阶段master说明 </p>
<ol>
<li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行 </p>
</li>
<li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已 经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。 </p>
<blockquote>
<p> repl-backlog-size 1mb</p>
</blockquote>
</li>
<li><p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区 </p>
</li>
</ol>
</li>
<li><p>数据同步阶段slave说明 </p>
<ol>
<li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务 </p>
<blockquote>
<p>slave-serve-stale-data yes|no </p>
</blockquote>
</li>
<li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送 命令</p>
</li>
<li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果 master带宽不足，因此数据同步需要根据业务需求，适量错峰</p>
</li>
<li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择 </p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>命名传播阶段</p>
<blockquote>
<p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的 状态，同步的动作称为命令传播 </p>
<p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令 </p>
</blockquote>
<ol>
<li><p>命令传播阶段的部分复制 </p>
<ul>
<li>命令传播阶段出现了断网现象 <ul>
<li>网络闪断闪连        忽略 </li>
<li>短时间网络中断    部分复制 </li>
<li>长时间网络中断    全量复制 </li>
</ul>
</li>
<li>部分复制的三个核心要素 <ul>
<li>服务器的运行 id（run id） </li>
<li>主服务器的复制积压缓冲区 </li>
<li>主从服务器的复制偏移量 </li>
</ul>
</li>
</ul>
</li>
<li><p>服务器运行ID（runid） </p>
<ol>
<li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id </li>
<li>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce </li>
<li>作用：运行id被用于在服务器间进行传输，识别身份 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 </li>
<li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发 送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid </li>
</ol>
</li>
<li><p>复制缓冲区 </p>
<ol>
<li>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区<ul>
<li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队 列长度时，最先入队的元素会被弹出，而新元素会被放入队列 </li>
</ul>
</li>
<li>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 </li>
<li>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） </li>
<li>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中 </li>
</ol>
</li>
<li><p>复制缓冲区内部工作原理 </p>
<ol>
<li>组成 <ul>
<li>偏移量 </li>
<li>字节值 </li>
</ul>
</li>
<li>工作原理 <ul>
<li>通过offset区分不同的slave当前数据传播的差异 </li>
<li>master记录已发送的信息对应的offset</li>
<li>slave记录已接收的信息对应的offset </li>
</ul>
</li>
</ol>
</li>
<li><p>主从服务器复制偏移量（offset）</p>
<ol>
<li>概念：一个数字，描述复制缓冲区中的指令字节位置 </li>
<li>分类： <ul>
<li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）  </li>
<li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个） </li>
</ul>
</li>
<li>数据来源： <ul>
<li>master端：发送一次记录一次 </li>
<li>slave端：接收一次记录一次</li>
</ul>
</li>
<li>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用 </li>
</ol>
</li>
<li><p>数据同步+命令传播阶段工作流程 </p>
<table>
<thead>
<tr>
<th>master</th>
<th>slave</th>
</tr>
</thead>
<tbody><tr>
<td>②执行bgsave生成RDB文件，记录当前的复制偏移量offset</td>
<td>①发送指令： psync2  ？-1   psync2  <runid> <offset></offset></runid></td>
</tr>
<tr>
<td>③发送 +FULLRESYNC runid offset   通过socket发送RDB文件给slave<br>期间接收客户端命令，offset发生了变化</td>
<td>④收到 +FULLRESYNC  保存master的runid和offset 清空当前全部数据，通过socket接收RDB文件，恢复RDB数据</td>
</tr>
<tr>
<td>⑥接收命令，判定runid是否匹配，判定offset是否在复制缓冲区中</td>
<td>⑤发送命令：psync2  runid offset</td>
</tr>
<tr>
<td>⑦如果runid或offset有一个不满足，执行全量复制<br>⑦如果runid或offset校验通过，offset与offset相同，忽略<br>⑦如果runid或offset校验通过，offset与offset不相同   发送 +CONTINUE offset   通过socket发送复制缓冲区中offset到offset的数据</td>
<td>⑧收到 +CONTINUE  保存master的offset 接收信息后，执行bgrewriteaof，恢复数据</td>
</tr>
<tr>
<td>1-4全量复制</td>
<td>5-8部分复制</td>
</tr>
</tbody></table>
</li>
<li><p>心跳机制</p>
<ul>
<li>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 </li>
<li>master心跳： <ul>
<li>指令：PING </li>
<li>周期：由repl-ping-slave-period决定，默认10秒 </li>
<li>作用：判断slave是否在线 </li>
<li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常 </li>
</ul>
</li>
<li>slave心跳任务 <ul>
<li>指令：REPLCONF ACK {offset} </li>
<li>周期：1秒 </li>
<li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li>
<li>作用2：判断master是否在线 </li>
</ul>
</li>
</ul>
</li>
<li><p>心跳阶段注意事项 </p>
<ul>
<li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 </p>
<blockquote>
<p>min-slaves-to-write 2<br>min-slaves-max-lag 8 </p>
</blockquote>
<p>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 </p>
</li>
<li><p>slave数量由slave发送REPLCONF ACK命令做确认 </p>
</li>
<li><p>slave延迟由slave发送REPLCONF ACK命令做确认 </p>
</li>
</ul>
</li>
<li><p>主从复制工作流程（完整） </p>
</li>
</ol>
</li>
</ol>
<h3 id="6-1-3-主从复制常见问题"><a href="#6-1-3-主从复制常见问题" class="headerlink" title="6.1.3 主从复制常见问题"></a>6.1.3 主从复制常见问题</h3><ol>
<li><p>频繁的全量复制（1） </p>
<blockquote>
<p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的 全量复制操作 </p>
<p>内部优化调整方案： </p>
<ol>
<li>master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave </li>
<li>在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中 <ul>
<li>repl-id repl-offset   </li>
<li>通过redis-check-rdb命令可以查看该信息 </li>
</ul>
</li>
<li>master重启后加载RDB文件，恢复数据 重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中 <ul>
<li>master_repl_id = repl    master_repl_offset = repl-offset</li>
<li>通过info命令可以查看该信息</li>
</ul>
</li>
</ol>
<p>作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master </p>
</blockquote>
</li>
<li><p>频繁的全量复制（2） </p>
<blockquote>
<ul>
<li>问题现象 <ul>
<li>网络环境不佳，出现网络中断，slave不提供服务</li>
</ul>
</li>
<li>问题原因 <ul>
<li>复制缓冲区过小，断网后slave的offset越界，触发全量复制 </li>
</ul>
</li>
<li>最终结果 <ul>
<li>slave反复进行全量复制 </li>
</ul>
</li>
<li>解决方案 <ul>
<li>修改复制缓冲区大小 </li>
</ul>
</li>
<li>建议设置如下： <ol>
<li>测算从master到slave的重连平均时长second </li>
<li>获取master平均每秒产生写命令数据总量write_size_per_second </li>
<li>最优复制缓冲区空间 = 2 * second * write_size_per_second </li>
</ol>
</li>
</ul>
</blockquote>
</li>
<li><p>频繁的网络中断（1） </p>
<ul>
<li><p>问题现象 </p>
<ul>
<li>master的CPU占用过高 或 slave频繁断开连接 </li>
</ul>
</li>
<li><p>问题原因 </p>
<ul>
<li>slave每1秒发送REPLCONF ACK命令到master </li>
<li>当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能 </li>
<li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应 </li>
</ul>
</li>
<li><p>最终结果 </p>
<ul>
<li>master各种资源（输出缓冲区、带宽、连接等）被严重占用 </li>
</ul>
</li>
<li><p>解决方案 </p>
<ul>
<li><p>通过设置合理的超时时间，确认是否释放slave </p>
<blockquote>
<p>repl-timeout </p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave </code></pre><ol start="4">
<li><p>频繁的网络中断（2） </p>
<ul>
<li><p>问题现象 </p>
<ul>
<li>slave与master连接断开</li>
</ul>
</li>
<li><p>问题原因 </p>
<ul>
<li>master发送ping指令频度较低</li>
<li>master设定超时时间较短 </li>
<li>ping指令在网络中存在丢包 </li>
</ul>
</li>
<li><p>解决方案 </p>
<ul>
<li><p>提高ping指令发送的频度 </p>
<blockquote>
<p> repl-ping-slave-period  </p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时 </code></pre><ol start="5">
<li><p>数据不一致 </p>
<ul>
<li><p>问题现象 </p>
<ul>
<li>多个slave获取相同数据不同步</li>
</ul>
</li>
<li><p>问题原因 </p>
<ul>
<li>网络信息不同步，数据发送有延迟</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li><p>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p>
</li>
<li><p>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问 </p>
<blockquote>
<p> slave-serve-stale-data  yes|no </p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高） </code></pre><h2 id="6-2-哨兵模式"><a href="#6-2-哨兵模式" class="headerlink" title="6.2 哨兵模式"></a>6.2 哨兵模式</h2><h3 id="6-2-1-作用"><a href="#6-2-1-作用" class="headerlink" title="6.2.1 作用"></a>6.2.1 作用</h3><ul>
<li>监控 <ul>
<li>不断的检查master和slave是否正常运行。 </li>
<li>master存活检测、master与slave运行情况检测 </li>
</ul>
</li>
<li>通知（提醒） <ul>
<li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。 </li>
</ul>
</li>
<li>自动故障转移 <ul>
<li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服 务器地址 </li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>​        哨兵也是一台redis服务器，只是不提供数据服务 </p>
<p>​        通常哨兵配置数量为单数 </p>
<h3 id="6-2-2-启用哨兵模式"><a href="#6-2-2-启用哨兵模式" class="headerlink" title="6.2.2 启用哨兵模式"></a>6.2.2 启用哨兵模式</h3><ol>
<li><p>配置一拖二的主从结构 </p>
</li>
<li><p>配置三个哨兵（配置相同，端口不同） </p>
<blockquote>
<p>参看sentinel.conf </p>
</blockquote>
</li>
<li><p>启动哨兵 </p>
<blockquote>
<p>redis-sentinel sentinel端口号 .conf </p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>配置项</th>
<th>范例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sentinel auth-pass  &lt;服务器名称&gt; <password></password></td>
<td>&lt;服务器名称&gt; <password> <br>sentinel auth-pass mymaster joey</password></td>
<td>设置哨兵监听的主服务器信息，最后的参数决定了最终参与选举的服务器（-1）</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds &lt;自定义服 务名称&gt;&lt;主机地址&gt;&lt;端口&gt;&lt;主从服务器总量&gt;</td>
<td>sentinel monitor mymaster 192.168.194.131 6381 1</td>
<td>指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒（30000），也是主从切换条件之一</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds  &lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td>sentinel down-aftermilliseconds mymaster 3000</td>
<td>指定同时进行主从的slave数量，数值越大，要求的网络资源越高，要求月洗，同步时间越长</td>
</tr>
<tr>
<td>sentinel parallel-syncs   &lt;服务名称&gt;&lt;服务器数（整数）&gt;</td>
<td>sentinel parallel-syncs mymaster</td>
<td>指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认3分钟</td>
</tr>
<tr>
<td>sentinel failover-timeout   &lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td>
<td>sentinel failover-timeout mymaster 9000</td>
<td>服务器无法正常联通时，设定的执行脚本，通常调试使用</td>
</tr>
<tr>
<td>sentinel notification-script   &lt;服务名称&gt;&lt;脚本路径&gt;</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="6-2-3-哨兵工作原理"><a href="#6-2-3-哨兵工作原理" class="headerlink" title="6.2.3 哨兵工作原理"></a>6.2.3 哨兵工作原理</h3><h2 id="6-3-redis集群"><a href="#6-3-redis集群" class="headerlink" title="6.3 redis集群"></a>6.3 redis集群</h2><h1 id="7-企业级解决方案"><a href="#7-企业级解决方案" class="headerlink" title="7.企业级解决方案"></a>7.企业级解决方案</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2020/04/01/中间件-Redis/" data-id="ckmh9ucn5009i3oumhxushh5w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库-MySQL-MySQL基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/10/数据库-MySQL-MySQL基础/" class="article-date">
  <time datetime="2020-02-09T16:00:00.000Z" itemprop="datePublished">2020-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>►<a class="article-category-link" href="/categories/数据库/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/10/数据库-MySQL-MySQL基础/">MySQL基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-MySQL服务"><a href="#1-MySQL服务" class="headerlink" title="1.MySQL服务"></a>1.MySQL服务</h1><h2 id="1-1-MySQL服务的启动和停止"><a href="#1-1-MySQL服务的启动和停止" class="headerlink" title="1.1 MySQL服务的启动和停止"></a>1.1 MySQL服务的启动和停止</h2><p>方式一：计算机——右击管理——服务</p>
<p>方式二：通过管理员身份运行</p>
<ul>
<li><code>net start 服务名（启动服务）</code></li>
<li><code>net stop 服务名（停止服务）</code></li>
</ul>
<h2 id="1-2-MySQL服务的登录和退出"><a href="#1-2-MySQL服务的登录和退出" class="headerlink" title="1.2 MySQL服务的登录和退出"></a>1.2 MySQL服务的登录和退出</h2><p>登录：<strong>mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码</strong></p>
<p>退出：<strong>exit或ctrl+C</strong></p>
<h1 id="2-DQL-Data-Query-Language-数据查询语言"><a href="#2-DQL-Data-Query-Language-数据查询语言" class="headerlink" title="2.DQL(Data Query Language)数据查询语言"></a>2.DQL(Data Query Language)数据查询语言</h1><h2 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ol>
<li>通过select查询完的结果 ，是一个虚拟的表格，不是真实存在</li>
<li>要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</li>
</ol>
<h2 id="2-2-条件查询"><a href="#2-2-条件查询" class="headerlink" title="2.2 条件查询"></a>2.2 条件查询</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 WHERE 筛选条件;</span><br></pre></td></tr></table></figure>

<p><strong>分类：</strong></p>
<ol>
<li><p>条件表达式<br>示例：salary&gt;10000<br>条件运算符：&gt;、&lt; 、&gt;=、 &lt;=、 = 、!=、 &lt;&gt;</p>
</li>
<li><p>逻辑表达式</p>
<p>示例：salary&gt;10000 &amp;&amp; salary&lt;20000</p>
<p>逻辑运算符：</p>
<ul>
<li>and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</li>
<li>or(||)：两个条件只要有一个成立，结果为true，否则为false</li>
<li>not(!)：如果条件成立，则not后为false，否则为true</li>
</ul>
</li>
<li><p>模糊查询<br>示例：last_name like ‘a%’</p>
</li>
</ol>
<h2 id="2-3-排序查询"><a href="#2-3-排序查询" class="headerlink" title="2.3 排序查询"></a>2.3 排序查询</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 ORDER BY 排序列表 【asc||desc】;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ol>
<li><p>asc ：升序，如果不写默认升序</p>
<p>desc：降序</p>
</li>
<li><p>排序列表 支持 单个字段、多个字段、函数、表达式、别名</p>
</li>
<li><p>order by的位置一般放在查询语句的最后（除limit语句之外）</p>
</li>
</ol>
<h2 id="2-4-常见函数"><a href="#2-4-常见函数" class="headerlink" title="2.4 常见函数"></a>2.4 常见函数</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(实参列表);</span><br></pre></td></tr></table></figure>

<p><strong>分类：</strong></p>
<ol>
<li><p>单行函数</p>
<ol>
<li><p>字符函数</p>
<ul>
<li><p>concat：连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(&apos;Hello&apos;,&apos;_&apos;,&apos;World&apos;);</span><br><span class="line">#结果：Hello_World</span><br></pre></td></tr></table></figure>
</li>
<li><p>substr：截取子串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#注意：索引从1开始</span><br><span class="line">#截取从指定索引处后面所有字符</span><br><span class="line">SELECT SUBSTR(&apos;Hello World&apos;,7);</span><br><span class="line">#结果：World</span><br><span class="line">#截取从指定索引处指定字符长度的字符</span><br><span class="line">SELECT SUBSTR(&apos;Hello World&apos;,1,3);</span><br><span class="line">#结果：Hel</span><br></pre></td></tr></table></figure>
</li>
<li><p>upper：变大写</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT UPPER(&apos;john&apos;);</span><br><span class="line">#结果：JOHN</span><br></pre></td></tr></table></figure>
</li>
<li><p>lower：变小写</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   SELECT LOWER(&apos;joHn&apos;);</span><br><span class="line">#结果：john</span><br></pre></td></tr></table></figure>
</li>
<li><p>replace：替换</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT REPLACE(&apos;Hello World&apos;,&apos;l&apos;,&apos;i&apos;);</span><br><span class="line">#结果：Heiio Worid</span><br></pre></td></tr></table></figure>
</li>
<li><p>length：获取字节长度</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(&apos;john&apos;);</span><br><span class="line">#结果：4</span><br></pre></td></tr></table></figure>
</li>
<li><p>trim：去前后空格</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LENGTH(TRIM(&apos;    Hello    &apos;));</span><br><span class="line">#结果：5</span><br></pre></td></tr></table></figure>
</li>
<li><p>lpad：左填充</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRIM(&apos;l&apos; FROM &apos;llllllllHellolllll&apos;);</span><br><span class="line">#结果：Hello</span><br></pre></td></tr></table></figure>
</li>
<li><p>rpad：右填充</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT LPAD(&apos;john&apos;,6,&apos;*&apos;);</span><br><span class="line">#结果：**john</span><br></pre></td></tr></table></figure>
</li>
<li><p>instr：获取子串第一次出现的索引</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT INSTR(&apos;Hello World&apos;,&apos;o&apos;);</span><br><span class="line">#结果：5</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数学函数</p>
<ul>
<li><p>ceil：向上取整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CEIL(-1.02);</span><br><span class="line">#结果：-1</span><br></pre></td></tr></table></figure>
</li>
<li><p>round：四舍五入</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ROUND(-1.55);</span><br><span class="line">#结果：-2</span><br><span class="line">SELECT ROUND(1.567,2);</span><br><span class="line">#结果：1.57</span><br></pre></td></tr></table></figure>
</li>
<li><p>mod：取模</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MOD(10,-3);</span><br><span class="line">#结果：1</span><br><span class="line">SELECT 10%3;</span><br><span class="line">#结果：1</span><br></pre></td></tr></table></figure>
</li>
<li><p>floor：向下取整</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT FLOOR(-9.99);</span><br><span class="line">#结果：-10</span><br></pre></td></tr></table></figure>
</li>
<li><p>truncate：截断</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TRUNCATE(1.69999,1);</span><br><span class="line">#结果：1.6</span><br></pre></td></tr></table></figure>
</li>
<li><p>rand：获取随机数，返回0-1之间的小数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT RAND();</span><br><span class="line">#结果：0.2870596892079894</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>日期函数</p>
<ul>
<li><p>now：返回当前日期+时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW();</span><br><span class="line">#结果：2020-02-10 16:05:07</span><br></pre></td></tr></table></figure>
</li>
<li><p>curdate：返回当前日期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURDATE();</span><br><span class="line">#结果：2020-02-10</span><br></pre></td></tr></table></figure>
</li>
<li><p>curtime：返回当前时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CURTIME();</span><br><span class="line">#结果：16:05:07</span><br></pre></td></tr></table></figure>
</li>
<li><p>year：返回年</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT YEAR(NOW()) 年;</span><br><span class="line">#结果：2020</span><br><span class="line">SELECT YEAR(&apos;1998-1-1&apos;) 年;</span><br><span class="line">#结果：1998</span><br></pre></td></tr></table></figure>
</li>
<li><p>month：返回月</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MONTH(NOW()) 月;</span><br><span class="line">#结果：2</span><br></pre></td></tr></table></figure>
</li>
<li><p>monthname：以英文形式返回月</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MONTHNAME(NOW()) 月;</span><br><span class="line">#结果：February</span><br></pre></td></tr></table></figure>
</li>
<li><p>day：返回日</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DAY(NOW()) 日;</span><br><span class="line">#结果：10</span><br></pre></td></tr></table></figure>
</li>
<li><p>hour：小时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT HOUR(NOW()) 小时;</span><br><span class="line">#结果：16</span><br></pre></td></tr></table></figure>
</li>
<li><p>minute：分钟</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MINUTE(NOW()) 分钟;</span><br><span class="line">#结果：6</span><br></pre></td></tr></table></figure>
</li>
<li><p>second：秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SECOND(NOW()) 秒;</span><br><span class="line">#结果：50</span><br></pre></td></tr></table></figure>
</li>
<li><p>date_format：将日期转换成字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATE_FORMAT(NOW(),&apos;%y年%m月%d日&apos;);</span><br><span class="line">#结果：20年02月10日</span><br></pre></td></tr></table></figure>
</li>
<li><p>str_to_date：将字符转换成日期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&apos;1998-3-2&apos;,&apos;%Y-%c-%d&apos;);</span><br><span class="line">#结果：1998-03-02</span><br></pre></td></tr></table></figure>
</li>
<li><p>datediff：返回两个日期相差的天数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATEDIFF(&apos;2020-12-30&apos;,&apos;2020-12-29&apos;);</span><br><span class="line">#结果：1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>流程控制函数</p>
<ul>
<li><p><strong>if</strong>(条件表达式，表达式1，表达式2)：</p>
<p> 如果条件表达式成立，返回表达式1，否则返回表达式2</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT IF(10&lt;5,&apos;大&apos;,&apos;小&apos;);</span><br><span class="line">#结果：小</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>case情况1</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 变量或表达式或字段</span><br><span class="line">when 常量1 then 值1</span><br><span class="line">when 常量2 then 值2</span><br><span class="line">...</span><br><span class="line">else 值n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#示例</span><br><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END AS 新工资</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>case情况2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case </span><br><span class="line">when 条件1 then 值1</span><br><span class="line">when 条件2 then 值2</span><br><span class="line">...</span><br><span class="line">else 值n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#示例</span><br><span class="line">SELECT salary,</span><br><span class="line">CASE </span><br><span class="line">	WHEN salary&gt;20000 THEN &apos;A&apos;</span><br><span class="line">    WHEN salary&gt;15000 THEN &apos;B&apos;</span><br><span class="line">	WHEN salary&gt;10000 THEN &apos;C&apos;</span><br><span class="line">    ELSE &apos;D&apos;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>其他函数</p>
<ul>
<li><p>version：当前数据库服务器的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br><span class="line">#结果：5.7.18-log</span><br></pre></td></tr></table></figure>
</li>
<li><p>database：当前打开的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br><span class="line">#结果：joeychat</span><br></pre></td></tr></table></figure>
</li>
<li><p>user：当前用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT USER();</span><br><span class="line">#结果：root@localhost</span><br></pre></td></tr></table></figure>
</li>
<li><p>password(‘字符’)：返回该字符的密码形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT PASSWORD(&apos;Hello&apos;);</span><br><span class="line">#结果：*FCA02337EEB51C3EE398B473FD9A9AFD093F9E64</span><br></pre></td></tr></table></figure>
</li>
<li><p>md5(‘字符’)：返回该字符的md5加密形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MD5(&apos;Hello&apos;);</span><br><span class="line">#结果：8b1a9953c4611296a827abf8c47804d7</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><p>分组函数</p>
<ol>
<li><p>函数</p>
<ul>
<li><p>sum：求和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(salary) FROM employees;</span><br></pre></td></tr></table></figure>
</li>
<li><p>max：最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary) FROM employees;</span><br></pre></td></tr></table></figure>
</li>
<li><p>min：最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(salary) FROM employees;</span><br></pre></td></tr></table></figure>
</li>
<li><p>avg：平均值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary) FROM employees;</span><br></pre></td></tr></table></figure>
</li>
<li><p>count：计数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(salary) FROM employees;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>特点</p>
<ol>
<li>以上五个分组函数都忽略<code>null</code>值，除了count(*)</li>
<li>sum和avg一般用于处理数值型，max、min、count可以处理任何数据类型</li>
<li>可以搭配distinct使用，用于统计去重后的结果</li>
<li>count的参数可以支持：字段、*、常量值，一般放1</li>
<li>效率：<ul>
<li>MYISAM存储引擎下 ，COUNT(*)的效率高</li>
<li>INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="2-5-分组查询"><a href="#2-5-分组查询" class="headerlink" title="2.5 分组查询"></a>2.5 分组查询</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表 FROM 表名 GROUP BY 分组的字段 HAVING 分组后的筛选 ORDER BY 排序列表;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ol>
<li><p>可以按单个字段分组</p>
</li>
<li><p>和分组函数一同查询的字段最好是分组后的字段</p>
</li>
<li><table>
<thead>
<tr>
<th>分组筛选</th>
<th>针对的表</th>
<th>位置</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>分组前筛选</td>
<td>原始表</td>
<td>group by的前面</td>
<td>where</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>group by的后面</td>
<td>having</td>
</tr>
</tbody></table>
</li>
<li><p>可以按多个字段分组，字段之间用逗号隔开</p>
</li>
<li><p>可以支持排序</p>
</li>
<li><p>having后可以支持别名</p>
</li>
</ol>
<h2 id="2-6-连接查询"><a href="#2-6-连接查询" class="headerlink" title="2.6 连接查询"></a>2.6 连接查询</h2><p><strong>sql99语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段，...</span><br><span class="line">FROM 表1</span><br><span class="line">INNER|LEFT OUTER|RIGHT OUTER|CROSS JOIN 表2 ON 连接条件</span><br><span class="line">INNER|LEFT OUTER|RIGHT OUTER|CROSS JOIN 表3 ON 连接条件</span><br><span class="line">WHERE 筛选条件</span><br><span class="line">GROUP BY 分组字段</span><br><span class="line">HAVING 分组后的筛选条件</span><br><span class="line">ORDER BY 排序的字段或表达式</span><br></pre></td></tr></table></figure>

<h2 id="2-7-子查询"><a href="#2-7-子查询" class="headerlink" title="2.7 子查询"></a>2.7 子查询</h2><p><strong>含义：</strong></p>
<p>​        一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询。<br>​        在外面的查询语句，称为主查询或外查询。</p>
<p><strong>特点：</strong></p>
<ol>
<li><p>子查询都放在小括号内</p>
</li>
<li><p>子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧</p>
</li>
<li><p>子查询优先于主查询执行，主查询使用了子查询的执行结果</p>
</li>
<li><p>子查询根据查询结果的行数不同分为以下两类：</p>
<ul>
<li><p>单行子查询</p>
<p>结果集只有一行，一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= </p>
<p>非法使用子查询的情况：</p>
<ul>
<li>子查询的结果为一组值</li>
<li>子查询的结果为空</li>
</ul>
</li>
<li><p>多行子查询</p>
<p>结果集有多行，一般搭配多行操作符使用：any、all、in、not in</p>
<p>in： 属于子查询结果中的任意一个就行</p>
<p>any和all往往可以用其他查询代替</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-8-分页查询"><a href="#2-8-分页查询" class="headerlink" title="2.8 分页查询"></a>2.8 分页查询</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">FROM 表</span><br><span class="line">LIMIT offset,size;</span><br><span class="line">#offset代表的是起始的条目索引，默认从0开始,可省略</span><br><span class="line">#size代表的是显示的条目数</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ol>
<li><p>起始条目索引从0开始</p>
</li>
<li><p>limit子句放在查询语句的最后</p>
</li>
<li><p>公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage，</p>
<p>说明：</p>
<p>​        sizePerPage：每页显示条目数</p>
<p>​        page：要显示的页数 </p>
</li>
</ol>
<h2 id="2-9-联合查询"><a href="#2-9-联合查询" class="headerlink" title="2.9 联合查询"></a>2.9 联合查询</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件 UNION all</span><br><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件 UNION all</span><br><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件 UNION all</span><br><span class="line">.....</span><br><span class="line">SELECT 字段|常量|表达式|函数 FROM 表 WHERE 条件</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ol>
<li>多条查询语句的查询的列数必须是一致的</li>
<li>多条查询语句的查询的列的类型几乎相同</li>
<li><strong>union代表去重，union all代表不去重</strong></li>
</ol>
<h1 id="3-DML-Data-Manipulate-Language-数据操作语言"><a href="#3-DML-Data-Manipulate-Language-数据操作语言" class="headerlink" title="3. DML(Data Manipulate Language)数据操作语言"></a>3. DML(Data Manipulate Language)数据操作语言</h1><h2 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一</span><br><span class="line">INSERT INTO 表名(字段名，...)VALUES(值1，...);</span><br><span class="line">#方式二</span><br><span class="line">INSERT INTO 表名 SET 字段=值,字段=值,...;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ol>
<li>字段类型和值类型一致或兼容，而且一一对应</li>
<li>可以为空的字段，可以不用插入值，或用null填充</li>
<li>不可以为空的字段，必须插入值</li>
<li>字段个数和值的个数必须一致</li>
<li>字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</li>
</ol>
<h2 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#单表更新</span><br><span class="line">UPDATE 表名 SET 字段=值,字段=值 WHERE 筛选条件;</span><br><span class="line">#多表更新</span><br><span class="line">UPDATE 表1 别名 </span><br><span class="line">LEFT|RIGHT|INNER JOIN 表2 别名 </span><br><span class="line">ON 连接条件  </span><br><span class="line">SET 字段=值,字段=值 </span><br><span class="line">WHERE 筛选条件;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用DELETE</span><br><span class="line"> #一、删除单表的记录</span><br><span class="line"> DELETE FROM 表名 WHERE 筛选条件;</span><br><span class="line"> #二、级联删除</span><br><span class="line"> DELETE 别名1,别名2 FROM 表1 别名 </span><br><span class="line"> LEFT|RIGHT|INNER JOIN 表2 别名 </span><br><span class="line"> ON 连接条件</span><br><span class="line"> WHERE 筛选条件;</span><br><span class="line">#使用TRUNCATE</span><br><span class="line">	TRUNCATE TABLE 表名;</span><br><span class="line">#区别：</span><br><span class="line">#	1.truncate删除后，如果再插入，标识列从1开</span><br><span class="line">#	  delete删除后，如果再插入，标识列从断点开始</span><br><span class="line">#	2.delete可以添加筛选条件</span><br><span class="line">#     truncate不可以添加筛选条件</span><br><span class="line">#	3.truncate效率较高</span><br><span class="line">#	4.truncate没有返回值</span><br><span class="line">#	  delete可以返回受影响的行数</span><br><span class="line">#	5.truncate不可以回滚</span><br><span class="line">#	  delete可以回滚</span><br></pre></td></tr></table></figure>

<h1 id="4-DDL-Data-Define-Language-数据定义语言"><a href="#4-DDL-Data-Define-Language-数据定义语言" class="headerlink" title="4.DDL(Data Define Language)数据定义语言"></a>4.DDL(Data Define Language)数据定义语言</h1><h2 id="4-1-库的管理"><a href="#4-1-库的管理" class="headerlink" title="4.1 库的管理"></a>4.1 库的管理</h2><ol>
<li><p>创建库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 【IF NOT EXISTS】 库名【 CHARACTER SET 字符集名】</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>修改库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 库名 CHARACTER SET 字符集名;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>删除库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 【IF EXISTS】 库名;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-2-表的管理"><a href="#4-2-表的管理" class="headerlink" title="4.2 表的管理"></a>4.2 表的管理</h2><ol>
<li><p>创建表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">	stuId INT,</span><br><span class="line">	stuName VARCHAR(20),</span><br><span class="line">	gender CHAR,</span><br><span class="line">	bornDate DATETIME</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表</p>
<p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>添加字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD COLUMN 列名 类型 【First|After 字段名】;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改字段名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改字段的类型或约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 列名 新类型 【新约束】;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP COLUMN 列名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME 【to】 新表名;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>删除表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] studentinfo;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制表</p>
<ol>
<li><p>复制表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 LIKE 旧表;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制表结构+数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名</span><br><span class="line">SELECT 查询列表 FROM 旧表 【WHERE筛选】;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h2><ol>
<li><p>整型</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">范围（有符号）</th>
<th align="left">范围（无符号）</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td align="left">1 byte</td>
<td align="left">(-128，127)</td>
<td align="left">(0，255)</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">2 bytes</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">(0，65 535)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">3 bytes</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">(0，16 777 215)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">INT或INTEGER</td>
<td align="left">4 bytes</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">(0，4 294 967 295)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">8 bytes</td>
<td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
<td align="left">极大整数值</td>
</tr>
<tr>
<td align="left">FLOAT</td>
<td align="left">4 bytes</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td align="left">单精度 浮点数值</td>
</tr>
<tr>
<td align="left">DOUBLE</td>
<td align="left">8 bytes</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">双精度 浮点数值</td>
</tr>
<tr>
<td align="left">DECIMAL</td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td align="left">依赖于M和D的值</td>
<td align="left">依赖于M和D的值</td>
<td align="left">小数值</td>
</tr>
</tbody></table>
</li>
<li><p>浮点型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>DECIMAL(M,D)</th>
<th>FLOAT</th>
<th>DOUBLE</th>
</tr>
</thead>
<tbody><tr>
<td>长度</td>
<td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>字符型</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR</td>
<td align="left">0-255 bytes</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left">VARCHAR</td>
<td align="left">0-65535 bytes</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">TINYBLOB</td>
<td align="left">0-255 bytes</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left">TINYTEXT</td>
<td align="left">0-255 bytes</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">0-65 535 bytes</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left">TEXT</td>
<td align="left">0-65 535 bytes</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMBLOB</td>
<td align="left">0-16 777 215 bytes</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMTEXT</td>
<td align="left">0-16 777 215 bytes</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left">LONGBLOB</td>
<td align="left">0-4 294 967 295 bytes</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left">LONGTEXT</td>
<td align="left">0-4 294 967 295 bytes</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
</li>
<li><p>日期型</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小 ( bytes)</th>
<th align="left">范围</th>
<th align="left">格式</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DATE</td>
<td align="left">3</td>
<td align="left">1000-01-01/9999-12-31</td>
<td align="left">YYYY-MM-DD</td>
<td align="left">日期值</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">3</td>
<td align="left">‘-838:59:59’/‘838:59:59’</td>
<td align="left">HH:MM:SS</td>
<td align="left">时间值或持续时间</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1</td>
<td align="left">1901/2155</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
</tr>
<tr>
<td align="left">DATETIME</td>
<td align="left">8</td>
<td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td align="left">YYYY-MM-DD HH:MM:SS</td>
<td align="left">混合日期和时间值</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">4</td>
<td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td align="left">YYYYMMDD HHMMSS</td>
<td align="left">混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="4-4-常见的约束"><a href="#4-4-常见的约束" class="headerlink" title="4.4 常见的约束"></a>4.4 常见的约束</h2><ol>
<li><p>常见约束</p>
<ol>
<li>NOT NULL：非空，该字段的值必填</li>
<li>UNIQUE：唯一，该字段的值不可重复</li>
<li>DEFAULT：默认，该字段的值不用手动插入有默认值</li>
<li>CHECK：检查，MYSQL不支持</li>
<li>PRIMARY KEY：主键，该字段的值不可重复并且非空  NIQUE+NOT NULL</li>
<li>FOREIGN KEY：外键，该字段的值引用了另外的表的字段</li>
</ol>
<p><strong>其中，主键和唯一</strong></p>
<ol>
<li>区别：<ul>
<li>一个表至多有一个主键，但可以有多个唯一</li>
<li>主键不允许为空，唯一可以为空</li>
</ul>
</li>
<li>相同点<ul>
<li>都具有唯一性</li>
<li>都支持组合键，但不推荐</li>
</ul>
</li>
</ol>
<p><strong>外键</strong></p>
<ol>
<li><p>用于限制两个表的关系，从表的字段值引用了主表的某字段值</p>
</li>
<li><p>外键列和主表的被引用列要求类型一致，意义一样，名称无要求</p>
</li>
<li><p>主表的被引用列要求是一个KEY（一般就是主键）</p>
</li>
<li><p>插入数据，先插入主表</p>
</li>
<li><p>当设置有外键的时候，可以通过一下两种方式实现删除主表的记录：</p>
<ul>
<li><p><strong>方式一：级联删除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table stuinfo add CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) on DELETE CASCADE;</span><br></pre></td></tr></table></figure>

<p>说明：这样删除主表中的数据的时候，引用他外键的表的数据也都会进行删除，当然这种做法有点残忍，但是在实际的业务中，进行数据维护的时候，确实也有这么干的</p>
</li>
<li><p><strong>方式二：级联置空</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table stuinfo add CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) on DELETE set null;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>这样删除主表中的数据的时候，引用他外键的表的数据不会进行删除，对应的引用外键的那一列会置为空，这种方法比较好。<br><strong>综上所述，要结合具体的业务场景进行选择。</strong></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>创建表时添加约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段名 字段类型 NOT NULL,#非空</span><br><span class="line">	字段名 字段类型 PRIMARY KEY,#主键</span><br><span class="line">	字段名 字段类型 UNIQUE,#唯一</span><br><span class="line">	字段名 字段类型 DEFAULT 值,#默认</span><br><span class="line">	CONSTRAINT 约束名 FOREIGN KEY(字段名) REFERENCES 主表（被引用列）</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p>
<p><strong>对比：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>支持类型</th>
<th>可以起约束名</th>
</tr>
</thead>
<tbody><tr>
<td>列级约束</td>
<td>除了外键</td>
<td>不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td>除了非空和默认</td>
<td>可以，但对主键无效</td>
</tr>
</tbody></table>
</li>
<li><p>修改表时添加或删除约束</p>
<ol>
<li><p>非空</p>
<ol>
<li><p>添加非空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 NOT NULL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除非空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 ;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>默认</p>
<ol>
<li><p>添加默认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 DEFAULT 值;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除默认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY COLUMN 字段名 字段类型 ;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>主键</p>
<ol>
<li><p>添加主键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD【 CONSTRAINT 约束名】 PRIMARY KEY(字段名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>唯一</p>
<ol>
<li><p>添加唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD【 CONSTRAINT 约束名】 UNIQUE(字段名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP INDEX 索引名;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>外键</p>
<ol>
<li><p>添加外键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD【 CONSTRAINT 约束名】 FOREIGN KEY(字段名) REFERENCES 主表（被引用列）;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 约束名;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>自增长列</p>
<ol>
<li><p>特点：</p>
<ol>
<li><p>不用手动插入值，可以自动提供序列值，默认从1开始，步长为1</p>
<p>AUTO_INCREMENT_INCREMENT</p>
<p>如果要更改起始值：手动插入值</p>
<p>如果要更改步长：更改系统变量 SET AUTO_INCREMENT_INCREMENT=值;</p>
</li>
<li><p>一个表至多有一个自增长列</p>
</li>
<li><p>自增长列只能支持数值型</p>
</li>
<li><p>自增长列必须为一个KEY</p>
</li>
</ol>
</li>
<li><p>创建表时设置自增长列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表(</span><br><span class="line">	字段名 字段类型 约束 AUTO_INCREMENT</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表时设置自增长列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表 MODIFY COLUMN 字段名 字段类型 约束 AUTO_INCREMENT</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除自增长列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表 MODIFY COLUMN 字段名 字段类型 约束</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="5-TCL-Transaction-Control-Language-事务控制语言"><a href="#5-TCL-Transaction-Control-Language-事务控制语言" class="headerlink" title="5.TCL(Transaction Control Language)事务控制语言"></a>5.TCL(Transaction Control Language)事务控制语言</h1><h2 id="5-1含义"><a href="#5-1含义" class="headerlink" title="5.1含义"></a>5.1含义</h2><p><strong>事务：</strong></p>
<p>​        一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行</p>
<h2 id="5-2-特点（ACID）"><a href="#5-2-特点（ACID）" class="headerlink" title="5.2 特点（ACID）"></a>5.2 特点（ACID）</h2><ul>
<li>A 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行</li>
<li>C 一致性：一个事务可以使数据从一个一致状态切换到另外一个一致的状态</li>
<li>I 隔离性：一个事务不受其他事务的干扰，多个事务互相隔离的</li>
<li>D 持久性：一个事务一旦提交了，则永久的持久化到本地</li>
</ul>
<h2 id="5-3-使用步骤"><a href="#5-3-使用步骤" class="headerlink" title="5.3 使用步骤"></a>5.3 使用步骤</h2><p><strong>了解：</strong><br>隐式（自动）事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete<br>显式事务：具有明显的开启和结束</p>
<p><strong>使用显式事务：</strong></p>
<p>①开启事务<br>set autocommit=0;<br>start transaction;#可以省略</p>
<p>②编写一组逻辑sql语句<br>注意：sql语句支持的是insert、update、delete</p>
<p>设置回滚点：<br>savepoint 回滚点名;</p>
<p>③结束事务<br>提交：commit;<br>回滚：rollback;<br>回滚到指定的地方：rollback to 回滚点名;</p>
<h2 id="5-4-并发事务"><a href="#5-4-并发事务" class="headerlink" title="5.4 并发事务"></a>5.4 并发事务</h2><ol>
<li><p>事务的并发问题是如何发生的？<br>多个事务同时操作 同一个数据库的相同数据时</p>
</li>
<li><p>并发问题都有哪些？<br>脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据<br>不可重复读：一个事务多次读取，结果不一样<br>幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的数据</p>
</li>
<li><p>如何解决并发问题<br>通过设置隔离级别来解决并发问题</p>
</li>
<li><p>隔离级别</p>
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED:读未提交</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>READ COMMITTED：读已提交</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>REPEATABLE READ：可重复读</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>SERIALIZABLE：串行化</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
</li>
<li><p>设置和查看隔离级别</p>
<ol>
<li><p>设置隔离级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set session|global  transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看隔离级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h1><h2 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h2><ol>
<li><p>含义：</p>
<p>​        mysql5.1版本出现的新特性，本身是一个虚拟表，它的数据来自于表，通过执行时动态生成。</p>
</li>
<li><p>好处：</p>
<ol>
<li>简化sql语句</li>
<li>提高了sql的重用性</li>
<li>保护基表的数据，提高了安全性</li>
</ol>
</li>
<li><p>语法</p>
<ol>
<li><p>创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<ol>
<li><p>方式一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view 视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view 视图1，视图2,...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc 视图名;</span><br><span class="line">show create view 视图名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.插入</span><br><span class="line">insert</span><br><span class="line">2.修改</span><br><span class="line">update</span><br><span class="line">3.删除</span><br><span class="line">delete</span><br><span class="line">4.查看</span><br><span class="line">select</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<p>视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新<br>①包含分组函数、group by、distinct、having、union、<br>②join<br>③常量视图<br>④where后的子查询用到了from中的表<br>⑤用到了不可更新的视图</p>
</li>
<li><p>视图和表的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>关键字</th>
<th>是否占用物理空间</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>view</td>
<td>占用较小，只保存sql逻辑</td>
<td>一般用于查询</td>
</tr>
<tr>
<td>表</td>
<td>table</td>
<td>保存实际的数据</td>
<td>增删改查</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="6-2-变量"><a href="#6-2-变量" class="headerlink" title="6.2 变量"></a>6.2 变量</h2><ol>
<li><p>系统变量</p>
<p><strong>说明：</strong>变量由系统提供的，不用自定义。</p>
<ol>
<li><p>全局变量</p>
<p>服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效</p>
</li>
<li><p>会话变量</p>
<p>服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p>
</li>
</ol>
<p><strong>语法：</strong></p>
<ul>
<li><p>查看系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有显式声明global还是session，则默认是session</span><br><span class="line">show 【global|session 】variables like &apos;&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看指定的系统变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有显式声明global还是session，则默认是session</span><br><span class="line">select @@【global|session】.变量名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为系统变量赋值</p>
<ul>
<li><p>方式一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#如果没有显式声明global还是session，则默认是session</span><br><span class="line">set 【global|session 】 变量名=值;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @@global.变量名=值;</span><br><span class="line">set @@变量名=值；</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义变量</p>
<ol>
<li><p>用户变量</p>
<p>作用域：针对于当前连接（会话）生效</p>
<p>位置：begin end里面，也可以放在外面</p>
<p>使用：</p>
<ol>
<li><p>声明并赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @变量名=值;或</span><br><span class="line">set @变量名:=值;或</span><br><span class="line">select @变量名:=值;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set @变量名=值;或</span><br><span class="line">set @变量名:=值;或</span><br><span class="line">select @变量名:=值;</span><br><span class="line">select xx into @变量名 from 表;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @变量名;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>局部变量</p>
<p>作用域：仅仅在定义它的begin end中有效</p>
<p>位置：只能放在begin end中，而且只能放在第一句</p>
<p>使用：</p>
<ol>
<li><p>声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare 变量名 类型 【default 值】;</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值或更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set 变量名=值;或</span><br><span class="line">set 变量名:=值;或</span><br><span class="line">select @变量名:=值;</span><br><span class="line">select xx into 变量名 from 表;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 变量名;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="6-3-存储过程"><a href="#6-3-存储过程" class="headerlink" title="6.3 存储过程"></a>6.3 存储过程</h2><ol>
<li><p>创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程名(参数模式 参数名 参数类型)</span><br><span class="line">begin</span><br><span class="line">		存储过程体</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p><strong>1.参数模式：in、out、inout，其中in可以省略</strong></p>
<p><strong>2.存储过程体的每一条sql语句都需要用分号结尾</strong></p>
</li>
<li><p>调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call 存储过程名(实参列表)</span><br><span class="line">#举例：</span><br><span class="line">#调用in模式的参数：call sp1（‘值’）;</span><br><span class="line">#调用out模式的参数：set @name; call sp1(@name);select @name;</span><br><span class="line">#调用inout模式的参数：set @name=值; call sp1(@name); select @name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create procedure 存储过程名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop procedure 存储过程名;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="6-4-函数"><a href="#6-4-函数" class="headerlink" title="6.4 函数"></a>6.4 函数</h2><ol>
<li><p>创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create function 函数名(参数名 参数类型) returns  返回类型</span><br><span class="line">begin</span><br><span class="line">	函数体</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>注意：函数体中肯定需要有return语句</strong></p>
</li>
<li><p>调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 函数名(实参列表);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create function 函数名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop function 函数名;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="6-5-流程控制结构"><a href="#6-5-流程控制结构" class="headerlink" title="6.5 流程控制结构"></a>6.5 流程控制结构</h2><h3 id="6-5-1-分支结构"><a href="#6-5-1-分支结构" class="headerlink" title="6.5.1 分支结构"></a>6.5.1 分支结构</h3><ol>
<li><p>IF函数</p>
<p>功能：实现简单双分支</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件，值1，值2)</span><br></pre></td></tr></table></figure>

<p>位置：可以作为表达式放在任何位置</p>
</li>
<li><p>CASE结构</p>
<p>功能：实现多分支</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一种</span><br><span class="line">case 表达式或字段</span><br><span class="line">when 值1 then 语句1;</span><br><span class="line">when 值2 then 语句2；</span><br><span class="line">..</span><br><span class="line">else 语句n;</span><br><span class="line">end [case];</span><br><span class="line">#第二种</span><br><span class="line">case </span><br><span class="line">when 条件1 then 语句1;</span><br><span class="line">when 条件2 then 语句2；</span><br><span class="line">..</span><br><span class="line">else 语句n;</span><br><span class="line">end [case];</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>IF结构</p>
<p>功能：实现多分支</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 条件1 then 语句1;</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure>

<p>位置：只能放在begin end中</p>
</li>
</ol>
<h3 id="6-5-2-循环结构"><a href="#6-5-2-循环结构" class="headerlink" title="6.5.2 循环结构"></a>6.5.2 循环结构</h3><ol>
<li><p>WHILE</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【名称:】while 循环条件 do</span><br><span class="line">		循环体</span><br><span class="line">end while 【名称】;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LOOP</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【名称：】loop</span><br><span class="line">		循环体</span><br><span class="line">end loop 【名称】;</span><br></pre></td></tr></table></figure>
</li>
<li><p>REPEAT</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【名称:】repeat</span><br><span class="line">		循环体</span><br><span class="line">until 结束条件 </span><br><span class="line">end repeat 【名称】;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对比</p>
<ol>
<li><p>这三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称</p>
<ul>
<li>leave：类似于break，用于跳出所在的循环</li>
<li>iterate：类似于continue，用于结束本次循环，继续下一次</li>
</ul>
</li>
<li><p>loop 一般用于实现简单的死循环</p>
<p>while 先判断后执行</p>
<p>repeat 先执行后判断，无条件至少执行一次</p>
</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2020/02/10/数据库-MySQL-MySQL基础/" data-id="ckmh9ucmk008j3oumzr7lge2q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-地图-高德地图画点、折线、多边形、长方形、圆" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/19/地图-高德地图画点、折线、多边形、长方形、圆/" class="article-date">
  <time datetime="2019-12-19T14:12:23.000Z" itemprop="datePublished">2019-12-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/地图/">地图</a>►<a class="article-category-link" href="/categories/地图/高德地图/">高德地图</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/19/地图-高德地图画点、折线、多边形、长方形、圆/">高德地图绘制矢量图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="高德地图绘制矢量图"><a href="#高德地图绘制矢量图" class="headerlink" title="高德地图绘制矢量图"></a>高德地图绘制矢量图</h1><h1 id="地图坐标选取器"><a href="#地图坐标选取器" class="headerlink" title="地图坐标选取器"></a>地图坐标选取器</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"chrome=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1.0, user-scalable=no, width=device-width"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html, body, #container &#123;</span><br><span class="line">            height: 100%;</span><br><span class="line">            width: 100%;</span><br><span class="line">            font-size: 14px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        body &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";</span><br><span class="line">            line-height: 1.5;</span><br><span class="line">            font-weight: 300;</span><br><span class="line">            color: #111213;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        * &#123;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .input-item &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            display: -ms-flexbox;</span><br><span class="line">            display: flex;</span><br><span class="line">            -ms-flex-wrap: wrap;</span><br><span class="line">            flex-wrap: wrap;</span><br><span class="line">            -ms-flex-align: center;</span><br><span class="line">            align-items: center;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 2.2rem;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .info &#123;</span><br><span class="line">            padding: .75rem 1.25rem;</span><br><span class="line">            margin-bottom: 1rem;</span><br><span class="line">            border-radius: .25rem;</span><br><span class="line">            position: fixed;</span><br><span class="line">            top: 1rem;</span><br><span class="line">            background-color: white;</span><br><span class="line">            width: auto;</span><br><span class="line">            min-width: 22rem;</span><br><span class="line">            border-width: 0;</span><br><span class="line">            left: 1rem;</span><br><span class="line">            right: auto;</span><br><span class="line">            box-shadow: 0 2px 6px 0 rgba(114, 124, 245, .5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .input-card &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            flex-direction: column;</span><br><span class="line">            min-width: 0;</span><br><span class="line">            word-wrap: break-word;</span><br><span class="line">            background-color: #fff;</span><br><span class="line">            background-clip: border-box;</span><br><span class="line">            border-radius: .25rem;</span><br><span class="line">            width: 22rem;</span><br><span class="line">            border-width: 0;</span><br><span class="line">            box-shadow: 0 2px 6px 0 rgba(114, 124, 245, .5);</span><br><span class="line">            position: fixed;</span><br><span class="line">            bottom: 1rem;</span><br><span class="line">            right: 1rem;</span><br><span class="line">            -ms-flex: 1 1 auto;</span><br><span class="line">            flex: 1 1 auto;</span><br><span class="line">            padding: 0.75rem 1.25rem;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .btn &#123;</span><br><span class="line">            width: 6rem;</span><br><span class="line">            margin: 0 1rem 0 2rem;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            font-weight: 400;</span><br><span class="line">            text-align: center;</span><br><span class="line">            white-space: nowrap;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">            -webkit-user-select: none;</span><br><span class="line">            -moz-user-select: none;</span><br><span class="line">            -ms-user-select: none;</span><br><span class="line">            user-select: none;</span><br><span class="line">            border: 1px solid transparent;</span><br><span class="line">            transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, box-shadow .15s ease-in-out;</span><br><span class="line">            background-color: transparent;</span><br><span class="line">            background-image: none;</span><br><span class="line">            color: #25A5F7;</span><br><span class="line">            border-color: #25A5F7;</span><br><span class="line">            padding: .25rem .5rem;</span><br><span class="line">            line-height: 1.5;</span><br><span class="line">            border-radius: 1rem;</span><br><span class="line">            -webkit-appearance: button;</span><br><span class="line">            cursor: pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            .btn:focus,</span><br><span class="line">            .btn:active:focus,</span><br><span class="line">            .btn.active:focus,</span><br><span class="line">            .btn.focus,</span><br><span class="line">            .btn:active.focus,</span><br><span class="line">            .btn.active.focus &#123;</span><br><span class="line">                outline: none;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        .input-text &#123;</span><br><span class="line">            width: 4rem;</span><br><span class="line">            margin-right: 1rem;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>鼠标工具绘制<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'container'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'info'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>操作说明：圆和矩形通过拖拽来绘制，其他覆盖物通过单击来绘制，双击结束绘制<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>当前类型：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"type"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>坐标信息：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"lnglat"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"location"</span>&gt;</span>位置信息： <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-card"</span> <span class="attr">style</span>=<span class="string">'width: 24rem;'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">checked</span> <span class="attr">value</span>=<span class="string">'marker'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span>&gt;</span>画点<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">value</span>=<span class="string">'polyline'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span>&gt;</span>画折线<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">value</span>=<span class="string">'polygon'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span> <span class="attr">style</span>=<span class="string">'width:5rem;'</span>&gt;</span>画多边形<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">value</span>=<span class="string">'rectangle'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span>&gt;</span>画矩形<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">'func'</span> <span class="attr">value</span>=<span class="string">'circle'</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-text"</span>&gt;</span>画圆<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"clear"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"清除"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"confirm"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">value</span>=<span class="string">"确定"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://webapi.amap.com/maps?v=1.4.15&amp;key=你的key&amp;plugin=AMap.MouseTool&amp;plugin=AMap.PolyEditor"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> map = <span class="keyword">new</span> AMap.Map(<span class="string">'container'</span>, &#123;</span></span><br><span class="line">            zoom: 13,</span><br><span class="line">            center: [110.255414, 20.009835],</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//自定义控件</span></span></span><br><span class="line"><span class="javascript">        AMap.plugin([<span class="string">'AMap.ToolBar'</span>, <span class="string">'AMap.Scale'</span>, <span class="string">'AMap.OverView'</span>, <span class="string">'AMap.MapType'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//map.addControl(new AMap.ToolBar());</span></span></span><br><span class="line"><span class="javascript">            map.addControl(<span class="keyword">new</span> AMap.Scale());</span></span><br><span class="line"><span class="javascript">            <span class="comment">//map.addControl(new AMap.OverView(&#123; isOpen: true &#125;));</span></span></span><br><span class="line"><span class="javascript">            map.addControl(<span class="keyword">new</span> AMap.MapType(&#123; <span class="attr">defaultType</span>: <span class="number">0</span> &#125;));</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> mouseTool = <span class="keyword">new</span> AMap.MouseTool(map);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//监听draw事件可获取画好的覆盖物</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> overlays = [];</span></span><br><span class="line"><span class="javascript">        <span class="comment">//结果集</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> result = &#123;</span></span><br><span class="line"><span class="javascript">            type: <span class="string">""</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                location: &#123; <span class="attr">lng</span>: <span class="string">""</span>, <span class="attr">lat</span>: <span class="string">""</span> &#125;, <span class="attr">path</span>: [],</span></span><br><span class="line"><span class="javascript">                bounds: &#123; <span class="attr">southwest</span>: &#123; <span class="attr">lng</span>: <span class="string">""</span>, <span class="attr">lat</span>: <span class="string">""</span> &#125;, <span class="attr">northeast</span>: &#123; <span class="attr">lng</span>: <span class="string">""</span>, <span class="attr">lat</span>: <span class="string">""</span> &#125;, &#125;,</span></span><br><span class="line"><span class="javascript">                circle: &#123; <span class="attr">center</span>: <span class="string">""</span>, <span class="attr">radius</span>: <span class="string">""</span> &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        mouseTool.on(<span class="string">'draw'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//清空覆盖物</span></span></span><br><span class="line">            map.remove(overlays);</span><br><span class="line">            overlays = [];</span><br><span class="line"><span class="javascript">            <span class="comment">//根据类型处理地图覆盖物</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> lnglat = [];<span class="comment">//单项目点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span> (e.obj.getExtData().type) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'marker'</span>: &#123;</span></span><br><span class="line">                    lnglat.push(e.obj.getPosition().lng);</span><br><span class="line">                    lnglat.push(e.obj.getPosition().lat);</span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"marker"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = lnglat;</span></span><br><span class="line">                    Geocoder(lnglat, e.obj.getExtData().type);</span><br><span class="line">                    overlays.push(e.obj);</span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'marker'</span>;</span></span><br><span class="line">                    result.data.location.lng = e.obj.getPosition().lng;</span><br><span class="line">                    result.data.location.lat = e.obj.getPosition().lat;</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'polyline'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = e.obj.getPath();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> tmp = [];</span></span><br><span class="line">                        tmp.push(data[i].lng);</span><br><span class="line">                        tmp.push(data[i].lat);</span><br><span class="line">                        lnglat.push(tmp);</span><br><span class="line">                        result.data.path.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'polyline'</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"polyline"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = lnglat;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> polyline = <span class="keyword">new</span> AMap.Polyline(&#123;</span></span><br><span class="line">                        path: data,</span><br><span class="line"><span class="javascript">                        isOutline: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                        outlineColor: <span class="string">'#ffeeff'</span>,</span></span><br><span class="line">                        borderWeight: 3,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">"#3366FF"</span>,</span></span><br><span class="line">                        strokeOpacity: 1,</span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line"><span class="javascript">                        <span class="comment">// 折线样式还支持 'dashed'</span></span></span><br><span class="line"><span class="javascript">                        strokeStyle: <span class="string">"solid"</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// strokeStyle是dashed时有效</span></span></span><br><span class="line">                        strokeDasharray: [10, 5],</span><br><span class="line"><span class="javascript">                        lineJoin: <span class="string">'round'</span>,</span></span><br><span class="line"><span class="javascript">                        lineCap: <span class="string">'round'</span>,</span></span><br><span class="line">                        zIndex: 50,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'polyline'</span> &#125;,</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    overlays.push(polyline);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    polyline.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">"AMap.PolyEditor"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> PolylineEditor = <span class="keyword">new</span> AMap.PolyEditor(map, polyline);</span></span><br><span class="line">                        overlays.push(PolylineEditor);</span><br><span class="line">                        PolylineEditor.open();</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定增加节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolylineEditor.on(<span class="string">'addnode'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定调整节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolylineEditor.on(<span class="string">'adjust'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定删除节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolylineEditor.on(<span class="string">'removenode'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'polygon'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = e.obj.getPath();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> tmp = [];</span></span><br><span class="line">                        tmp.push(data[i].lng);</span><br><span class="line">                        tmp.push(data[i].lat);</span><br><span class="line">                        lnglat.push(tmp);</span><br><span class="line">                        result.data.path.push(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'polygon'</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"polygon"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = lnglat;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> polygon = <span class="keyword">new</span> AMap.Polygon(&#123;</span></span><br><span class="line">                        path: data,</span><br><span class="line"><span class="javascript">                        isOutline: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                        outlineColor: <span class="string">'#ffeeff'</span>,</span></span><br><span class="line">                        borderWeight: 3,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">"#3366FF"</span>,</span></span><br><span class="line">                        strokeOpacity: 1,</span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line"><span class="javascript">                        <span class="comment">// 折线样式还支持 'dashed'</span></span></span><br><span class="line"><span class="javascript">                        strokeStyle: <span class="string">"solid"</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// strokeStyle是dashed时有效</span></span></span><br><span class="line">                        strokeDasharray: [10, 5],</span><br><span class="line"><span class="javascript">                        lineJoin: <span class="string">'round'</span>,</span></span><br><span class="line"><span class="javascript">                        lineCap: <span class="string">'round'</span>,</span></span><br><span class="line">                        zIndex: 50,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'polygon'</span> &#125;,</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    overlays.push(polygon);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    polygon.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">"AMap.PolyEditor"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> PolygonEditor = <span class="keyword">new</span> AMap.PolyEditor(map, polygon);</span></span><br><span class="line">                        overlays.push(PolygonEditor);</span><br><span class="line">                        PolygonEditor.open();</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定增加节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolygonEditor.on(<span class="string">'addnode'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定调整节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolygonEditor.on(<span class="string">'adjust'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        <span class="comment">//绑定删除节点事件</span></span></span><br><span class="line"><span class="javascript">                        PolygonEditor.on(<span class="string">'removenode'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'rectangle'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = e.obj.getBounds();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> southwestlng = data.southwest.lng;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> southwestlat = data.southwest.lat;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> northeastlng = data.northeast.lng;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> northeastlat = data.northeast.lat;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"rectangle"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">"southwest:["</span> + southwestlng + <span class="string">","</span> + southwestlat + <span class="string">"],northeast:["</span> + northeastlng + <span class="string">","</span> + northeastlat + <span class="string">"]"</span>;</span></span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'polygon'</span>;</span></span><br><span class="line">                    result.data.bounds.southwest.lng = southwestlng;</span><br><span class="line">                    result.data.bounds.southwest.lat = southwestlat;</span><br><span class="line">                    result.data.bounds.northeast.lng = northeastlng;</span><br><span class="line">                    result.data.bounds.northeast.lat = northeastlat;</span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//重新声明矩形对象</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> rectangle = <span class="keyword">new</span> AMap.Rectangle(&#123;</span></span><br><span class="line">                        bounds: data,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'red'</span>,</span></span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line">                        strokeOpacity: 0.5,</span><br><span class="line">                        strokeDasharray: [30, 10],</span><br><span class="line"><span class="javascript">                        <span class="comment">// strokeStyle还支持 solid</span></span></span><br><span class="line"><span class="javascript">                        strokeStyle: <span class="string">'dashed'</span>,</span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">'blue'</span>,</span></span><br><span class="line">                        fillOpacity: 0.5,</span><br><span class="line"><span class="javascript">                        cursor: <span class="string">'pointer'</span>,</span></span><br><span class="line">                        zIndex: 50,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'rectangle'</span> &#125;,</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    overlays.push(rectangle);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    rectangle.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">"AMap.RectangleEditor"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> RectangleEditor = <span class="keyword">new</span> AMap.RectangleEditor(map, rectangle);</span></span><br><span class="line">                        overlays.push(RectangleEditor);</span><br><span class="line">                        RectangleEditor.open();</span><br><span class="line"><span class="javascript">                        RectangleEditor.on(<span class="string">'adjust'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'circle'</span>: &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> radius = e.obj.getRadius();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> center = e.obj.getCenter();</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"circle"</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">"圆心："</span> + center + <span class="string">"半径："</span> + radius;</span></span><br><span class="line"><span class="javascript">                    result.type = <span class="string">'circle'</span>;</span></span><br><span class="line">                    result.data.circle.center = center;</span><br><span class="line">                    result.data.circle.radius = radius;</span><br><span class="line"><span class="javascript">                    <span class="comment">//关闭鼠标绘图工具，true表示清除图形，false保留</span></span></span><br><span class="line"><span class="javascript">                    mouseTool.close(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> circle = <span class="keyword">new</span> AMap.Circle(&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">//map: mapObj,</span></span></span><br><span class="line">                        center: center,</span><br><span class="line">                        radius: radius,</span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">"#F33"</span>,</span></span><br><span class="line">                        strokeOpacity: 1,</span><br><span class="line">                        strokeWeight: 3,</span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">"ee2200"</span>,</span></span><br><span class="line">                        fillOpacity: 0.35,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'circle'</span> &#125;,</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    overlays.push(circle);</span><br><span class="line"><span class="javascript">                    <span class="comment">//地图更新对象</span></span></span><br><span class="line">                    circle.setMap(map);</span><br><span class="line"><span class="javascript">                    <span class="comment">//启用编辑</span></span></span><br><span class="line"><span class="javascript">                    AMap.plugin([<span class="string">"AMap.CircleEditor"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> CircleEditor = <span class="keyword">new</span> AMap.CircleEditor(map, circle);</span></span><br><span class="line">                        overlays.push(CircleEditor);</span><br><span class="line">                        CircleEditor.open();</span><br><span class="line"><span class="javascript">                        CircleEditor.on(<span class="string">'move'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line"><span class="javascript">                        CircleEditor.on(<span class="string">'adjust'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">                            updateData(event);</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//绘制图形</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">type</span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">//清空上一次覆盖物</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//不是点需要先通过编辑工具关闭</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (overlays.length &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type != <span class="string">'marker'</span>) &#123;</span></span><br><span class="line">                    overlays[1].close();</span><br><span class="line">                &#125;</span><br><span class="line">                map.remove(overlays[0]);</span><br><span class="line">                overlays = [];</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"address"</span>).innerHTML = <span class="string">""</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (type == <span class="string">'marker'</span>)</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"location"</span>).style.display = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"location"</span>).style.display = <span class="string">"none"</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span> (type) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'marker'</span>: &#123;</span></span><br><span class="line">                    mouseTool.marker(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Marker的Option设置</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">//draggable: true,</span></span></span><br><span class="line"><span class="javascript">                        <span class="comment">//类型参数，用作区分</span></span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'marker'</span> &#125;,</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'polyline'</span>: &#123;</span></span><br><span class="line">                    mouseTool.polyline(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Polyline的Option设置</span></span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'#80d8ff'</span>,</span></span><br><span class="line">                        strokeWeight: 6,</span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'polyline'</span> &#125;,</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'polygon'</span>: &#123;</span></span><br><span class="line">                    mouseTool.polygon(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Polygon的Option设置</span></span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">'#00b0ff'</span>,</span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'#80d8ff'</span>,</span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'polygon'</span> &#125;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'rectangle'</span>: &#123;</span></span><br><span class="line">                    mouseTool.rectangle(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Polygon的Option设置</span></span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">'#00b0ff'</span>,</span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'#80d8ff'</span>,</span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'rectangle'</span> &#125;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="string">'circle'</span>: &#123;</span></span><br><span class="line">                    mouseTool.circle(&#123;</span><br><span class="line"><span class="javascript">                        <span class="comment">//同Circle的Option设置</span></span></span><br><span class="line"><span class="javascript">                        fillColor: <span class="string">'#00b0ff'</span>,</span></span><br><span class="line"><span class="javascript">                        strokeColor: <span class="string">'#80d8ff'</span>,</span></span><br><span class="line"><span class="javascript">                        extData: &#123; <span class="attr">type</span>: <span class="string">'circle'</span> &#125;</span></span><br><span class="line">                    &#125;);</span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> radios = <span class="built_in">document</span>.getElementsByName(<span class="string">'func'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; radios.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            radios[i].onchange = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line">                draw(e.target.value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">//默认画点</span></span></span><br><span class="line"><span class="javascript">        draw(<span class="string">'marker'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//逆地理编码</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Geocoder</span>(<span class="params">lnglat, type</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            AMap.plugin(<span class="string">'AMap.Geocoder'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> geocoder = <span class="keyword">new</span> AMap.Geocoder(&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// city 指定进行编码查询的城市，支持传入城市名、adcode 和 citycode</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// city: '010'</span></span></span><br><span class="line">                    radius: 1000,</span><br><span class="line"><span class="javascript">                    extensions: <span class="string">"all"</span></span></span><br><span class="line">                &#125;)</span><br><span class="line"><span class="javascript">                geocoder.getAddress(lnglat, <span class="function"><span class="keyword">function</span> (<span class="params">status, result</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (status === <span class="string">'complete'</span> &amp;&amp; result.info === <span class="string">'OK'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// result为对应的地理位置详细信息</span></span></span><br><span class="line"><span class="javascript">                        <span class="built_in">document</span>.getElementById(<span class="string">"address"</span>).innerHTML = result.regeocode.formattedAddress;</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//编辑事件绑定方法，实时更新左上角数据</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">updateData</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type == <span class="string">"polyline"</span> || overlays[<span class="number">0</span>].getExtData().type == <span class="string">"polygon"</span>) &#123;</span></span><br><span class="line">                data = overlays[0].getPath();</span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> lnglat = [];</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> tmp = [];</span></span><br><span class="line">                    tmp.push(data[i].lng);</span><br><span class="line">                    tmp.push(data[i].lat);</span><br><span class="line">                    lnglat.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"type"</span>).innerHTML = <span class="string">"polygon"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = lnglat;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type == <span class="string">"rectangle"</span>) &#123;</span></span><br><span class="line">                data = overlays[0].getBounds();</span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">"southwest:["</span> + data.southwest.lng + <span class="string">","</span> + data.southwest.lat</span></span><br><span class="line"><span class="javascript">                    + <span class="string">"],northeast:["</span> + data.northeast.lng + <span class="string">","</span> + data.northeast.lat + <span class="string">"]"</span>;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type == <span class="string">"circle"</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"lnglat"</span>).innerHTML = <span class="string">"圆心："</span> + overlays[<span class="number">0</span>].getCenter() + <span class="string">"半径："</span> + overlays[<span class="number">0</span>].getRadius();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//清除</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'clear'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//不是点需要先关闭编辑工具</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (overlays.length &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (overlays[<span class="number">0</span>].getExtData().type != <span class="string">'marker'</span>) &#123;</span></span><br><span class="line">                    overlays[1].close();</span><br><span class="line">                &#125;</span><br><span class="line">                map.remove(overlays[0]);</span><br><span class="line">                draw(overlays[0].getExtData().type);</span><br><span class="line">            &#125;</span><br><span class="line">            overlays = [];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">//确认，自定义保存结果</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'confirm'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="built_in">JSON</span>.stringify(result));</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(result));</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/12/19/地图-高德地图画点、折线、多边形、长方形、圆/" data-id="ckmh9ucm2007o3oumanpqne57" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/地图/">地图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高德地图/">高德地图</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-JsPlumb绘制流程图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/06/JS-JsPlumb绘制流程图/" class="article-date">
  <time datetime="2019-11-06T14:12:23.000Z" itemprop="datePublished">2019-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/Jsplumb/">Jsplumb</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/06/JS-JsPlumb绘制流程图/">jsplumb绘制流程图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>背景：公司项目需要一个能绘制流程图的功能，能绘制能保存，并且能够将每个节点和表单数据关联起来。决定使用jsPlumb，然后在github查阅资料看到<a href="https://github.com/smile1828/demo-jsPlumb" target="_blank" rel="noopener">demo-jsPlumb</a>，在这个基础上进行了修改完善，一些细节方面也进行了优化，非常感谢 smile1828。</p>
<p>功能：</p>
<ul>
<li><p>按钮点击新增节点，或者拖拽新增节点</p>
<blockquote>
<p>项目上只需要用到一个图形，所以就做成新增按钮，需要多个节点拖动，html可以取消隐藏</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-body"</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-menu"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">h5</span>&gt;</span>节点类型列表<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"flow-btns"</span> <span class="attr">class</span>=<span class="string">"flow-btns"</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-btn btn-base"</span> <span class="attr">data-type</span>=<span class="string">"base"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-btn btn-flow"</span> <span class="attr">data-type</span>=<span class="string">"flow"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-btn btn-node"</span> <span class="attr">data-type</span>=<span class="string">"node"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;             <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-btn btn-judge"</span> <span class="attr">data-type</span>=<span class="string">"judge"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-container"</span>&gt;</span></span><br><span class="line">&gt;         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flow-main"</span> <span class="attr">id</span>=<span class="string">"flow-main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20191106161400.png" alt="新增节点"></p>
</li>
<li><p>单击节点，右上角出现删除角标点击删除，也可以按delete删除</p>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20191106161444.png" alt="删除节点"></p>
</li>
<li><p>双击节点，可打开自定义窗口</p>
</li>
<li><p>节点支持连线</p>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20191106161630.png" alt="连线节点"></p>
</li>
<li><p>连线单击选中后，按delete删除</p>
</li>
<li><p>连线双击可以添加label</p>
</li>
<li><p>点击保存按钮，可以将流程图存为json数据通过ajax传给后端保存</p>
</li>
<li><p>对于已经存在数据的可以直接调用draw方法绘制</p>
</li>
<li><p>支持清空画布</p>
</li>
</ul>
<p>参考链接：</p>
<ul>
<li><a href="https://github.com/smile1828/demo-jsPlumb" target="_blank" rel="noopener">demo-jsPlumb</a></li>
<li><a href="https://www.cnblogs.com/xcj26/p/9870734.html" target="_blank" rel="noopener">jsplumb 中文教程</a></li>
<li><a href="https://blog.csdn.net/T_tq_bnsg_bs_ll/article/details/91380367" target="_blank" rel="noopener">jsPlumb应用指南（一）概念部分</a></li>
</ul>
<p>注：文件在<a href="https://github.com/fangchenyong/jsPlumb-Flowchart" target="_blank" rel="noopener">Github地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/11/06/JS-JsPlumb绘制流程图/" data-id="ckmh9ucia00063oumw8zzw5g9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jsplumb/">Jsplumb</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/netty/">netty</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/源码/">源码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/源码/Object/">Object</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/源码/String/">String</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Jsplumb/">Jsplumb</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/">CentOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/ActiveMQ/">ActiveMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/FastDFS/">FastDFS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/FastDFS/nginx/">nginx</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/JDK/">JDK</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/MongoDB/">MongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/zigw/">zigw</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Oracle/">Oracle</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Oracle/正则表达式/">正则表达式</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/My-Java-Life/">My Java Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ORM/">ORM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ORM/Hibernate/">Hibernate</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/地图/">地图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/地图/腾讯地图/">腾讯地图</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/地图/高德地图/">高德地图</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/Oracle/">Oracle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/SqlServer/">SqlServer</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/数组/">数组</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/数组/稀疏数组/">稀疏数组</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/环形队列/">环形队列</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/创建型模式/">创建型模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/创建型模式/单例模式/">单例模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/设计原则/">设计原则</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试题/">面试题</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/面试题/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目/">项目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/项目/方兴商城/">方兴商城</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveMQ/">ActiveMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS/">CentOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FastDFS/">FastDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hibernate/">Hibernate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jsplumb/">Jsplumb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/My-Java-Life/">My Java Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/">ORM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object/">Object</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SqlServer/">SqlServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zigw/">zigw</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维码/">二维码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/创建型模式/">创建型模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例模式/">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/地图/">地图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/存储过程/">存储过程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环形队列/">环形队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稀疏数组/">稀疏数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/腾讯地图/">腾讯地图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计原则/">设计原则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试题/">面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高德地图/">高德地图</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ActiveMQ/" style="font-size: 10px;">ActiveMQ</a> <a href="/tags/CentOS/" style="font-size: 18.33px;">CentOS</a> <a href="/tags/FastDFS/" style="font-size: 10px;">FastDFS</a> <a href="/tags/Hibernate/" style="font-size: 10px;">Hibernate</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 13.33px;">JavaScript</a> <a href="/tags/Jsplumb/" style="font-size: 10px;">Jsplumb</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/My-Java-Life/" style="font-size: 10px;">My Java Life</a> <a href="/tags/MySQL/" style="font-size: 11.67px;">MySQL</a> <a href="/tags/MySql/" style="font-size: 10px;">MySql</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/ORM/" style="font-size: 10px;">ORM</a> <a href="/tags/Object/" style="font-size: 10px;">Object</a> <a href="/tags/Oracle/" style="font-size: 11.67px;">Oracle</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 11.67px;">SpringBoot</a> <a href="/tags/SqlServer/" style="font-size: 11.67px;">SqlServer</a> <a href="/tags/String/" style="font-size: 10px;">String</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/netty/" style="font-size: 10px;">netty</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/zigw/" style="font-size: 10px;">zigw</a> <a href="/tags/二维码/" style="font-size: 10px;">二维码</a> <a href="/tags/创建型模式/" style="font-size: 10px;">创建型模式</a> <a href="/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/tags/地图/" style="font-size: 11.67px;">地图</a> <a href="/tags/存储过程/" style="font-size: 10px;">存储过程</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 11.67px;">数据结构</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/源码/" style="font-size: 11.67px;">源码</a> <a href="/tags/环形队列/" style="font-size: 10px;">环形队列</a> <a href="/tags/稀疏数组/" style="font-size: 10px;">稀疏数组</a> <a href="/tags/腾讯地图/" style="font-size: 10px;">腾讯地图</a> <a href="/tags/设计原则/" style="font-size: 10px;">设计原则</a> <a href="/tags/设计模式/" style="font-size: 11.67px;">设计模式</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a> <a href="/tags/面试题/" style="font-size: 10px;">面试题</a> <a href="/tags/高德地图/" style="font-size: 10px;">高德地图</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/20/面试-集合/">面试题-集合框架</a>
          </li>
        
          <li>
            <a href="/2021/03/13/The Road To Bald Man!/">The Road To Bald Man!</a>
          </li>
        
          <li>
            <a href="/2020/07/21/框架-Maven-配置标签详解/">Maven配置标签详解</a>
          </li>
        
          <li>
            <a href="/2020/07/13/设计模式-七大原则/">设计模式-七大设计原则</a>
          </li>
        
          <li>
            <a href="/2020/07/13/设计模式-创建型模式-单例模式/">设计模式-创建型模式-单例模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 fangchenyong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>