<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Joey</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Joey">
<meta property="og:url" content="http://fangchenyong.top/page/4/index.html">
<meta property="og:site_name" content="Joey">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joey">
  
    <link rel="alternate" href="/atom.xml" title="Joey" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Joey</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">首页</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://fangchenyong.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux-install_JDK1.8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/Linux-install_JDK1.8/" class="article-date">
  <time datetime="2019-07-22T16:00:00.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>►<a class="article-category-link" href="/categories/Linux/CentOS/">CentOS</a>►<a class="article-category-link" href="/categories/Linux/CentOS/JDK/">JDK</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/Linux-install_JDK1.8/">Centos7.2下安装JDK三种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Centos7-2下安装JDK三种方法"><a href="#Centos7-2下安装JDK三种方法" class="headerlink" title="Centos7.2下安装JDK三种方法"></a>Centos7.2下安装JDK三种方法</h2><h3 id="方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量"><a href="#方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量" class="headerlink" title="方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量"></a>方法一：手动下载JDK压缩包或者本地上传解压，然后设置环境变量</h3><h4 id="1-在-usr-目录下创建java目录"><a href="#1-在-usr-目录下创建java目录" class="headerlink" title="1. 在/usr/目录下创建java目录"></a>1. 在/usr/目录下创建java目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir/usr/java</span><br><span class="line">[root@localhost ~]# cd /usr/java</span><br></pre></td></tr></table></figure>

<h4 id="2-下载jdk-然后解压"><a href="#2-下载jdk-然后解压" class="headerlink" title="2. 下载jdk,然后解压"></a>2. 下载jdk,然后解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# curl -O （jdk下载链接）</span><br><span class="line">[root@localhost java]# tar -zxvf jdk-8u192-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3. 设置环境变量"></a>3. 设置环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# vim /etc/profile</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在profile中最后添加如下内容:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_192</span><br><span class="line">JRE_HOME=/usr/java/jdk1.8.0_192/jre</span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br></pre></td></tr></table></figure>

<blockquote>
<p>让修改生效:</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost java]# source /etc/profile</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 若因修改环境变量导致系统出现command not found错误,可尝试以下方法</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>编辑环境变量文件</span><br><span class="line">[root@localhost java]# /usr/bin/vim /etc/profile</span><br><span class="line"><span class="meta">#</span>修改或删除原先配置文件 :wq 保存退出 执行export</span><br><span class="line">[root@localhost java]# export PATH=/usr/bin:/usr/sbin:/bin:/sbin</span><br><span class="line"><span class="meta">#</span>重新执行使更改立即生效</span><br><span class="line">[root@localhost java]# source /etc/profile</span><br></pre></td></tr></table></figure>

<h4 id="4-验证JDK有效性"><a href="#4-验证JDK有效性" class="headerlink" title="4. 验证JDK有效性"></a>4. 验证JDK有效性</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos jdk1.8.0_192]# java -version</span><br><span class="line">java version "1.8.0_192"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_192-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.192-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用yum命令在线安装JDK"><a href="#方法二：使用yum命令在线安装JDK" class="headerlink" title="方法二：使用yum命令在线安装JDK"></a>方法二：使用yum命令在线安装JDK</h3><h4 id="1-查看yum库中都有哪些jdk版本，全是openjdk"><a href="#1-查看yum库中都有哪些jdk版本，全是openjdk" class="headerlink" title="1. 查看yum库中都有哪些jdk版本，全是openjdk"></a>1. 查看yum库中都有哪些jdk版本，全是openjdk</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos jdk1.8.0_192]# yum search java|grep jdk</span><br><span class="line">ldapjdk-javadoc.noarch : Javadoc for ldapjdk</span><br><span class="line">java-1.6.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">...</span><br><span class="line">java-1.7.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">...</span><br><span class="line">java-1.8.0-openjdk.i686 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk-accessibility.i686 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-accessibility-debug.i686 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-accessibility-debug.x86_64 : OpenJDK accessibility connector</span><br><span class="line">java-1.8.0-openjdk-debug.i686 : OpenJDK Runtime Environment with full debug on</span><br><span class="line">java-1.8.0-openjdk-debug.x86_64 : OpenJDK Runtime Environment with full debug on</span><br><span class="line">java-1.8.0-openjdk-demo.i686 : OpenJDK Demos</span><br><span class="line">java-1.8.0-openjdk-demo.x86_64 : OpenJDK Demos</span><br><span class="line">java-1.8.0-openjdk-demo-debug.i686 : OpenJDK Demos with full debug on</span><br><span class="line">java-1.8.0-openjdk-demo-debug.x86_64 : OpenJDK Demos with full debug on</span><br><span class="line">java-1.8.0-openjdk-devel.i686 : OpenJDK Development Environment</span><br><span class="line">java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment</span><br><span class="line">java-1.8.0-openjdk-devel-debug.i686 : OpenJDK Development Environment with full</span><br><span class="line">java-1.8.0-openjdk-devel-debug.x86_64 : OpenJDK Development Environment with</span><br><span class="line">java-1.8.0-openjdk-headless.i686 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk-headless.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">java-1.8.0-openjdk-headless-debug.i686 : OpenJDK Runtime Environment with full</span><br><span class="line">java-1.8.0-openjdk-headless-debug.x86_64 : OpenJDK Runtime Environment with full</span><br><span class="line">java-1.8.0-openjdk-javadoc.noarch : OpenJDK API Documentation</span><br><span class="line">java-1.8.0-openjdk-javadoc-debug.noarch : OpenJDK API Documentation for packages</span><br><span class="line">java-1.8.0-openjdk-javadoc-zip.noarch : OpenJDK API Documentation compressed in</span><br><span class="line">java-1.8.0-openjdk-javadoc-zip-debug.noarch : OpenJDK API Documentation</span><br><span class="line">java-1.8.0-openjdk-src.i686 : OpenJDK Source Bundle</span><br><span class="line">java-1.8.0-openjdk-src.x86_64 : OpenJDK Source Bundle</span><br><span class="line">java-1.8.0-openjdk-src-debug.i686 : OpenJDK Source Bundle for packages with</span><br><span class="line">java-1.8.0-openjdk-src-debug.x86_64 : OpenJDK Source Bundle for packages with</span><br><span class="line">java-11-openjdk.i686 : OpenJDK Runtime Environment 11</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="2-选择版本进行安装"><a href="#2-选择版本进行安装" class="headerlink" title="2. 选择版本进行安装"></a>2. 选择版本进行安装</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>选择1.8版本进行安装,安装完之后，默认的安装目录是在: /usr/lib/jvm/</span><br><span class="line">[root@localhost ~]# yum install java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<h4 id="3-设置环境变量-，使修改立即生效，查看是否安装成功参考方法一"><a href="#3-设置环境变量-，使修改立即生效，查看是否安装成功参考方法一" class="headerlink" title="3. 设置环境变量 ，使修改立即生效，查看是否安装成功参考方法一"></a>3. 设置环境变量 ，使修改立即生效，查看是否安装成功参考方法一</h4><h3 id="方法三：使用rpm安装"><a href="#方法三：使用rpm安装" class="headerlink" title="方法三：使用rpm安装"></a>方法三：使用rpm安装</h3><h4 id="1-其他步骤具体参考上述方法"><a href="#1-其他步骤具体参考上述方法" class="headerlink" title="1. 其他步骤具体参考上述方法"></a>1. 其他步骤具体参考上述方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost  ~]# rpm -ivh jdk-7u79-linux-x64.rpm</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/07/23/Linux-install_JDK1.8/" data-id="ckmh9ucij000e3oum252gz23k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CentOS/">CentOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDK/">JDK</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-install_MongoDB4.0.5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/Linux-install_MongoDB4.0.5/" class="article-date">
  <time datetime="2019-07-22T16:00:00.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>►<a class="article-category-link" href="/categories/Linux/CentOS/">CentOS</a>►<a class="article-category-link" href="/categories/Linux/CentOS/MongoDB/">MongoDB</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/Linux-install_MongoDB4.0.5/">CentOS 7.2安装MongoDB 4.0.5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CentOS-7-2安装MongoDB-4-0-5"><a href="#CentOS-7-2安装MongoDB-4-0-5" class="headerlink" title="CentOS 7.2安装MongoDB 4.0.5"></a>CentOS 7.2安装MongoDB 4.0.5</h2><h4 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h4><blockquote>
<p><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">MongoDB官网</a>下载安装包上传至服务器或者获取下载链接使用wget命令</p>
</blockquote>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E5%AE%98%E7%BD%91.png" alt="MongoDB官网"></p>
<blockquote>
<p>创建mongdb目录，使用wget命令下载压缩包</p>
</blockquote>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E4%B8%8B%E8%BD%BD.png" alt="MongoDB下载"></p>
<h4 id="2-解压压缩包"><a href="#2-解压压缩包" class="headerlink" title="2. 解压压缩包"></a>2. 解压压缩包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos mongodb]# tar zxvf mongodb-linux-x86_64-4.0.5.tgz</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E8%A7%A3%E5%8E%8B.png" alt="MongoDB解压"></p>
<h4 id="3-新建data文件夹用于存放数据，logs文件夹存放日志"><a href="#3-新建data文件夹用于存放数据，logs文件夹存放日志" class="headerlink" title="3. 新建data文件夹用于存放数据，logs文件夹存放日志"></a>3. 新建data文件夹用于存放数据，logs文件夹存放日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos mongodb-linux-x86_64-4.0.5]# mkdir data</span><br><span class="line">[root@VM_0_5_centos mongodb-linux-x86_64-4.0.5]# mkdir logs</span><br><span class="line">[root@VM_0_5_centos mongodb-linux-x86_64-4.0.5]# ls</span><br><span class="line">bin  data  LICENSE-Community.txt  logs  MPL-2  README  THIRD-PARTY-NOTICES</span><br></pre></td></tr></table></figure>

<h4 id="4-新建一个配置文件mongodb-conf"><a href="#4-新建一个配置文件mongodb-conf" class="headerlink" title="4. 新建一个配置文件mongodb.conf"></a>4. 新建一个配置文件mongodb.conf</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="MongoDB配置文件"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#端口</span><br><span class="line">port=27017</span><br><span class="line">#数据库存文件存放目录</span><br><span class="line">dbpath=/usr/local/mongodb/mongodb-linux-x86_64-4.0.5/data</span><br><span class="line">#日志文件存放路径</span><br><span class="line">logpath=/usr/local/mongodb/mongodb-linux-x86_64-4.0.5/data/mongodb.log</span><br><span class="line">#使用追加的方式写日志</span><br><span class="line">logappend=true</span><br><span class="line">#在后台运行</span><br><span class="line">fork=true </span><br><span class="line">#最大同时连接数</span><br><span class="line">maxConns=100</span><br><span class="line">#不启用验证</span><br><span class="line">noauth=true</span><br><span class="line">#每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）</span><br><span class="line">journal=true</span><br><span class="line">#存储引擎有mmapv1、wiretiger、mongorocks，即使宕机，启动时wiredtiger会先将数据恢复到最近一次的checkpoint点，然后重放后续的journal日志来恢复。</span><br><span class="line">storageEngine=wiredTiger</span><br><span class="line">#配置外部访问</span><br><span class="line">bind_ip = 0.0.0.0</span><br></pre></td></tr></table></figure>

<h4 id="5-用配置文件启动MongoDB"><a href="#5-用配置文件启动MongoDB" class="headerlink" title="5. 用配置文件启动MongoDB"></a>5. 用配置文件启动MongoDB</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos bin]# ./mongod --config /usr/local/mongodb/mongodb-linux-x86_64-4.0.5/mongodb.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 26478</span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure>

<h4 id="6-用RoBo连接MongoDB"><a href="#6-用RoBo连接MongoDB" class="headerlink" title="6. 用RoBo连接MongoDB"></a>6. 用RoBo连接MongoDB</h4><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E8%BF%9E%E6%8E%A51.png" alt="MongoDB连接1"></p>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E8%BF%9E%E6%8E%A52.png" alt="MongoDB连接2"></p>
<h4 id="7-java连接MongoDB"><a href="#7-java连接MongoDB" class="headerlink" title="7. java连接MongoDB"></a>7. java连接MongoDB</h4><blockquote>
<p>出现报错</p>
</blockquote>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/MongoDB%E6%8A%A5%E9%94%99.png" alt="MongoDB报错"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/07/23/Linux-install_MongoDB4.0.5/" data-id="ckmh9ucif000a3oumax7aby1s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CentOS/">CentOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MongoDB/">MongoDB</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-install_MySql5.7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/Linux-install_MySql5.7/" class="article-date">
  <time datetime="2019-07-22T16:00:00.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>►<a class="article-category-link" href="/categories/Linux/CentOS/">CentOS</a>►<a class="article-category-link" href="/categories/Linux/CentOS/MySql/">MySql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/Linux-install_MySql5.7/">CentOS 7.2 安装MySql 5.7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CentOS-7-2-安装MySql-5-7"><a href="#CentOS-7-2-安装MySql-5-7" class="headerlink" title="CentOS 7.2 安装MySql 5.7"></a>CentOS 7.2 安装MySql 5.7</h2><h4 id="1-下载rpm包"><a href="#1-下载rpm包" class="headerlink" title="1. 下载rpm包"></a>1. 下载rpm包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# wget http://repo.mysql.com//mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E4%B8%8B%E8%BD%BD.png" alt="mysql下载"></p>
<h4 id="2-下载安装软件源"><a href="#2-下载安装软件源" class="headerlink" title="2. 下载安装软件源"></a>2. 下载安装软件源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# yum localinstall mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E5%AE%89%E8%A3%85.png" alt="mysql安装"></p>
<h4 id="3-查看系统是否添加该源"><a href="#3-查看系统是否添加该源" class="headerlink" title="3. 查看系统是否添加该源"></a>3. 查看系统是否添加该源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# yum repolist all | grep mysql</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E6%BA%90.png" alt="mysql源"></p>
<h4 id="4-安装MySql"><a href="#4-安装MySql" class="headerlink" title="4. 安装MySql"></a>4. 安装MySql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# yum install mysql-community-server.x86_64</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B.png" alt="mysql安装过程"></p>
<h4 id="5-启动MySql-Server"><a href="#5-启动MySql-Server" class="headerlink" title="5. 启动MySql Server"></a>5. 启动MySql Server</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>启动Mysql</span><br><span class="line">[root@VM_0_5_centos home]# systemctl start mysqld</span><br><span class="line"><span class="meta">#</span>查看启动状态</span><br><span class="line">[root@VM_0_5_centos home]# systemctl status mysqld</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E5%90%AF%E5%8A%A8.png" alt="mysql启动"></p>
<h4 id="6-查看MySQL随机临时密码"><a href="#6-查看MySQL随机临时密码" class="headerlink" title="6. 查看MySQL随机临时密码"></a>6. 查看MySQL随机临时密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# grep 'temporary password' /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E4%B8%B4%E6%97%B6%E5%AF%86%E7%A0%81.png" alt="mysql临时密码"></p>
<h4 id="7-修改MySql密码"><a href="#7-修改MySql密码" class="headerlink" title="7. 修改MySql密码"></a>7. 修改MySql密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%8A%A5%E9%94%99.png" alt="mysql修改密码报错"></p>
<blockquote>
<p>MySQL里带了一个密码验证的插件来防止密码设置过于简单。</p>
<p>密码要求：</p>
<ul>
<li>特殊字符</li>
<li>大小写字母</li>
<li>数字</li>
<li>长度8位</li>
</ul>
<p>实例密码：Fangchy1120.！</p>
</blockquote>
<h4 id="8-登录MySql修改密码"><a href="#8-登录MySql修改密码" class="headerlink" title="8. 登录MySql修改密码"></a>8. 登录MySql修改密码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos home]# mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E6%8A%A5%E9%94%99.png" alt="mysql报错"></p>
<blockquote>
<p>原来MySQL5.6.6版本之后增加了密码强度验证插件validate_password，相关参数设置的较为严格。<br>使用了该插件会检查设置的密码是否符合当前设置的强度规则，若不满足则拒绝设置。影响的语句和函数有：create user,grant,set password,password(),old password。</p>
</blockquote>
<ol>
<li><strong>查看mysql全局参数</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &apos;validate_password%&apos;;</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">| validate_password_check_user_name    | OFF    |</span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 8      |</span><br><span class="line">| validate_password_mixed_case_count   | 1      |</span><br><span class="line">| validate_password_number_count       | 1      |</span><br><span class="line">| validate_password_policy             | MEDIUM |</span><br><span class="line">| validate_password_special_char_count | 1      |</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>参数解释</strong></p>
<blockquote>
<ul>
<li><p>validate_password_dictionary_file</p>
<p>插件用于验证密码强度的字典文件路径。</p>
</li>
<li><p>validate_password_length</p>
<p>密码最小长度，参数默认为8，它有最小值的限制，最小值为：validate_password_number_count + validate_password_special_char_count + (2 * validate_password_mixed_case_count)</p>
</li>
<li><p>validate_password_mixed_case_count</p>
<p>密码至少要包含的小写字母个数和大写字母个数。</p>
</li>
<li><p>validate_password_number_count</p>
<p>密码至少要包含的数字个数。</p>
</li>
<li><p>validate_password_policy</p>
<p>密码强度检查等级，0/LOW、1/MEDIUM、2/STRONG。有以下取值：</p>
<table>
<thead>
<tr>
<th>Policy</th>
<th>Tests Performed</th>
</tr>
</thead>
<tbody><tr>
<td>0 or LOW</td>
<td>Length</td>
</tr>
<tr>
<td>1 or MEDIUM</td>
<td>Length; numeric, lowercase/uppercase, and special characters</td>
</tr>
<tr>
<td>2 or STRONG</td>
<td>Length; numeric, lowercase/uppercase, and special characters; dictionary file</td>
</tr>
</tbody></table>
<p>默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。</p>
</li>
<li><p>validate_password_special_char_count</p>
<p>密码至少要包含的特殊字符数。  </p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>修改上面的各项参数，全部执行成功</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_mixed_case_count=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_number_count=3;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_special_char_count=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set global validate_password_length=3;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>查看修改后的参数</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;validate_password%&apos;;</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| Variable_name                        | Value |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| validate_password_check_user_name    | OFF   |</span><br><span class="line">| validate_password_dictionary_file    |       |</span><br><span class="line">| validate_password_length             | 3     |</span><br><span class="line">| validate_password_mixed_case_count   | 0     |</span><br><span class="line">| validate_password_number_count       | 3     |</span><br><span class="line">| validate_password_policy             | LOW   |</span><br><span class="line">| validate_password_special_char_count | 0     |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>修改成简单密码</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>使用新密码登录</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_0_5_centos ~]# mysql -uroot -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 16</span><br><span class="line">Server version: 5.7.24 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>配置远程连接(腾讯云不需要配置端口)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>查看mysql端口</span><br><span class="line">[root@VM_0_5_centos ~]# netstat -ntlp|grep 3306</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      13929/mysqld</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置远程连接，赋予任何主机上以root身份访问数据的权限 </span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/mysql%E8%BF%9E%E6%8E%A51.png" alt="mysql连接1"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/07/23/Linux-install_MySql5.7/" data-id="ckmh9ucin000f3oumiro8ii3g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CentOS/">CentOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/">MySql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-Java基础笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/20/Java-Java基础笔记/" class="article-date">
  <time datetime="2019-07-19T16:00:00.000Z" itemprop="datePublished">2019-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/20/Java-Java基础笔记/">Java基础笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="Java基础笔记"><a href="#Java基础笔记" class="headerlink" title="Java基础笔记"></a>Java基础笔记</h1><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h2><h3 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h3><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p>
<p><strong>特点：关键字中所字母都为小写</strong></p>
<p>具体如下：</p>
<ul>
<li><p>用于定义数据类型的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>interface</td>
<td>enum</td>
<td>byte</td>
<td>short</td>
</tr>
<tr>
<td>int</td>
<td>long</td>
<td>float</td>
<td>double</td>
<td>char</td>
</tr>
<tr>
<td>boolean</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义流程控制的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>if</td>
<td>else</td>
<td>switch</td>
<td>case</td>
<td>default</td>
</tr>
<tr>
<td>while</td>
<td>do</td>
<td>for</td>
<td>break</td>
<td>continue</td>
</tr>
<tr>
<td>return</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义访问权限修饰符的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义类、函数、变量修饰符的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>abstract</td>
<td>final</td>
<td>static</td>
<td>synchronized</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义类与类之间关系的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>extents</td>
<td>implements</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义建立实例及引用实例、判断实例的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>new</td>
<td>this</td>
<td>super</td>
<td>instanceof</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于异常处理的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>try</td>
<td>catch</td>
<td>finally</td>
<td>throw</td>
<td>throws</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-2保留字"><a href="#1-2保留字" class="headerlink" title="1.2保留字"></a>1.2保留字</h3><p>goto、const</p>
<h3 id="1-3标识符"><a href="#1-3标识符" class="headerlink" title="1.3标识符"></a>1.3标识符</h3><p>定义：凡是自己可以起名字的地方都叫标识符</p>
<p>涉及到的结构：包名、类名、接口名、变量名、方法名、常量名</p>
<p>规则：</p>
<ul>
<li><strong>由26个英文字母大小写，0-9，_或$组成</strong></li>
<li><strong>数字不可以开头</strong></li>
<li><strong>不可以使用关键字和保留字，但能包含关键字和保留字</strong></li>
<li><strong>Java中严格区分大小写，长度无限制</strong></li>
<li><strong>标识符不能包含空格</strong></li>
</ul>
<p>规范：</p>
<ul>
<li>包名：多单词组成时所有字符都小写</li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
<li>变量名、方法名：多单词组成时，第一个单词的首字母小写，第二个单词开始每个单词首字母大写：XxxYyyZzz</li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ul>
<h3 id="1-4变量"><a href="#1-4变量" class="headerlink" title="1.4变量"></a>1.4变量</h3><ol>
<li><p>变量的分类</p>
<ol>
<li><p>按数据类型分类</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522100724.png" alt></p>
</li>
<li><p>详细说明</p>
<ol>
<li>整型：byte(1字节=8bit) \ short(2字节) \ int(4字节) \ long(8字节)<ul>
<li>① byte范围：-128 ~ 127</li>
<li>② 声明long型变量，必须以”l”或”L”结尾</li>
<li>③ 通常，定义整型变量时，使用int型。</li>
<li>④整型的常量，默认类型是：int型</li>
</ul>
</li>
<li>浮点型：float(4字节) \ double(8字节)<ul>
<li>① 浮点型，表示带小数点的数值</li>
<li>② float表示数值的范围比long还大</li>
<li>③ 定义float类型变量时，变量要以”f”或”F”结尾</li>
<li>④ 通常，定义浮点型变量时，使用double型。</li>
<li>⑤ 浮点型的常量，默认类型为：double</li>
</ul>
</li>
<li>字符型：char (1字符=2字节)<ul>
<li>① 定义char型变量，通常使用一对’’,内部只能写一个字符</li>
<li>② 表示方式：1.声明一个字符 2.转义字符 3.直接使用 Unicode 值来表示字符型常量</li>
</ul>
</li>
<li>布尔型：boolean<ul>
<li>① 只能取两个值之一：true 、 false</li>
<li>② 常常在条件判断、循环结构中使用</li>
</ul>
</li>
</ol>
</li>
<li><p>按声明的位置分类</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522123945.png" alt></p>
</li>
</ol>
</li>
<li><p>定义变量的格式</p>
<p> 数据类型  变量名 = 变量值;<br> 数据类型  变量名;<br> 变量名 = 变量值;</p>
</li>
<li><p>变量使用的注意点</p>
<ul>
<li>变量必须先声明，后使用</li>
<li>变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了</li>
<li>同一个作用域内，不可以声明两个同名的变量</li>
</ul>
</li>
<li><p>基本数据类型变量间运算规则</p>
<ol>
<li><p>涉及到的基本数据类型：除了boolean之外的其他7种</p>
</li>
<li><p>自动类型转换(只涉及7种基本数据类型）</p>
<p> 结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果<strong>自动提升为容量大</strong>的数据类型。</p>
<blockquote>
<p>byte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double </p>
<p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p>
<p><strong>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</strong></p>
</blockquote>
</li>
<li><p>强制类型转换(只涉及7种基本数据类型）：<strong>自动类型提升运算的逆运算</strong>。</p>
<ol>
<li>需要使用强转符：(类型)</li>
<li>注意点：强制类型转换，可能导致精度损失。</li>
</ol>
</li>
<li><p>String与8种基本数据类型间的运算</p>
<ol>
<li><p>String属于引用数据类型，翻译为：字符串</p>
</li>
<li><p>声明String类型变量时，使用一对””</p>
</li>
<li><p>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</p>
</li>
<li><p>运算的结果仍然是String类型</p>
<p>避免：</p>
<p>String s = 123;//编译错误</p>
<p>String s1 = “123”;</p>
<p>int i = (int)s1;//编译错误</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="1-5运算符"><a href="#1-5运算符" class="headerlink" title="1.5运算符"></a>1.5运算符</h3><ol>
<li><p>算数运算符： + - * / % (前)++ (后)++ (前)– (后)– </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="comment">//除号：/</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> result1 = num1 / num2;</span><br><span class="line">System.out.println(result1);<span class="comment">//2</span></span><br><span class="line"><span class="comment">// %:取余运算</span></span><br><span class="line"><span class="comment">//结果的符号与被模数的符号相同</span></span><br><span class="line"><span class="comment">//开发中，经常使用%来判断能否被除尽的情况。</span></span><br><span class="line"><span class="keyword">int</span> m1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m1 % n1 = "</span> + m1 % n1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m2 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m2 % n2 = "</span> + m2 % n2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m3 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n3 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m3 % n3 = "</span> + m3 % n3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m4 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n4 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m4 % n4 = "</span> + m4 % n4);</span><br><span class="line"><span class="comment">//(前)++ :先自增1，后运算</span></span><br><span class="line"><span class="comment">//(后)++ :先运算，后自增1</span></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = ++a1;</span><br><span class="line">System.out.println(<span class="string">"a1 = "</span> + a1 + <span class="string">",b1 = "</span> + b1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = a2++;</span><br><span class="line">System.out.println(<span class="string">"a2 = "</span> + a2 + <span class="string">",b2 = "</span> + b2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">++a3;<span class="comment">//a3++;</span></span><br><span class="line"><span class="keyword">int</span> b3 = a3;</span><br><span class="line"><span class="comment">//(前)-- :先自减1，后运算</span></span><br><span class="line"><span class="comment">//(后)-- :先运算，后自减1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b4 = a4--;<span class="comment">//int b4 = --a4;</span></span><br><span class="line">System.out.println(<span class="string">"a4 = "</span> + a4 + <span class="string">",b4 = "</span> + b4);</span><br><span class="line"></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>.<span class="comment">//(前)++ :先自增1，后运算</span></span><br><span class="line"> <span class="comment">//(后)++ :先运算，后自增1</span></span><br><span class="line"><span class="number">2</span>.<span class="comment">//(前)-- :先自减1，后运算</span></span><br><span class="line">  <span class="comment">//(后)-- :先运算，后自减1</span></span><br><span class="line"><span class="number">3</span>.连接符：+：只能使用在String与其他数据类型变量之间使用。</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值运算符：=  +=  -=  *=  /=  %= </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i2,j2;</span><br><span class="line"><span class="comment">//连续赋值</span></span><br><span class="line">i2 = j2 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//***************</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">10</span>,j3 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">num1 += <span class="number">2</span>;<span class="comment">//num1 = num1 + 2;</span></span><br><span class="line">System.out.println(num1);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">12</span>;</span><br><span class="line">num2 %= <span class="number">5</span>;<span class="comment">//num2 = num2 % 5;</span></span><br><span class="line">System.out.println(num2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//s1 = s1 + 2;//编译失败</span></span><br><span class="line">s1 += <span class="number">2</span>;<span class="comment">//结论：不会改变变量本身的数据类型</span></span><br><span class="line">System.out.println(s1);</span><br><span class="line"></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>.运算的结果不会改变变量本身的数据类型</span><br><span class="line"><span class="number">2</span>.</span><br><span class="line"><span class="comment">//开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 2;</span></span><br><span class="line"><span class="comment">//方式二：num += 2; (推荐)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 1;</span></span><br><span class="line"><span class="comment">//方式二：num += 1; </span></span><br><span class="line"><span class="comment">//方式三：num++; (推荐)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较运算符： == != &gt;  &lt;  &gt;=  &lt;=  instanceof</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line">System.out.println(i = j);<span class="comment">//20</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(b2 == b1);<span class="comment">//false</span></span><br><span class="line">System.out.println(b2 = b1);<span class="comment">//true</span></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>.比较运算符的结果是<span class="keyword">boolean</span>类型</span><br><span class="line"><span class="number">2</span>.&gt;  &lt;  &gt;=  &lt;= :只能使用在数值类型的数据之间。</span><br><span class="line"><span class="number">3</span>. == 和 !=: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</span><br><span class="line">Account acct1 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">Account acct2 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">boolean</span> b1 = (acct1 == acct2);<span class="comment">//比较两个Account是否是同一个账户。</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = (acct1 != acct2);<span class="comment">//</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符：&amp; &amp;&amp;  |  || !  ^</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="comment">//区分&amp; 与 &amp;&amp;</span></span><br><span class="line"><span class="comment">//相同点1：&amp; 与  &amp;&amp; 的运算结果相同</span></span><br><span class="line"><span class="comment">//相同点2：当符号左边是true时，二者都会执行符号右边的运算</span></span><br><span class="line"><span class="comment">//不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</span></span><br><span class="line"><span class="comment">//开发中，推荐使用&amp;&amp;</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">b1 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b1 &amp; (num1++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在北京"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在南京"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">true</span>;</span><br><span class="line">b2 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b2 &amp;&amp; (num2++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在北京"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在南京"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line"><span class="comment">// 区分：| 与 || </span></span><br><span class="line"><span class="comment">//相同点1：| 与  || 的运算结果相同</span></span><br><span class="line"><span class="comment">//相同点2：当符号左边是false时，二者都会执行符号右边的运算</span></span><br><span class="line"><span class="comment">//不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</span></span><br><span class="line"><span class="comment">//开发中，推荐使用||</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = <span class="keyword">false</span>;</span><br><span class="line">b3 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b3 | (num3++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在北京"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在南京"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"num3 = "</span> + num3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b4 = <span class="keyword">false</span>;</span><br><span class="line">b4 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num4 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b4 || (num4++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在北京"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我现在在南京"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"num4 = "</span> + num4);</span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>.逻辑运算符操作的都是<span class="keyword">boolean</span>类型的变量。而且结果也是<span class="keyword">boolean</span>类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算符：&lt;&lt;  &gt;&gt; &gt;&gt;&gt; &amp;  |  ^  ~</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">21</span>;</span><br><span class="line">i = -<span class="number">21</span>;</span><br><span class="line">System.out.println(<span class="string">"i &lt;&lt; 2 :"</span> + (i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">"i &lt;&lt; 3 :"</span> + (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">"i &lt;&lt; 27 :"</span> + (i &lt;&lt; <span class="number">27</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">"m &amp; n :"</span> + (m &amp; n));</span><br><span class="line">System.out.println(<span class="string">"m | n :"</span> + (m | n));</span><br><span class="line">System.out.println(<span class="string">"m ^ n :"</span> + (m ^ n));</span><br><span class="line">【面试题】 你能否写出最高效的<span class="number">2</span> * <span class="number">8</span>的实现方式？ </span><br><span class="line">答案：<span class="number">2</span> &lt;&lt; <span class="number">3</span>  或  <span class="number">8</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>. 位运算符操作的都是整型的数据</span><br><span class="line"><span class="number">2</span>. &lt;&lt; ：在一定范围内，每向左移<span class="number">1</span>位，相当于 * <span class="number">2</span></span><br><span class="line">   &gt;&gt; :在一定范围内，每向右移<span class="number">1</span>位，相当于 / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">典型题目：</span><br><span class="line"><span class="number">1</span>.交换两个变量的值。</span><br><span class="line"><span class="number">2</span>.实现<span class="number">60</span>的二进制到十六进制的转换</span><br></pre></td></tr></table></figure>
</li>
<li><p>三元运算符：(条件表达式)? 表达式1 : 表达式2</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="number">1</span>.获取两个整数的较大值</span><br><span class="line"><span class="number">2</span>.获取三个数的最大值</span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1</span>. 说明</span><br><span class="line">① 条件表达式的结果为<span class="keyword">boolean</span>类型</span><br><span class="line">② 根据条件表达式真或假，决定执行表达式<span class="number">1</span>，还是表达式<span class="number">2</span>.</span><br><span class="line">  如果表达式为<span class="keyword">true</span>，则执行表达式<span class="number">1</span>。</span><br><span class="line">  如果表达式为<span class="keyword">false</span>，则执行表达式<span class="number">2</span>。</span><br><span class="line">③ 表达式<span class="number">1</span> 和表达式<span class="number">2</span>要求是一致的。</span><br><span class="line">④ 三元运算符可以嵌套使用</span><br><span class="line"><span class="number">2</span>. 凡是可以使用三元运算符的地方，都可以改写为<span class="keyword">if</span>-<span class="keyword">else</span>，反之，不成立。</span><br><span class="line"><span class="number">3</span>. 如果程序既可以使用三元运算符，又可以使用<span class="keyword">if</span>-<span class="keyword">else</span>结构，那么优先选择三元运算符。原因：简洁、执行效率高。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="1-6流程控制"><a href="#1-6流程控制" class="headerlink" title="1.6流程控制"></a>1.6流程控制</h3><ol>
<li><p>分支结构</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">if</span>-<span class="keyword">else</span>条件判断结构</span><br><span class="line"><span class="number">1.1</span>.</span><br><span class="line">结构一：</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构二：二选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构三：n选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	执行表达式n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span>.说明：</span><br><span class="line"><span class="number">1</span>. <span class="keyword">else</span> 结构是可选的。</span><br><span class="line"><span class="number">2</span>. 针对于条件表达式：</span><br><span class="line">   &gt; 如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。</span><br><span class="line">   &gt; 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。</span><br><span class="line">   &gt; 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。</span><br><span class="line"><span class="number">3</span>. <span class="keyword">if</span>-<span class="keyword">else</span>结构是可以相互嵌套的。</span><br><span class="line"><span class="number">4</span>. 如果<span class="keyword">if</span>-<span class="keyword">else</span>结构中的执行语句只有一行时，对应的一对&#123;&#125;可以省略的。但是，不建议大家省略。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.<span class="keyword">switch</span>-<span class="keyword">case</span>选择结构</span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">	执行语句<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">	执行语句<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	执行语句n;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>.说明：</span><br><span class="line">① 根据<span class="keyword">switch</span>表达式中的值，依次匹配各个<span class="keyword">case</span>中的常量。一旦匹配成功，则进入相应<span class="keyword">case</span>结构中，调用其执行语句。</span><br><span class="line">  当调用完执行语句以后，则仍然继续向下执行其他<span class="keyword">case</span>结构中的执行语句，直到遇到<span class="keyword">break</span>关键字或此<span class="keyword">switch</span>-<span class="keyword">case</span>结构</span><br><span class="line">  末尾结束为止。</span><br><span class="line">② <span class="keyword">break</span>,可以使用在<span class="keyword">switch</span>-<span class="keyword">case</span>结构中，表示一旦执行到此关键字，就跳出<span class="keyword">switch</span>-<span class="keyword">case</span>结构</span><br><span class="line">③ <span class="keyword">switch</span>结构中的表达式，只能是如下的<span class="number">6</span>种数据类型之一：</span><br><span class="line">   <span class="keyword">byte</span> 、<span class="keyword">short</span>、<span class="keyword">char</span>、<span class="keyword">int</span>、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)</span><br><span class="line">④ <span class="keyword">case</span> 之后只能声明常量。不能声明范围。</span><br><span class="line">⑤ <span class="keyword">break</span>关键字是可选的。</span><br><span class="line">⑥ <span class="keyword">default</span>:相当于<span class="keyword">if</span>-<span class="keyword">else</span>结构中的<span class="keyword">else</span>.  </span><br><span class="line">  <span class="keyword">default</span>结构是可选的，而且位置是灵活的。</span><br><span class="line"><span class="number">3</span>.如果<span class="keyword">switch</span>-<span class="keyword">case</span>结构中的多个<span class="keyword">case</span>的执行语句相同，则可以考虑进行合并。</span><br><span class="line"><span class="number">4</span>.<span class="keyword">break</span>在<span class="keyword">switch</span>-<span class="keyword">case</span>中是可选的</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环结构</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.循环结构的四要素</span><br><span class="line">① 初始化条件</span><br><span class="line">② 循环条件  ---&gt;是<span class="keyword">boolean</span>类型</span><br><span class="line">③ 循环体</span><br><span class="line">④ 迭代条件</span><br><span class="line">说明：通常情况下，循环结束都是因为②中循环条件返回<span class="keyword">false</span>了。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.三种循环结构：</span><br><span class="line"><span class="number">2.1</span> <span class="keyword">for</span>循环结构</span><br><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">	③</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"><span class="number">2.2</span> <span class="keyword">while</span>循环结构</span><br><span class="line">①</span><br><span class="line"><span class="keyword">while</span>(②)&#123;</span><br><span class="line">	③;</span><br><span class="line">	④;</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line">说明：</span><br><span class="line">写<span class="keyword">while</span>循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>和<span class="keyword">while</span>循环总结：</span><br><span class="line"><span class="number">1</span>. 开发中，基本上我们都会从<span class="keyword">for</span>、<span class="keyword">while</span>中进行选择，实现循环结构。</span><br><span class="line"><span class="number">2</span>. <span class="keyword">for</span>循环和<span class="keyword">while</span>循环是可以相互转换的！ </span><br><span class="line">  区别：<span class="keyword">for</span>循环和<span class="keyword">while</span>循环的初始化条件部分的作用范围不同。</span><br><span class="line"><span class="number">3</span>. 我们写程序，要避免出现死循环。</span><br><span class="line"><span class="number">2.3</span> <span class="keyword">do</span>-<span class="keyword">while</span>循环结构</span><br><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	③;</span><br><span class="line">	④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br><span class="line">执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>.<span class="keyword">do</span>-<span class="keyword">while</span>循环至少会执行一次循环体！</span><br><span class="line"><span class="number">2</span>.开发中，使用<span class="keyword">for</span>和<span class="keyword">while</span>更多一些。较少使用<span class="keyword">do</span>-<span class="keyword">while</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.“无限循环”结构: <span class="keyword">while</span>(<span class="keyword">true</span>) 或 <span class="keyword">for</span>(;;)</span><br><span class="line">总结：如何结束一个循环结构？</span><br><span class="line">方式一：当循环条件是<span class="keyword">false</span>时</span><br><span class="line">方式二：在循环体中，执行<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.嵌套循环</span><br><span class="line"><span class="number">1</span>.嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环</span><br><span class="line">  内层循环：循环结构A</span><br><span class="line">  外层循环：循环结构B</span><br><span class="line"><span class="number">2</span>.说明：</span><br><span class="line">① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</span><br><span class="line">② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次</span><br><span class="line">③ 外层循环控制行数，内层循环控制列数</span><br><span class="line">【典型练习】</span><br><span class="line">		<span class="comment">//练习一：</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		******</span></span><br><span class="line"><span class="comment">		******</span></span><br><span class="line"><span class="comment">		******</span></span><br><span class="line"><span class="comment">		******</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">4</span>;j++ )&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">6</span>;i++)&#123;</span><br><span class="line">				System.out.print(<span class="string">'*'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//练习二：</span></span><br><span class="line">		<span class="comment">/*			i(行号)		j(*的个数)</span></span><br><span class="line"><span class="comment">		*			1			1</span></span><br><span class="line"><span class="comment">		**			2			2</span></span><br><span class="line"><span class="comment">		***			3			3</span></span><br><span class="line"><span class="comment">		****		4			4</span></span><br><span class="line"><span class="comment">		*****		5			5</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;<span class="comment">//控制行数</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)&#123;<span class="comment">//控制列数</span></span><br><span class="line">				System.out.print(<span class="string">"*"</span>);</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//练习三：九九乘法表</span></span><br><span class="line">		<span class="comment">//练习四：100以内的质数</span></span><br><span class="line"></span><br><span class="line">补充:衡量一个功能代码的优劣：</span><br><span class="line"><span class="number">1</span>.正确性</span><br><span class="line"><span class="number">2</span>.可读性</span><br><span class="line"><span class="number">3</span>.健壮性</span><br><span class="line"><span class="number">4</span>.高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</span><br><span class="line"></span><br><span class="line">如何理解流程控制的练习：</span><br><span class="line">流程控制结构的使用 + 算法逻辑</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>关键字：break和continue</p>
<table>
<thead>
<tr>
<th></th>
<th>使用范围</th>
<th>循环中使用的作用(不同点)</th>
<th>相同点</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>switch-case循环结构中</td>
<td>结束当前循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
<tr>
<td>continue</td>
<td>循环结构中</td>
<td>结束当次循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
</tbody></table>
<p> 补充：带标签的break和continue的使用</p>
<p> ​            return在方法中使用。</p>
</li>
<li><p>补充：Scanner类的使用</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何从键盘获取不同类型的变量：需要使用Scanner类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">具体实现步骤：</span></span><br><span class="line"><span class="comment">1.导包：import java.util.Scanner;</span></span><br><span class="line"><span class="comment">2.Scanner的实例化:Scanner scan = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">3.调用Scanner类的相关方法（next() / nextXxx()），来获取指定类型的变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException</span></span><br><span class="line"><span class="comment">导致程序终止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.导包：import java.util.Scanner;</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//2.Scanner的实例化</span></span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.调用Scanner类的相关方法</span></span><br><span class="line">		System.out.println(<span class="string">"请输入你的姓名："</span>);</span><br><span class="line">		String name = scan.next();</span><br><span class="line">		System.out.println(name);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"请输入你的芳龄："</span>);</span><br><span class="line">		<span class="keyword">int</span> age = scan.nextInt();</span><br><span class="line">		System.out.println(age);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"请输入你的体重："</span>);</span><br><span class="line">		<span class="keyword">double</span> weight = scan.nextDouble();</span><br><span class="line">		System.out.println(weight);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"你是否相中我了呢？(true/false)"</span>);</span><br><span class="line">		<span class="keyword">boolean</span> isLove = scan.nextBoolean();</span><br><span class="line">		System.out.println(isLove);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串</span></span><br><span class="line">		System.out.println(<span class="string">"请输入你的性别：(男/女)"</span>);</span><br><span class="line">		String gender = scan.next();<span class="comment">//"男"</span></span><br><span class="line">		<span class="keyword">char</span> genderChar = gender.charAt(<span class="number">0</span>);<span class="comment">//获取索引为0位置上的字符</span></span><br><span class="line">		System.out.println(genderChar);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h3 id="2-1一维数组"><a href="#2-1一维数组" class="headerlink" title="2.1一维数组"></a>2.1一维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.一维数组的声明与初始化</span><br><span class="line">正确的方式：</span><br><span class="line">	<span class="keyword">int</span> num;<span class="comment">//声明</span></span><br><span class="line">	num = <span class="number">10</span>;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">1001</span>;<span class="comment">//声明 + 初始化</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line">	<span class="comment">//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">	ids = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line">	<span class="comment">//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">	String[] names = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">错误的方式：</span><br><span class="line"><span class="comment">//		int[] arr1 = new int[];</span></span><br><span class="line"><span class="comment">//		int[5] arr2 = new int[5];</span></span><br><span class="line"><span class="comment">//		int[] arr3 = new int[3]&#123;1,2,3&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.一维数组元素的引用：通过角标的方式调用。</span><br><span class="line">		<span class="comment">//数组的角标（或索引从0开始的，到数组的长度-1结束。</span></span><br><span class="line">		names[<span class="number">0</span>] = <span class="string">"王铭"</span>;</span><br><span class="line">		names[<span class="number">1</span>] = <span class="string">"王赫"</span>;</span><br><span class="line">		names[<span class="number">2</span>] = <span class="string">"张学良"</span>;</span><br><span class="line">		names[<span class="number">3</span>] = <span class="string">"孙居龙"</span>;</span><br><span class="line">		names[<span class="number">4</span>] = <span class="string">"王宏志"</span>;<span class="comment">//charAt(0)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.数组的属性：length</span><br><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br><span class="line">System.out.println(ids.length);</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">数组一旦初始化，其长度就是确定的。arr.length</span><br><span class="line">数组长度一旦确定，就不可修改。</span><br><span class="line"><span class="number">4</span>.一维数组的遍历</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; names.length;i++)&#123;</span><br><span class="line">	System.out.println(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span>.一维数组元素的默认初始化值</span><br><span class="line">		&gt; 数组元素是整型：<span class="number">0</span></span><br><span class="line"> * 		&gt; 数组元素是浮点型：<span class="number">0.0</span></span><br><span class="line"> * 		&gt; 数组元素是<span class="keyword">char</span>型：<span class="number">0</span>或<span class="string">'\u0000'</span>，而非<span class="string">'0'</span></span><br><span class="line"> * 		&gt; 数组元素是<span class="keyword">boolean</span>型：<span class="keyword">false</span></span><br><span class="line"> * </span><br><span class="line"> * 		&gt; 数组元素是引用数据类型：<span class="keyword">null</span></span><br><span class="line"><span class="number">6</span>.一维数组的内存解析</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130221.png" alt></p>
<h3 id="2-2二维数组"><a href="#2-2二维数组" class="headerlink" title="2.2二维数组"></a>2.2二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.如何理解二维数组？</span><br><span class="line">数组属于引用数据类型</span><br><span class="line">数组的元素也可以是引用数据类型</span><br><span class="line">一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.二维数组的声明与初始化</span><br><span class="line">正确的方式：</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一维数组</span></span><br><span class="line">	<span class="comment">//静态初始化</span></span><br><span class="line">	<span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">	<span class="comment">//动态初始化1</span></span><br><span class="line">	String[][] arr2 = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="comment">//动态初始化2</span></span><br><span class="line">	String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];</span><br><span class="line">	<span class="comment">//也是正确的写法：</span></span><br><span class="line">	<span class="keyword">int</span>[] arr4[] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;<span class="comment">//类型推断</span></span><br><span class="line">错误的方式：</span><br><span class="line"><span class="comment">//		String[][] arr4 = new String[][4];</span></span><br><span class="line"><span class="comment">//		String[4][3] arr5 = new String[][];</span></span><br><span class="line"><span class="comment">//		int[][] arr6 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span></span><br><span class="line"><span class="number">3</span>.如何调用二维数组元素:</span><br><span class="line">	System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">	System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//null</span></span><br><span class="line">	</span><br><span class="line">	arr3[<span class="number">1</span>] = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">	System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">	System.out.println(arr3[<span class="number">0</span>]);<span class="comment">//</span></span><br><span class="line"><span class="number">4</span>.二维数组的属性：</span><br><span class="line">	System.out.println(arr4.length);<span class="comment">//3</span></span><br><span class="line">	System.out.println(arr4[<span class="number">0</span>].length);<span class="comment">//3</span></span><br><span class="line">	System.out.println(arr4[<span class="number">1</span>].length);<span class="comment">//4</span></span><br><span class="line"><span class="number">5</span>.遍历二维数组元素</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr4.length;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr4[i].length;j++)&#123;</span><br><span class="line">			System.out.print(arr4[i][j] + <span class="string">"  "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.二维数组元素的默认初始化值</span><br><span class="line"> * 	规定：二维数组分为外层数组的元素，内层数组的元素</span><br><span class="line"> * 		<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"> * 		外层元素：arr[<span class="number">0</span>],arr[<span class="number">1</span>]等</span><br><span class="line"> * 		内层元素：arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">2</span>]等</span><br><span class="line"> * </span><br><span class="line"> *   ⑤ 数组元素的默认初始化值 </span><br><span class="line"> *   针对于初始化方式一：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"> *      外层元素的初始化值为：地址值</span><br><span class="line"> *      内层元素的初始化值为：与一维数组初始化情况相同</span><br><span class="line"> *      </span><br><span class="line"> *   针对于初始化方式二：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line"> *   	外层元素的初始化值为：<span class="keyword">null</span></span><br><span class="line"> *      内层元素的初始化值为：不能调用，否则报错。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.二维数组的内存结构</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130249.png" alt></p>
<h3 id="2-3常见算法"><a href="#2-3常见算法" class="headerlink" title="2.3常见算法"></a>2.3常见算法</h3><ol>
<li><p>数组的创建与元素赋值：</p>
<p> 杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p>
</li>
<li><p>针对于数值型的数组：</p>
<p> 最大值、最小值、总和、平均数等</p>
</li>
<li><p>数组的赋值与复制</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1,array2;</span><br><span class="line">array1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p> 3.1 赋值：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2 = array1;</span><br></pre></td></tr></table></figure>

<p> 如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130448.png" alt><br> 3.2 复制：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2 = <span class="keyword">new</span> <span class="keyword">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array2.length;i++)&#123;</span><br><span class="line">	array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130705.png" alt></p>
<p> 如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</p>
</li>
<li><p>数组元素的反转</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length / <span class="number">2</span>;i++)&#123;</span><br><span class="line">    String temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">    arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">    String temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组中指定元素的查找：搜索、检索</p>
<p> 5.1 线性查找： </p>
<p> 实现思路：通过遍历的方式，一个一个的数据进行比较、查找。</p>
<p> 适用性：具有普遍适用性。</p>
<p> 5.2 二分法查找：</p>
<p> 实现思路：每次比较中间值，折半的方式检索。</p>
<p> 适用性：（前提：数组必须有序）</p>
</li>
<li><p>数组的排序算法</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130852.png" alt></p>
<p> 理解：</p>
<p> 1）衡量排序算法的优劣：时间复杂度、空间复杂度、稳定性</p>
<p> 2）排序的分类：内部排序 与 外部排序（需要借助于磁盘）</p>
<p> 3）不同排序算法的时间复杂度</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130927.png" alt></p>
<p> 4）手写冒泡排序</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">43</span>,<span class="number">32</span>,<span class="number">76</span>,-<span class="number">98</span>,<span class="number">0</span>,<span class="number">64</span>,<span class="number">33</span>,-<span class="number">21</span>,<span class="number">32</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-4Arrays工具类"><a href="#2-4Arrays工具类" class="headerlink" title="2.4Arrays工具类"></a>2.4Arrays工具类</h3><ol>
<li><p>理解：</p>
<p> ① 定义在java.util包下。</p>
<p> ② Arrays:提供了很多操作数组的方法。</p>
</li>
<li><p>使用：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.boolean equals(int[] a,int[] b):判断两个数组是否相等。</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> isEquals = Arrays.equals(arr1, arr2);</span><br><span class="line">System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.String toString(int[] a):输出数组信息。</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.void fill(int[] a,int val):将指定值填充到数组之中。</span></span><br><span class="line">Arrays.fill(arr1,<span class="number">10</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.void sort(int[] a):对数组进行排序。</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.int binarySearch(int[] a,int key)</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(arr3, <span class="number">210</span>);</span><br><span class="line"><span class="keyword">if</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"未找到"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-5常见异常"><a href="#2-5常见异常" class="headerlink" title="2.5常见异常"></a>2.5常见异常</h3><ol>
<li><p>数组角标越界异常：ArrayIndexOutOfBoundsException</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(arr[-<span class="number">2</span>]);</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>空指针异常：NullPointerException</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line"><span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">System.out.println(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//情况三：</span></span><br><span class="line">String[] arr3 = <span class="keyword">new</span> String[]&#123;<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"CC"</span>&#125;;</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>].toString());</span><br></pre></td></tr></table></figure>

<p> 小知识：一旦程序出现异常，未处理时，就终止执行。</p>
</li>
</ol>
<h2 id="3-面向对象（上）"><a href="#3-面向对象（上）" class="headerlink" title="3.面向对象（上）"></a>3.面向对象（上）</h2><h3 id="3-1类与对象"><a href="#3-1类与对象" class="headerlink" title="3.1类与对象"></a>3.1类与对象</h3><ol>
<li><p>面向对象学习的三条主线：</p>
<ol>
<li>Java类及类的成员：属性、方法、构造器；代码块、内部类</li>
<li>面向对象的大特征：封装性、继承性、多态性、(抽象性)</li>
<li>其它关键字：this、super、static、final、abstract、interface、package、import等</li>
</ol>
</li>
<li><p>面向对象与面向过程（理解）</p>
<ol>
<li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li>
<li>面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
</ol>
</li>
<li><p>完成一个项目（或功能）的思路：</p>
<ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。</li>
<li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。</li>
</ul>
</li>
<li><p>面向对象中两个重要的概念：</p>
<p> 类：对一类事物的描述，是抽象的、概念上的定义</p>
<p> 对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)</p>
<p> ​            面向对象程序设计的重点是类的设计，设计类，就是设计类的成员。</p>
<p> 二者的关系：对象，是由类new出来的，派生出来的。</p>
</li>
<li><p>面向对象思想落地实现的规则一</p>
<ol>
<li><p>创建类，设计类的成员</p>
</li>
<li><p>创建类的对象</p>
</li>
<li><p>通过“对象.属性”或“对象.方法”调用对象的结构</p>
<p>补充：几个概念的使用说明</p>
</li>
<li><p>属性 = 成员变量 = field = 域、字段</p>
</li>
<li><p>方法 = 成员方法 = 函数 = method</p>
</li>
<li><p>创建类的对象 = 类的实例化 = 实例化类</p>
</li>
</ol>
</li>
<li><p>对象的创建与对象的内存解析</p>
<p> 典型代码：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p3 = p1;<span class="comment">//没有新创建一个对象，共用一个堆空间中的对象实体。</span></span><br></pre></td></tr></table></figure>

<p> 说明：</p>
<p> ​        如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）<br> 意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</p>
<p> 内存解析：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522151443.png" alt></p>
<p> <img src="E:%5CGitHubBlog%5Cfangchenyong.github.io%5CHexo%5Csource_posts%5C%E5%9F%BA%E7%A1%80.assets%5C1590131692254.png" alt="1590131692254"></p>
</li>
<li><p>匿名对象:我们创建的对象，没显式的赋给一个变量名。即为匿名对象</p>
<p> 特点：匿名对象只能调用一次。</p>
<p> 举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line"><span class="keyword">new</span> Phone().playGame();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">new</span> Phone().showPrice();<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure>

<p> 应用场景：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象的使用</span></span><br><span class="line">mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">其中，</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">		phone.sendEmail();</span><br><span class="line">		phone.playGame();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>理解”万事万物皆对象”</p>
<ol>
<li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构<ul>
<li>Scanner,String等</li>
<li>文件：File</li>
<li>网络资源：URL</li>
</ul>
</li>
<li>涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</li>
</ol>
</li>
<li><p>JVM内存结构简述</p>
<p> 编译完源程序以后，生成一个或多个字节码文件。</p>
<p> 我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节</p>
<p> 码文件对应的类加载到内存中，涉及到内存解析。</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522151721.png" alt></p>
<p> 虚拟机栈：即为平时提到的栈结构。</p>
<p> 我们将局部变量存储在栈结构中堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。</p>
<p> 补充：对象的属性（非static的）加载在堆空间中。</p>
<p> 方法区：类的加载信息、常量池、静态域</p>
</li>
</ol>
<h3 id="3-2类的结构之一：属性"><a href="#3-2类的结构之一：属性" class="headerlink" title="3.2类的结构之一：属性"></a>3.2类的结构之一：属性</h3><p>对比：属性  vs  局部变量</p>
<ul>
<li><p>相同点</p>
<ol>
<li>定义变量的格式：数据类型  变量名 = 变量值</li>
<li>先声明，后使用</li>
<li>变量都其对应的作用域</li>
</ol>
</li>
<li><p>不同点</p>
<ol>
<li><p>在类中声明的位置的不同</p>
<ul>
<li>属性：直接定义在类的一对{}内</li>
<li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li>
</ul>
</li>
<li><p>关于权限修饰符的不同</p>
<ul>
<li><p>属性：可以在声明属性时，指明其权限，使用权限修饰符。</p>
<p>  ​            常用的权限修饰符：private、public、缺省、protected  —&gt;封装性</p>
</li>
<li><p>局部变量：不可以使用权限修饰符。</p>
</li>
</ul>
</li>
<li><p>默认初始化值的情况：</p>
<ul>
<li><p>属性：类的属性，根据其类型，都默认初始化值。</p>
<ul>
<li>整型（byte、short、int、long：0）</li>
<li>浮点型（float、double：0.0）</li>
<li>字符型（char：0  （或’\u0000’））</li>
<li>布尔型（boolean：false）</li>
<li>引用数据类型（类、数组、接口：null）</li>
</ul>
</li>
<li><p>局部变量：没默认初始化值。</p>
<p>  ​                    意味着，我们在调用局部变量之前，一定要显式赋值。</p>
<p>  ​                    特别地：形参在调用时，我们赋值即可。</p>
</li>
</ul>
</li>
<li><p>在内存中加载的位置：</p>
<ul>
<li>属性：加载到堆空间中   （非static）</li>
<li>局部变量：加载到栈空间</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-3类的结构之二：方法"><a href="#3-3类的结构之二：方法" class="headerlink" title="3.3类的结构之二：方法"></a>3.3类的结构之二：方法</h3><ol>
<li><p>方法的声明：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法的声明：权限修饰符  返回值类型  方法名(形参列表)&#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字：return</p>
<ul>
<li>使用范围：使用在方法体中</li>
<li>作用：<ul>
<li>结束方法</li>
<li>针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</li>
</ul>
</li>
<li>注意点：return关键字后面不可以声明执行语句。</li>
</ul>
</li>
<li><p>方法的重载</p>
<ol>
<li><p>概念</p>
<p> 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p>
<p> <strong>总结：”两同一不同”:同一个类、相同方法名</strong></p>
<p> ​            <strong>参数列表不同：参数个数不同，参数类型不同</strong></p>
</li>
<li><p>构成重载的举例：</p>
<p> 举例一：Arrays类中重载的sort() / binarySearch()；PrintStream中的println()</p>
<p> 举例二：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如下的4个方法构成了重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">double</span> d1,<span class="keyword">double</span> d2)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(String s ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,String s)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"4"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何判断是否构成方法的重载？</p>
<p> 严格按照定义判断：两同一不同。</p>
<p> <strong>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</strong></p>
</li>
<li><p>如何确定类中某一个方法的调用：</p>
<p> 方法名 —&gt; 参数列表</p>
<p> 面试题：方法的重载与重写的区别？</p>
<blockquote>
<p>throws\throw<br>String\StringBuffer\StringBuilder<br>Collection\Collections<br>final\finally\finalize<br>…</p>
</blockquote>
<blockquote>
<p>抽象类、接口<br>sleep() / wait()</p>
</blockquote>
</li>
</ol>
</li>
<li><p>可变个数形参的方法</p>
<ol>
<li><p>使用说明：</p>
<ol>
<li>jdk 5.0新增的内容</li>
<li>具体使用：<ul>
<li>可变个数形参的格式：数据类型 … 变量名</li>
<li>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</li>
<li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</li>
<li>可变个数形参在方法的形参中，必须声明在末尾</li>
<li>可变个数形参在方法的形参中,最多只能声明一个可变形参。</li>
</ul>
</li>
</ol>
</li>
<li><p>举例说明</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show(String)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String ... strs)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"show(String ... strs)"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//	public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用时：</span></span><br><span class="line">test.show(<span class="string">"hello"</span>);</span><br><span class="line">test.show(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">test.show();</span><br><span class="line"></span><br><span class="line">test.show(<span class="keyword">new</span> String[]&#123;<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"CC"</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>java 的值传递机制</p>
<ol>
<li><p>针对于方法内变量的赋值举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"***********基本数据类型：****************"</span>);</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n = m;</span><br><span class="line">System.out.println(<span class="string">"m = "</span> + m + <span class="string">", n = "</span> + n);</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">"m = "</span> + m + <span class="string">", n = "</span> + n);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"***********引用数据类型：****************"</span>);</span><br><span class="line">Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">o1.orderId = <span class="number">1001</span>;</span><br><span class="line">Order o2 = o1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line">System.out.println(<span class="string">"o1.orderId = "</span> + o1.orderId + <span class="string">",o2.orderId = "</span> +o2.orderId);</span><br><span class="line"></span><br><span class="line">o2.orderId = <span class="number">1002</span>;</span><br><span class="line">System.out.println(<span class="string">"o1.orderId = "</span> + o1.orderId + <span class="string">",o2.orderId = "</span> +o2.orderId);</span><br></pre></td></tr></table></figure>

<p> 规则：</p>
<p> ​        如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</p>
<p> ​        如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p>
</li>
<li><p>针对于方法的参数概念</p>
<p> 形参：方法定义时，声明的小括号内的参数</p>
<p> 实参：方法调用时，实际传递给形参的数据</p>
</li>
<li><p>java中参数传递机制：值传递</p>
<p> 规则：</p>
<p> ​        如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</p>
<p> ​        如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</p>
</li>
<li><p>典型例题与内存解析：</p>
<ul>
<li><p>【例题1】</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522155534.png" alt></p>
</li>
<li><p>【例题2】</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522155539.png" alt></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>递归方法</p>
<ol>
<li><p>定义：递归方法：一个方法体内调用它自身。</p>
</li>
<li><p>如何理解递归方法？</p>
<ul>
<li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</li>
<li>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</li>
</ul>
</li>
<li><p>举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//			return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="3-4面向对象的特征一：封装性"><a href="#3-4面向对象的特征一：封装性" class="headerlink" title="3.4面向对象的特征一：封装性"></a>3.4面向对象的特征一：封装性</h3><ol>
<li><p>为什么要引入封装性？</p>
<p> 我们程序设计追求“高内聚，低耦合”。</p>
<ul>
<li><p>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</p>
</li>
<li><p>低耦合 ：仅对外暴露少量的方法用于使用。</p>
<p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p>
</li>
</ul>
</li>
<li><p>问题引入：</p>
<p> 当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).</p>
<p> 此时，针对于属性就体现了封装性。</p>
</li>
<li><p>封装性思想具体的代码体现：</p>
<ul>
<li><p>体现一：将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>体现二：不对外暴露的私有的方法</p>
</li>
<li><p>体现三：单例模式（将构造器私有化）</p>
</li>
<li><p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的。</p>
</li>
</ul>
</li>
<li><p>Java规定的四种权限修饰符</p>
<ol>
<li><p>权限从小到大顺序为：private &lt;  缺省 &lt; protected &lt; public</p>
</li>
<li><p>具体的修饰范围：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>（缺省）</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
</li>
<li><p>权限修饰符可用来修饰的结构说明：</p>
<p> 4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p>
<p> 修饰类的话，只能使用：缺省、public</p>
</li>
</ol>
</li>
</ol>
<h3 id="3-5类的结构之三：构造器"><a href="#3-5类的结构之三：构造器" class="headerlink" title="3.5类的结构之三：构造器"></a>3.5类的结构之三：构造器</h3><ol>
<li><p>构造器（或构造方法）：Constructor</p>
<p> 构造器的作用：</p>
<ul>
<li>1.创建对象</li>
<li>2.初始化对象的信息</li>
</ul>
</li>
<li><p>使用说明：</p>
<ul>
<li>1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</li>
<li>2.定义构造器的格式：权限修饰符  类名(形参列表){}</li>
<li>3.一个类中定义的多个构造器，彼此构成重载</li>
<li>4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li>5.一个类中，至少会有一个构造器。</li>
</ul>
</li>
<li><p>举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Person()....."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性赋值顺序</p>
<ol>
<li><p>默认初始化</p>
</li>
<li><p>显式初始化</p>
</li>
<li><p>构造器中初始化</p>
</li>
<li><p>通过”对象.方法” 或 “对象.属性”的方式，赋值</p>
<p>以上操作的先后顺序：① - ② - ③ - ④ </p>
</li>
</ol>
</li>
<li><p>JavaBean的概念</p>
<p> 所谓JavaBean，是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>一个无参的公共的构造器</li>
<li>属性，且对应的get、set方法</li>
</ul>
</li>
</ol>
<h3 id="3-6关键词：this"><a href="#3-6关键词：this" class="headerlink" title="3.6关键词：this"></a>3.6关键词：this</h3><ol>
<li><p>可以调用的结构：属性、方法；构造器</p>
</li>
<li><p>this调用属性、方法：</p>
<p> this理解为：当前对象  或 当前正在创建的对象</p>
<ul>
<li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li>
<li>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li>
</ul>
</li>
<li><p>this调用构造器：</p>
<ol>
<li>我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器</li>
<li>构造器中不能通过”this(形参列表)”方式调用自己</li>
<li>如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</li>
<li>规定：”this(形参列表)”必须声明在当前构造器的首行</li>
<li>构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器</li>
</ol>
</li>
</ol>
<h3 id="3-7关键词：package-import"><a href="#3-7关键词：package-import" class="headerlink" title="3.7关键词：package/import"></a>3.7关键词：package/import</h3><p><strong>package</strong></p>
<ol>
<li><p>使用说明：</p>
<ol>
<li>为了更好的实现项目中类的管理，提供包的概念</li>
<li>使用package声明类或接口所属的包，声明在源文件的首行</li>
<li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li>
<li>每”.”一次，就代表一层文件目录。</li>
</ol>
</li>
<li><p>举例：</p>
<ul>
<li><p>举例一：</p>
<p>  某航运软件系统包括：一组域对象、GUI和reports子系统</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161002.png" alt></p>
</li>
<li><p>举例二：MVC设计模式</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161017.png" alt></p>
</li>
</ul>
</li>
<li><p>JDK中的主要包介绍：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161042.png" alt></p>
</li>
</ol>
<p><strong>import</strong></p>
<h2 id="4-面向对象（中）"><a href="#4-面向对象（中）" class="headerlink" title="4.面向对象（中）"></a>4.面向对象（中）</h2><h3 id="4-1面向对象的特征二：继承性"><a href="#4-1面向对象的特征二：继承性" class="headerlink" title="4.1面向对象的特征二：继承性"></a>4.1面向对象的特征二：继承性</h3><ol>
<li><p>为什么要有类的继承性？(继承性的好处）</p>
<ol>
<li><p>减少了代码的冗余，提高了代码的复用性</p>
</li>
<li><p>便于功能的扩展</p>
</li>
<li><p>为之后多态性的使用，提供了前提</p>
<p>图示：</p>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161542.png" alt></p>
</li>
</ol>
</li>
<li><p>继承性的格式：</p>
<p> <code>class A extends B{}</code></p>
<p> A:子类、派生类、subclass</p>
<p> B:父类、超类、基类、superclass</p>
</li>
<li><p>子类继承父类以后有哪些不同？</p>
<ul>
<li><p>体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。</p>
<p>  特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。</p>
</li>
<li><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。</p>
<p>  子类和父类的关系，不同于子集和集合的关系。</p>
<p>  extends：延展、扩展</p>
</li>
</ul>
</li>
<li><p>Java中继承性的说明</p>
<ol>
<li><p>一个类可以被多个子类继承。</p>
</li>
<li><p>Java中类的单继承性：一个类只能有一个父类</p>
</li>
<li><p>子父类是相对的概念。</p>
</li>
<li><p>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</p>
</li>
<li><p>子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</p>
<p>图示：</p>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161347.png" alt></p>
</li>
</ol>
</li>
<li><p>java.lang.Object类的理解</p>
<ol>
<li>如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li>
<li>所有的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类</li>
<li>意味着，所的java类具有java.lang.Object类声明的功能。</li>
</ol>
</li>
</ol>
<h3 id="4-2方法的重写"><a href="#4-2方法的重写" class="headerlink" title="4.2方法的重写"></a>4.2方法的重写</h3><ol>
<li><p>什么是方法的重写(override 或 overwrite)？</p>
<p> 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。</p>
</li>
<li><p>应用：</p>
<p> 重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p>
</li>
<li><p>举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> <span class="keyword">extends</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求表面积</span></span><br><span class="line">&#125;</span><br><span class="line">***************</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckAccount</span> <span class="keyword">extends</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写的规则：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法的声明： 权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p>
<ol>
<li><p>① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</p>
</li>
<li><p>② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</p>
<p> 特殊情况：子类不能重写父类中声明为private权限的方法</p>
</li>
<li><p>返回值类型：</p>
<ul>
<li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li>
<li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li>
<li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</li>
</ul>
</li>
<li><p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
<p>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。</p>
</li>
</ol>
</li>
<li><p>面试题：</p>
<p> 区分方法的重写和重载？</p>
<p> 答：</p>
<ol>
<li><p>二者的概念：</p>
</li>
<li><p>重载和重写的具体规则</p>
</li>
<li><p>重载：不表现为多态性。</p>
<p> 重写：表现为多态性。</p>
<p>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p>
<p>所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</p>
<p>而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 </p>
<p>引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-3关键字：super"><a href="#4-3关键字：super" class="headerlink" title="4.3关键字：super"></a>4.3关键字：super</h3><ol>
<li>super 关键字可以理解为：父类的</li>
<li>可以用来调用的结构：属性、方法、构造器</li>
<li>super调用属性、方法：<ol>
<li>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li>
<li>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li>
</ol>
</li>
<li>super调用构造器：<ol>
<li>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li>
<li>“super(形参列表)”的使用，必须声明在子类构造器的首行！</li>
<li>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二一，不能同时出现</li>
<li>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</li>
<li>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</li>
</ol>
</li>
</ol>
<h3 id="4-4子类对象实例化全过程"><a href="#4-4子类对象实例化全过程" class="headerlink" title="4.4子类对象实例化全过程"></a>4.4子类对象实例化全过程</h3><ol>
<li><p>从结果上看：继承性</p>
<ul>
<li>子类继承父类以后，就获取了父类中声明的属性或方法。</li>
<li>创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</li>
</ul>
</li>
<li><p>从过程上看：</p>
<p> 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</p>
<p> 图示：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164236.png" alt></p>
</li>
<li><p>强调说明：</p>
<p> 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164256.png" alt></p>
</li>
</ol>
<h3 id="4-5面向对象的特征三：多态性"><a href="#4-5面向对象的特征三：多态性" class="headerlink" title="4.5面向对象的特征三：多态性"></a>4.5面向对象的特征三：多态性</h3><ol>
<li><p>多态性的理解：可以理解为一个事物的多种形态。</p>
</li>
<li><p>何为多态性：</p>
<p> 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p>
<p> 举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Man();</span><br><span class="line">Object obj = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure>
</li>
<li><p>多态性的使用：虚拟方法调用</p>
<p> 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p>
<p> <strong>总结：编译，看左边；运行，看右边。</strong></p>
</li>
<li><p>多态性的使用前提：</p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
</li>
<li><p>多态性的应用举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例一：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal animal)</span></span>&#123;<span class="comment">//Animal animal = new Dog();</span></span><br><span class="line">		animal.eat();</span><br><span class="line">		animal.shout();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//举例二：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//举例三：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doData</span><span class="params">(Connection conn)</span></span>&#123;<span class="comment">//conn = new MySQlConnection(); / conn = new OracleConnection();</span></span><br><span class="line">		<span class="comment">//规范的步骤去操作数据</span></span><br><span class="line"><span class="comment">//		conn.method1();</span></span><br><span class="line"><span class="comment">//		conn.method2();</span></span><br><span class="line"><span class="comment">//		conn.method3();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多态性使用的注意点：</p>
<p> <strong>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</strong></p>
</li>
<li><p>关于向上转型与向下转型：</p>
<ol>
<li><p>向上转型：多态</p>
</li>
<li><p>向下转型：</p>
<ol>
<li><p>为什么使用向下转型：</p>
<p> 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。</p>
</li>
<li><p>如何实现向下转型：</p>
<p> 使用强制类型转换符：()</p>
</li>
<li><p>使用时的注意点：</p>
<ol>
<li>使用强转时，可能出现ClassCastException的异常。</li>
<li>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</li>
</ol>
</li>
<li><p>instanceof的使用：</p>
<ol>
<li>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</li>
<li>如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。</li>
<li>要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</li>
</ol>
</li>
<li><p>图示：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164521.png" alt></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>面试题：</p>
<ol>
<li><p>谈谈你对多态性的理解？</p>
<ul>
<li><p>实现代码的通用性。</p>
</li>
<li><p>Object类中定义的public boolean equals(Object obj){  }</p>
<p>  JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)</p>
</li>
<li><p>抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</p>
</li>
</ul>
</li>
<li><p>多态是编译时行为还是运行时行为？</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-6Object类的使用"><a href="#4-6Object类的使用" class="headerlink" title="4.6Object类的使用"></a>4.6Object类的使用</h3><ol>
<li><p>java.lang.Object类的说明：</p>
<ol>
<li><p>Object类是所Java类的根父类</p>
</li>
<li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 </p>
</li>
<li><p>Object类中的功能(属性、方法)就具通用性。</p>
<p>属性：无</p>
<p>方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()</p>
<p>wait() 、 notify()、notifyAll()</p>
</li>
<li><p>Object类只声明了一个空参的构造器</p>
</li>
</ol>
</li>
<li><p>equals()方法</p>
<ol>
<li><p>equals()的使用：</p>
<ol>
<li><p>是一个方法，而非运算符</p>
</li>
<li><p>只能适用于引用数据类型</p>
</li>
<li><p>Object类中equals()的定义：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p>
</li>
<li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是</p>
<p> 两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p>
</li>
<li><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相</p>
<p> 同。那么，我们就需要对Object类中的equals()进行重写.</p>
<p> 重写的原则：比较两个对象的实体内容是否相同.</p>
</li>
</ol>
</li>
<li><p>如何重写equals()</p>
<p> 手动重写举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">//重写其equals()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">this</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">			User u = (User)obj;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age == u.age &amp;&amp; <span class="keyword">this</span>.name.equals(u.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回顾 == 运算符的使用：</p>
<p> == ：运算符</p>
<ul>
<li><p>可以使用在基本数据类型变量和引用数据类型变量中</p>
</li>
<li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p>
<p>  如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p>
<p>补充： == 符号使用时，必须保证符号左右两边的变量类型一致。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>toString()方法</p>
<ol>
<li><p>toString()的使用：</p>
<ol>
<li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p>
</li>
<li><p>Object类中toString()的定义：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息</p>
</li>
<li><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p>
</li>
</ol>
</li>
<li><p>如何重写toString()</p>
<p> 举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Customer [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>面试题：</p>
<ul>
<li>final、finally、finalize的区别？</li>
<li>== 和 equals() 区别</li>
</ul>
</li>
</ol>
<h3 id="4-7单元测试方法"><a href="#4-7单元测试方法" class="headerlink" title="4.7单元测试方法"></a>4.7单元测试方法</h3><p>Java中的JUnit单元测试</p>
<p>步骤：</p>
<ol>
<li><p>选中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步</p>
</li>
<li><p>创建Java类，进行单元测试。</p>
<p> 此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p>
</li>
<li><p>此类中声明单元测试方法。</p>
<p> 此时的单元测试方法：方法的权限是public,没返回值，没形参</p>
</li>
<li><p>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p>
</li>
<li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p>
</li>
</ol>
<p>说明：</p>
<ol>
<li>如果执行结果没任何异常：绿条</li>
<li>如果执行结果出现异常：红条</li>
</ol>
<h3 id="4-8包装类的使用"><a href="#4-8包装类的使用" class="headerlink" title="4.8包装类的使用"></a>4.8包装类的使用</h3><ol>
<li><p>为什么要有包装类(或封装类）</p>
<p> 为了使基本数据类型的变量具有类的特征，引入包装类。</p>
</li>
<li><p>基本数据类型与对应的包装类：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522165706.png" alt></p>
</li>
<li><p>需要掌握的类型间的转换：（基本数据类型、包装类、String）</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522165718.png" alt></p>
<p> 简易版：</p>
<ul>
<li><p>基本数据类型&lt;—&gt;包装类：JDK 5.0 新特性：自动装箱 与自动拆箱</p>
</li>
<li><p>基本数据类型、包装类—&gt;String:调用String重载的valueOf(Xxx xxx)</p>
</li>
<li><p>String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)</p>
<p>   注意：转换时，可能会报NumberFormatException</p>
<p>应用场景举例：</p>
<p>​        Vector类中关于添加元素，只定义了形参为Object类型的方法：</p>
<p>v.addElement(Object obj);   //基本数据类型 —&gt;包装类 —&gt;使用多态</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-面向对象（下）"><a href="#5-面向对象（下）" class="headerlink" title="5.面向对象（下）"></a>5.面向对象（下）</h2><h3 id="5-1关键字：static"><a href="#5-1关键字：static" class="headerlink" title="5.1关键字：static"></a>5.1关键字：static</h3><ol>
<li><p>可以用来修饰的结构：主要用来修饰类的内部结构</p>
<p> 属性、方法、代码块、内部类</p>
</li>
<li><p>static修饰属性：静态变量（或类变量）</p>
<ul>
<li><p>属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)</p>
<ul>
<li><p>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</p>
</li>
<li><p>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p>
</li>
</ul>
</li>
<li><p>static修饰属性的其他说明：</p>
<ol>
<li><p>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</p>
</li>
<li><p>静态变量的加载要早于对象的创建。</p>
</li>
<li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p>
<ol start="4">
<li><table>
<thead>
<tr>
<th></th>
<th>类变量</th>
<th>实例变量</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>对象</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
</li>
<li><p>静态属性举例：System.out; Math.PI;</p>
</li>
</ul>
</li>
<li><p>静态变量内存解析：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200529173043.png" alt></p>
</li>
<li><p>static修饰方法：静态方法、类方法</p>
<ol>
<li><p>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</p>
</li>
<li><table>
<thead>
<tr>
<th></th>
<th>静态方法</th>
<th>非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>对象</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody></table>
</li>
<li><p>静态方法中，只能调用静态的方法或属性</p>
<p> 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
</li>
</ol>
</li>
<li><p>static的注意点：</p>
<ol>
<li>在静态的方法内，不能使用this关键字、super关键字</li>
<li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</li>
</ol>
</li>
<li><p>如何判定属性和方法应该使用static关键字：</p>
<ol>
<li>关于属性<ul>
<li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li>
<li>类中的常量也常常声明为static</li>
</ul>
</li>
<li>关于方法<ul>
<li>操作静态属性的方法，通常设置为static的</li>
<li>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li>
</ul>
</li>
</ol>
</li>
<li><p>使用举例：</p>
<ol>
<li><p>举例一：Arrays、Math、Collections等工具类</p>
</li>
<li><p>举例二：单例模式</p>
</li>
<li><p>举例三：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//自动赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = init++;</span><br><span class="line">        total++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="comment">//		id = init++;</span></span><br><span class="line">        <span class="comment">//		total++;</span></span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total;<span class="comment">//记录创建的圆的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> init = <span class="number">1001</span>;<span class="comment">//static声明的属性被所对象所共享</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> 	</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>涉及设计模式–&gt;单例模式</p>
<ol>
<li><p>设计模式</p>
<ol>
<li><p>设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。</p>
</li>
<li><p>常用设计模式  — 23种经典的设计模式  GOF</p>
<blockquote>
<p>创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 </p>
</blockquote>
</li>
</ol>
</li>
<li><p>单例模式</p>
<ol>
<li><p>要解决的问题</p>
<p> 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p>
</li>
<li><p>具体代码的实现</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">饿汉式<span class="number">1</span>：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.内部创建类的对象</span></span><br><span class="line">	<span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">饿汉式<span class="number">2</span>：使用了静态代码块</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line">	<span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> Order();</span><br><span class="line"> &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">懒汉式：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line">	<span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			</span><br><span class="line">			instance = <span class="keyword">new</span> Order();</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两种方式的对比</p>
<ul>
<li>饿汉式：<ul>
<li>坏处：对象加载时间过长。</li>
<li>好处：饿汉式是线程安全的</li>
</ul>
</li>
<li>懒汉式：<ul>
<li>好处：延迟对象的创建。</li>
<li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-2main-的使用说明"><a href="#5-2main-的使用说明" class="headerlink" title="5.2main()的使用说明"></a>5.2main()的使用说明</h3><blockquote>
<ul>
<li><ol>
<li>main()方法作为程序的入口</li>
</ol>
</li>
<li><ol start="2">
<li>main()方法也是一个普通的静态方法</li>
</ol>
</li>
<li><ol start="3">
<li>main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</li>
</ol>
</li>
</ul>
<p>如何将控制台获取的数据传给形参：String[] args?<br>  运行时：java 类名 “Tom” “Jerry” “123” “true”</p>
<p>sysout(args[0]);//“Tom”<br>sysout(args[3]);//“true”  –&gt;Boolean.parseBoolean(args[3]);<br>sysout(args[4]);//报异常</p>
</blockquote>
<h3 id="5-3类的结构：代码块"><a href="#5-3类的结构：代码块" class="headerlink" title="5.3类的结构：代码块"></a>5.3类的结构：代码块</h3><ol>
<li><p>代码块的作用：用来初始化类、对象的信息</p>
</li>
<li><p>分类：代码块要是使用修饰符，只能使用static</p>
<p> 分类：静态代码块  vs 非静态代码块</p>
</li>
<li><p>静态代码块：</p>
<blockquote>
<p>内部可以输出语句<br>随着类的加载而执行,而且只执行一次<br>作用：初始化类的信息<br>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>静态代码块的执行要优先于非静态代码块的执行<br>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p>
</blockquote>
<p> 非静态代码块：</p>
<blockquote>
<p>内部可以输出语句<br>随着对象的创建而执行<br>每创建一个对象，就执行一次非静态代码块<br>作用：可以在创建对象时，对对象的属性等进行初始化<br>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p>
</blockquote>
</li>
<li><p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：</p>
<p> 由父及子，静态先行。</p>
</li>
<li><p>属性的赋值顺序</p>
<blockquote>
<ul>
<li>①默认初始化<ul>
<li>②显式初始化/⑤在代码块中赋值</li>
<li>③构造器中初始化</li>
<li>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</li>
<li></li>
<li></li>
<li>执行的先后顺序：① - ② / ⑤ - ③ - ④</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="5-4关键字：final"><a href="#5-4关键字：final" class="headerlink" title="5.4关键字：final"></a>5.4关键字：final</h3><ol>
<li><p>可以用来修饰：类、方法、变量</p>
</li>
<li><p>具体的：</p>
<ol>
<li><p>final 用来修饰一个类:此类不能被其他类所继承。</p>
<p> 比如：String类、System类、StringBuffer类</p>
</li>
<li><p>final 用来修饰方法：表明此方法不可以被重写</p>
<p> 比如：Object类中getClass();</p>
</li>
<li><p>final 用来修饰变量：此时的”变量”就称为是一个常量</p>
<ul>
<li>final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li>
<li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li>
</ul>
<p>static final 用来修饰属性：全局常量</p>
</li>
</ol>
</li>
</ol>
<h3 id="5-5关键字：abstract"><a href="#5-5关键字：abstract" class="headerlink" title="5.5关键字：abstract"></a>5.5关键字：abstract</h3><ol>
<li><p>可以用来修饰：类、方法</p>
</li>
<li><p>具体的：</p>
<ul>
<li>abstract修饰类：抽象类<ul>
<li>此类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</li>
</ul>
</li>
<li>abstract修饰方法：抽象方法<ul>
<li>抽象方法只方法的声明，没方法体</li>
<li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li>
<li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li>
<li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li>
</ul>
</li>
</ul>
</li>
<li><p>注意点：</p>
<ol>
<li>abstract不能用来修饰：属性、构造器等结构</li>
<li>abstract不能用来修饰私方法、静态方法、final的方法、final的类</li>
</ol>
</li>
<li><p>abstract的应用举例：</p>
<ol>
<li><p>举例一：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GeometricObject</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">GeometricObject</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例二：IO流中设计到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部定义了抽象的read()、write()方法。</p>
</li>
</ol>
</li>
<li><p>涉及设计模式–&gt;模板方法</p>
<ol>
<li><p>解决的问题</p>
<p> 在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变<br> 部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
</li>
<li><p>举例</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.code();<span class="comment">//不确定的部分、易变的部分</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"花费的时间为："</span> + (end - start));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">					isFlag = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景</p>
<p> 模板方法设计模式是编程中经常用的到的模式。各个框架、类库中都有用到，比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servlet中关于doGet/doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中的JDBCTemplate、HibernateTemplate等</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="5-6关键字：interface"><a href="#5-6关键字：interface" class="headerlink" title="5.6关键字：interface"></a>5.6关键字：interface</h3><ol>
<li><p>使用说明：</p>
<ol>
<li><p>接口使用interface来定义</p>
</li>
<li><p>Java中，接口和类是并列的两个结构</p>
</li>
<li><p>如何定义接口：定义接口中的成员</p>
<ol>
<li>JDK7及以前：只能定义全局常量和抽象方法<ul>
<li>全局常量：public static final的.但是书写时，可以省略不写</li>
<li>抽象方法：public abstract的</li>
</ul>
</li>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略</li>
</ol>
</li>
<li><p>接口中不能定义构造器的！意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p>
<p> 如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</p>
<p> 如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</p>
</li>
<li><p>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性</p>
<p> 格式：class AA extends BB implements CC,DD,EE</p>
</li>
<li><p>接口与接口之间可以继承，而且可以多继承</p>
</li>
<li><p>接口的具体使用，体现多态性</p>
</li>
<li><p>接口，实际上可以看做是一种规范</p>
</li>
</ol>
</li>
<li><p>举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span></span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">		usb.start();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"具体传输数据的细节"</span>);</span><br><span class="line">		</span><br><span class="line">		usb.stop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">	<span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"U盘开启工作"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"U盘结束工作"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"打印机开启工作"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"打印机结束工作"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 体会：</p>
<ul>
<li>1.接口使用上也满足多态性</li>
<li>2.接口，实际上就是定义了一种规范</li>
<li>3.开发中，体会面向接口编程！</li>
</ul>
</li>
<li><p>体会面向接口编程的思想</p>
<p> 面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个<br> 数据库厂商的API。</p>
</li>
<li><p>Java8中关于接口的新规范</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//知识点1：接口中定义的静态方法，只能通过接口来调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class="line"><span class="comment">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class="line"><span class="comment">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class="line"><span class="comment">//那么在实现类没重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class="line"><span class="comment">//这就需要我们必须在实现类中重写此方法</span></span><br><span class="line"><span class="comment">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">    <span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">    CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>面试题：</p>
<p> 抽象类和接口的异同？</p>
<ul>
<li><p>相同点：不能实例化；都可以包含抽象方法的。</p>
</li>
<li><p>不同点：</p>
<ul>
<li>1）把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明</li>
<li>2）类：单继承性 ，接口：多继承，类与接口：多实现</li>
</ul>
</li>
</ul>
</li>
<li><p>涉及设计模式–&gt;代理模式、工厂模式</p>
<ol>
<li><p>代理模式</p>
<ol>
<li><p>解决的问题</p>
<p> 代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 </p>
</li>
<li><p>举例</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"真实的服务器访问网络"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> NetWork work;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.work = work;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"联网之前的检查工作"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		check();</span><br><span class="line">		work.browse();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景</p>
<ul>
<li><p>应用场景：</p>
<ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法调用（RMI）</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>静态代理（静态定义代理类）</p>
</li>
<li><p>动态代理（动态生成代理类）</p>
<p>  JDK自带的动态代理，需要反射等知识</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>工厂模式</p>
<ol>
<li><p>解决的问题</p>
<p> 实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p>
</li>
<li><p>具体模式</p>
<ul>
<li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li>
<li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</li>
<li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-7类的结构：内部类"><a href="#5-7类的结构：内部类" class="headerlink" title="5.7类的结构：内部类"></a>5.7类的结构：内部类</h3><ol>
<li><p>定义：Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.</p>
</li>
<li><p>内部类的分类：</p>
<p> 成员内部类（静态、非静态 ） vs 局部内部类(方法内、代码块内、构造器内)</p>
</li>
<li><p>成员内部类的理解：</p>
<p> 一方面，作为外部类的成员：</p>
<ul>
<li><p>调用外部类的结构</p>
</li>
<li><p>可以被static修饰</p>
</li>
<li><p>可以被4种不同的权限修饰</p>
<p>另一方面，作为一个类：</p>
</li>
<li><p>类内可以定义属性、方法、构造器等</p>
</li>
<li><p>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</p>
</li>
<li><p>可以被abstract修饰</p>
</li>
</ul>
</li>
<li><p>成员内部类：</p>
<ol>
<li><p>如何创建成员内部类的对象？(静态的，非静态的)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">//Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Bird bird = p.new Bird();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何在成员内部类中调用外部类的结构？</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name = <span class="string">"小明"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">		String name = <span class="string">"杜鹃"</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">			System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">			System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">			System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">		<span class="comment">//Person.this.eat();</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>局部内部类的使用：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">		<span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//		class MyComparable implements Comparable&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//				return 0;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		return new MyComparable();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二：</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p> 注意点：</p>
<p> 在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。</p>
<ul>
<li><p><strong>jdk 7及之前版本：要求此局部变量显式的声明为final的</strong></p>
</li>
<li><p><strong>jdk 8及之后的版本：可以省略final的声明</strong></p>
<p>总结：</p>
<p>成员内部类和局部内部类，在编译以后，都会生成字节码文件。</p>
<p>格式：</p>
</li>
<li><p>成员内部类：外部类$内部类名.class    </p>
</li>
<li><p>局部内部类：外部类$数字 内部类名.class</p>
</li>
</ul>
</li>
</ol>
<h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h2><h3 id="6-1异常"><a href="#6-1异常" class="headerlink" title="6.1异常"></a>6.1异常</h3><ol>
<li><p>异常的体系结构</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">	|-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">	|-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">		|------编译时异常(checked)</span><br><span class="line">				|-----IOException</span><br><span class="line">					|-----FileNotFoundException</span><br><span class="line">					|-----ClassNotFoundException</span><br><span class="line">			|------运行时异常(unchecked,RuntimeException)</span><br><span class="line">				|-----NullPointerException</span><br><span class="line">					|-----ArrayIndexOutOfBoundsException</span><br><span class="line">					|-----ClassCastException</span><br><span class="line">					|-----NumberFormatException</span><br><span class="line">					|-----InputMismatchException</span><br><span class="line">					|-----ArithmeticException</span><br></pre></td></tr></table></figure>

<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522172127.png" alt></p>
</li>
<li><p>从程序执行过程，看编译时异常和运行时异常</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522171550.png" alt></p>
<p> 编译时异常：执行javac.exe命名时，可能出现的异常</p>
<p> 运行时异常：执行java.exe命名时，出现的异常</p>
</li>
<li><p>常见的异常类型，请举例说明：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> score = scanner.nextInt();</span><br><span class="line">    System.out.println(score);</span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">"123"</span>;</span><br><span class="line">    str = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">    String str = (String)obj;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">    <span class="comment">//		int[] arr = new int[10];</span></span><br><span class="line">    <span class="comment">//		System.out.println(arr[10]);</span></span><br><span class="line">    <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">    String str = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//		int[] arr = null;</span></span><br><span class="line">    <span class="comment">//		System.out.println(arr[3]);</span></span><br><span class="line">    String str = <span class="string">"abc"</span>;</span><br><span class="line">    str = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//		File file = new File("hello.txt");</span></span><br><span class="line">    <span class="comment">//		FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line">    <span class="comment">//		</span></span><br><span class="line">    <span class="comment">//		int data = fis.read();</span></span><br><span class="line">    <span class="comment">//		while(data != -1)&#123;</span></span><br><span class="line">    <span class="comment">//			System.out.print((char)data);</span></span><br><span class="line">    <span class="comment">//			data = fis.read();</span></span><br><span class="line">    <span class="comment">//		&#125;</span></span><br><span class="line">    <span class="comment">//		</span></span><br><span class="line">    <span class="comment">//		fis.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="6-2异常的处理"><a href="#6-2异常的处理" class="headerlink" title="6.2异常的处理"></a>6.2异常的处理</h3><ol>
<li><p>异常处理的抓抛模型</p>
<ol>
<li><p>“抓”</p>
<p> 可以理解为异常的处理方式：</p>
<ul>
<li>try-catch-finally </li>
<li>throws</li>
</ul>
</li>
<li><p>”抛“</p>
<p> 程序在正常执行的过程中，一旦出现异常，就会中异常代码处生成一个异常对象，并将此对象抛出。</p>
<p> 异常对象的产生：</p>
<ul>
<li>系统自动生成的异常对象</li>
<li>手动生成的一个异常对象，并抛出（throw）</li>
</ul>
</li>
</ol>
</li>
<li><p>异常处理方式：try-catch-finally</p>
</li>
<li><p>方法重写的规则之一：</p>
<p> 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
</li>
</ol>
<h3 id="6-3手动抛出异常对象"><a href="#6-3手动抛出异常对象" class="headerlink" title="6.3手动抛出异常对象"></a>6.3手动抛出异常对象</h3><ol>
<li><p>使用说明</p>
<p> 在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。</p>
</li>
<li><p>面试题</p>
<p> throw 和  throws区别：</p>
<p> throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。</p>
<p> throws 属于异常处理的一种方式，声明在方法的声明处。</p>
</li>
<li><p>典型例题</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">this</span>.id = id;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//手动抛出异常对象</span></span><br><span class="line"><span class="comment">//			throw new RuntimeException("您输入的数据非法！");</span></span><br><span class="line"><span class="comment">//			throw new Exception("您输入的数据非法！");</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"不能输入负数"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Student [id="</span> + id + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="6-4自定义异常类"><a href="#6-4自定义异常类" class="headerlink" title="6.4自定义异常类"></a>6.4自定义异常类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何自定义异常类？</span></span><br><span class="line"><span class="comment"> * 1. 继承于现的异常结构：RuntimeException 、Exception</span></span><br><span class="line"><span class="comment"> * 2. 提供全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment"> * 3. 提供重载的构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-多线程"><a href="#7-多线程" class="headerlink" title="7.多线程"></a>7.多线程</h2><p>程序、进程、线程的理解</p>
<p>并行和并发</p>
<p>创建多线程的两种方式</p>
<p>Thread类中的常用方法</p>
<p>Thread的生命周期</p>
<p>线程的同步机制</p>
<p>​    线程安全的单例模式（懒汉式）</p>
<p>​    死锁问题</p>
<p>线程通信</p>
<p>JDK5.0新增线程创建的方式</p>
<h2 id="8-常用类"><a href="#8-常用类" class="headerlink" title="8.常用类"></a>8.常用类</h2><p>String类</p>
<p>StringBuffer、StringBuilder</p>
<p>JDK8之前日期时间API</p>
<p>JDK8中新日期时间API</p>
<p>Java比较器</p>
<p>其他类</p>
<h2 id="9-枚举类和注解"><a href="#9-枚举类和注解" class="headerlink" title="9.枚举类和注解"></a>9.枚举类和注解</h2><p>枚举类的使用</p>
<p>注解类的使用</p>
<h2 id="10-集合"><a href="#10-集合" class="headerlink" title="10.集合"></a>10.集合</h2><p>数组与集合</p>
<p>Collection接口</p>
<p>Iterator接口与foreach循环 </p>
<p>Collection子接口：List接口</p>
<p>Collection子接口：Set接口</p>
<p>Map接口</p>
<p>Collections工具类的使用</p>
<p>数据结构简述</p>
<h2 id="11-泛型"><a href="#11-泛型" class="headerlink" title="11.泛型"></a>11.泛型</h2><p>泛型的理解</p>
<p>泛型在集合中的使用</p>
<p>自定义泛型类、泛型接口、泛型方法</p>
<p>泛型在继承上的体现</p>
<p>通配符</p>
<h2 id="12-IO流"><a href="#12-IO流" class="headerlink" title="12.IO流"></a>12.IO流</h2><p>File类的使用</p>
<p>IO流概述</p>
<p>节点流（或文件流）</p>
<p>缓冲流的使用</p>
<p>转换流的使用</p>
<p>​    编码集</p>
<p>其它的流的使用</p>
<p>对象流的使用</p>
<p>RandomAccessFile的使用</p>
<p>Path、Paths、Files的使用</p>
<h2 id="13-网络编程"><a href="#13-网络编程" class="headerlink" title="13.网络编程"></a>13.网络编程</h2><p>InetAddress类的使用</p>
<p>TCP网络编程</p>
<p>UDP网络编程</p>
<p>URL编程</p>
<h2 id="14-反射机制"><a href="#14-反射机制" class="headerlink" title="14.反射机制"></a>14.反射机制</h2><p>反射的概述</p>
<p>Class类的理解与获取Class的实例</p>
<p>了解ClassLoader</p>
<p>反射应用一：创建运行时类的对象</p>
<p>反射应用二：获取运行时类的完整结构</p>
<p>反射应用三：调用运行时类的指定结构</p>
<p>反射应用四：动态代理</p>
<h2 id="15-Java8的其他新特性"><a href="#15-Java8的其他新特性" class="headerlink" title="15.Java8的其他新特性"></a>15.Java8的其他新特性</h2><h2 id="16-Java9、10、11新特性"><a href="#16-Java9、10、11新特性" class="headerlink" title="16.Java9、10、11新特性"></a>16.Java9、10、11新特性</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/07/20/Java-Java基础笔记/" data-id="ckmh9ucmy009a3oumw4e7d0m3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-Java笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/Java-Java笔记/" class="article-date">
  <time datetime="2019-07-17T16:00:00.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/Java-Java笔记/">Java笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="java基础笔记"><a href="#java基础笔记" class="headerlink" title="java基础笔记"></a>java基础笔记</h2><ol>
<li><h4 id="基本数据类型和包装类型"><a href="#基本数据类型和包装类型" class="headerlink" title="基本数据类型和包装类型"></a>基本数据类型和包装类型</h4><blockquote>
<p>基本数据类型：short、int、long、double、float、char、string、boolean</p>
<p>包装类型：Short、Integer、Long、Double、Float、Char、String、Boolean</p>
<p>装箱：1. 手动装箱：Integer.valueOf(1) ;    2. 自动装箱：Integer i = 1;</p>
<p>拆箱：1. 手动拆箱：int j = i.intValue() ;    2. 自动拆箱：int j = i ;</p>
<p>JDK1.5开始为什么要引入包装类型：java是面向对象的语言，而基本的数据类型不具备面向对象的特性。</p>
<p>例：用Integer和int分别表示一个类的ID，进行非空判断的时候，Integer只要判断是否为null，int还要判断是否为0；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; Integer num1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; Integer num2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; System.out.println(<span class="string">"num1==num2 "</span> + (num1 == num2));</span><br><span class="line">&gt; </span><br><span class="line">&gt; Integer num3 = <span class="number">100</span>;</span><br><span class="line">&gt; Integer num4 = <span class="number">100</span>;</span><br><span class="line">&gt; System.out.println(<span class="string">"num3==num4 "</span> +(num3 == num4));</span><br><span class="line">&gt; </span><br><span class="line">&gt; Integer num5 = <span class="number">128</span>;</span><br><span class="line">&gt; Integer num6 = <span class="number">128</span>;</span><br><span class="line">&gt; System.out.println(<span class="string">"num5==num6 "</span> + (num5 == num6));</span><br><span class="line">&gt; </span><br><span class="line">&gt; Integer num7 = <span class="number">100</span>;</span><br><span class="line">&gt; Integer num8 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; System.out.println(<span class="string">"num7==num8 "</span> + (num7 == num8));</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">int</span> num9 = <span class="number">100</span>;</span><br><span class="line">&gt; Integer num10 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; Integer num11 = <span class="number">100</span>;</span><br><span class="line">&gt; System.out.println(<span class="string">"num9==num10 "</span> + (num9 == num10));</span><br><span class="line">&gt; System.out.println(<span class="string">"num9==num11 "</span> + (num9 == num11));</span><br><span class="line">&gt; </span><br><span class="line">&gt; 结果：num1==num2 <span class="keyword">false</span>  </span><br><span class="line">&gt; 	 num3==num4 <span class="keyword">true</span></span><br><span class="line">&gt; 	 num5==num6 <span class="keyword">false</span></span><br><span class="line">&gt; 	 num7==num8 <span class="keyword">false</span></span><br><span class="line">&gt; 	 num9==num10 <span class="keyword">true</span></span><br><span class="line">&gt; 	 num9==num11 <span class="keyword">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; 源码：</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">&gt;             <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     </span><br><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">static</span> &#123;</span><br><span class="line">&gt;             <span class="comment">// high value may be configured by property</span></span><br><span class="line">&gt;             <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">&gt;             String integerCacheHighPropValue =</span><br><span class="line">&gt;                 sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">&gt;             <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt;                 <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                     <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">&gt;                     i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">&gt;                     <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">&gt;                     h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">&gt;                 &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">&gt;                     <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;             high = h;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">&gt;             <span class="keyword">int</span> j = low;</span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">&gt;                 cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">&gt;             <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; 分析：</span><br><span class="line">&gt; <span class="number">1</span>.==对于对象来说比较的是对象的地址，两个新<span class="keyword">new</span>的对象地址不同，输出<span class="keyword">false</span>。</span><br><span class="line">&gt; <span class="number">2</span>.jvm在初始化的时候，会将低值（-<span class="number">128</span>）到高值（默认<span class="number">127</span>）之间的数字加载到内存中。低值是固定的，高值是可变的。在java程序执行的时候加上 -XX:AutoBoxCacheMax=&lt;size&gt; 的参数即可。缓如果初始化的数字是-<span class="number">128</span>~<span class="number">127</span>之间就会引用内存中的地址，输出<span class="keyword">true</span>。</span><br><span class="line">&gt; <span class="number">3</span>.同上。</span><br><span class="line">&gt; <span class="number">4</span>.num7是引用的本地内存地址，而num8是<span class="keyword">new</span>出来的，所以地址不同，输出<span class="keyword">false</span>。</span><br><span class="line">&gt; <span class="number">5</span>.包装类Integer和基本数据类型<span class="keyword">int</span>类型比较时，会自动拆箱为<span class="keyword">int</span>类型比较，实际上就变成两个基本的数据类型<span class="keyword">int</span>类型进行比较，而基本类型==比较的是值而不是地址，所以输出<span class="keyword">true</span>。</span><br><span class="line">&gt; <span class="number">6</span>.同上，即使是新<span class="keyword">new</span>出来的地址不同，但是最终拆箱为<span class="keyword">int</span>类型比较值是否相等，所以输出<span class="keyword">true</span>。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>“==”和“equals()” 方法区别</p>
<blockquote>
<p><strong>变量分为基本数据类型和引用数据类型</strong></p>
<p>1）对于==，比较的是值是否相等</p>
<p>​    如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>
<p>　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p>
<p>2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象</p>
<p>　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p>
<p>　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>
</blockquote>
</li>
<li><p>String、StringBuilder、StringBuffer区别</p>
<blockquote>
<p>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.String底层使用<span class="keyword">final</span>关键字修饰的数组，因此不可变</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="number">2</span>.StringBuilder继承AbstractStringBuilder抽象类使用的是普通数组所以可以改变。</span><br><span class="line">     <span class="comment">/** The value is used for character storage.*/</span></span><br><span class="line">     <span class="keyword">char</span>[] value;</span><br><span class="line"><span class="number">3</span>.StringBuffer继承AbstractStringBuilder抽象类使用的是普通数组所以可以改变。并且与StringBuilder重写的方法不同，方法添加了<span class="keyword">synchronized</span>关键字，线程安全但是效率低。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</p>
<p>String：适用于少量的字符串操作的情况</p>
<p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p>
<p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>
</blockquote>
</li>
<li><h4 id="java中的集合"><a href="#java中的集合" class="headerlink" title="java中的集合"></a>java中的集合</h4><blockquote>
<p>java中的集合分类存储value（继承Collection接口）和存储key-value（继承）形式。</p>
<p><strong>存储值：</strong>List、Set</p>
<blockquote>
<p>List是有序的，可以重复的。</p>
<p>Set是无序的，不可以重复的。根据equals和hascode判断，也就是如果一个对象要存储在Set中，必须重写equals和hasCode方法。</p>
</blockquote>
<p><strong>存储键值：</strong>Map</p>
</blockquote>
</li>
<li><h4 id="ArrayList和LinkedList的区别和使用场景"><a href="#ArrayList和LinkedList的区别和使用场景" class="headerlink" title="ArrayList和LinkedList的区别和使用场景"></a>ArrayList和LinkedList的区别和使用场景</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1</span>.ArrayList底层使用的是数组。</span><br><span class="line">&gt; 	<span class="keyword">transient</span> Object[] elementData; </span><br><span class="line">&gt; <span class="number">2</span>.LinkedList底层使用的是链表。</span><br><span class="line">&gt; 	<span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">&gt; 	<span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>区别：</strong></p>
<p>数组查询特定元素快，而插入、删除和修改比较慢，因为数组在内存中是一块连续的内存，如果是插入或删除需要移动内存。</p>
<p>链表在内存中是不连续的，在当前元素中存放的是下一个或者上一个元素的地址。查询时需要从头部开始查找至尾部，效率低。而插入时不需要移动内存，只需要改变节点指针即可。所以插入或删除效率高。</p>
<p><strong>使用场景：</strong></p>
<p>ArrayList使用在查询比较多，但是插入和删除比较少的情况，</p>
<p>LinkedList使用在查询比较少，但是插入和删除比较多的情况。</p>
</blockquote>
</li>
<li><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h4><blockquote>
<p><strong>相同点：</strong>都可以用来存储Key-Value类型数据</p>
<p><strong>不同点：</strong></p>
<ol>
<li><p>HashMap可以使用null值作为key或者value，而Hashtable不行。</p>
</li>
<li><p>HashMap是线程不安全的，效率高。而Hashtable是线程安全的，效率低。</p>
</li>
<li><p>HashMap继承了AbstractMap抽象类同时实现Map, Cloneable, Serializable接口，而Hashtable继承了Dictionary抽象类同时实现Map, Cloneable, Serializable接口。</p>
</li>
</ol>
<p><strong>线程安全又要效率高？ConcurrentHashMap</strong></p>
<p>通过把整个Map分为N个Segment（类似于Hashtable）,可以提供相关的线程安全，又可以提升效率，默认提升16倍。</p>
</blockquote>
</li>
<li><h4 id="实现一个拷贝文件的工具类使用字节流还是字符流"><a href="#实现一个拷贝文件的工具类使用字节流还是字符流" class="headerlink" title="实现一个拷贝文件的工具类使用字节流还是字符流"></a>实现一个拷贝文件的工具类使用字节流还是字符流</h4><blockquote>
<p>我们拷贝的文件不确定是只包含字符流，有可能有字节流（图片、声音、图像等），为考虑到通用性，要使用字节流。</p>
</blockquote>
</li>
<li><h4 id="线程的几种实现方式"><a href="#线程的几种实现方式" class="headerlink" title="线程的几种实现方式"></a>线程的几种实现方式</h4><blockquote>
<ol>
<li><p>通过继承Thread类实现一个线程</p>
</li>
<li><p>通过实现Runnable接口实现一个线程</p>
</li>
<li><p>通过实现callable接口，重写call函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;    <span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line">&gt;    <span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式一  开始 (Thread是一个类继承了Runnable接口) =======</span></span><br><span class="line">&gt;            Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法中写我们业务代码</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">&gt;                        <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                            Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1000毫秒(就是1秒)</span></span><br><span class="line">&gt;                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt;                            e.printStackTrace();</span><br><span class="line">&gt;                        &#125;</span><br><span class="line">&gt;                        <span class="comment">//打印当前线程名称</span></span><br><span class="line">&gt;                        System.out.println(<span class="string">"创建线程方式一,打印线程名称: "</span>+Thread.currentThread().getName());</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                        <span class="comment">//打印当前线程名称,这里采用this来获取,在某些时候这里并不适用,推荐使用上面一种方式</span></span><br><span class="line">&gt;                        System.out.println(<span class="string">"创建线程方式一,通过this调用getName方法,打印线程名称: "</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">&gt;                    &#125;</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            thread.start();<span class="comment">//启动线程</span></span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式一  结束  =======</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式二开始  (Runnable是一个接口)=======</span></span><br><span class="line">&gt;            Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法中写我们业务代码</span></span><br><span class="line">&gt;                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">&gt;                        <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                            Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1000毫秒(就是1秒)</span></span><br><span class="line">&gt;                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt;                            e.printStackTrace();</span><br><span class="line">&gt;                        &#125;</span><br><span class="line">&gt;                        <span class="comment">//打印当前线程名称</span></span><br><span class="line">&gt;                        System.out.println(<span class="string">"创建线程方式二,打印线程名称: "</span>+Thread.currentThread().getName());</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                        <span class="comment">//TODO 这种方式就不适合上面打印2的方式通过this来调用获取当前线程名称的方法</span></span><br><span class="line">&gt;                    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;);</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            thread2.start();<span class="comment">//启动线程</span></span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式二  结束  =======</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式三 开始  =======</span></span><br><span class="line">&gt;            FutureTask&lt;Integer&gt; thread3 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&gt;                    <span class="keyword">int</span> count =<span class="number">0</span>;  </span><br><span class="line">&gt;                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;  </span><br><span class="line">&gt;                        count=count+i;  </span><br><span class="line">&gt;                    &#125;  </span><br><span class="line">&gt;                    <span class="comment">//打印当前线程名称</span></span><br><span class="line">&gt;                    System.out.println(<span class="string">"创建线程方式三,打印线程名称: "</span>+Thread.currentThread().getName());</span><br><span class="line">&gt;                    <span class="keyword">return</span> count; <span class="comment">//返回值   </span></span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;);  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="keyword">new</span> Thread(thread3,<span class="string">"这是线程名称"</span>).start();<span class="comment">//启动线程</span></span><br><span class="line">&gt;            <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                System.out.println(<span class="string">"创建线程方式三,打印返回值:"</span>+ thread3.get());<span class="comment">//打印返回值</span></span><br><span class="line">&gt;            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&gt;                e.printStackTrace();</span><br><span class="line">&gt;            &#125; </span><br><span class="line">&gt;         <span class="comment">// =======  创建线程方式三 结束  =======</span></span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p>   <strong>区别：</strong></p>
<ul>
<li><p>采用继承Thread类方式：</p>
<p>​    优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。</p>
<p>​    缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。</p>
</li>
<li><p>采用实现Runnable接口方式：</p>
<p>​    优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<p>​    缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。</p>
</li>
</ul>
</blockquote>
</li>
<li><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><blockquote>
<ol>
<li><strong>newCachedThreadPool</strong></li>
</ol>
<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>这种类型的线程池特点是：</p>
<ul>
<li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&gt; 			<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">&gt; 			<span class="keyword">try</span> &#123;</span><br><span class="line">&gt; 				Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">&gt; 			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; 				e.printStackTrace();</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 			cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 					System.out.println(index);</span><br><span class="line">&gt; 				&#125;</span><br><span class="line">&gt; 			&#125;);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>newFixedThreadPool</strong></li>
</ol>
<p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p>
<p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&gt; 			<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">&gt; 			fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 					<span class="keyword">try</span> &#123;</span><br><span class="line">&gt; 						System.out.println(index);</span><br><span class="line">&gt; 						Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&gt; 					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; 						e.printStackTrace();</span><br><span class="line">&gt; 					&#125;</span><br><span class="line">&gt; 				&#125;</span><br><span class="line">&gt; 			&#125;);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置如Runtime.getRuntime().availableProcessors()</p>
<ol start="3">
<li><strong>newSingleThreadExecutor</strong></li>
</ol>
<p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&gt; 			<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">&gt; 			singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 					<span class="keyword">try</span> &#123;</span><br><span class="line">&gt; 						System.out.println(index);</span><br><span class="line">&gt; 						Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&gt; 					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; 						e.printStackTrace();</span><br><span class="line">&gt; 					&#125;</span><br><span class="line">&gt; 				&#125;</span><br><span class="line">&gt; 			&#125;);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="4">
<li><strong>newScheduleThreadPool</strong></li>
</ol>
<p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>
<p>延迟3秒执行，延迟执行示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">&gt; 		scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 				System.out.println(<span class="string">"delay 3 seconds"</span>);</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>表示延迟1秒后每3秒执行一次，定期执行示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">&gt; 		scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 				System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><h4 id="使用线程池的风险，为什么使用线程池"><a href="#使用线程池的风险，为什么使用线程池" class="headerlink" title="使用线程池的风险，为什么使用线程池"></a>使用线程池的风险，为什么使用线程池</h4><blockquote>
<p><strong>风险：</strong></p>
<ol>
<li>死锁</li>
<li>资源不足</li>
<li>并发错误</li>
<li>线程泄漏</li>
<li>请求过载</li>
</ol>
<p><strong>作用：</strong>（连接池同理）</p>
<ol>
<li>限定线程的个数，不会由于线程过多而导致系统运行缓慢或崩溃</li>
<li>线程池不需要每次去创建或销毁，节约资源，响应速度快</li>
</ol>
</blockquote>
</li>
<li><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><blockquote>
<p><strong>常用的设计模式：</strong></p>
<ol>
<li><p>单例模式（饱汉模式、饿汉模式）：</p>
<p>（1）构造方法私有化，在除了自己类中其他地方都不能创建</p>
<p>（2）在自己的类中创建一个单实例（饱汉模式是一出来就创建单实例，而饿汉模式需要用到的时候才创建）</p>
<p>（3）提供一个方法或获取该实例对象（创建时需要进行方法同步）</p>
</li>
<li><p>工厂模式：SpringIOC使用的就是工厂模式，对象的创建交给一个工厂  创建。</p>
</li>
<li><p>代理模式：SpringAOP使用的就是动态代理。</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="javaWeb笔记"><a href="#javaWeb笔记" class="headerlink" title="javaWeb笔记"></a>javaWeb笔记</h2><ol>
<li><h4 id="Http-Get和Post请求的区别"><a href="#Http-Get和Post请求的区别" class="headerlink" title="Http Get和Post请求的区别"></a>Http Get和Post请求的区别</h4><blockquote>
<p><strong>相同点：</strong></p>
<p>Get和Post请求都是Http请求方式，用户通过不同的Http请求对资源实现不同的操作。GET，POST，PUT，DELETE对应着对资源的查，改，增，删4个操作，GET一般用于获取/查询资源信息，而POST用于更新资源信息。</p>
<p><strong>区别：</strong></p>
<ol>
<li>GET请求提交的数据会在地址栏显示出来，而POST请求地址栏不会改变，数据放置在HTTP包体中。</li>
<li>传输数据的大小不同，GET由于浏览器对地址长度的限制导致传输的数据有限制，而POST不会。</li>
<li>GET提交的数据会在地址中显示出来，安全性较低，而POST则不会。</li>
</ol>
</blockquote>
</li>
<li><h4 id="servlet的理解"><a href="#servlet的理解" class="headerlink" title="servlet的理解"></a>servlet的理解</h4><blockquote>
<p>Servlet 是用java编写的服务器端程序，而这些Servlet都要实现Servlet接口。主要用于交互式地浏览和修改数据，生成动态Web内容。Servlet运行于支持java的web容器中。</p>
<p>HttpServlet重写doGet和doPost方法或者service方法完成对get和post请求的响应。</p>
</blockquote>
</li>
<li><h4 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h4><blockquote>
<ol>
<li>加载Servlet的class</li>
<li>实例化Servlet</li>
<li>调用Servlet的init完成实例化</li>
<li>运行service方法，响应doGet或doPost请求</li>
<li>调用destory方法销毁实例</li>
</ol>
</blockquote>
</li>
<li><h4 id="Servlet-API中forward-和redirect-区别"><a href="#Servlet-API中forward-和redirect-区别" class="headerlink" title="Servlet API中forward() 和redirect()区别"></a>Servlet API中forward() 和redirect()区别</h4><blockquote>
<p>forward：转发，地址不变，服务端跳转</p>
<p>redirect：重定向，地址改变，客户端跳转</p>
</blockquote>
</li>
<li><h4 id="Session和Cookie区别"><a href="#Session和Cookie区别" class="headerlink" title="Session和Cookie区别"></a>Session和Cookie区别</h4><blockquote>
<p><strong>相同点：</strong></p>
<p>Session和cookie都是会话跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务端记录信息确定用户身份。但是Session是实现依赖于Cookie，sessionId（session的唯一标识需要存放在客户端）</p>
<p><strong>区别：</strong></p>
<ol>
<li><p>Cookie数据存放在客户端浏览器，Session存放在服务器上</p>
</li>
<li><p>Cookie安全性较Session差</p>
</li>
<li><p>Session运行时间久会占用较多服务器内存，影响服务器性能</p>
</li>
<li><p>单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie</p>
</li>
<li><p>登录信息等重要信息存放在Session中，安全性较高</p>
<p>其他信息如果需要保留，存在Cookie中（比如购物车的实现，但是Cookie在客户端是可以禁用的，所以可以采用cookie+数据库方式实现）</p>
</li>
</ol>
</blockquote>
</li>
<li><h4 id="MVC的各部分都有哪些技术来实现"><a href="#MVC的各部分都有哪些技术来实现" class="headerlink" title="MVC的各部分都有哪些技术来实现"></a>MVC的各部分都有哪些技术来实现</h4><blockquote>
<ul>
<li>M（Model） 模型     javabean……</li>
<li>V（View）     视图     html、jsp、freemarker、thymeleaf……</li>
<li>C（Control）控制器 Servlet、Action……</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="数据库笔记"><a href="#数据库笔记" class="headerlink" title="数据库笔记"></a>数据库笔记</h2><ol>
<li><h4 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h4><blockquote>
<ul>
<li><p>关系型数据库</p>
<blockquote>
<p> MySql、Oracle、SqlServer……</p>
</blockquote>
</li>
<li><p>非关系型数据库</p>
<blockquote>
<p>redis、memcache、mogodb、hadoop……</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><h4 id="关系型数据库三范式"><a href="#关系型数据库三范式" class="headerlink" title="关系型数据库三范式"></a>关系型数据库三范式</h4><blockquote>
<ol>
<li><p>第一范式（1NF)所谓第一范式（1NF）是指<strong>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</strong>。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>
<p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。理解注释：列不可分。</p>
</li>
<li><p>第二范式（2NF)第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求<strong>数据库表中的每个实例或行必须可以被惟一的区分</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。要求实体的属性完全依赖于主关键字。理解注释：不能部分依赖。即：一张表存在组合主键时，其他非主键字段不能部分依赖。</p>
</li>
<li><p>第三范式（3NF)满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求<strong>一个数据库表中不包含已在其它表中已包含的非主关键字信息</strong>。在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。理解注释：不能存在传递依赖。即：除主键外，其他字段必须依赖主键。</p>
</li>
</ol>
</blockquote>
</li>
<li><h4 id="事务四个基本特征ACID特性"><a href="#事务四个基本特征ACID特性" class="headerlink" title="事务四个基本特征ACID特性"></a>事务四个基本特征ACID特性</h4><blockquote>
<p>​    事务是并发控制的单位，使用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）.这是可靠数据库所应具备的几个特性.</p>
<ul>
<li><p>原子性</p>
<blockquote>
<p>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</blockquote>
</li>
<li><p>一致性</p>
<blockquote>
<p>在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>
</blockquote>
</li>
<li><p>隔离性</p>
<blockquote>
<p>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p>
</blockquote>
</li>
<li><p>持久性</p>
<blockquote>
<p>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><h4 id="MySql数据库默认的最大连接数"><a href="#MySql数据库默认的最大连接数" class="headerlink" title="MySql数据库默认的最大连接数"></a>MySql数据库默认的最大连接数</h4><blockquote>
<p>特定服务器上的数据库只能支持一定数目同时连接，这时候需要我们设置最大连接数（最多同时服务多少连接），在my.ini中查看设置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; # The maximum amount of concurrent sessions the MySQL server will</span><br><span class="line">&gt; # allow. One of these connections will be reserved for a user with</span><br><span class="line">&gt; # SUPER privileges to allow the administrator to login even if the</span><br><span class="line">&gt; # connection limit has been reached.</span><br><span class="line">&gt; max_connections=151</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><h4 id="MySql分页、Oracle分页和SqlServer分页"><a href="#MySql分页、Oracle分页和SqlServer分页" class="headerlink" title="MySql分页、Oracle分页和SqlServer分页"></a><del>MySql分页、Oracle分页和SqlServer分页</del></h4><blockquote>
<p>MySql使用limit关键字来分页</p>
<p>Oracle使用rownum</p>
<p>SqlServer使用top</p>
</blockquote>
</li>
<li><h4 id="触发器使用场景"><a href="#触发器使用场景" class="headerlink" title="触发器使用场景"></a><strong>触发器使用场景</strong></h4><blockquote>
</blockquote>
</li>
</ol>
<h2 id="前端笔记"><a href="#前端笔记" class="headerlink" title="前端笔记"></a>前端笔记</h2><h2 id="框架笔记"><a href="#框架笔记" class="headerlink" title="框架笔记"></a>框架笔记</h2><ol>
<li><h4 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h4><blockquote>
<ol>
<li>用户向服务器发送请求，请求被Spring前端控制器DispatcherServlet拦截</li>
<li>DispatcherServlet对请求的URL进行解析，得到请求资源标识符（URL）。然后根据URI调用HandlerMapping获的该Handler配置的所有相关对象，最后以HandlerExecutionChain对象的形式返回</li>
<li>DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter适配器，提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller），Handler执行完成后，向DispatcherServlet返回一个ModelAndVIew对象</li>
<li>DispatcherServlet根据返回的ModelAndVIew，选择一个合适的ViewResolver视图解析器</li>
<li>通过ViewResolver结合Model和View。来渲染视图，DispatcherServlet将渲染结果返回给客户端</li>
</ol>
</blockquote>
</li>
<li><h4 id="Struts2和SpringMVC区别"><a href="#Struts2和SpringMVC区别" class="headerlink" title="Struts2和SpringMVC区别"></a>Struts2和SpringMVC区别</h4><blockquote>
<ol>
<li>Struts2的前端控制器是Filter，SpringMVC是Servlet</li>
<li>SpringMVC是基于方法设计，而Struts2是基于对象</li>
<li>SpringMVC属于Spring大家族中的一员，Spring对于SpringMVC的控制器管理更加方便，而Struts2采用XML配置参数来管理</li>
<li>Struts2中自身提供多种参数接收，其实都是通过ValueStack进行传递和赋值，而SpringMVC是通过方法的参数进行接收</li>
<li>Struts2拥有较多的技术点，比如拦截器、值栈和OGNL表达式，学习成本较高，而SpringMVC相对比较简单</li>
<li>Struts有自己的interceptor拦截机制，SpringMVC使用的是独立的AOP</li>
<li>SpringMVC处理Ajax请求，直接通过返回数据，方法中使用注解@ResponseBody直接转为JSON对象返回，而Struts2是通过插件的方式处理</li>
</ol>
</blockquote>
</li>
<li><h4 id="Spring中的两大核心"><a href="#Spring中的两大核心" class="headerlink" title="Spring中的两大核心"></a>Spring中的两大核心</h4><blockquote>
<ol>
<li><p>IOC（Inversion of Control）或DI（Dependency Injection）</p>
<blockquote>
<p><strong>IOC控制反转：</strong></p>
<p>在spring中BeanFactory是IOC容器的核心接口，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。XmlBeanFactory实现BeanFactory接口，通过获取xml配置文件数据，组成应用对象及对象间的依赖关系。</p>
<p>Spring中有三种注入方式：set注入、接口注入、构造方法注入</p>
<p>核心原理：配置文件+反射+容器</p>
</blockquote>
</li>
<li><p>AOP面向切面编程：</p>
<blockquote>
<p>使用动态代理的方式在执行前后或出现异常后执行相关逻辑</p>
<p>主要用于：事务、日志、权限校验</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><h4 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h4><blockquote>
<p>为了解决面向对象与关系数据库存在的互不匹配的现象的框架</p>
</blockquote>
</li>
<li><h4 id="Mybatis和Hibernate区别"><a href="#Mybatis和Hibernate区别" class="headerlink" title="Mybatis和Hibernate区别"></a>Mybatis和Hibernate区别</h4><blockquote>
<p><strong>相同点：</strong></p>
<p>​    都是java中的ORM框架、屏蔽了jdbc api的底层访问细节。</p>
<p>​    mybatis：专注sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis也可以实现映射（输入映射，输出映射）</p>
<p>​    应用场景：适用需求变化较多的项目，比如：互联网项目。</p>
<p>​    hibernate:是一个标准的ORM框架（对象关系映射）。入门门槛较高，不需要写sql，sql语句自动生成，对sql语句进行优化、修改比较困难。</p>
<p>​    应用场景：适用需求变化不多的中小型项目，比如：后台管理系统，erp，orm，oa等</p>
</blockquote>
</li>
<li><h4 id="Hibernate映射对象的状态"><a href="#Hibernate映射对象的状态" class="headerlink" title="Hibernate映射对象的状态"></a>Hibernate映射对象的状态</h4><blockquote>
<ol>
<li>临时状态(transient)(瞬态)：刚用new 语句创建，还没有被持久化，并且不处于Sesssion 的缓存中。处于临时状态的Java 对象被称为临时对象。</li>
<li>持久化状态(persistent)：已经被持久化，并且加入到Session 的缓存中。处于持久化状态的Java 对象被称为持久化对象。</li>
<li>删除状态(removed)：不再处于Session 的缓存中，并且Session 已经计划将其从数据库中删除。处于删除状态的Java 对象被称为删除对象。</li>
<li>游离状态(detached)：已经被持久化，但不再处于Session 的缓存中。处于游离状态的Java 对象被称为游离对象。</li>
</ol>
<p>下面以具体的代码来说明这四种状态:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">&gt;   </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">&gt;         SessionFactory sessionFactory=HibernateUtil.getSessionFactory();  </span><br><span class="line">&gt;         Session session=sessionFactory.openSession(); <span class="comment">// 生成一个session  </span></span><br><span class="line">&gt;         session.beginTransaction(); <span class="comment">// 开启事务  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         Person p1=<span class="keyword">new</span> Person(<span class="string">"天天"</span>,<span class="string">"18"</span>,<span class="string">"3009"</span>); <span class="comment">// 临时对象1  </span></span><br><span class="line">&gt;         Person p2=<span class="keyword">new</span> Person(<span class="string">"小李"</span>,<span class="string">"23"</span>,<span class="string">"4009"</span>); <span class="comment">// 临时对象1   </span></span><br><span class="line">&gt;         session.save(p1); <span class="comment">// 持久化对象  </span></span><br><span class="line">&gt;         session.save(p2); <span class="comment">// 持久化对象  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         session.delete(p2); <span class="comment">// 删除对象  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         session.getTransaction().commit(); <span class="comment">// 提交事务  </span></span><br><span class="line">&gt;         session.close(); <span class="comment">// 关闭session  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         System.out.println(p1.getName()); <span class="comment">// 游离对象  </span></span><br><span class="line">&gt;         System.out.println(p2.getName()); <span class="comment">// 删除对象  </span></span><br><span class="line">&gt;     &#125;     </span><br><span class="line">&gt; &#125;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><h4 id="Hibernate缓存机制"><a href="#Hibernate缓存机制" class="headerlink" title="Hibernate缓存机制"></a>Hibernate缓存机制</h4><blockquote>
<p>​    使用缓存是为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能</p>
<p>​    Hibernate缓存分为一级缓存和二级缓存，一级缓存就是Session级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。</p>
<p>什么样的数据适合存放到第二级缓存中？ 　　</p>
<p>​    1) 很少被修改的数据 　帖子的最后回复时间　</p>
<p>​    2) 经常被查询的数据   电商的地点</p>
<p>​    3) 不是很重要的数据，允许出现偶尔并发的数据 　　</p>
<p>​    4) 不会被并发访问的数据 　　</p>
<p>​    5) 常量数据 </p>
<p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用memcahe,redis等中央缓存来代替二级缓存。</p>
</blockquote>
</li>
<li><h4 id="webservice使用场景"><a href="#webservice使用场景" class="headerlink" title="webservice使用场景"></a>webservice使用场景</h4><blockquote>
<p>​    webservice是一个SOA（面向服务的编程）的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过Internet进行基于Http协议的网络应用间的交互。</p>
<ol>
<li><p>异构系统(不同语言)的整合</p>
</li>
<li><p>不同客户端的整合，浏览器、手机端(android,ios.塞班)、微信端、PC端等终端来访问</p>
</li>
<li><p>实实在在的列子：</p>
<p>天气预报：可以通过实现webservice客户端调用远程天气服务实的。 </p>
<p>单点登录：一个服务是所有系统的登录</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="服务器及优化"><a href="#服务器及优化" class="headerlink" title="服务器及优化"></a>服务器及优化</h2><ol>
<li><h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><blockquote>
<p>常用：</p>
<p>​    Pwd 获取当前路径</p>
<p>​    Cd 跳转到目录</p>
<p>​    Su -u 切换到管理员</p>
<p>​    Ls ls 列举目录</p>
<p>文件操作命令：</p>
<p>​    文件</p>
<p>​           tail 查看</p>
<p>​           rm -rf </p>
<p>​           vi</p>
<p>​    文件夹</p>
<p>​           mkdir </p>
<p>​           rm -r</p>
</blockquote>
</li>
<li><h4 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h4><blockquote>
<p>做过mysql数据库的优化、其他数据库类似</p>
<p>定位：查找、定位慢查询</p>
<p>优化手段：</p>
<p>​    a) 创建索引：创建合适的索引，我们就可以现在索引中查询，查询到以后直接找对应的记录。</p>
<p>​    b) 分表：当一张表的数据比较多或者一张表的某些字段的值比较多并且很少使用时，采用水平分表和垂直分表来优化</p>
<p>​    c) 读写分离：当一台服务器不能满足需求时，采用读写分离的方式进行集群。</p>
<p>​    d) 缓存：使用redis来进行缓存</p>
<p>​    e) 一些常用优化技巧</p>
<p><a href="http://www.cnblogs.com/luyucheng/p/6323477.html" target="_blank" rel="noopener">优化</a></p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/07/18/Java-Java笔记/" data-id="ckmh9ucmj008g3oumtqkfx49q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构-1-稀疏数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/数据结构-1-稀疏数组/" class="article-date">
  <time datetime="2019-07-17T16:00:00.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>►<a class="article-category-link" href="/categories/数据结构/数组/">数组</a>►<a class="article-category-link" href="/categories/数据结构/数组/稀疏数组/">稀疏数组</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/数据结构-1-稀疏数组/">稀疏数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>​        当一个数组中大部分元素为0，或者为同一值的数组时，可研使用稀疏数组来保存该数组。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h2><ol>
<li>记录数组一共有几行几列，有多少个不同的值。</li>
<li>把具有不同值的元素的行列及值记录在小规模的数组中，从而缩小程序的规模。</li>
</ol>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200709221603.png" alt></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: SparseArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * 二维数组转稀疏数组思路</span></span><br><span class="line"><span class="comment"> * 1. 遍历原始的二维数组，得到有效数据的个数count</span></span><br><span class="line"><span class="comment"> * 2. 根据count就可以创建 稀疏数组 sparseArr   int[count + 1] [3]</span></span><br><span class="line"><span class="comment"> * 3. 将二维数组的有效数据数据存入到 稀疏数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 10136</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/9 22:20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个原始的二维数组11*11</span></span><br><span class="line">        <span class="comment">//0表示没有棋子，1表示黑子，2表示蓝子</span></span><br><span class="line">        <span class="keyword">int</span> chessOriginArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessOriginArr[<span class="number">1</span>][<span class="number">2</span>]= <span class="number">1</span>;</span><br><span class="line">        chessOriginArr[<span class="number">2</span>][<span class="number">3</span>]= <span class="number">2</span>;</span><br><span class="line">        chessOriginArr[<span class="number">5</span>][<span class="number">2</span>]= <span class="number">2</span>;</span><br><span class="line">        chessOriginArr[<span class="number">2</span>][<span class="number">4</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出原始数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessOriginArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1. 遍历原始的二维数组，得到有效数据的个数count</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessOriginArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data!=<span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(count);//2</span></span><br><span class="line">        <span class="comment">//2. 根据count就可以创建 稀疏数组 sparseArr   int[count + 1] [3]</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//3. 将二维数组的有效数据数据存入到 稀疏数组</span></span><br><span class="line">        <span class="comment">//第一行存储原始数组的行数，列数以及有效数字数量</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line">        <span class="keyword">int</span> rowNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(chessOriginArr[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    rowNum++;</span><br><span class="line">                    sparseArr[rowNum][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[rowNum][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[rowNum][<span class="number">2</span>] = chessOriginArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:sparseArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        <span class="comment">//稀疏数组还原为原始数组</span></span><br><span class="line">        <span class="keyword">int</span> chessOriginBackArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessOriginBackArr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:chessOriginBackArr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> data :row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	1	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	2	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">------------------------------------</span><br><span class="line">11	11	4	</span><br><span class="line">1	2	1	</span><br><span class="line">2	3	2	</span><br><span class="line">2	4	1	</span><br><span class="line">5	2	2	</span><br><span class="line">------------------------------------</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	1	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	2	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/07/18/数据结构-1-稀疏数组/" data-id="ckmh9ucj200143oumba9lprwz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数组/">数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/稀疏数组/">稀疏数组</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构-2-环形队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/数据结构-2-环形队列/" class="article-date">
  <time datetime="2019-07-17T16:00:00.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>►<a class="article-category-link" href="/categories/数据结构/环形队列/">环形队列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/数据结构-2-环形队列/">数组模拟环形队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><ol>
<li>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li>
<li>遵循<strong>先进先出</strong>的原则。即：先进入队列的数据，要先取出。后进入的要后取出</li>
</ol>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h2><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200709225933.png" alt></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/07/18/数据结构-2-环形队列/" data-id="ckmh9ucj300153oumzpcyiomp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环形队列/">环形队列</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-项目-FangXingMallNote" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/29/项目-FangXingMallNote/" class="article-date">
  <time datetime="2019-06-29T14:12:23.000Z" itemprop="datePublished">2019-06-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/项目/">项目</a>►<a class="article-category-link" href="/categories/项目/方兴商城/">方兴商城</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/29/项目-FangXingMallNote/">方兴商城笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="方兴商城"><a href="#方兴商城" class="headerlink" title="方兴商城"></a>方兴商城</h1><h2 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h2><p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="系统架构图"></p>
<h2 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h2><table>
<thead>
<tr>
<th><strong>表名称</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>tb_brand</td>
<td>品牌</td>
</tr>
<tr>
<td>tb_specification</td>
<td>规格</td>
</tr>
<tr>
<td>tb_specification_option</td>
<td>规格选项</td>
</tr>
<tr>
<td>tb_type_template</td>
<td>类型模板：用于关联品牌和规格</td>
</tr>
<tr>
<td>tb_item_cat</td>
<td>商品分类</td>
</tr>
<tr>
<td>tb_seller</td>
<td>商家</td>
</tr>
<tr>
<td>tb_goods</td>
<td>商品</td>
</tr>
<tr>
<td>tb_goods_desc</td>
<td>商品详情</td>
</tr>
<tr>
<td>tb_item</td>
<td>商品明细</td>
</tr>
<tr>
<td>tb_content</td>
<td>内容（广告）</td>
</tr>
<tr>
<td>tb_content_category</td>
<td>内容（广告）类型</td>
</tr>
<tr>
<td>tb_user</td>
<td>用户</td>
</tr>
<tr>
<td>tb_order</td>
<td>订单</td>
</tr>
<tr>
<td>tb_order_item</td>
<td>订单明细</td>
</tr>
<tr>
<td>tb_pay_log</td>
<td>支付日志</td>
</tr>
</tbody></table>
<h2 id="系统框架组合"><a href="#系统框架组合" class="headerlink" title="系统框架组合"></a>系统框架组合</h2><ul>
<li>前端<ul>
<li>AngularJS(基础指令学习)</li>
<li>BootStrap</li>
</ul>
</li>
<li>后端<ul>
<li>Spring</li>
<li>SpringMVC</li>
<li>SpringSecurity</li>
<li>Mybatis</li>
<li>Dubbox</li>
</ul>
</li>
</ul>
<h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h2><ol>
<li>创建父工程fangxingmall-parent（POM）</li>
<li>创建实体类模块fangxingmall-pojo</li>
<li>创建数据访问模块fangxingmall-dao</li>
<li>创建商家商品服务接口模块fangxingmall-sellergoods-interface</li>
<li>创建商家商品服务模块fangxingmall-sellergoods-service</li>
<li>创建运营商管理后台模块fangxingmall-manager-web</li>
<li>创建商家管理后台模块fangxingmall-shop-web</li>
</ol>
<h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><ol>
<li><p>服务器安装软件</p>
<ul>
<li><p>安装zookeeper</p>
<ol>
<li><p>服务器安装JDK</p>
</li>
<li><p>上传zookeeper压缩包到服务器</p>
</li>
<li><p>解压缩</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# tar -zxvf zookeeper-3.4.6.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入zookeeper-3.4.6目录创建data文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# mkdir data</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入conf目录，重命名zoo_sample.cfg为zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开zoo.cfg文件，修改data存储路径为你解压缩新建的data路径，pwd查看当前路径直接复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# vim zoo.cfg</span><br><span class="line"><span class="meta">#</span>dataDir=/usr/dubbo/zookeeper-3.4.6/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入bin目录，启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# ./zkServer.sh start</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# ./zkServer.sh stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_90_242_centos bin]# ./zkServer.sh status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /usr/dubbo/zookeeper-3.4.6/bin/../conf/zoo.cfg</span><br><span class="line">Mode: standalonexxxxxxxxxx [root@VM_90_242_centos bin]# ./zkServer.sh statusJMX enabled by defaultUsing config: /usr/dubbo/zookeeper-3.4.6/bin/../conf/zoo.cfgMode: standalone./zkServer.sh statusshell</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>安装Dubbox</p>
<ol>
<li><p>手动安装Dubbox的jar包到本地仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=d:\setup\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置离线约束</p>
<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20190918105912.png" alt="配置离线约束"></p>
</li>
</ol>
</li>
<li><p><a href="https://fangchenyong.top/2019/07/23/install_ActiveMQ/">安装activemq</a></p>
</li>
</ul>
</li>
<li><p>修改</p>
<ol>
<li><p>数据库连接修改</p>
<blockquote>
<p>/fangxingmall-dao/src/main/resources/properties/db.properties</p>
</blockquote>
</li>
<li><p>redis配置修改</p>
<blockquote>
<p>/fangxingmall-common/src/main/resources/properties/redis-config.properties</p>
</blockquote>
</li>
<li><p>日志文件配置修改</p>
<blockquote>
<p>/fangxingmall-sellergoods-service/src/main/resources/log4j.properties</p>
</blockquote>
</li>
<li><p>dubbo连接修改</p>
<blockquote>
<p>/fangxingmall-sellergoods-service/src/main/resources/spring/applicationContext-service.xml</p>
<p>/fangxingmall-shop-web/src/main/resources/spring/springmvc.xml</p>
<p>/fangxingmall-shop-web/src/main/resources/spring/spring-security.xml</p>
<p>/fangxingmall-manager-web/src/main/resources/spring/springmvc.xml</p>
<p>/fangxingmall-content-service/src/main/resources/spring/applicationContext-service.xml</p>
<p>/fangxingmall-portal-web/src/main/resources/spring/springmvc.xml</p>
<p>/fangxingmall-search-web/src/main/resources/spring/springmvc.xml</p>
</blockquote>
</li>
<li><p>FastDFS配置</p>
</li>
<li><p>solr配置</p>
<blockquote>
<p>/fangxingmall-solr-util/src/main/resources/spring/applicationContext-solr.xml</p>
</blockquote>
</li>
<li></li>
</ol>
</li>
<li><p>启动模块（MavenBulid tomcat7:run）</p>
<ol>
<li>fangxingmall-sellergoods-service，端口9001</li>
<li>fangxingmall-manager-web，端口9101</li>
<li>fangxingmall-content-service，端口9002</li>
<li>fangxingmall-shop-web，端口9102</li>
<li>fangxingmall-portal-web，端口9103</li>
<li>fangxingmall-search-service，端口9004</li>
<li>fangxingmall-search-web，端口9104</li>
<li>fangxingmall-page-service，端口9005</li>
<li>fangxingmall-page-web，端口9105</li>
</ol>
</li>
<li><p>开发进度</p>
<ul>
<li><p>新增、修改、删除商品分类</p>
</li>
<li><p>安装Fast DFS服务器</p>
</li>
<li><p>TO DO 图片上传</p>
</li>
<li><p>按销量、评价排序</p>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fangchenyong.top/2019/06/29/项目-FangXingMallNote/" data-id="ckmh9ucj500173oumzmku5vta" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/">SpringBoot</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/SpringBoot/netty/">netty</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/源码/">源码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/源码/Object/">Object</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/源码/String/">String</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Jsplumb/">Jsplumb</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/">CentOS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/ActiveMQ/">ActiveMQ</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/FastDFS/">FastDFS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/FastDFS/nginx/">nginx</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/JDK/">JDK</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/MongoDB/">MongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/Tomcat/">Tomcat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/CentOS/zigw/">zigw</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Oracle/">Oracle</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Oracle/正则表达式/">正则表达式</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/My-Java-Life/">My Java Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ORM/">ORM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ORM/Hibernate/">Hibernate</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/地图/">地图</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/地图/腾讯地图/">腾讯地图</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/地图/高德地图/">高德地图</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/Oracle/">Oracle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/SqlServer/">SqlServer</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/数组/">数组</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/数组/稀疏数组/">稀疏数组</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/环形队列/">环形队列</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/创建型模式/">创建型模式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/创建型模式/单例模式/">单例模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/设计原则/">设计原则</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试题/">面试题</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/面试题/集合/">集合</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目/">项目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/项目/方兴商城/">方兴商城</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveMQ/">ActiveMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS/">CentOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FastDFS/">FastDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hibernate/">Hibernate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jsplumb/">Jsplumb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/My-Java-Life/">My Java Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/">ORM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object/">Object</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SqlServer/">SqlServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zigw/">zigw</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维码/">二维码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/创建型模式/">创建型模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例模式/">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/地图/">地图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/存储过程/">存储过程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环形队列/">环形队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稀疏数组/">稀疏数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/腾讯地图/">腾讯地图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计原则/">设计原则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试题/">面试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高德地图/">高德地图</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ActiveMQ/" style="font-size: 10px;">ActiveMQ</a> <a href="/tags/CentOS/" style="font-size: 18.33px;">CentOS</a> <a href="/tags/FastDFS/" style="font-size: 10px;">FastDFS</a> <a href="/tags/Hibernate/" style="font-size: 10px;">Hibernate</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 13.33px;">JavaScript</a> <a href="/tags/Jsplumb/" style="font-size: 10px;">Jsplumb</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/My-Java-Life/" style="font-size: 10px;">My Java Life</a> <a href="/tags/MySQL/" style="font-size: 11.67px;">MySQL</a> <a href="/tags/MySql/" style="font-size: 10px;">MySql</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/ORM/" style="font-size: 10px;">ORM</a> <a href="/tags/Object/" style="font-size: 10px;">Object</a> <a href="/tags/Oracle/" style="font-size: 11.67px;">Oracle</a> <a href="/tags/Redis/" style="font-size: 13.33px;">Redis</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 11.67px;">SpringBoot</a> <a href="/tags/SqlServer/" style="font-size: 11.67px;">SqlServer</a> <a href="/tags/String/" style="font-size: 10px;">String</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/netty/" style="font-size: 10px;">netty</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/zigw/" style="font-size: 10px;">zigw</a> <a href="/tags/二维码/" style="font-size: 10px;">二维码</a> <a href="/tags/创建型模式/" style="font-size: 10px;">创建型模式</a> <a href="/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/tags/地图/" style="font-size: 11.67px;">地图</a> <a href="/tags/存储过程/" style="font-size: 10px;">存储过程</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 11.67px;">数据结构</a> <a href="/tags/数组/" style="font-size: 10px;">数组</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/源码/" style="font-size: 11.67px;">源码</a> <a href="/tags/环形队列/" style="font-size: 10px;">环形队列</a> <a href="/tags/稀疏数组/" style="font-size: 10px;">稀疏数组</a> <a href="/tags/腾讯地图/" style="font-size: 10px;">腾讯地图</a> <a href="/tags/设计原则/" style="font-size: 10px;">设计原则</a> <a href="/tags/设计模式/" style="font-size: 11.67px;">设计模式</a> <a href="/tags/集合/" style="font-size: 10px;">集合</a> <a href="/tags/面试题/" style="font-size: 10px;">面试题</a> <a href="/tags/高德地图/" style="font-size: 10px;">高德地图</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/20/面试-集合/">面试题-集合框架</a>
          </li>
        
          <li>
            <a href="/2021/03/13/The Road To Bald Man!/">The Road To Bald Man!</a>
          </li>
        
          <li>
            <a href="/2020/07/21/框架-Maven-配置标签详解/">Maven配置标签详解</a>
          </li>
        
          <li>
            <a href="/2020/07/13/设计模式-七大原则/">设计模式-七大设计原则</a>
          </li>
        
          <li>
            <a href="/2020/07/13/设计模式-创建型模式-单例模式/">设计模式-创建型模式-单例模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 fangchenyong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>