<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础笔记 | Joey</title><meta name="keywords" content="Java"><meta name="author" content="方陈勇"><meta name="copyright" content="方陈勇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础笔记">
<meta property="og:url" content="https://fangchenyong.github.io/2019/07/20/Java-Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Joey">
<meta property="og:description" content="Java基础笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG">
<meta property="article:published_time" content="2019-07-19T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-14T07:59:25.555Z">
<meta property="article:author" content="方陈勇">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fangchenyong.github.io/2019/07/20/Java-Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-09-14 15:59:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/3FD9B055-6361-49B7-B8CE-5BA9144BD27F.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">50</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Joey</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-07-19T16:00:00.000Z" title="发表于 2019-07-20 00:00:00">2019-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-14T07:59:25.555Z" title="更新于 2020-09-14 15:59:25">2020-09-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>68分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="Java基础笔记"><a href="#Java基础笔记" class="headerlink" title="Java基础笔记"></a>Java基础笔记</h1><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h2><h3 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h3><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p>
<p><strong>特点：关键字中所字母都为小写</strong></p>
<p>具体如下：</p>
<ul>
<li><p>用于定义数据类型的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>interface</td>
<td>enum</td>
<td>byte</td>
<td>short</td>
</tr>
<tr>
<td>int</td>
<td>long</td>
<td>float</td>
<td>double</td>
<td>char</td>
</tr>
<tr>
<td>boolean</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义流程控制的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>if</td>
<td>else</td>
<td>switch</td>
<td>case</td>
<td>default</td>
</tr>
<tr>
<td>while</td>
<td>do</td>
<td>for</td>
<td>break</td>
<td>continue</td>
</tr>
<tr>
<td>return</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义访问权限修饰符的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义类、函数、变量修饰符的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>abstract</td>
<td>final</td>
<td>static</td>
<td>synchronized</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义类与类之间关系的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>extents</td>
<td>implements</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于定义建立实例及引用实例、判断实例的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>new</td>
<td>this</td>
<td>super</td>
<td>instanceof</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>用于异常处理的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>try</td>
<td>catch</td>
<td>finally</td>
<td>throw</td>
<td>throws</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-2保留字"><a href="#1-2保留字" class="headerlink" title="1.2保留字"></a>1.2保留字</h3><p>goto、const</p>
<h3 id="1-3标识符"><a href="#1-3标识符" class="headerlink" title="1.3标识符"></a>1.3标识符</h3><p>定义：凡是自己可以起名字的地方都叫标识符</p>
<p>涉及到的结构：包名、类名、接口名、变量名、方法名、常量名</p>
<p>规则：</p>
<ul>
<li><strong>由26个英文字母大小写，0-9，_或$组成</strong></li>
<li><strong>数字不可以开头</strong></li>
<li><strong>不可以使用关键字和保留字，但能包含关键字和保留字</strong></li>
<li><strong>Java中严格区分大小写，长度无限制</strong></li>
<li><strong>标识符不能包含空格</strong></li>
</ul>
<p>规范：</p>
<ul>
<li>包名：多单词组成时所有字符都小写</li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
<li>变量名、方法名：多单词组成时，第一个单词的首字母小写，第二个单词开始每个单词首字母大写：XxxYyyZzz</li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ul>
<h3 id="1-4变量"><a href="#1-4变量" class="headerlink" title="1.4变量"></a>1.4变量</h3><ol>
<li><p>变量的分类</p>
<ol>
<li><p>按数据类型分类</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522100724.png"></p>
</li>
<li><p>详细说明</p>
<ol>
<li>整型：byte(1字节=8bit) \ short(2字节) \ int(4字节) \ long(8字节)<ul>
<li>① byte范围：-128 ~ 127</li>
<li>② 声明long型变量，必须以”l”或”L”结尾</li>
<li>③ 通常，定义整型变量时，使用int型。</li>
<li>④整型的常量，默认类型是：int型</li>
</ul>
</li>
<li>浮点型：float(4字节) \ double(8字节)<ul>
<li>① 浮点型，表示带小数点的数值</li>
<li>② float表示数值的范围比long还大</li>
<li>③ 定义float类型变量时，变量要以”f”或”F”结尾</li>
<li>④ 通常，定义浮点型变量时，使用double型。</li>
<li>⑤ 浮点型的常量，默认类型为：double</li>
</ul>
</li>
<li>字符型：char (1字符=2字节)<ul>
<li>① 定义char型变量，通常使用一对’’,内部只能写一个字符</li>
<li>② 表示方式：1.声明一个字符 2.转义字符 3.直接使用 Unicode 值来表示字符型常量</li>
</ul>
</li>
<li>布尔型：boolean<ul>
<li>① 只能取两个值之一：true 、 false</li>
<li>② 常常在条件判断、循环结构中使用</li>
</ul>
</li>
</ol>
</li>
<li><p>按声明的位置分类</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522123945.png"></p>
</li>
</ol>
</li>
<li><p>定义变量的格式</p>
<p> 数据类型  变量名 = 变量值;<br> 数据类型  变量名;<br> 变量名 = 变量值;</p>
</li>
<li><p>变量使用的注意点</p>
<ul>
<li>变量必须先声明，后使用</li>
<li>变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了</li>
<li>同一个作用域内，不可以声明两个同名的变量</li>
</ul>
</li>
<li><p>基本数据类型变量间运算规则</p>
<ol>
<li><p>涉及到的基本数据类型：除了boolean之外的其他7种</p>
</li>
<li><p>自动类型转换(只涉及7种基本数据类型）</p>
<p> 结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果<strong>自动提升为容量大</strong>的数据类型。</p>
<blockquote>
<p>byte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double </p>
<p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p>
<p><strong>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</strong></p>
</blockquote>
</li>
<li><p>强制类型转换(只涉及7种基本数据类型）：<strong>自动类型提升运算的逆运算</strong>。</p>
<ol>
<li>需要使用强转符：(类型)</li>
<li>注意点：强制类型转换，可能导致精度损失。</li>
</ol>
</li>
<li><p>String与8种基本数据类型间的运算</p>
<ol>
<li><p>String属于引用数据类型，翻译为：字符串</p>
</li>
<li><p>声明String类型变量时，使用一对””</p>
</li>
<li><p>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</p>
</li>
<li><p>运算的结果仍然是String类型</p>
</li>
</ol>
<p>   避免：</p>
<p>   String s = 123;//编译错误</p>
<p>   String s1 = “123”;</p>
<p>   int i = (int)s1;//编译错误</p>
</li>
</ol>
</li>
</ol>
<h3 id="1-5运算符"><a href="#1-5运算符" class="headerlink" title="1.5运算符"></a>1.5运算符</h3><ol>
<li><p>算数运算符： + - * / % (前)++ (后)++ (前)– (后)– </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="comment">//除号：/</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> result1 = num1 / num2;</span><br><span class="line">System.out.println(result1);<span class="comment">//2</span></span><br><span class="line"><span class="comment">// %:取余运算</span></span><br><span class="line"><span class="comment">//结果的符号与被模数的符号相同</span></span><br><span class="line"><span class="comment">//开发中，经常使用%来判断能否被除尽的情况。</span></span><br><span class="line"><span class="keyword">int</span> m1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m1 % n1 = &quot;</span> + m1 % n1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m2 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m2 % n2 = &quot;</span> + m2 % n2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m3 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n3 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m3 % n3 = &quot;</span> + m3 % n3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m4 = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n4 = -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m4 % n4 = &quot;</span> + m4 % n4);</span><br><span class="line"><span class="comment">//(前)++ :先自增1，后运算</span></span><br><span class="line"><span class="comment">//(后)++ :先运算，后自增1</span></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = ++a1;</span><br><span class="line">System.out.println(<span class="string">&quot;a1 = &quot;</span> + a1 + <span class="string">&quot;,b1 = &quot;</span> + b1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = a2++;</span><br><span class="line">System.out.println(<span class="string">&quot;a2 = &quot;</span> + a2 + <span class="string">&quot;,b2 = &quot;</span> + b2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">++a3;<span class="comment">//a3++;</span></span><br><span class="line"><span class="keyword">int</span> b3 = a3;</span><br><span class="line"><span class="comment">//(前)-- :先自减1，后运算</span></span><br><span class="line"><span class="comment">//(后)-- :先运算，后自减1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b4 = a4--;<span class="comment">//int b4 = --a4;</span></span><br><span class="line">System.out.println(<span class="string">&quot;a4 = &quot;</span> + a4 + <span class="string">&quot;,b4 = &quot;</span> + b4);</span><br><span class="line"></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span><span class="comment">//(前)++ :先自增1，后运算</span></span><br><span class="line"> <span class="comment">//(后)++ :先运算，后自增1</span></span><br><span class="line"><span class="number">2.</span><span class="comment">//(前)-- :先自减1，后运算</span></span><br><span class="line">  <span class="comment">//(后)-- :先运算，后自减1</span></span><br><span class="line"><span class="number">3.</span>连接符：+：只能使用在String与其他数据类型变量之间使用。</span><br></pre></td></tr></table></figure></li>
<li><p>赋值运算符：=  +=  -=  *=  /=  %= </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i2,j2;</span><br><span class="line"><span class="comment">//连续赋值</span></span><br><span class="line">i2 = j2 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//***************</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">10</span>,j3 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">num1 += <span class="number">2</span>;<span class="comment">//num1 = num1 + 2;</span></span><br><span class="line">System.out.println(num1);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">12</span>;</span><br><span class="line">num2 %= <span class="number">5</span>;<span class="comment">//num2 = num2 % 5;</span></span><br><span class="line">System.out.println(num2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//s1 = s1 + 2;//编译失败</span></span><br><span class="line">s1 += <span class="number">2</span>;<span class="comment">//结论：不会改变变量本身的数据类型</span></span><br><span class="line">System.out.println(s1);</span><br><span class="line"></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span>运算的结果不会改变变量本身的数据类型</span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="comment">//开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 2;</span></span><br><span class="line"><span class="comment">//方式二：num += 2; (推荐)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 1;</span></span><br><span class="line"><span class="comment">//方式二：num += 1; </span></span><br><span class="line"><span class="comment">//方式三：num++; (推荐)</span></span><br></pre></td></tr></table></figure></li>
<li><p>比较运算符： == != &gt;  &lt;  &gt;=  &lt;=  instanceof</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line">System.out.println(i = j);<span class="comment">//20</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(b2 == b1);<span class="comment">//false</span></span><br><span class="line">System.out.println(b2 = b1);<span class="comment">//true</span></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span>比较运算符的结果是<span class="keyword">boolean</span>类型</span><br><span class="line"><span class="number">2.</span>&gt;  &lt;  &gt;=  &lt;= :只能使用在数值类型的数据之间。</span><br><span class="line"><span class="number">3.</span> == 和 !=: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</span><br><span class="line">Account acct1 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">Account acct2 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">boolean</span> b1 = (acct1 == acct2);<span class="comment">//比较两个Account是否是同一个账户。</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = (acct1 != acct2);<span class="comment">//</span></span><br></pre></td></tr></table></figure></li>
<li><p>逻辑运算符：&amp; &amp;&amp;  |  || !  ^</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="comment">//区分&amp; 与 &amp;&amp;</span></span><br><span class="line"><span class="comment">//相同点1：&amp; 与  &amp;&amp; 的运算结果相同</span></span><br><span class="line"><span class="comment">//相同点2：当符号左边是true时，二者都会执行符号右边的运算</span></span><br><span class="line"><span class="comment">//不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</span></span><br><span class="line"><span class="comment">//开发中，推荐使用&amp;&amp;</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">b1 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b1 &amp; (num1++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">true</span>;</span><br><span class="line">b2 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b2 &amp;&amp; (num2++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line"><span class="comment">// 区分：| 与 || </span></span><br><span class="line"><span class="comment">//相同点1：| 与  || 的运算结果相同</span></span><br><span class="line"><span class="comment">//相同点2：当符号左边是false时，二者都会执行符号右边的运算</span></span><br><span class="line"><span class="comment">//不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</span></span><br><span class="line"><span class="comment">//开发中，推荐使用||</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = <span class="keyword">false</span>;</span><br><span class="line">b3 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b3 | (num3++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num3 = &quot;</span> + num3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b4 = <span class="keyword">false</span>;</span><br><span class="line">b4 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> num4 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b4 || (num4++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num4 = &quot;</span> + num4);</span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span>逻辑运算符操作的都是<span class="keyword">boolean</span>类型的变量。而且结果也是<span class="keyword">boolean</span>类型</span><br></pre></td></tr></table></figure></li>
<li><p>位运算符：&lt;&lt;  &gt;&gt; &gt;&gt;&gt; &amp;  |  ^  ~</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">21</span>;</span><br><span class="line">i = -<span class="number">21</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;i &lt;&lt; 2 :&quot;</span> + (i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;i &lt;&lt; 3 :&quot;</span> + (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;i &lt;&lt; 27 :&quot;</span> + (i &lt;&lt; <span class="number">27</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m &amp; n :&quot;</span> + (m &amp; n));</span><br><span class="line">System.out.println(<span class="string">&quot;m | n :&quot;</span> + (m | n));</span><br><span class="line">System.out.println(<span class="string">&quot;m ^ n :&quot;</span> + (m ^ n));</span><br><span class="line">【面试题】 你能否写出最高效的<span class="number">2</span> * <span class="number">8</span>的实现方式？ </span><br><span class="line">答案：<span class="number">2</span> &lt;&lt; <span class="number">3</span>  或  <span class="number">8</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span> 位运算符操作的都是整型的数据</span><br><span class="line"><span class="number">2.</span> &lt;&lt; ：在一定范围内，每向左移<span class="number">1</span>位，相当于 * <span class="number">2</span></span><br><span class="line">   &gt;&gt; :在一定范围内，每向右移<span class="number">1</span>位，相当于 / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">典型题目：</span><br><span class="line"><span class="number">1.</span>交换两个变量的值。</span><br><span class="line"><span class="number">2.</span>实现<span class="number">60</span>的二进制到十六进制的转换</span><br></pre></td></tr></table></figure></li>
<li><p>三元运算符：(条件表达式)? 表达式1 : 表达式2</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【典型代码】</span><br><span class="line"><span class="number">1.</span>获取两个整数的较大值</span><br><span class="line"><span class="number">2.</span>获取三个数的最大值</span><br><span class="line">【特别说明的】</span><br><span class="line"><span class="number">1.</span> 说明</span><br><span class="line">① 条件表达式的结果为<span class="keyword">boolean</span>类型</span><br><span class="line">② 根据条件表达式真或假，决定执行表达式<span class="number">1</span>，还是表达式<span class="number">2.</span></span><br><span class="line">  如果表达式为<span class="keyword">true</span>，则执行表达式<span class="number">1</span>。</span><br><span class="line">  如果表达式为<span class="keyword">false</span>，则执行表达式<span class="number">2</span>。</span><br><span class="line">③ 表达式<span class="number">1</span> 和表达式<span class="number">2</span>要求是一致的。</span><br><span class="line">④ 三元运算符可以嵌套使用</span><br><span class="line"><span class="number">2.</span> 凡是可以使用三元运算符的地方，都可以改写为<span class="keyword">if</span>-<span class="keyword">else</span>，反之，不成立。</span><br><span class="line"><span class="number">3.</span> 如果程序既可以使用三元运算符，又可以使用<span class="keyword">if</span>-<span class="keyword">else</span>结构，那么优先选择三元运算符。原因：简洁、执行效率高。</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-6流程控制"><a href="#1-6流程控制" class="headerlink" title="1.6流程控制"></a>1.6流程控制</h3><ol>
<li><p>分支结构</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">if</span>-<span class="keyword">else</span>条件判断结构</span><br><span class="line"><span class="number">1.1</span>.</span><br><span class="line">结构一：</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构二：二选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构三：n选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	执行表达式n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span>.说明：</span><br><span class="line"><span class="number">1.</span> <span class="keyword">else</span> 结构是可选的。</span><br><span class="line"><span class="number">2.</span> 针对于条件表达式：</span><br><span class="line">   &gt; 如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。</span><br><span class="line">   &gt; 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。</span><br><span class="line">   &gt; 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。</span><br><span class="line"><span class="number">3.</span> <span class="keyword">if</span>-<span class="keyword">else</span>结构是可以相互嵌套的。</span><br><span class="line"><span class="number">4.</span> 如果<span class="keyword">if</span>-<span class="keyword">else</span>结构中的执行语句只有一行时，对应的一对&#123;&#125;可以省略的。但是，不建议大家省略。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="keyword">switch</span>-<span class="keyword">case</span>选择结构</span><br><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">	执行语句<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">	执行语句<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	执行语句n;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>说明：</span><br><span class="line">① 根据<span class="keyword">switch</span>表达式中的值，依次匹配各个<span class="keyword">case</span>中的常量。一旦匹配成功，则进入相应<span class="keyword">case</span>结构中，调用其执行语句。</span><br><span class="line">  当调用完执行语句以后，则仍然继续向下执行其他<span class="keyword">case</span>结构中的执行语句，直到遇到<span class="keyword">break</span>关键字或此<span class="keyword">switch</span>-<span class="keyword">case</span>结构</span><br><span class="line">  末尾结束为止。</span><br><span class="line">② <span class="keyword">break</span>,可以使用在<span class="keyword">switch</span>-<span class="keyword">case</span>结构中，表示一旦执行到此关键字，就跳出<span class="keyword">switch</span>-<span class="keyword">case</span>结构</span><br><span class="line">③ <span class="keyword">switch</span>结构中的表达式，只能是如下的<span class="number">6</span>种数据类型之一：</span><br><span class="line">   <span class="keyword">byte</span> 、<span class="keyword">short</span>、<span class="keyword">char</span>、<span class="keyword">int</span>、枚举类型(JDK5<span class="number">.0</span>新增)、String类型(JDK7<span class="number">.0</span>新增)</span><br><span class="line">④ <span class="keyword">case</span> 之后只能声明常量。不能声明范围。</span><br><span class="line">⑤ <span class="keyword">break</span>关键字是可选的。</span><br><span class="line">⑥ <span class="keyword">default</span>:相当于<span class="keyword">if</span>-<span class="keyword">else</span>结构中的<span class="keyword">else</span>.  </span><br><span class="line">  <span class="keyword">default</span>结构是可选的，而且位置是灵活的。</span><br><span class="line"><span class="number">3.</span>如果<span class="keyword">switch</span>-<span class="keyword">case</span>结构中的多个<span class="keyword">case</span>的执行语句相同，则可以考虑进行合并。</span><br><span class="line"><span class="number">4.</span><span class="keyword">break</span>在<span class="keyword">switch</span>-<span class="keyword">case</span>中是可选的</span><br></pre></td></tr></table></figure></li>
<li><p>循环结构</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>循环结构的四要素</span><br><span class="line">① 初始化条件</span><br><span class="line">② 循环条件  ---&gt;是<span class="keyword">boolean</span>类型</span><br><span class="line">③ 循环体</span><br><span class="line">④ 迭代条件</span><br><span class="line">说明：通常情况下，循环结束都是因为②中循环条件返回<span class="keyword">false</span>了。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>三种循环结构：</span><br><span class="line"><span class="number">2.1</span> <span class="keyword">for</span>循环结构</span><br><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">	③</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"><span class="number">2.2</span> <span class="keyword">while</span>循环结构</span><br><span class="line">①</span><br><span class="line"><span class="keyword">while</span>(②)&#123;</span><br><span class="line">	③;</span><br><span class="line">	④;</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line">说明：</span><br><span class="line">写<span class="keyword">while</span>循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>和<span class="keyword">while</span>循环总结：</span><br><span class="line"><span class="number">1.</span> 开发中，基本上我们都会从<span class="keyword">for</span>、<span class="keyword">while</span>中进行选择，实现循环结构。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">for</span>循环和<span class="keyword">while</span>循环是可以相互转换的！ </span><br><span class="line">  区别：<span class="keyword">for</span>循环和<span class="keyword">while</span>循环的初始化条件部分的作用范围不同。</span><br><span class="line"><span class="number">3.</span> 我们写程序，要避免出现死循环。</span><br><span class="line"><span class="number">2.3</span> <span class="keyword">do</span>-<span class="keyword">while</span>循环结构</span><br><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	③;</span><br><span class="line">	④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br><span class="line">执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="number">1.</span><span class="keyword">do</span>-<span class="keyword">while</span>循环至少会执行一次循环体！</span><br><span class="line"><span class="number">2.</span>开发中，使用<span class="keyword">for</span>和<span class="keyword">while</span>更多一些。较少使用<span class="keyword">do</span>-<span class="keyword">while</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>“无限循环”结构: <span class="keyword">while</span>(<span class="keyword">true</span>) 或 <span class="keyword">for</span>(;;)</span><br><span class="line">总结：如何结束一个循环结构？</span><br><span class="line">方式一：当循环条件是<span class="keyword">false</span>时</span><br><span class="line">方式二：在循环体中，执行<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>嵌套循环</span><br><span class="line"><span class="number">1.</span>嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环</span><br><span class="line">  内层循环：循环结构A</span><br><span class="line">  外层循环：循环结构B</span><br><span class="line"><span class="number">2.</span>说明：</span><br><span class="line">① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</span><br><span class="line">② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次</span><br><span class="line">③ 外层循环控制行数，内层循环控制列数</span><br><span class="line">【典型练习】</span><br><span class="line">		<span class="comment">//练习一：</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		******</span></span><br><span class="line"><span class="comment">		******</span></span><br><span class="line"><span class="comment">		******</span></span><br><span class="line"><span class="comment">		******</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">4</span>;j++ )&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">6</span>;i++)&#123;</span><br><span class="line">				System.out.print(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//练习二：</span></span><br><span class="line">		<span class="comment">/*			i(行号)		j(*的个数)</span></span><br><span class="line"><span class="comment">		*			1			1</span></span><br><span class="line"><span class="comment">		**			2			2</span></span><br><span class="line"><span class="comment">		***			3			3</span></span><br><span class="line"><span class="comment">		****		4			4</span></span><br><span class="line"><span class="comment">		*****		5			5</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;<span class="comment">//控制行数</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)&#123;<span class="comment">//控制列数</span></span><br><span class="line">				System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//练习三：九九乘法表</span></span><br><span class="line">		<span class="comment">//练习四：100以内的质数</span></span><br><span class="line"></span><br><span class="line">补充:衡量一个功能代码的优劣：</span><br><span class="line"><span class="number">1.</span>正确性</span><br><span class="line"><span class="number">2.</span>可读性</span><br><span class="line"><span class="number">3.</span>健壮性</span><br><span class="line"><span class="number">4.</span>高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</span><br><span class="line"></span><br><span class="line">如何理解流程控制的练习：</span><br><span class="line">流程控制结构的使用 + 算法逻辑</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字：break和continue</p>
<table>
<thead>
<tr>
<th></th>
<th>使用范围</th>
<th>循环中使用的作用(不同点)</th>
<th>相同点</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>switch-case循环结构中</td>
<td>结束当前循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
<tr>
<td>continue</td>
<td>循环结构中</td>
<td>结束当次循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
</tbody></table>
<p> 补充：带标签的break和continue的使用</p>
<p> ​            return在方法中使用。</p>
</li>
<li><p>补充：Scanner类的使用</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何从键盘获取不同类型的变量：需要使用Scanner类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">具体实现步骤：</span></span><br><span class="line"><span class="comment">1.导包：import java.util.Scanner;</span></span><br><span class="line"><span class="comment">2.Scanner的实例化:Scanner scan = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">3.调用Scanner类的相关方法（next() / nextXxx()），来获取指定类型的变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException</span></span><br><span class="line"><span class="comment">导致程序终止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.导包：import java.util.Scanner;</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//2.Scanner的实例化</span></span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.调用Scanner类的相关方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的姓名：&quot;</span>);</span><br><span class="line">		String name = scan.next();</span><br><span class="line">		System.out.println(name);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的芳龄：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> age = scan.nextInt();</span><br><span class="line">		System.out.println(age);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的体重：&quot;</span>);</span><br><span class="line">		<span class="keyword">double</span> weight = scan.nextDouble();</span><br><span class="line">		System.out.println(weight);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;你是否相中我了呢？(true/false)&quot;</span>);</span><br><span class="line">		<span class="keyword">boolean</span> isLove = scan.nextBoolean();</span><br><span class="line">		System.out.println(isLove);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的性别：(男/女)&quot;</span>);</span><br><span class="line">		String gender = scan.next();<span class="comment">//&quot;男&quot;</span></span><br><span class="line">		<span class="keyword">char</span> genderChar = gender.charAt(<span class="number">0</span>);<span class="comment">//获取索引为0位置上的字符</span></span><br><span class="line">		System.out.println(genderChar);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h3 id="2-1一维数组"><a href="#2-1一维数组" class="headerlink" title="2.1一维数组"></a>2.1一维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>一维数组的声明与初始化</span><br><span class="line">正确的方式：</span><br><span class="line">	<span class="keyword">int</span> num;<span class="comment">//声明</span></span><br><span class="line">	num = <span class="number">10</span>;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">1001</span>;<span class="comment">//声明 + 初始化</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line">	<span class="comment">//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">	ids = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line">	<span class="comment">//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">	String[] names = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">错误的方式：</span><br><span class="line"><span class="comment">//		int[] arr1 = new int[];</span></span><br><span class="line"><span class="comment">//		int[5] arr2 = new int[5];</span></span><br><span class="line"><span class="comment">//		int[] arr3 = new int[3]&#123;1,2,3&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>一维数组元素的引用：通过角标的方式调用。</span><br><span class="line">		<span class="comment">//数组的角标（或索引从0开始的，到数组的长度-1结束。</span></span><br><span class="line">		names[<span class="number">0</span>] = <span class="string">&quot;王铭&quot;</span>;</span><br><span class="line">		names[<span class="number">1</span>] = <span class="string">&quot;王赫&quot;</span>;</span><br><span class="line">		names[<span class="number">2</span>] = <span class="string">&quot;张学良&quot;</span>;</span><br><span class="line">		names[<span class="number">3</span>] = <span class="string">&quot;孙居龙&quot;</span>;</span><br><span class="line">		names[<span class="number">4</span>] = <span class="string">&quot;王宏志&quot;</span>;<span class="comment">//charAt(0)</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数组的属性：length</span><br><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br><span class="line">System.out.println(ids.length);</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">数组一旦初始化，其长度就是确定的。arr.length</span><br><span class="line">数组长度一旦确定，就不可修改。</span><br><span class="line"><span class="number">4.</span>一维数组的遍历</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; names.length;i++)&#123;</span><br><span class="line">	System.out.println(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>一维数组元素的默认初始化值</span><br><span class="line">		&gt; 数组元素是整型：<span class="number">0</span></span><br><span class="line"> * 		&gt; 数组元素是浮点型：<span class="number">0.0</span></span><br><span class="line"> * 		&gt; 数组元素是<span class="keyword">char</span>型：<span class="number">0</span>或<span class="string">&#x27;\u0000&#x27;</span>，而非<span class="string">&#x27;0&#x27;</span></span><br><span class="line"> * 		&gt; 数组元素是<span class="keyword">boolean</span>型：<span class="keyword">false</span></span><br><span class="line"> * </span><br><span class="line"> * 		&gt; 数组元素是引用数据类型：<span class="keyword">null</span></span><br><span class="line"><span class="number">6.</span>一维数组的内存解析</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130221.png"></p>
<h3 id="2-2二维数组"><a href="#2-2二维数组" class="headerlink" title="2.2二维数组"></a>2.2二维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>如何理解二维数组？</span><br><span class="line">数组属于引用数据类型</span><br><span class="line">数组的元素也可以是引用数据类型</span><br><span class="line">一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>二维数组的声明与初始化</span><br><span class="line">正确的方式：</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一维数组</span></span><br><span class="line">	<span class="comment">//静态初始化</span></span><br><span class="line">	<span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">	<span class="comment">//动态初始化1</span></span><br><span class="line">	String[][] arr2 = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="comment">//动态初始化2</span></span><br><span class="line">	String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];</span><br><span class="line">	<span class="comment">//也是正确的写法：</span></span><br><span class="line">	<span class="keyword">int</span>[] arr4[] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;<span class="comment">//类型推断</span></span><br><span class="line">错误的方式：</span><br><span class="line"><span class="comment">//		String[][] arr4 = new String[][4];</span></span><br><span class="line"><span class="comment">//		String[4][3] arr5 = new String[][];</span></span><br><span class="line"><span class="comment">//		int[][] arr6 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span></span><br><span class="line"><span class="number">3.</span>如何调用二维数组元素:</span><br><span class="line">	System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">	System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//null</span></span><br><span class="line">	</span><br><span class="line">	arr3[<span class="number">1</span>] = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">	System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">	System.out.println(arr3[<span class="number">0</span>]);<span class="comment">//</span></span><br><span class="line"><span class="number">4.</span>二维数组的属性：</span><br><span class="line">	System.out.println(arr4.length);<span class="comment">//3</span></span><br><span class="line">	System.out.println(arr4[<span class="number">0</span>].length);<span class="comment">//3</span></span><br><span class="line">	System.out.println(arr4[<span class="number">1</span>].length);<span class="comment">//4</span></span><br><span class="line"><span class="number">5.</span>遍历二维数组元素</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr4.length;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr4[i].length;j++)&#123;</span><br><span class="line">			System.out.print(arr4[i][j] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>二维数组元素的默认初始化值</span><br><span class="line"> * 	规定：二维数组分为外层数组的元素，内层数组的元素</span><br><span class="line"> * 		<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"> * 		外层元素：arr[<span class="number">0</span>],arr[<span class="number">1</span>]等</span><br><span class="line"> * 		内层元素：arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">2</span>]等</span><br><span class="line"> * </span><br><span class="line"> *   ⑤ 数组元素的默认初始化值 </span><br><span class="line"> *   针对于初始化方式一：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"> *      外层元素的初始化值为：地址值</span><br><span class="line"> *      内层元素的初始化值为：与一维数组初始化情况相同</span><br><span class="line"> *      </span><br><span class="line"> *   针对于初始化方式二：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line"> *   	外层元素的初始化值为：<span class="keyword">null</span></span><br><span class="line"> *      内层元素的初始化值为：不能调用，否则报错。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>二维数组的内存结构</span><br></pre></td></tr></table></figure>

<p><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130249.png"></p>
<h3 id="2-3常见算法"><a href="#2-3常见算法" class="headerlink" title="2.3常见算法"></a>2.3常见算法</h3><ol>
<li><p>数组的创建与元素赋值：</p>
<p> 杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p>
</li>
<li><p>针对于数值型的数组：</p>
<p> 最大值、最小值、总和、平均数等</p>
</li>
<li><p>数组的赋值与复制</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1,array2;</span><br><span class="line">array1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p> 3.1 赋值：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2 = array1;</span><br></pre></td></tr></table></figure>

<p> 如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130448.png"><br> 3.2 复制：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array2 = <span class="keyword">new</span> <span class="keyword">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array2.length;i++)&#123;</span><br><span class="line">	array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130705.png"></p>
<p> 如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</p>
</li>
<li><p>数组元素的反转</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length / <span class="number">2</span>;i++)&#123;</span><br><span class="line">    String temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">    arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">    String temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数组中指定元素的查找：搜索、检索</p>
<p> 5.1 线性查找： </p>
<p> 实现思路：通过遍历的方式，一个一个的数据进行比较、查找。</p>
<p> 适用性：具有普遍适用性。</p>
<p> 5.2 二分法查找：</p>
<p> 实现思路：每次比较中间值，折半的方式检索。</p>
<p> 适用性：（前提：数组必须有序）</p>
</li>
<li><p>数组的排序算法</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130852.png"></p>
<p> 理解：</p>
<p> 1）衡量排序算法的优劣：时间复杂度、空间复杂度、稳定性</p>
<p> 2）排序的分类：内部排序 与 外部排序（需要借助于磁盘）</p>
<p> 3）不同排序算法的时间复杂度</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522130927.png"></p>
<p> 4）手写冒泡排序</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">43</span>,<span class="number">32</span>,<span class="number">76</span>,-<span class="number">98</span>,<span class="number">0</span>,<span class="number">64</span>,<span class="number">33</span>,-<span class="number">21</span>,<span class="number">32</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-4Arrays工具类"><a href="#2-4Arrays工具类" class="headerlink" title="2.4Arrays工具类"></a>2.4Arrays工具类</h3><ol>
<li><p>理解：</p>
<p> ① 定义在java.util包下。</p>
<p> ② Arrays:提供了很多操作数组的方法。</p>
</li>
<li><p>使用：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.boolean equals(int[] a,int[] b):判断两个数组是否相等。</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> isEquals = Arrays.equals(arr1, arr2);</span><br><span class="line">System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.String toString(int[] a):输出数组信息。</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.void fill(int[] a,int val):将指定值填充到数组之中。</span></span><br><span class="line">Arrays.fill(arr1,<span class="number">10</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.void sort(int[] a):对数组进行排序。</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.int binarySearch(int[] a,int key)</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(arr3, <span class="number">210</span>);</span><br><span class="line"><span class="keyword">if</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-5常见异常"><a href="#2-5常见异常" class="headerlink" title="2.5常见异常"></a>2.5常见异常</h3><ol>
<li><p>数组角标越界异常：ArrayIndexOutOfBoundsException</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(arr[-<span class="number">2</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>空指针异常：NullPointerException</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line"><span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">System.out.println(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//情况三：</span></span><br><span class="line">String[] arr3 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>].toString());</span><br></pre></td></tr></table></figure>

<p> 小知识：一旦程序出现异常，未处理时，就终止执行。</p>
</li>
</ol>
<h2 id="3-面向对象（上）"><a href="#3-面向对象（上）" class="headerlink" title="3.面向对象（上）"></a>3.面向对象（上）</h2><h3 id="3-1类与对象"><a href="#3-1类与对象" class="headerlink" title="3.1类与对象"></a>3.1类与对象</h3><ol>
<li><p>面向对象学习的三条主线：</p>
<ol>
<li>Java类及类的成员：属性、方法、构造器；代码块、内部类</li>
<li>面向对象的大特征：封装性、继承性、多态性、(抽象性)</li>
<li>其它关键字：this、super、static、final、abstract、interface、package、import等</li>
</ol>
</li>
<li><p>面向对象与面向过程（理解）</p>
<ol>
<li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li>
<li>面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
</ol>
</li>
<li><p>完成一个项目（或功能）的思路：</p>
<ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。</li>
<li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。</li>
</ul>
</li>
<li><p>面向对象中两个重要的概念：</p>
<p> 类：对一类事物的描述，是抽象的、概念上的定义</p>
<p> 对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)</p>
<p> ​            面向对象程序设计的重点是类的设计，设计类，就是设计类的成员。</p>
<p> 二者的关系：对象，是由类new出来的，派生出来的。</p>
</li>
<li><p>面向对象思想落地实现的规则一</p>
<ol>
<li>创建类，设计类的成员</li>
<li>创建类的对象</li>
<li>通过“对象.属性”或“对象.方法”调用对象的结构</li>
</ol>
<p> 补充：几个概念的使用说明</p>
<ol>
<li>属性 = 成员变量 = field = 域、字段</li>
<li>方法 = 成员方法 = 函数 = method</li>
<li>创建类的对象 = 类的实例化 = 实例化类</li>
</ol>
</li>
<li><p>对象的创建与对象的内存解析</p>
<p> 典型代码：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p3 = p1;<span class="comment">//没有新创建一个对象，共用一个堆空间中的对象实体。</span></span><br></pre></td></tr></table></figure>

<p> 说明：</p>
<p> ​        如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）<br> 意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</p>
<p> 内存解析：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522151443.png"></p>
<p> <img src="E:\GitHubBlog\fangchenyong.github.io\Hexo\source_posts\基础.assets\1590131692254.png" alt="1590131692254"></p>
</li>
<li><p>匿名对象:我们创建的对象，没显式的赋给一个变量名。即为匿名对象</p>
<p> 特点：匿名对象只能调用一次。</p>
<p> 举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Phone().sendEmail();</span><br><span class="line"><span class="keyword">new</span> Phone().playGame();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">new</span> Phone().showPrice();<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure>

<p> 应用场景：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象的使用</span></span><br><span class="line">mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">其中，</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">		phone.sendEmail();</span><br><span class="line">		phone.playGame();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>理解”万事万物皆对象”</p>
<ol>
<li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构<ul>
<li>Scanner,String等</li>
<li>文件：File</li>
<li>网络资源：URL</li>
</ul>
</li>
<li>涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</li>
</ol>
</li>
<li><p>JVM内存结构简述</p>
<p> 编译完源程序以后，生成一个或多个字节码文件。</p>
<p> 我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节</p>
<p> 码文件对应的类加载到内存中，涉及到内存解析。</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522151721.png"></p>
<p> 虚拟机栈：即为平时提到的栈结构。</p>
<p> 我们将局部变量存储在栈结构中堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。</p>
<p> 补充：对象的属性（非static的）加载在堆空间中。</p>
<p> 方法区：类的加载信息、常量池、静态域</p>
</li>
</ol>
<h3 id="3-2类的结构之一：属性"><a href="#3-2类的结构之一：属性" class="headerlink" title="3.2类的结构之一：属性"></a>3.2类的结构之一：属性</h3><p>对比：属性  vs  局部变量</p>
<ul>
<li><p>相同点</p>
<ol>
<li>定义变量的格式：数据类型  变量名 = 变量值</li>
<li>先声明，后使用</li>
<li>变量都其对应的作用域</li>
</ol>
</li>
<li><p>不同点</p>
<ol>
<li><p>在类中声明的位置的不同</p>
<ul>
<li>属性：直接定义在类的一对{}内</li>
<li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li>
</ul>
</li>
<li><p>关于权限修饰符的不同</p>
<ul>
<li><p>属性：可以在声明属性时，指明其权限，使用权限修饰符。</p>
<p>  ​            常用的权限修饰符：private、public、缺省、protected  —&gt;封装性</p>
</li>
<li><p>局部变量：不可以使用权限修饰符。</p>
</li>
</ul>
</li>
<li><p>默认初始化值的情况：</p>
<ul>
<li><p>属性：类的属性，根据其类型，都默认初始化值。</p>
<ul>
<li>整型（byte、short、int、long：0）</li>
<li>浮点型（float、double：0.0）</li>
<li>字符型（char：0  （或’\u0000’））</li>
<li>布尔型（boolean：false）</li>
<li>引用数据类型（类、数组、接口：null）</li>
</ul>
</li>
<li><p>局部变量：没默认初始化值。</p>
<p>  ​                    意味着，我们在调用局部变量之前，一定要显式赋值。</p>
<p>  ​                    特别地：形参在调用时，我们赋值即可。</p>
</li>
</ul>
</li>
<li><p>在内存中加载的位置：</p>
<ul>
<li>属性：加载到堆空间中   （非static）</li>
<li>局部变量：加载到栈空间</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-3类的结构之二：方法"><a href="#3-3类的结构之二：方法" class="headerlink" title="3.3类的结构之二：方法"></a>3.3类的结构之二：方法</h3><ol>
<li><p>方法的声明：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法的声明：权限修饰符  返回值类型  方法名(形参列表)&#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关键字：return</p>
<ul>
<li>使用范围：使用在方法体中</li>
<li>作用：<ul>
<li> 结束方法</li>
<li> 针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</li>
</ul>
</li>
<li>注意点：return关键字后面不可以声明执行语句。</li>
</ul>
</li>
<li><p>方法的重载</p>
<ol>
<li><p>概念</p>
<p> 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p>
<p> <strong>总结：”两同一不同”:同一个类、相同方法名</strong></p>
<p> ​            <strong>参数列表不同：参数个数不同，参数类型不同</strong></p>
</li>
<li><p>构成重载的举例：</p>
<p> 举例一：Arrays类中重载的sort() / binarySearch()；PrintStream中的println()</p>
<p> 举例二：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如下的4个方法构成了重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">double</span> d1,<span class="keyword">double</span> d2)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(String s ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i,String s)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如何判断是否构成方法的重载？</p>
<p> 严格按照定义判断：两同一不同。</p>
<p> <strong>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</strong></p>
</li>
<li><p>如何确定类中某一个方法的调用：</p>
<p> 方法名 —&gt; 参数列表</p>
<p> 面试题：方法的重载与重写的区别？</p>
<blockquote>
<p>throws\throw<br>String\StringBuffer\StringBuilder<br>Collection\Collections<br>final\finally\finalize<br>…</p>
</blockquote>
<blockquote>
<p>抽象类、接口<br>sleep() / wait()</p>
</blockquote>
</li>
</ol>
</li>
<li><p>可变个数形参的方法</p>
<ol>
<li><p>使用说明：</p>
<ol>
<li>jdk 5.0新增的内容</li>
<li>具体使用：<ul>
<li>可变个数形参的格式：数据类型 … 变量名</li>
<li>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</li>
<li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</li>
<li>可变个数形参在方法的形参中，必须声明在末尾</li>
<li>可变个数形参在方法的形参中,最多只能声明一个可变形参。</li>
</ul>
</li>
</ol>
</li>
<li><p>举例说明</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String ... strs)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String ... strs)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//	public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用时：</span></span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">test.show();</span><br><span class="line"></span><br><span class="line">test.show(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>java 的值传递机制</p>
<ol>
<li><p>针对于方法内变量的赋值举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;***********基本数据类型：****************&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n = m;</span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;***********引用数据类型：****************&quot;</span>);</span><br><span class="line">Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">o1.orderId = <span class="number">1001</span>;</span><br><span class="line">Order o2 = o1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br><span class="line"></span><br><span class="line">o2.orderId = <span class="number">1002</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br></pre></td></tr></table></figure>

<p> 规则：</p>
<p> ​        如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</p>
<p> ​        如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p>
</li>
<li><p>针对于方法的参数概念</p>
<p> 形参：方法定义时，声明的小括号内的参数</p>
<p> 实参：方法调用时，实际传递给形参的数据</p>
</li>
<li><p>java中参数传递机制：值传递</p>
<p> 规则：</p>
<p> ​        如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</p>
<p> ​        如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</p>
</li>
<li><p>典型例题与内存解析：</p>
<ul>
<li><p>【例题1】</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522155534.png"></p>
</li>
<li><p>【例题2】</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522155539.png"></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>递归方法</p>
<ol>
<li><p>定义：递归方法：一个方法体内调用它自身。</p>
</li>
<li><p>如何理解递归方法？</p>
<ul>
<li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</li>
<li>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</li>
</ul>
</li>
<li><p>举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//			return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="3-4面向对象的特征一：封装性"><a href="#3-4面向对象的特征一：封装性" class="headerlink" title="3.4面向对象的特征一：封装性"></a>3.4面向对象的特征一：封装性</h3><ol>
<li><p>为什么要引入封装性？</p>
<p> 我们程序设计追求“高内聚，低耦合”。</p>
<ul>
<li><p>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</p>
</li>
<li><p>低耦合 ：仅对外暴露少量的方法用于使用。</p>
</li>
</ul>
<p> 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p>
</li>
<li><p>问题引入：</p>
<p> 当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).</p>
<p> 此时，针对于属性就体现了封装性。</p>
</li>
<li><p>封装性思想具体的代码体现：</p>
<ul>
<li><p>体现一：将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>体现二：不对外暴露的私有的方法</p>
</li>
<li><p>体现三：单例模式（将构造器私有化）</p>
</li>
<li><p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的。</p>
</li>
</ul>
</li>
<li><p>Java规定的四种权限修饰符</p>
<ol>
<li><p>权限从小到大顺序为：private &lt;  缺省 &lt; protected &lt; public</p>
</li>
<li><p>具体的修饰范围：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>（缺省）</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
</li>
<li><p>权限修饰符可用来修饰的结构说明：</p>
<p> 4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p>
<p> 修饰类的话，只能使用：缺省、public</p>
</li>
</ol>
</li>
</ol>
<h3 id="3-5类的结构之三：构造器"><a href="#3-5类的结构之三：构造器" class="headerlink" title="3.5类的结构之三：构造器"></a>3.5类的结构之三：构造器</h3><ol>
<li><p>构造器（或构造方法）：Constructor</p>
<p> 构造器的作用：</p>
<ul>
<li>1.创建对象</li>
<li>2.初始化对象的信息</li>
</ul>
</li>
<li><p>使用说明：</p>
<ul>
<li>1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</li>
<li>2.定义构造器的格式：权限修饰符  类名(形参列表){}</li>
<li>3.一个类中定义的多个构造器，彼此构成重载</li>
<li>4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li>5.一个类中，至少会有一个构造器。</li>
</ul>
</li>
<li><p>举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person().....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>属性赋值顺序</p>
<ol>
<li>默认初始化</li>
<li>显式初始化</li>
<li>构造器中初始化</li>
<li>通过”对象.方法” 或 “对象.属性”的方式，赋值</li>
</ol>
<p> 以上操作的先后顺序：① - ② - ③ - ④ </p>
</li>
<li><p>JavaBean的概念</p>
<p> 所谓JavaBean，是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>一个无参的公共的构造器</li>
<li>属性，且对应的get、set方法</li>
</ul>
</li>
</ol>
<h3 id="3-6关键词：this"><a href="#3-6关键词：this" class="headerlink" title="3.6关键词：this"></a>3.6关键词：this</h3><ol>
<li><p>可以调用的结构：属性、方法；构造器</p>
</li>
<li><p>this调用属性、方法：</p>
<p> this理解为：当前对象  或 当前正在创建的对象</p>
<ul>
<li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li>
<li>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li>
</ul>
</li>
<li><p>this调用构造器：</p>
<ol>
<li>我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器</li>
<li>构造器中不能通过”this(形参列表)”方式调用自己</li>
<li>如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</li>
<li>规定：”this(形参列表)”必须声明在当前构造器的首行</li>
<li>构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器</li>
</ol>
</li>
</ol>
<h3 id="3-7关键词：package-import"><a href="#3-7关键词：package-import" class="headerlink" title="3.7关键词：package/import"></a>3.7关键词：package/import</h3><p><strong>package</strong></p>
<ol>
<li><p>使用说明：</p>
<ol>
<li>为了更好的实现项目中类的管理，提供包的概念</li>
<li>使用package声明类或接口所属的包，声明在源文件的首行</li>
<li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li>
<li>每”.”一次，就代表一层文件目录。</li>
</ol>
</li>
<li><p>举例：</p>
<ul>
<li><p>举例一：</p>
<p>  某航运软件系统包括：一组域对象、GUI和reports子系统</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161002.png"></p>
</li>
<li><p>举例二：MVC设计模式</p>
<p>  <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161017.png"></p>
</li>
</ul>
</li>
<li><p>JDK中的主要包介绍：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161042.png"></p>
</li>
</ol>
<p><strong>import</strong></p>
<h2 id="4-面向对象（中）"><a href="#4-面向对象（中）" class="headerlink" title="4.面向对象（中）"></a>4.面向对象（中）</h2><h3 id="4-1面向对象的特征二：继承性"><a href="#4-1面向对象的特征二：继承性" class="headerlink" title="4.1面向对象的特征二：继承性"></a>4.1面向对象的特征二：继承性</h3><ol>
<li><p>为什么要有类的继承性？(继承性的好处）</p>
<ol>
<li>减少了代码的冗余，提高了代码的复用性</li>
<li>便于功能的扩展</li>
<li>为之后多态性的使用，提供了前提</li>
</ol>
<p> 图示：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161542.png"></p>
</li>
<li><p>继承性的格式：</p>
<p> <code>class A extends B&#123;&#125;</code></p>
<p> A:子类、派生类、subclass</p>
<p> B:父类、超类、基类、superclass</p>
</li>
<li><p>子类继承父类以后有哪些不同？</p>
<ul>
<li><p>体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。</p>
<p>  特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。</p>
</li>
<li><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。</p>
<p>  子类和父类的关系，不同于子集和集合的关系。</p>
<p>  extends：延展、扩展</p>
</li>
</ul>
</li>
<li><p>Java中继承性的说明</p>
<ol>
<li>一个类可以被多个子类继承。</li>
<li>Java中类的单继承性：一个类只能有一个父类</li>
<li>子父类是相对的概念。</li>
<li>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</li>
<li>子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</li>
</ol>
<p> 图示：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522161347.png"></p>
</li>
<li><p>java.lang.Object类的理解</p>
<ol>
<li>如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li>
<li>所有的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类</li>
<li>意味着，所的java类具有java.lang.Object类声明的功能。</li>
</ol>
</li>
</ol>
<h3 id="4-2方法的重写"><a href="#4-2方法的重写" class="headerlink" title="4.2方法的重写"></a>4.2方法的重写</h3><ol>
<li><p>什么是方法的重写(override 或 overwrite)？</p>
<p> 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。</p>
</li>
<li><p>应用：</p>
<p> 重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p>
</li>
<li><p>举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> <span class="keyword">extends</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求表面积</span></span><br><span class="line">&#125;</span><br><span class="line">***************</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckAccount</span> <span class="keyword">extends</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重写的规则：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法的声明： 权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p>
<ol>
<li><p>① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</p>
</li>
<li><p>② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</p>
<p> 特殊情况：子类不能重写父类中声明为private权限的方法</p>
</li>
<li><p>返回值类型：</p>
<ul>
<li>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</li>
<li>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</li>
<li>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</li>
</ul>
</li>
<li><p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
</li>
</ol>
<p> 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。</p>
</li>
<li><p>面试题：</p>
<p> 区分方法的重写和重载？</p>
<p> 答：</p>
<ol>
<li><p>二者的概念：</p>
</li>
<li><p>重载和重写的具体规则</p>
</li>
<li><p>重载：不表现为多态性。</p>
<p> 重写：表现为多态性。</p>
</li>
</ol>
<p> 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p>
<p> 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</p>
<p> 而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 </p>
<p> 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</p>
</li>
</ol>
<h3 id="4-3关键字：super"><a href="#4-3关键字：super" class="headerlink" title="4.3关键字：super"></a>4.3关键字：super</h3><ol>
<li>super 关键字可以理解为：父类的</li>
<li>可以用来调用的结构：属性、方法、构造器</li>
<li>super调用属性、方法：<ol>
<li>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li>
<li>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li>
</ol>
</li>
<li>super调用构造器：<ol>
<li>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li>
<li>“super(形参列表)”的使用，必须声明在子类构造器的首行！</li>
<li>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二一，不能同时出现</li>
<li>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</li>
<li>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</li>
</ol>
</li>
</ol>
<h3 id="4-4子类对象实例化全过程"><a href="#4-4子类对象实例化全过程" class="headerlink" title="4.4子类对象实例化全过程"></a>4.4子类对象实例化全过程</h3><ol>
<li><p>从结果上看：继承性</p>
<ul>
<li>子类继承父类以后，就获取了父类中声明的属性或方法。</li>
<li>创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</li>
</ul>
</li>
<li><p>从过程上看：</p>
<p> 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</p>
<p> 图示：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164236.png"></p>
</li>
<li><p>强调说明：</p>
<p> 虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164256.png"></p>
</li>
</ol>
<h3 id="4-5面向对象的特征三：多态性"><a href="#4-5面向对象的特征三：多态性" class="headerlink" title="4.5面向对象的特征三：多态性"></a>4.5面向对象的特征三：多态性</h3><ol>
<li><p>多态性的理解：可以理解为一个事物的多种形态。</p>
</li>
<li><p>何为多态性：</p>
<p> 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p>
<p> 举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Man();</span><br><span class="line">Object obj = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure></li>
<li><p>多态性的使用：虚拟方法调用</p>
<p> 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p>
<p> <strong>总结：编译，看左边；运行，看右边。</strong></p>
</li>
<li><p>多态性的使用前提：</p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
</li>
<li><p>多态性的应用举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例一：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal animal)</span></span>&#123;<span class="comment">//Animal animal = new Dog();</span></span><br><span class="line">		animal.eat();</span><br><span class="line">		animal.shout();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//举例二：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//举例三：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doData</span><span class="params">(Connection conn)</span></span>&#123;<span class="comment">//conn = new MySQlConnection(); / conn = new OracleConnection();</span></span><br><span class="line">		<span class="comment">//规范的步骤去操作数据</span></span><br><span class="line"><span class="comment">//		conn.method1();</span></span><br><span class="line"><span class="comment">//		conn.method2();</span></span><br><span class="line"><span class="comment">//		conn.method3();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多态性使用的注意点：</p>
<p> <strong>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</strong></p>
</li>
<li><p>关于向上转型与向下转型：</p>
<ol>
<li><p>向上转型：多态</p>
</li>
<li><p>向下转型：</p>
<ol>
<li><p>为什么使用向下转型：</p>
<p> 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。</p>
</li>
<li><p>如何实现向下转型：</p>
<p> 使用强制类型转换符：()</p>
</li>
<li><p>使用时的注意点：</p>
<ol>
<li>使用强转时，可能出现ClassCastException的异常。</li>
<li>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</li>
</ol>
</li>
<li><p>instanceof的使用：</p>
<ol>
<li>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</li>
<li>如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。</li>
<li>要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</li>
</ol>
</li>
<li><p>图示：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522164521.png"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>面试题：</p>
<ol>
<li><p>谈谈你对多态性的理解？</p>
<ul>
<li><p>实现代码的通用性。</p>
</li>
<li><p>Object类中定义的public boolean equals(Object obj){  }</p>
<p>  JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)</p>
</li>
<li><p>抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</p>
</li>
</ul>
</li>
<li><p>多态是编译时行为还是运行时行为？</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-6Object类的使用"><a href="#4-6Object类的使用" class="headerlink" title="4.6Object类的使用"></a>4.6Object类的使用</h3><ol>
<li><p>java.lang.Object类的说明：</p>
<ol>
<li><p>Object类是所Java类的根父类</p>
</li>
<li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 </p>
</li>
<li><p>Object类中的功能(属性、方法)就具通用性。</p>
<p>属性：无</p>
<p>方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()</p>
<p>wait() 、 notify()、notifyAll()</p>
</li>
<li><p>Object类只声明了一个空参的构造器</p>
</li>
</ol>
</li>
<li><p>equals()方法</p>
<ol>
<li><p>equals()的使用：</p>
<ol>
<li><p>是一个方法，而非运算符</p>
</li>
<li><p>只能适用于引用数据类型</p>
</li>
<li><p>Object类中equals()的定义：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p>
</li>
<li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是</p>
<p> 两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p>
</li>
<li><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相</p>
<p> 同。那么，我们就需要对Object类中的equals()进行重写.</p>
<p> 重写的原则：比较两个对象的实体内容是否相同.</p>
</li>
</ol>
</li>
<li><p>如何重写equals()</p>
<p> 手动重写举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">//重写其equals()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">this</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">			User u = (User)obj;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age == u.age &amp;&amp; <span class="keyword">this</span>.name.equals(u.name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>回顾 == 运算符的使用：</p>
<p> == ：运算符</p>
<ul>
<li><p>可以使用在基本数据类型变量和引用数据类型变量中</p>
</li>
<li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p>
<p>  如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p>
</li>
</ul>
<p> 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。</p>
</li>
</ol>
</li>
<li><p>toString()方法</p>
<ol>
<li><p>toString()的使用：</p>
<ol>
<li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p>
</li>
<li><p>Object类中toString()的定义：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息</p>
</li>
<li><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p>
</li>
</ol>
</li>
<li><p>如何重写toString()</p>
<p> 举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Customer [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>面试题：</p>
<ul>
<li>final、finally、finalize的区别？</li>
<li>== 和 equals() 区别</li>
</ul>
</li>
</ol>
<h3 id="4-7单元测试方法"><a href="#4-7单元测试方法" class="headerlink" title="4.7单元测试方法"></a>4.7单元测试方法</h3><p>Java中的JUnit单元测试</p>
<p>步骤：</p>
<ol>
<li><p>选中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步</p>
</li>
<li><p>创建Java类，进行单元测试。</p>
<p> 此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p>
</li>
<li><p>此类中声明单元测试方法。</p>
<p> 此时的单元测试方法：方法的权限是public,没返回值，没形参</p>
</li>
<li><p>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p>
</li>
<li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p>
</li>
</ol>
<p>说明：</p>
<ol>
<li>如果执行结果没任何异常：绿条</li>
<li>如果执行结果出现异常：红条</li>
</ol>
<h3 id="4-8包装类的使用"><a href="#4-8包装类的使用" class="headerlink" title="4.8包装类的使用"></a>4.8包装类的使用</h3><ol>
<li><p>为什么要有包装类(或封装类）</p>
<p> 为了使基本数据类型的变量具有类的特征，引入包装类。</p>
</li>
<li><p>基本数据类型与对应的包装类：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522165706.png"></p>
</li>
<li><p>需要掌握的类型间的转换：（基本数据类型、包装类、String）</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522165718.png"></p>
<p> 简易版：</p>
<ul>
<li><p>基本数据类型&lt;—&gt;包装类：JDK 5.0 新特性：自动装箱 与自动拆箱</p>
</li>
<li><p>基本数据类型、包装类—&gt;String:调用String重载的valueOf(Xxx xxx)</p>
</li>
<li><p>String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)</p>
<p>   注意：转换时，可能会报NumberFormatException</p>
</li>
</ul>
<p> 应用场景举例：</p>
<p> ​        Vector类中关于添加元素，只定义了形参为Object类型的方法：</p>
<p> v.addElement(Object obj);   //基本数据类型 —&gt;包装类 —&gt;使用多态</p>
</li>
</ol>
<h2 id="5-面向对象（下）"><a href="#5-面向对象（下）" class="headerlink" title="5.面向对象（下）"></a>5.面向对象（下）</h2><h3 id="5-1关键字：static"><a href="#5-1关键字：static" class="headerlink" title="5.1关键字：static"></a>5.1关键字：static</h3><ol>
<li><p>可以用来修饰的结构：主要用来修饰类的内部结构</p>
<p> 属性、方法、代码块、内部类</p>
</li>
<li><p>static修饰属性：静态变量（或类变量）</p>
<ul>
<li><p>属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)</p>
<ul>
<li><p>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</p>
</li>
<li><p>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p>
</li>
</ul>
</li>
<li><p>static修饰属性的其他说明：</p>
<ol>
<li><p>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</p>
</li>
<li><p>静态变量的加载要早于对象的创建。</p>
</li>
<li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p>
</li>
<li><table>
<thead>
<tr>
<th></th>
<th>类变量</th>
<th>实例变量</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>对象</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>静态属性举例：System.out; Math.PI;</p>
</li>
</ul>
</li>
<li><p>静态变量内存解析：</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200529173043.png"></p>
</li>
<li><p>static修饰方法：静态方法、类方法</p>
<ol>
<li><p>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</p>
</li>
<li><table>
<thead>
<tr>
<th></th>
<th>静态方法</th>
<th>非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>对象</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody></table>
</li>
<li><p>静态方法中，只能调用静态的方法或属性</p>
<p> 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
</li>
</ol>
</li>
<li><p>static的注意点：</p>
<ol>
<li>在静态的方法内，不能使用this关键字、super关键字</li>
<li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</li>
</ol>
</li>
<li><p>如何判定属性和方法应该使用static关键字：</p>
<ol>
<li>关于属性<ul>
<li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li>
<li>类中的常量也常常声明为static</li>
</ul>
</li>
<li>关于方法<ul>
<li>操作静态属性的方法，通常设置为static的</li>
<li>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li>
</ul>
</li>
</ol>
</li>
<li><p>使用举例：</p>
<ol>
<li><p> 举例一：Arrays、Math、Collections等工具类</p>
</li>
<li><p>举例二：单例模式</p>
</li>
<li><p>举例三：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//自动赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = init++;</span><br><span class="line">        total++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="comment">//		id = init++;</span></span><br><span class="line">        <span class="comment">//		total++;</span></span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total;<span class="comment">//记录创建的圆的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> init = <span class="number">1001</span>;<span class="comment">//static声明的属性被所对象所共享</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span> 	</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>涉及设计模式–&gt;单例模式</p>
<ol>
<li><p>设计模式</p>
<ol>
<li><p>设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。</p>
</li>
<li><p>常用设计模式  — 23种经典的设计模式  GOF</p>
<blockquote>
<p>创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 </p>
</blockquote>
</li>
</ol>
</li>
<li><p>单例模式</p>
<ol>
<li><p>要解决的问题</p>
<p> 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p>
</li>
<li><p>具体代码的实现</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">饿汉式<span class="number">1</span>：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.内部创建类的对象</span></span><br><span class="line">	<span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">饿汉式<span class="number">2</span>：使用了静态代码块</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line">	<span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> Order();</span><br><span class="line"> &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">懒汉式：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line">	<span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			</span><br><span class="line">			instance = <span class="keyword">new</span> Order();</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>两种方式的对比</p>
<ul>
<li>饿汉式：<ul>
<li>坏处：对象加载时间过长。</li>
<li>好处：饿汉式是线程安全的</li>
</ul>
</li>
<li>懒汉式：<ul>
<li>好处：延迟对象的创建。</li>
<li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-2main-的使用说明"><a href="#5-2main-的使用说明" class="headerlink" title="5.2main()的使用说明"></a>5.2main()的使用说明</h3><blockquote>
<ul>
<li><ol>
<li>main()方法作为程序的入口</li>
</ol>
</li>
<li><ol start="2">
<li>main()方法也是一个普通的静态方法</li>
</ol>
</li>
<li><ol start="3">
<li>main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</li>
</ol>
</li>
</ul>
<p>如何将控制台获取的数据传给形参：String[] args?<br>  运行时：java 类名 “Tom” “Jerry” “123” “true”</p>
<p>sysout(args[0]);//“Tom”<br>sysout(args[3]);//“true”  –&gt;Boolean.parseBoolean(args[3]);<br>sysout(args[4]);//报异常</p>
</blockquote>
<h3 id="5-3类的结构：代码块"><a href="#5-3类的结构：代码块" class="headerlink" title="5.3类的结构：代码块"></a>5.3类的结构：代码块</h3><ol>
<li><p>代码块的作用：用来初始化类、对象的信息</p>
</li>
<li><p>分类：代码块要是使用修饰符，只能使用static</p>
<p> 分类：静态代码块  vs 非静态代码块</p>
</li>
<li><p>静态代码块：</p>
<blockquote>
<p>内部可以输出语句<br>随着类的加载而执行,而且只执行一次<br>作用：初始化类的信息<br>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>静态代码块的执行要优先于非静态代码块的执行<br>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p>
</blockquote>
<p> 非静态代码块：</p>
<blockquote>
<p>内部可以输出语句<br>随着对象的创建而执行<br>每创建一个对象，就执行一次非静态代码块<br>作用：可以在创建对象时，对对象的属性等进行初始化<br>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p>
</blockquote>
</li>
<li><p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：</p>
<p> 由父及子，静态先行。</p>
</li>
<li><p>属性的赋值顺序</p>
<blockquote>
<ul>
<li>①默认初始化</li>
<li>②显式初始化/⑤在代码块中赋值</li>
<li>③构造器中初始化</li>
<li>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</li>
<li></li>
<li></li>
<li>执行的先后顺序：① - ② / ⑤ - ③ - ④</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="5-4关键字：final"><a href="#5-4关键字：final" class="headerlink" title="5.4关键字：final"></a>5.4关键字：final</h3><ol>
<li><p>可以用来修饰：类、方法、变量</p>
</li>
<li><p>具体的：</p>
<ol>
<li><p>final 用来修饰一个类:此类不能被其他类所继承。</p>
<p> 比如：String类、System类、StringBuffer类</p>
</li>
<li><p>final 用来修饰方法：表明此方法不可以被重写</p>
<p> 比如：Object类中getClass();</p>
</li>
<li><p>final 用来修饰变量：此时的”变量”就称为是一个常量</p>
<ul>
<li>final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li>
<li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li>
</ul>
</li>
</ol>
<p> static final 用来修饰属性：全局常量</p>
</li>
</ol>
<h3 id="5-5关键字：abstract"><a href="#5-5关键字：abstract" class="headerlink" title="5.5关键字：abstract"></a>5.5关键字：abstract</h3><ol>
<li><p>可以用来修饰：类、方法</p>
</li>
<li><p>具体的：</p>
<ul>
<li>abstract修饰类：抽象类<ul>
<li>此类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</li>
</ul>
</li>
<li>abstract修饰方法：抽象方法<ul>
<li>抽象方法只方法的声明，没方法体</li>
<li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li>
<li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li>
<li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li>
</ul>
</li>
</ul>
</li>
<li><p>注意点：</p>
<ol>
<li>abstract不能用来修饰：属性、构造器等结构</li>
<li>abstract不能用来修饰私方法、静态方法、final的方法、final的类</li>
</ol>
</li>
<li><p>abstract的应用举例：</p>
<ol>
<li><p>举例一：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GeometricObject</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">GeometricObject</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>举例二：IO流中设计到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部定义了抽象的read()、write()方法。</p>
</li>
</ol>
</li>
<li><p>涉及设计模式–&gt;模板方法</p>
<ol>
<li><p>解决的问题</p>
<p> 在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变<br> 部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
</li>
<li><p>举例</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.code();<span class="comment">//不确定的部分、易变的部分</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">					isFlag = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>应用场景</p>
<p> 模板方法设计模式是编程中经常用的到的模式。各个框架、类库中都有用到，比如常见的有：</p>
<ul>
<li>数据库访问的封装</li>
<li>Junit单元测试</li>
<li>JavaWeb的Servlet中关于doGet/doPost方法调用</li>
<li>Hibernate中模板程序</li>
<li>Spring中的JDBCTemplate、HibernateTemplate等</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="5-6关键字：interface"><a href="#5-6关键字：interface" class="headerlink" title="5.6关键字：interface"></a>5.6关键字：interface</h3><ol>
<li><p>使用说明：</p>
<ol>
<li><p>接口使用interface来定义</p>
</li>
<li><p>Java中，接口和类是并列的两个结构</p>
</li>
<li><p>如何定义接口：定义接口中的成员</p>
<ol>
<li>JDK7及以前：只能定义全局常量和抽象方法<ul>
<li>全局常量：public static final的.但是书写时，可以省略不写</li>
<li>抽象方法：public abstract的</li>
</ul>
</li>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略</li>
</ol>
</li>
<li><p>接口中不能定义构造器的！意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p>
<p> 如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</p>
<p> 如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</p>
</li>
<li><p>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性</p>
<p> 格式：class AA extends BB implements CC,DD,EE</p>
</li>
<li><p>接口与接口之间可以继承，而且可以多继承</p>
</li>
<li><p>接口的具体使用，体现多态性</p>
</li>
<li><p>接口，实际上可以看做是一种规范</p>
</li>
</ol>
</li>
<li><p>举例：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span></span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">		usb.start();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		usb.stop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">	<span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 体会：</p>
<ul>
<li>1.接口使用上也满足多态性</li>
<li>2.接口，实际上就是定义了一种规范</li>
<li>3.开发中，体会面向接口编程！</li>
</ul>
</li>
<li><p>体会面向接口编程的思想</p>
<p> 面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个<br> 数据库厂商的API。</p>
</li>
<li><p>Java8中关于接口的新规范</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//知识点1：接口中定义的静态方法，只能通过接口来调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span></span><br><span class="line"><span class="comment">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span></span><br><span class="line"><span class="comment">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span></span><br><span class="line"><span class="comment">//那么在实现类没重写此方法的情况下，报错。--&gt;接口冲突。</span></span><br><span class="line"><span class="comment">//这就需要我们必须在实现类中重写此方法</span></span><br><span class="line"><span class="comment">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">    <span class="keyword">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="keyword">super</span>.method3();</span><br><span class="line">    CompareB.<span class="keyword">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>面试题：</p>
<p> 抽象类和接口的异同？</p>
<ul>
<li><p>相同点：不能实例化；都可以包含抽象方法的。</p>
</li>
<li><p>不同点：</p>
<ul>
<li>1）把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明</li>
<li>2）类：单继承性 ，接口：多继承，类与接口：多实现</li>
</ul>
</li>
</ul>
</li>
<li><p>涉及设计模式–&gt;代理模式、工厂模式</p>
<ol>
<li><p>代理模式</p>
<ol>
<li><p>解决的问题</p>
<p> 代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 </p>
</li>
<li><p>举例</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> NetWork work;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.work = work;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;联网之前的检查工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		check();</span><br><span class="line">		work.browse();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>应用场景</p>
<ul>
<li><p>应用场景：</p>
<ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法调用（RMI）</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>静态代理（静态定义代理类）</p>
</li>
<li><p>动态代理（动态生成代理类）</p>
<p>  JDK自带的动态代理，需要反射等知识</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>工厂模式</p>
<ol>
<li><p>解决的问题</p>
<p> 实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p>
</li>
<li><p>具体模式</p>
<ul>
<li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li>
<li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</li>
<li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-7类的结构：内部类"><a href="#5-7类的结构：内部类" class="headerlink" title="5.7类的结构：内部类"></a>5.7类的结构：内部类</h3><ol>
<li><p>定义：Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.</p>
</li>
<li><p>内部类的分类：</p>
<p> 成员内部类（静态、非静态 ） vs 局部内部类(方法内、代码块内、构造器内)</p>
</li>
<li><p>成员内部类的理解：</p>
<p> 一方面，作为外部类的成员：</p>
<ul>
<li>调用外部类的结构</li>
<li>可以被static修饰</li>
<li>可以被4种不同的权限修饰</li>
</ul>
<p> 另一方面，作为一个类：</p>
<ul>
<li>类内可以定义属性、方法、构造器等</li>
<li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li>
<li>可以被abstract修饰</li>
</ul>
</li>
<li><p>成员内部类：</p>
<ol>
<li><p>如何创建成员内部类的对象？(静态的，非静态的)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">//Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如何在成员内部类中调用外部类的结构？</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">		String name = <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">			System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">			System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">			System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">		<span class="comment">//Person.this.eat();</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>局部内部类的使用：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">		<span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//		class MyComparable implements Comparable&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//				return 0;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		return new MyComparable();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二：</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p> 注意点：</p>
<p> 在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。</p>
<ul>
<li><strong>jdk 7及之前版本：要求此局部变量显式的声明为final的</strong></li>
<li><strong>jdk 8及之后的版本：可以省略final的声明</strong></li>
</ul>
<p> 总结：</p>
<p> 成员内部类和局部内部类，在编译以后，都会生成字节码文件。</p>
<p> 格式：</p>
<ul>
<li>成员内部类：外部类$内部类名.class    </li>
<li>局部内部类：外部类$数字 内部类名.class</li>
</ul>
</li>
</ol>
<h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6.异常处理"></a>6.异常处理</h2><h3 id="6-1异常"><a href="#6-1异常" class="headerlink" title="6.1异常"></a>6.1异常</h3><ol>
<li><p>异常的体系结构</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">	|-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">	|-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">		|------编译时异常(checked)</span><br><span class="line">				|-----IOException</span><br><span class="line">					|-----FileNotFoundException</span><br><span class="line">					|-----ClassNotFoundException</span><br><span class="line">			|------运行时异常(unchecked,RuntimeException)</span><br><span class="line">				|-----NullPointerException</span><br><span class="line">					|-----ArrayIndexOutOfBoundsException</span><br><span class="line">					|-----ClassCastException</span><br><span class="line">					|-----NumberFormatException</span><br><span class="line">					|-----InputMismatchException</span><br><span class="line">					|-----ArithmeticException</span><br></pre></td></tr></table></figure>

<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522172127.png"></p>
</li>
<li><p>从程序执行过程，看编译时异常和运行时异常</p>
<p> <img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/img/20200522171550.png"></p>
<p> 编译时异常：执行javac.exe命名时，可能出现的异常</p>
<p> 运行时异常：执行java.exe命名时，出现的异常</p>
</li>
<li><p>常见的异常类型，请举例说明：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> score = scanner.nextInt();</span><br><span class="line">    System.out.println(score);</span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">    String str = (String)obj;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">    <span class="comment">//		int[] arr = new int[10];</span></span><br><span class="line">    <span class="comment">//		System.out.println(arr[10]);</span></span><br><span class="line">    <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">    String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//		int[] arr = null;</span></span><br><span class="line">    <span class="comment">//		System.out.println(arr[3]);</span></span><br><span class="line">    String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    str = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//		File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line">    <span class="comment">//		FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line">    <span class="comment">//		</span></span><br><span class="line">    <span class="comment">//		int data = fis.read();</span></span><br><span class="line">    <span class="comment">//		while(data != -1)&#123;</span></span><br><span class="line">    <span class="comment">//			System.out.print((char)data);</span></span><br><span class="line">    <span class="comment">//			data = fis.read();</span></span><br><span class="line">    <span class="comment">//		&#125;</span></span><br><span class="line">    <span class="comment">//		</span></span><br><span class="line">    <span class="comment">//		fis.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-2异常的处理"><a href="#6-2异常的处理" class="headerlink" title="6.2异常的处理"></a>6.2异常的处理</h3><ol>
<li><p>异常处理的抓抛模型</p>
<ol>
<li><p>“抓”</p>
<p> 可以理解为异常的处理方式：</p>
<ul>
<li>try-catch-finally </li>
<li>throws</li>
</ul>
</li>
<li><p>”抛“</p>
<p> 程序在正常执行的过程中，一旦出现异常，就会中异常代码处生成一个异常对象，并将此对象抛出。</p>
<p> 异常对象的产生：</p>
<ul>
<li>系统自动生成的异常对象</li>
<li>手动生成的一个异常对象，并抛出（throw）</li>
</ul>
</li>
</ol>
</li>
<li><p>异常处理方式：try-catch-finally</p>
</li>
<li><p>方法重写的规则之一：</p>
<p> 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
</li>
</ol>
<h3 id="6-3手动抛出异常对象"><a href="#6-3手动抛出异常对象" class="headerlink" title="6.3手动抛出异常对象"></a>6.3手动抛出异常对象</h3><ol>
<li><p>使用说明</p>
<p> 在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。</p>
</li>
<li><p>面试题</p>
<p> throw 和  throws区别：</p>
<p> throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。</p>
<p> throws 属于异常处理的一种方式，声明在方法的声明处。</p>
</li>
<li><p>典型例题</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">this</span>.id = id;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//手动抛出异常对象</span></span><br><span class="line"><span class="comment">//			throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="comment">//			throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-4自定义异常类"><a href="#6-4自定义异常类" class="headerlink" title="6.4自定义异常类"></a>6.4自定义异常类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何自定义异常类？</span></span><br><span class="line"><span class="comment"> * 1. 继承于现的异常结构：RuntimeException 、Exception</span></span><br><span class="line"><span class="comment"> * 2. 提供全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment"> * 3. 提供重载的构造器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-多线程"><a href="#7-多线程" class="headerlink" title="7.多线程"></a>7.多线程</h2><p>程序、进程、线程的理解</p>
<p>并行和并发</p>
<p>创建多线程的两种方式</p>
<p>Thread类中的常用方法</p>
<p>Thread的生命周期</p>
<p>线程的同步机制</p>
<p>​    线程安全的单例模式（懒汉式）</p>
<p>​    死锁问题</p>
<p>线程通信</p>
<p>JDK5.0新增线程创建的方式</p>
<h2 id="8-常用类"><a href="#8-常用类" class="headerlink" title="8.常用类"></a>8.常用类</h2><p>String类</p>
<p>StringBuffer、StringBuilder</p>
<p>JDK8之前日期时间API</p>
<p>JDK8中新日期时间API</p>
<p>Java比较器</p>
<p>其他类</p>
<h2 id="9-枚举类和注解"><a href="#9-枚举类和注解" class="headerlink" title="9.枚举类和注解"></a>9.枚举类和注解</h2><p>枚举类的使用</p>
<p>注解类的使用</p>
<h2 id="10-集合"><a href="#10-集合" class="headerlink" title="10.集合"></a>10.集合</h2><p>数组与集合</p>
<p>Collection接口</p>
<p>Iterator接口与foreach循环 </p>
<p>Collection子接口：List接口</p>
<p>Collection子接口：Set接口</p>
<p>Map接口</p>
<p>Collections工具类的使用</p>
<p>数据结构简述</p>
<h2 id="11-泛型"><a href="#11-泛型" class="headerlink" title="11.泛型"></a>11.泛型</h2><p>泛型的理解</p>
<p>泛型在集合中的使用</p>
<p>自定义泛型类、泛型接口、泛型方法</p>
<p>泛型在继承上的体现</p>
<p>通配符</p>
<h2 id="12-IO流"><a href="#12-IO流" class="headerlink" title="12.IO流"></a>12.IO流</h2><p>File类的使用</p>
<p>IO流概述</p>
<p>节点流（或文件流）</p>
<p>缓冲流的使用</p>
<p>转换流的使用</p>
<p>​    编码集</p>
<p>其它的流的使用</p>
<p>对象流的使用</p>
<p>RandomAccessFile的使用</p>
<p>Path、Paths、Files的使用</p>
<h2 id="13-网络编程"><a href="#13-网络编程" class="headerlink" title="13.网络编程"></a>13.网络编程</h2><p>InetAddress类的使用</p>
<p>TCP网络编程</p>
<p>UDP网络编程</p>
<p>URL编程</p>
<h2 id="14-反射机制"><a href="#14-反射机制" class="headerlink" title="14.反射机制"></a>14.反射机制</h2><p>反射的概述</p>
<p>Class类的理解与获取Class的实例</p>
<p>了解ClassLoader</p>
<p>反射应用一：创建运行时类的对象</p>
<p>反射应用二：获取运行时类的完整结构</p>
<p>反射应用三：调用运行时类的指定结构</p>
<p>反射应用四：动态代理</p>
<h2 id="15-Java8的其他新特性"><a href="#15-Java8的其他新特性" class="headerlink" title="15.Java8的其他新特性"></a>15.Java8的其他新特性</h2><h2 id="16-Java9、10、11新特性"><a href="#16-Java9、10、11新特性" class="headerlink" title="16.Java9、10、11新特性"></a>16.Java9、10、11新特性</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">方陈勇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://fangchenyong.github.io/2019/07/20/Java-Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/">https://fangchenyong.github.io/2019/07/20/Java-Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fangchenyong.github.io" target="_blank">Joey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/07/23/%E6%95%B0%E6%8D%AE%E5%BA%93-Sql%20Server-sqlserver%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/"><img class="prev-cover" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SqlServer 备份还原</div></div></a></div><div class="next-post pull-right"><a href="/2019/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"><img class="next-cover" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">稀疏数组</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/04/12/Java-深入理解Java虚拟机/" title="深入理解Java虚拟机"><img class="cover" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-12</div><div class="title">深入理解Java虚拟机</div></div></a></div><div><a href="/2021/03/20/Java-源码-JDK8-HashMap/" title="JDK8 HashMap源码"><img class="cover" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-20</div><div class="title">JDK8 HashMap源码</div></div></a></div><div><a href="/2019/09/06/Java-源码-JDK8-String/" title="JDK8 String源码"><img class="cover" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-06</div><div class="title">JDK8 String源码</div></div></a></div><div><a href="/2019/08/23/项目-基于Netty+WebSocket简易版微信/" title="基于Netty+WebSocket简易版微信"><img class="cover" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-23</div><div class="title">基于Netty+WebSocket简易版微信</div></div></a></div><div><a href="/2019/08/23/Java-源码-JDK8-Object/" title="JDK8 Object源码"><img class="cover" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-23</div><div class="title">JDK8 Object源码</div></div></a></div><div><a href="/2019/07/29/项目-理财产品系统/" title="理财产品系统（慕课网）"><img class="cover" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-07-29</div><div class="title">理财产品系统（慕课网）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/3FD9B055-6361-49B7-B8CE-5BA9144BD27F.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">方陈勇</div><div class="author-info__description">一路向前</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">50</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fangchenyong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fangchenyong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1013659102@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">个人笔记，如有疑问请联系 QQ:1013659102。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0"><span class="toc-text">Java基础笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">1.基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">1.1 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">1.2保留字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">1.3标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E5%8F%98%E9%87%8F"><span class="toc-text">1.4变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.5运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">1.6流程控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84"><span class="toc-text">2.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">2.1一维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">2.2二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-text">2.3常见算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">2.4Arrays工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-text">2.5常见异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">3.面向对象（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.1类与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B1%9E%E6%80%A7"><span class="toc-text">3.2类的结构之一：属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%96%B9%E6%B3%95"><span class="toc-text">3.3类的结构之二：方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%80%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-text">3.4面向对象的特征一：封装性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">3.5类的结构之三：构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E5%85%B3%E9%94%AE%E8%AF%8D%EF%BC%9Athis"><span class="toc-text">3.6关键词：this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E5%85%B3%E9%94%AE%E8%AF%8D%EF%BC%9Apackage-import"><span class="toc-text">3.7关键词：package&#x2F;import</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-text">4.面向对象（中）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-text">4.1面向对象的特征二：继承性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-text">4.2方法的重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Asuper"><span class="toc-text">4.3关键字：super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">4.4子类对象实例化全过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%89%EF%BC%9A%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">4.5面向对象的特征三：多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6Object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.6Object类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-text">4.7单元测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.8包装类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">5.面向对象（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Astatic"><span class="toc-text">5.1关键字：static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2main-%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-text">5.2main()的使用说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">5.3类的结构：代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Afinal"><span class="toc-text">5.4关键字：final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Aabstract"><span class="toc-text">5.5关键字：abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Ainterface"><span class="toc-text">5.6关键字：interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">5.7类的结构：内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">6.异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E5%BC%82%E5%B8%B8"><span class="toc-text">6.1异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">6.2异常的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-text">6.3手动抛出异常对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text">6.4自定义异常类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">7.多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">8.常用类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-text">9.枚举类和注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%9B%86%E5%90%88"><span class="toc-text">10.集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%B3%9B%E5%9E%8B"><span class="toc-text">11.泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-IO%E6%B5%81"><span class="toc-text">12.IO流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">13.网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">14.反射机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Java8%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">15.Java8的其他新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Java9%E3%80%8110%E3%80%8111%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">16.Java9、10、11新特性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/04/12/Java-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="深入理解Java虚拟机"><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解Java虚拟机"/></a><div class="content"><a class="title" href="/2021/04/12/Java-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="深入理解Java虚拟机">深入理解Java虚拟机</a><time datetime="2021-04-11T16:00:00.000Z" title="发表于 2021-04-12 00:00:00">2021-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/21/%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="面试题-并发编程"><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题-并发编程"/></a><div class="content"><a class="title" href="/2021/03/21/%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="面试题-并发编程">面试题-并发编程</a><time datetime="2021-03-20T16:00:00.000Z" title="发表于 2021-03-21 00:00:00">2021-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/20/%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/" title="面试题-集合框架"><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题-集合框架"/></a><div class="content"><a class="title" href="/2021/03/20/%E9%9D%A2%E8%AF%95-%E9%9B%86%E5%90%88/" title="面试题-集合框架">面试题-集合框架</a><time datetime="2021-03-19T16:00:00.000Z" title="发表于 2021-03-20 00:00:00">2021-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/20/Java-%E6%BA%90%E7%A0%81-JDK8-HashMap/" title="JDK8 HashMap源码"><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK8 HashMap源码"/></a><div class="content"><a class="title" href="/2021/03/20/Java-%E6%BA%90%E7%A0%81-JDK8-HashMap/" title="JDK8 HashMap源码">JDK8 HashMap源码</a><time datetime="2021-03-19T16:00:00.000Z" title="发表于 2021-03-20 00:00:00">2021-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/13/The%20Road%20To%20Bald%20Man!/" title="The Road To Bald Man!"><img src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The Road To Bald Man!"/></a><div class="content"><a class="title" href="/2021/03/13/The%20Road%20To%20Bald%20Man!/" title="The Road To Bald Man!">The Road To Bald Man!</a><time datetime="2021-03-12T16:00:00.000Z" title="发表于 2021-03-13 00:00:00">2021-03-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/BEF238F4E59CF4D91A694FE9C5DBC030.JPG')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 方陈勇</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">人生没有退路！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script></div></body></html>