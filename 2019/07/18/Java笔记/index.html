<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Java笔记 | Joey</title><meta name="description" content="Java基础笔记"><meta name="keywords" content="Java"><meta name="author" content="fangchenyong"><meta name="copyright" content="fangchenyong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://fangchenyong.top/2019/07/18/Java笔记/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Java笔记"><meta name="twitter:description" content="Java基础笔记"><meta name="twitter:image" content="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/6C4819608FCCD2B5E6F8F1B1C583429F.png"><meta property="og:type" content="article"><meta property="og:title" content="Java笔记"><meta property="og:url" content="http://fangchenyong.top/2019/07/18/Java笔记/"><meta property="og:site_name" content="Joey"><meta property="og:description" content="Java基础笔记"><meta property="og:image" content="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/6C4819608FCCD2B5E6F8F1B1C583429F.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="数组模拟环形队列" href="http://fangchenyong.top/2019/07/18/数据结构-2-环形队列/"><link rel="next" title="稀疏数组" href="http://fangchenyong.top/2019/07/18/数据结构-1-稀疏数组/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://github.com/fangchenyong","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java基础笔记"><span class="toc-text">java基础笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本数据类型和包装类型"><span class="toc-text">基本数据类型和包装类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java中的集合"><span class="toc-text">java中的集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList和LinkedList的区别和使用场景"><span class="toc-text">ArrayList和LinkedList的区别和使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap和Hashtable的区别"><span class="toc-text">HashMap和Hashtable的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现一个拷贝文件的工具类使用字节流还是字符流"><span class="toc-text">实现一个拷贝文件的工具类使用字节流还是字符流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的几种实现方式"><span class="toc-text">线程的几种实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用线程池的风险，为什么使用线程池"><span class="toc-text">使用线程池的风险，为什么使用线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设计模式"><span class="toc-text">设计模式</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#javaWeb笔记"><span class="toc-text">javaWeb笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Http-Get和Post请求的区别"><span class="toc-text">Http Get和Post请求的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#servlet的理解"><span class="toc-text">servlet的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#servlet的生命周期"><span class="toc-text">servlet的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet-API中forward-和redirect-区别"><span class="toc-text">Servlet API中forward() 和redirect()区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session和Cookie区别"><span class="toc-text">Session和Cookie区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVC的各部分都有哪些技术来实现"><span class="toc-text">MVC的各部分都有哪些技术来实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库笔记"><span class="toc-text">数据库笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库分类"><span class="toc-text">数据库分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关系型数据库三范式"><span class="toc-text">关系型数据库三范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务四个基本特征ACID特性"><span class="toc-text">事务四个基本特征ACID特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySql数据库默认的最大连接数"><span class="toc-text">MySql数据库默认的最大连接数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySql分页、Oracle分页和SqlServer分页"><span class="toc-text">MySql分页、Oracle分页和SqlServer分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#触发器使用场景"><span class="toc-text">触发器使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端笔记"><span class="toc-text">前端笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#框架笔记"><span class="toc-text">框架笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringMVC执行流程"><span class="toc-text">SpringMVC执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Struts2和SpringMVC区别"><span class="toc-text">Struts2和SpringMVC区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring中的两大核心"><span class="toc-text">Spring中的两大核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ORM框架"><span class="toc-text">ORM框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis和Hibernate区别"><span class="toc-text">Mybatis和Hibernate区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hibernate映射对象的状态"><span class="toc-text">Hibernate映射对象的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hibernate缓存机制"><span class="toc-text">Hibernate缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webservice使用场景"><span class="toc-text">webservice使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务器及优化"><span class="toc-text">服务器及优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux常用命令"><span class="toc-text">Linux常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库优化"><span class="toc-text">数据库优化</span></a></li></ol></li></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_5954.JPG)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Joey</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/6C4819608FCCD2B5E6F8F1B1C583429F.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java笔记</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-07-18<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-22</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">7.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 26 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="java基础笔记"><a href="#java基础笔记" class="headerlink" title="java基础笔记"></a>java基础笔记</h2><ol>
<li><h4 id="基本数据类型和包装类型"><a href="#基本数据类型和包装类型" class="headerlink" title="基本数据类型和包装类型"></a>基本数据类型和包装类型</h4><blockquote>
<p>基本数据类型：short、int、long、double、float、char、string、boolean</p>
<p>包装类型：Short、Integer、Long、Double、Float、Char、String、Boolean</p>
<p>装箱：1. 手动装箱：Integer.valueOf(1) ;    2. 自动装箱：Integer i = 1;</p>
<p>拆箱：1. 手动拆箱：int j = i.intValue() ;    2. 自动拆箱：int j = i ;</p>
<p>JDK1.5开始为什么要引入包装类型：java是面向对象的语言，而基本的数据类型不具备面向对象的特性。</p>
<p>例：用Integer和int分别表示一个类的ID，进行非空判断的时候，Integer只要判断是否为null，int还要判断是否为0；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; Integer num1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; Integer num2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; System.out.println(<span class="string">"num1==num2 "</span> + (num1 == num2));</span><br><span class="line">&gt; </span><br><span class="line">&gt; Integer num3 = <span class="number">100</span>;</span><br><span class="line">&gt; Integer num4 = <span class="number">100</span>;</span><br><span class="line">&gt; System.out.println(<span class="string">"num3==num4 "</span> +(num3 == num4));</span><br><span class="line">&gt; </span><br><span class="line">&gt; Integer num5 = <span class="number">128</span>;</span><br><span class="line">&gt; Integer num6 = <span class="number">128</span>;</span><br><span class="line">&gt; System.out.println(<span class="string">"num5==num6 "</span> + (num5 == num6));</span><br><span class="line">&gt; </span><br><span class="line">&gt; Integer num7 = <span class="number">100</span>;</span><br><span class="line">&gt; Integer num8 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; System.out.println(<span class="string">"num7==num8 "</span> + (num7 == num8));</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">int</span> num9 = <span class="number">100</span>;</span><br><span class="line">&gt; Integer num10 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">&gt; Integer num11 = <span class="number">100</span>;</span><br><span class="line">&gt; System.out.println(<span class="string">"num9==num10 "</span> + (num9 == num10));</span><br><span class="line">&gt; System.out.println(<span class="string">"num9==num11 "</span> + (num9 == num11));</span><br><span class="line">&gt; </span><br><span class="line">&gt; 结果：num1==num2 <span class="keyword">false</span>  </span><br><span class="line">&gt; 	 num3==num4 <span class="keyword">true</span></span><br><span class="line">&gt; 	 num5==num6 <span class="keyword">false</span></span><br><span class="line">&gt; 	 num7==num8 <span class="keyword">false</span></span><br><span class="line">&gt; 	 num9==num10 <span class="keyword">true</span></span><br><span class="line">&gt; 	 num9==num11 <span class="keyword">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; 源码：</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">&gt;             <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     </span><br><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">&gt;         <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">static</span> &#123;</span><br><span class="line">&gt;             <span class="comment">// high value may be configured by property</span></span><br><span class="line">&gt;             <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">&gt;             String integerCacheHighPropValue =</span><br><span class="line">&gt;                 sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">&gt;             <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt;                 <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                     <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">&gt;                     i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">&gt;                     <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">&gt;                     h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">&gt;                 &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">&gt;                     <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;             high = h;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">&gt;             <span class="keyword">int</span> j = low;</span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">&gt;                 cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">&gt;             <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; 分析：</span><br><span class="line">&gt; <span class="number">1</span>.==对于对象来说比较的是对象的地址，两个新<span class="keyword">new</span>的对象地址不同，输出<span class="keyword">false</span>。</span><br><span class="line">&gt; <span class="number">2</span>.jvm在初始化的时候，会将低值（-<span class="number">128</span>）到高值（默认<span class="number">127</span>）之间的数字加载到内存中。低值是固定的，高值是可变的。在java程序执行的时候加上 -XX:AutoBoxCacheMax=&lt;size&gt; 的参数即可。缓如果初始化的数字是-<span class="number">128</span>~<span class="number">127</span>之间就会引用内存中的地址，输出<span class="keyword">true</span>。</span><br><span class="line">&gt; <span class="number">3</span>.同上。</span><br><span class="line">&gt; <span class="number">4</span>.num7是引用的本地内存地址，而num8是<span class="keyword">new</span>出来的，所以地址不同，输出<span class="keyword">false</span>。</span><br><span class="line">&gt; <span class="number">5</span>.包装类Integer和基本数据类型<span class="keyword">int</span>类型比较时，会自动拆箱为<span class="keyword">int</span>类型比较，实际上就变成两个基本的数据类型<span class="keyword">int</span>类型进行比较，而基本类型==比较的是值而不是地址，所以输出<span class="keyword">true</span>。</span><br><span class="line">&gt; <span class="number">6</span>.同上，即使是新<span class="keyword">new</span>出来的地址不同，但是最终拆箱为<span class="keyword">int</span>类型比较值是否相等，所以输出<span class="keyword">true</span>。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>“==”和“equals()” 方法区别</p>
<blockquote>
<p><strong>变量分为基本数据类型和引用数据类型</strong></p>
<p>1）对于==，比较的是值是否相等</p>
<p>​    如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>
<p>　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p>
<p>2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象</p>
<p>　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p>
<p>　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>
</blockquote>
</li>
<li><p>String、StringBuilder、StringBuffer区别</p>
<blockquote>
<p>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.String底层使用<span class="keyword">final</span>关键字修饰的数组，因此不可变</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="number">2</span>.StringBuilder继承AbstractStringBuilder抽象类使用的是普通数组所以可以改变。</span><br><span class="line">     <span class="comment">/** The value is used for character storage.*/</span></span><br><span class="line">     <span class="keyword">char</span>[] value;</span><br><span class="line"><span class="number">3</span>.StringBuffer继承AbstractStringBuilder抽象类使用的是普通数组所以可以改变。并且与StringBuilder重写的方法不同，方法添加了<span class="keyword">synchronized</span>关键字，线程安全但是效率低。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</p>
<p>String：适用于少量的字符串操作的情况</p>
<p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p>
<p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>
</blockquote>
</li>
<li><h4 id="java中的集合"><a href="#java中的集合" class="headerlink" title="java中的集合"></a>java中的集合</h4><blockquote>
<p>java中的集合分类存储value（继承Collection接口）和存储key-value（继承）形式。</p>
<p><strong>存储值：</strong>List、Set</p>
<blockquote>
<p>List是有序的，可以重复的。</p>
<p>Set是无序的，不可以重复的。根据equals和hascode判断，也就是如果一个对象要存储在Set中，必须重写equals和hasCode方法。</p>
</blockquote>
<p><strong>存储键值：</strong>Map</p>
</blockquote>
</li>
<li><h4 id="ArrayList和LinkedList的区别和使用场景"><a href="#ArrayList和LinkedList的区别和使用场景" class="headerlink" title="ArrayList和LinkedList的区别和使用场景"></a>ArrayList和LinkedList的区别和使用场景</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1</span>.ArrayList底层使用的是数组。</span><br><span class="line">&gt; 	<span class="keyword">transient</span> Object[] elementData; </span><br><span class="line">&gt; <span class="number">2</span>.LinkedList底层使用的是链表。</span><br><span class="line">&gt; 	<span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">&gt; 	<span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>区别：</strong></p>
<p>数组查询特定元素快，而插入、删除和修改比较慢，因为数组在内存中是一块连续的内存，如果是插入或删除需要移动内存。</p>
<p>链表在内存中是不连续的，在当前元素中存放的是下一个或者上一个元素的地址。查询时需要从头部开始查找至尾部，效率低。而插入时不需要移动内存，只需要改变节点指针即可。所以插入或删除效率高。</p>
<p><strong>使用场景：</strong></p>
<p>ArrayList使用在查询比较多，但是插入和删除比较少的情况，</p>
<p>LinkedList使用在查询比较少，但是插入和删除比较多的情况。</p>
</blockquote>
</li>
<li><h4 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h4><blockquote>
<p><strong>相同点：</strong>都可以用来存储Key-Value类型数据</p>
<p><strong>不同点：</strong></p>
<ol>
<li><p>HashMap可以使用null值作为key或者value，而Hashtable不行。</p>
</li>
<li><p>HashMap是线程不安全的，效率高。而Hashtable是线程安全的，效率低。</p>
</li>
<li><p>HashMap继承了AbstractMap抽象类同时实现Map, Cloneable, Serializable接口，而Hashtable继承了Dictionary抽象类同时实现Map, Cloneable, Serializable接口。</p>
</li>
</ol>
<p><strong>线程安全又要效率高？ConcurrentHashMap</strong></p>
<p>通过把整个Map分为N个Segment（类似于Hashtable）,可以提供相关的线程安全，又可以提升效率，默认提升16倍。</p>
</blockquote>
</li>
<li><h4 id="实现一个拷贝文件的工具类使用字节流还是字符流"><a href="#实现一个拷贝文件的工具类使用字节流还是字符流" class="headerlink" title="实现一个拷贝文件的工具类使用字节流还是字符流"></a>实现一个拷贝文件的工具类使用字节流还是字符流</h4><blockquote>
<p>我们拷贝的文件不确定是只包含字符流，有可能有字节流（图片、声音、图像等），为考虑到通用性，要使用字节流。</p>
</blockquote>
</li>
<li><h4 id="线程的几种实现方式"><a href="#线程的几种实现方式" class="headerlink" title="线程的几种实现方式"></a>线程的几种实现方式</h4><blockquote>
<ol>
<li><p>通过继承Thread类实现一个线程</p>
</li>
<li><p>通过实现Runnable接口实现一个线程</p>
</li>
<li><p>通过实现callable接口，重写call函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;    <span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line">&gt;    <span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式一  开始 (Thread是一个类继承了Runnable接口) =======</span></span><br><span class="line">&gt;            Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法中写我们业务代码</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">&gt;                        <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                            Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1000毫秒(就是1秒)</span></span><br><span class="line">&gt;                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt;                            e.printStackTrace();</span><br><span class="line">&gt;                        &#125;</span><br><span class="line">&gt;                        <span class="comment">//打印当前线程名称</span></span><br><span class="line">&gt;                        System.out.println(<span class="string">"创建线程方式一,打印线程名称: "</span>+Thread.currentThread().getName());</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                        <span class="comment">//打印当前线程名称,这里采用this来获取,在某些时候这里并不适用,推荐使用上面一种方式</span></span><br><span class="line">&gt;                        System.out.println(<span class="string">"创建线程方式一,通过this调用getName方法,打印线程名称: "</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">&gt;                    &#125;</span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            thread.start();<span class="comment">//启动线程</span></span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式一  结束  =======</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式二开始  (Runnable是一个接口)=======</span></span><br><span class="line">&gt;            Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法中写我们业务代码</span></span><br><span class="line">&gt;                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">&gt;                        <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                            Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1000毫秒(就是1秒)</span></span><br><span class="line">&gt;                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt;                            e.printStackTrace();</span><br><span class="line">&gt;                        &#125;</span><br><span class="line">&gt;                        <span class="comment">//打印当前线程名称</span></span><br><span class="line">&gt;                        System.out.println(<span class="string">"创建线程方式二,打印线程名称: "</span>+Thread.currentThread().getName());</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                        <span class="comment">//TODO 这种方式就不适合上面打印2的方式通过this来调用获取当前线程名称的方法</span></span><br><span class="line">&gt;                    &#125;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;);</span><br><span class="line">&gt;    </span><br><span class="line">&gt;            thread2.start();<span class="comment">//启动线程</span></span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式二  结束  =======</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="comment">// =======  创建线程方式三 开始  =======</span></span><br><span class="line">&gt;            FutureTask&lt;Integer&gt; thread3 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;                <span class="meta">@Override</span></span><br><span class="line">&gt;                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&gt;                    <span class="keyword">int</span> count =<span class="number">0</span>;  </span><br><span class="line">&gt;                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;  </span><br><span class="line">&gt;                        count=count+i;  </span><br><span class="line">&gt;                    &#125;  </span><br><span class="line">&gt;                    <span class="comment">//打印当前线程名称</span></span><br><span class="line">&gt;                    System.out.println(<span class="string">"创建线程方式三,打印线程名称: "</span>+Thread.currentThread().getName());</span><br><span class="line">&gt;                    <span class="keyword">return</span> count; <span class="comment">//返回值   </span></span><br><span class="line">&gt;                &#125;</span><br><span class="line">&gt;            &#125;);  </span><br><span class="line">&gt;    </span><br><span class="line">&gt;            <span class="keyword">new</span> Thread(thread3,<span class="string">"这是线程名称"</span>).start();<span class="comment">//启动线程</span></span><br><span class="line">&gt;            <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                System.out.println(<span class="string">"创建线程方式三,打印返回值:"</span>+ thread3.get());<span class="comment">//打印返回值</span></span><br><span class="line">&gt;            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&gt;                e.printStackTrace();</span><br><span class="line">&gt;            &#125; </span><br><span class="line">&gt;         <span class="comment">// =======  创建线程方式三 结束  =======</span></span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p>   <strong>区别：</strong></p>
<ul>
<li><p>采用继承Thread类方式：</p>
<p>​    优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。</p>
<p>​    缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。</p>
</li>
<li><p>采用实现Runnable接口方式：</p>
<p>​    优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<p>​    缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。</p>
</li>
</ul>
</blockquote>
</li>
<li><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><blockquote>
<ol>
<li><strong>newCachedThreadPool</strong></li>
</ol>
<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>这种类型的线程池特点是：</p>
<ul>
<li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&gt; 			<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">&gt; 			<span class="keyword">try</span> &#123;</span><br><span class="line">&gt; 				Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">&gt; 			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; 				e.printStackTrace();</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 			cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 					System.out.println(index);</span><br><span class="line">&gt; 				&#125;</span><br><span class="line">&gt; 			&#125;);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>newFixedThreadPool</strong></li>
</ol>
<p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p>
<p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&gt; 			<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">&gt; 			fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 					<span class="keyword">try</span> &#123;</span><br><span class="line">&gt; 						System.out.println(index);</span><br><span class="line">&gt; 						Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&gt; 					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; 						e.printStackTrace();</span><br><span class="line">&gt; 					&#125;</span><br><span class="line">&gt; 				&#125;</span><br><span class="line">&gt; 			&#125;);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置如Runtime.getRuntime().availableProcessors()</p>
<ol start="3">
<li><strong>newSingleThreadExecutor</strong></li>
</ol>
<p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">&gt; 			<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">&gt; 			singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 					<span class="keyword">try</span> &#123;</span><br><span class="line">&gt; 						System.out.println(index);</span><br><span class="line">&gt; 						Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&gt; 					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; 						e.printStackTrace();</span><br><span class="line">&gt; 					&#125;</span><br><span class="line">&gt; 				&#125;</span><br><span class="line">&gt; 			&#125;);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="4">
<li><strong>newScheduleThreadPool</strong></li>
</ol>
<p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>
<p>延迟3秒执行，延迟执行示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">&gt; 		scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 				System.out.println(<span class="string">"delay 3 seconds"</span>);</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>表示延迟1秒后每3秒执行一次，定期执行示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> test;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">&gt; <span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; 		ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">&gt; 		scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">&gt; 			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 				System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);</span><br><span class="line">&gt; 			&#125;</span><br><span class="line">&gt; 		&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><h4 id="使用线程池的风险，为什么使用线程池"><a href="#使用线程池的风险，为什么使用线程池" class="headerlink" title="使用线程池的风险，为什么使用线程池"></a>使用线程池的风险，为什么使用线程池</h4><blockquote>
<p><strong>风险：</strong></p>
<ol>
<li>死锁</li>
<li>资源不足</li>
<li>并发错误</li>
<li>线程泄漏</li>
<li>请求过载</li>
</ol>
<p><strong>作用：</strong>（连接池同理）</p>
<ol>
<li>限定线程的个数，不会由于线程过多而导致系统运行缓慢或崩溃</li>
<li>线程池不需要每次去创建或销毁，节约资源，响应速度快</li>
</ol>
</blockquote>
</li>
<li><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><blockquote>
<p><strong>常用的设计模式：</strong></p>
<ol>
<li><p>单例模式（饱汉模式、饿汉模式）：</p>
<p>（1）构造方法私有化，在除了自己类中其他地方都不能创建</p>
<p>（2）在自己的类中创建一个单实例（饱汉模式是一出来就创建单实例，而饿汉模式需要用到的时候才创建）</p>
<p>（3）提供一个方法或获取该实例对象（创建时需要进行方法同步）</p>
</li>
<li><p>工厂模式：SpringIOC使用的就是工厂模式，对象的创建交给一个工厂  创建。</p>
</li>
<li><p>代理模式：SpringAOP使用的就是动态代理。</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="javaWeb笔记"><a href="#javaWeb笔记" class="headerlink" title="javaWeb笔记"></a>javaWeb笔记</h2><ol>
<li><h4 id="Http-Get和Post请求的区别"><a href="#Http-Get和Post请求的区别" class="headerlink" title="Http Get和Post请求的区别"></a>Http Get和Post请求的区别</h4><blockquote>
<p><strong>相同点：</strong></p>
<p>Get和Post请求都是Http请求方式，用户通过不同的Http请求对资源实现不同的操作。GET，POST，PUT，DELETE对应着对资源的查，改，增，删4个操作，GET一般用于获取/查询资源信息，而POST用于更新资源信息。</p>
<p><strong>区别：</strong></p>
<ol>
<li>GET请求提交的数据会在地址栏显示出来，而POST请求地址栏不会改变，数据放置在HTTP包体中。</li>
<li>传输数据的大小不同，GET由于浏览器对地址长度的限制导致传输的数据有限制，而POST不会。</li>
<li>GET提交的数据会在地址中显示出来，安全性较低，而POST则不会。</li>
</ol>
</blockquote>
</li>
<li><h4 id="servlet的理解"><a href="#servlet的理解" class="headerlink" title="servlet的理解"></a>servlet的理解</h4><blockquote>
<p>Servlet 是用java编写的服务器端程序，而这些Servlet都要实现Servlet接口。主要用于交互式地浏览和修改数据，生成动态Web内容。Servlet运行于支持java的web容器中。</p>
<p>HttpServlet重写doGet和doPost方法或者service方法完成对get和post请求的响应。</p>
</blockquote>
</li>
<li><h4 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a>servlet的生命周期</h4><blockquote>
<ol>
<li>加载Servlet的class</li>
<li>实例化Servlet</li>
<li>调用Servlet的init完成实例化</li>
<li>运行service方法，响应doGet或doPost请求</li>
<li>调用destory方法销毁实例</li>
</ol>
</blockquote>
</li>
<li><h4 id="Servlet-API中forward-和redirect-区别"><a href="#Servlet-API中forward-和redirect-区别" class="headerlink" title="Servlet API中forward() 和redirect()区别"></a>Servlet API中forward() 和redirect()区别</h4><blockquote>
<p>forward：转发，地址不变，服务端跳转</p>
<p>redirect：重定向，地址改变，客户端跳转</p>
</blockquote>
</li>
<li><h4 id="Session和Cookie区别"><a href="#Session和Cookie区别" class="headerlink" title="Session和Cookie区别"></a>Session和Cookie区别</h4><blockquote>
<p><strong>相同点：</strong></p>
<p>Session和cookie都是会话跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务端记录信息确定用户身份。但是Session是实现依赖于Cookie，sessionId（session的唯一标识需要存放在客户端）</p>
<p><strong>区别：</strong></p>
<ol>
<li><p>Cookie数据存放在客户端浏览器，Session存放在服务器上</p>
</li>
<li><p>Cookie安全性较Session差</p>
</li>
<li><p>Session运行时间久会占用较多服务器内存，影响服务器性能</p>
</li>
<li><p>单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie</p>
</li>
<li><p>登录信息等重要信息存放在Session中，安全性较高</p>
<p>其他信息如果需要保留，存在Cookie中（比如购物车的实现，但是Cookie在客户端是可以禁用的，所以可以采用cookie+数据库方式实现）</p>
</li>
</ol>
</blockquote>
</li>
<li><h4 id="MVC的各部分都有哪些技术来实现"><a href="#MVC的各部分都有哪些技术来实现" class="headerlink" title="MVC的各部分都有哪些技术来实现"></a>MVC的各部分都有哪些技术来实现</h4><blockquote>
<ul>
<li>M（Model） 模型     javabean……</li>
<li>V（View）     视图     html、jsp、freemarker、thymeleaf……</li>
<li>C（Control）控制器 Servlet、Action……</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="数据库笔记"><a href="#数据库笔记" class="headerlink" title="数据库笔记"></a>数据库笔记</h2><ol>
<li><h4 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h4><blockquote>
<ul>
<li><p>关系型数据库</p>
<blockquote>
<p> MySql、Oracle、SqlServer……</p>
</blockquote>
</li>
<li><p>非关系型数据库</p>
<blockquote>
<p>redis、memcache、mogodb、hadoop……</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><h4 id="关系型数据库三范式"><a href="#关系型数据库三范式" class="headerlink" title="关系型数据库三范式"></a>关系型数据库三范式</h4><blockquote>
<ol>
<li><p>第一范式（1NF)所谓第一范式（1NF）是指<strong>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</strong>。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>
<p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。理解注释：列不可分。</p>
</li>
<li><p>第二范式（2NF)第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求<strong>数据库表中的每个实例或行必须可以被惟一的区分</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。要求实体的属性完全依赖于主关键字。理解注释：不能部分依赖。即：一张表存在组合主键时，其他非主键字段不能部分依赖。</p>
</li>
<li><p>第三范式（3NF)满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求<strong>一个数据库表中不包含已在其它表中已包含的非主关键字信息</strong>。在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。理解注释：不能存在传递依赖。即：除主键外，其他字段必须依赖主键。</p>
</li>
</ol>
</blockquote>
</li>
<li><h4 id="事务四个基本特征ACID特性"><a href="#事务四个基本特征ACID特性" class="headerlink" title="事务四个基本特征ACID特性"></a>事务四个基本特征ACID特性</h4><blockquote>
<p>​    事务是并发控制的单位，使用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）.这是可靠数据库所应具备的几个特性.</p>
<ul>
<li><p>原子性</p>
<blockquote>
<p>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</blockquote>
</li>
<li><p>一致性</p>
<blockquote>
<p>在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>
</blockquote>
</li>
<li><p>隔离性</p>
<blockquote>
<p>隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p>
</blockquote>
</li>
<li><p>持久性</p>
<blockquote>
<p>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><h4 id="MySql数据库默认的最大连接数"><a href="#MySql数据库默认的最大连接数" class="headerlink" title="MySql数据库默认的最大连接数"></a>MySql数据库默认的最大连接数</h4><blockquote>
<p>特定服务器上的数据库只能支持一定数目同时连接，这时候需要我们设置最大连接数（最多同时服务多少连接），在my.ini中查看设置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; # The maximum amount of concurrent sessions the MySQL server will</span><br><span class="line">&gt; # allow. One of these connections will be reserved for a user with</span><br><span class="line">&gt; # SUPER privileges to allow the administrator to login even if the</span><br><span class="line">&gt; # connection limit has been reached.</span><br><span class="line">&gt; max_connections=151</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><h4 id="MySql分页、Oracle分页和SqlServer分页"><a href="#MySql分页、Oracle分页和SqlServer分页" class="headerlink" title="MySql分页、Oracle分页和SqlServer分页"></a><del>MySql分页、Oracle分页和SqlServer分页</del></h4><blockquote>
<p>MySql使用limit关键字来分页</p>
<p>Oracle使用rownum</p>
<p>SqlServer使用top</p>
</blockquote>
</li>
<li><h4 id="触发器使用场景"><a href="#触发器使用场景" class="headerlink" title="触发器使用场景"></a><strong>触发器使用场景</strong></h4><blockquote>
</blockquote>
</li>
</ol>
<h2 id="前端笔记"><a href="#前端笔记" class="headerlink" title="前端笔记"></a>前端笔记</h2><h2 id="框架笔记"><a href="#框架笔记" class="headerlink" title="框架笔记"></a>框架笔记</h2><ol>
<li><h4 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h4><blockquote>
<ol>
<li>用户向服务器发送请求，请求被Spring前端控制器DispatcherServlet拦截</li>
<li>DispatcherServlet对请求的URL进行解析，得到请求资源标识符（URL）。然后根据URI调用HandlerMapping获的该Handler配置的所有相关对象，最后以HandlerExecutionChain对象的形式返回</li>
<li>DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter适配器，提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller），Handler执行完成后，向DispatcherServlet返回一个ModelAndVIew对象</li>
<li>DispatcherServlet根据返回的ModelAndVIew，选择一个合适的ViewResolver视图解析器</li>
<li>通过ViewResolver结合Model和View。来渲染视图，DispatcherServlet将渲染结果返回给客户端</li>
</ol>
</blockquote>
</li>
<li><h4 id="Struts2和SpringMVC区别"><a href="#Struts2和SpringMVC区别" class="headerlink" title="Struts2和SpringMVC区别"></a>Struts2和SpringMVC区别</h4><blockquote>
<ol>
<li>Struts2的前端控制器是Filter，SpringMVC是Servlet</li>
<li>SpringMVC是基于方法设计，而Struts2是基于对象</li>
<li>SpringMVC属于Spring大家族中的一员，Spring对于SpringMVC的控制器管理更加方便，而Struts2采用XML配置参数来管理</li>
<li>Struts2中自身提供多种参数接收，其实都是通过ValueStack进行传递和赋值，而SpringMVC是通过方法的参数进行接收</li>
<li>Struts2拥有较多的技术点，比如拦截器、值栈和OGNL表达式，学习成本较高，而SpringMVC相对比较简单</li>
<li>Struts有自己的interceptor拦截机制，SpringMVC使用的是独立的AOP</li>
<li>SpringMVC处理Ajax请求，直接通过返回数据，方法中使用注解@ResponseBody直接转为JSON对象返回，而Struts2是通过插件的方式处理</li>
</ol>
</blockquote>
</li>
<li><h4 id="Spring中的两大核心"><a href="#Spring中的两大核心" class="headerlink" title="Spring中的两大核心"></a>Spring中的两大核心</h4><blockquote>
<ol>
<li><p>IOC（Inversion of Control）或DI（Dependency Injection）</p>
<blockquote>
<p><strong>IOC控制反转：</strong></p>
<p>在spring中BeanFactory是IOC容器的核心接口，负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。XmlBeanFactory实现BeanFactory接口，通过获取xml配置文件数据，组成应用对象及对象间的依赖关系。</p>
<p>Spring中有三种注入方式：set注入、接口注入、构造方法注入</p>
<p>核心原理：配置文件+反射+容器</p>
</blockquote>
</li>
<li><p>AOP面向切面编程：</p>
<blockquote>
<p>使用动态代理的方式在执行前后或出现异常后执行相关逻辑</p>
<p>主要用于：事务、日志、权限校验</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><h4 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h4><blockquote>
<p>为了解决面向对象与关系数据库存在的互不匹配的现象的框架</p>
</blockquote>
</li>
<li><h4 id="Mybatis和Hibernate区别"><a href="#Mybatis和Hibernate区别" class="headerlink" title="Mybatis和Hibernate区别"></a>Mybatis和Hibernate区别</h4><blockquote>
<p><strong>相同点：</strong></p>
<p>​    都是java中的ORM框架、屏蔽了jdbc api的底层访问细节。</p>
<p>​    mybatis：专注sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis也可以实现映射（输入映射，输出映射）</p>
<p>​    应用场景：适用需求变化较多的项目，比如：互联网项目。</p>
<p>​    hibernate:是一个标准的ORM框架（对象关系映射）。入门门槛较高，不需要写sql，sql语句自动生成，对sql语句进行优化、修改比较困难。</p>
<p>​    应用场景：适用需求变化不多的中小型项目，比如：后台管理系统，erp，orm，oa等</p>
</blockquote>
</li>
<li><h4 id="Hibernate映射对象的状态"><a href="#Hibernate映射对象的状态" class="headerlink" title="Hibernate映射对象的状态"></a>Hibernate映射对象的状态</h4><blockquote>
<ol>
<li>临时状态(transient)(瞬态)：刚用new 语句创建，还没有被持久化，并且不处于Sesssion 的缓存中。处于临时状态的Java 对象被称为临时对象。</li>
<li>持久化状态(persistent)：已经被持久化，并且加入到Session 的缓存中。处于持久化状态的Java 对象被称为持久化对象。</li>
<li>删除状态(removed)：不再处于Session 的缓存中，并且Session 已经计划将其从数据库中删除。处于删除状态的Java 对象被称为删除对象。</li>
<li>游离状态(detached)：已经被持久化，但不再处于Session 的缓存中。处于游离状态的Java 对象被称为游离对象。</li>
</ol>
<p>下面以具体的代码来说明这四种状态:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">&gt;   </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">&gt;         SessionFactory sessionFactory=HibernateUtil.getSessionFactory();  </span><br><span class="line">&gt;         Session session=sessionFactory.openSession(); <span class="comment">// 生成一个session  </span></span><br><span class="line">&gt;         session.beginTransaction(); <span class="comment">// 开启事务  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         Person p1=<span class="keyword">new</span> Person(<span class="string">"天天"</span>,<span class="string">"18"</span>,<span class="string">"3009"</span>); <span class="comment">// 临时对象1  </span></span><br><span class="line">&gt;         Person p2=<span class="keyword">new</span> Person(<span class="string">"小李"</span>,<span class="string">"23"</span>,<span class="string">"4009"</span>); <span class="comment">// 临时对象1   </span></span><br><span class="line">&gt;         session.save(p1); <span class="comment">// 持久化对象  </span></span><br><span class="line">&gt;         session.save(p2); <span class="comment">// 持久化对象  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         session.delete(p2); <span class="comment">// 删除对象  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         session.getTransaction().commit(); <span class="comment">// 提交事务  </span></span><br><span class="line">&gt;         session.close(); <span class="comment">// 关闭session  </span></span><br><span class="line">&gt;           </span><br><span class="line">&gt;         System.out.println(p1.getName()); <span class="comment">// 游离对象  </span></span><br><span class="line">&gt;         System.out.println(p2.getName()); <span class="comment">// 删除对象  </span></span><br><span class="line">&gt;     &#125;     </span><br><span class="line">&gt; &#125;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><h4 id="Hibernate缓存机制"><a href="#Hibernate缓存机制" class="headerlink" title="Hibernate缓存机制"></a>Hibernate缓存机制</h4><blockquote>
<p>​    使用缓存是为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能</p>
<p>​    Hibernate缓存分为一级缓存和二级缓存，一级缓存就是Session级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。</p>
<p>什么样的数据适合存放到第二级缓存中？ 　　</p>
<p>​    1) 很少被修改的数据 　帖子的最后回复时间　</p>
<p>​    2) 经常被查询的数据   电商的地点</p>
<p>​    3) 不是很重要的数据，允许出现偶尔并发的数据 　　</p>
<p>​    4) 不会被并发访问的数据 　　</p>
<p>​    5) 常量数据 </p>
<p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用memcahe,redis等中央缓存来代替二级缓存。</p>
</blockquote>
</li>
<li><h4 id="webservice使用场景"><a href="#webservice使用场景" class="headerlink" title="webservice使用场景"></a>webservice使用场景</h4><blockquote>
<p>​    webservice是一个SOA（面向服务的编程）的架构，它是不依赖于语言，不依赖于平台，可以实现不同的语言间的相互调用，通过Internet进行基于Http协议的网络应用间的交互。</p>
<ol>
<li><p>异构系统(不同语言)的整合</p>
</li>
<li><p>不同客户端的整合，浏览器、手机端(android,ios.塞班)、微信端、PC端等终端来访问</p>
</li>
<li><p>实实在在的列子：</p>
<p>天气预报：可以通过实现webservice客户端调用远程天气服务实的。 </p>
<p>单点登录：一个服务是所有系统的登录</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="服务器及优化"><a href="#服务器及优化" class="headerlink" title="服务器及优化"></a>服务器及优化</h2><ol>
<li><h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><blockquote>
<p>常用：</p>
<p>​    Pwd 获取当前路径</p>
<p>​    Cd 跳转到目录</p>
<p>​    Su -u 切换到管理员</p>
<p>​    Ls ls 列举目录</p>
<p>文件操作命令：</p>
<p>​    文件</p>
<p>​           tail 查看</p>
<p>​           rm -rf </p>
<p>​           vi</p>
<p>​    文件夹</p>
<p>​           mkdir </p>
<p>​           rm -r</p>
</blockquote>
</li>
<li><h4 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h4><blockquote>
<p>做过mysql数据库的优化、其他数据库类似</p>
<p>定位：查找、定位慢查询</p>
<p>优化手段：</p>
<p>​    a) 创建索引：创建合适的索引，我们就可以现在索引中查询，查询到以后直接找对应的记录。</p>
<p>​    b) 分表：当一张表的数据比较多或者一张表的某些字段的值比较多并且很少使用时，采用水平分表和垂直分表来优化</p>
<p>​    c) 读写分离：当一台服务器不能满足需求时，采用读写分离的方式进行集群。</p>
<p>​    d) 缓存：使用redis来进行缓存</p>
<p>​    e) 一些常用优化技巧</p>
<p><a href="http://www.cnblogs.com/luyucheng/p/6323477.html" target="_blank" rel="noopener">优化</a></p>
</blockquote>
</li>
</ol>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java    </a></div><div class="post_share"><div class="social-share" data-image="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/6C4819608FCCD2B5E6F8F1B1C583429F.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/07/18/数据结构-2-环形队列/"><img class="prev_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/B3402E0D-8544-4AFD-BB48-88F3D7F7466C.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_6261.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_6923.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/F07254A8-F2DA-4308-9464-88E9E471FD6C.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_5519.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/FC43A5A0-16A7-411A-877A-C3F4C3D8C890.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_7755.JPG" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>数组模拟环形队列</span></div></a></div><div class="next-post pull-right"><a href="/2019/07/18/数据结构-1-稀疏数组/"><img class="next_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/B3402E0D-8544-4AFD-BB48-88F3D7F7466C.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_6261.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_6923.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/F07254A8-F2DA-4308-9464-88E9E471FD6C.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_5519.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/FC43A5A0-16A7-411A-877A-C3F4C3D8C890.JPG,https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_7755.JPG" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>稀疏数组</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/09/06/JDK8-String/" title="JDK8 String源码"><img class="relatedPosts_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/FC43A5A0-16A7-411A-877A-C3F4C3D8C890.JPG"><div class="relatedPosts_title">JDK8 String源码</div></a></div><div class="relatedPosts_item"><a href="/2019/08/23/基于Netty+WebSocket简易版微信/" title="基于Netty+WebSocket简易版微信"><img class="relatedPosts_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_7755.JPG"><div class="relatedPosts_title">基于Netty+WebSocket简易版微信</div></a></div><div class="relatedPosts_item"><a href="/2019/08/23/JDK8-Object/" title="JDK8 Object源码"><img class="relatedPosts_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/B3402E0D-8544-4AFD-BB48-88F3D7F7466C.JPG"><div class="relatedPosts_title">JDK8 Object源码</div></a></div><div class="relatedPosts_item"><a href="/2019/07/29/理财产品系统/" title="理财产品系统（慕课网）"><img class="relatedPosts_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/B3402E0D-8544-4AFD-BB48-88F3D7F7466C.JPG"><div class="relatedPosts_title">理财产品系统（慕课网）</div></a></div><div class="relatedPosts_item"><a href="/2019/07/20/Java基础笔记/" title="Java基础笔记"><img class="relatedPosts_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/F07254A8-F2DA-4308-9464-88E9E471FD6C.JPG"><div class="relatedPosts_title">Java基础笔记</div></a></div><div class="relatedPosts_item"><a href="/2019/06/29/FangXingMallNote/" title="方兴商城笔记"><img class="relatedPosts_cover lozad" data-src="https://fangchenyong.oss-cn-hangzhou.aliyuncs.com/IMG_6923.JPG"><div class="relatedPosts_title">方兴商城笔记</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By fangchenyong</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">仅供学习使用。</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>